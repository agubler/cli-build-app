/*!
 * 
 * [Dojo](https://dojo.io/)
 * Copyright [JS Foundation](https://js.foundation/) & contributors
 * [New BSD license](https://github.com/dojo/meta/blob/master/LICENSE)
 * All rights reserved
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("main", [], factory);
	else if(typeof exports === 'object')
		exports["main"] = factory();
	else
		root["main"] = factory();
})(this, function() {
return dojoWebpackJsonptest_app(["main"],{

/***/ "./node_modules/@dojo/core/Destroyable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var lang_1 = __webpack_require__("./node_modules/@dojo/core/lang.js");
var Promise_1 = __webpack_require__("./node_modules/@dojo/shim/Promise.js");
/**
 * No operation function to replace own once instance is destoryed
 */
function noop() {
    return Promise_1.default.resolve(false);
}
/**
 * No op function used to replace own, once instance has been destoryed
 */
function destroyed() {
    throw new Error('Call made to destroyed method');
}
var Destroyable = /** @class */ (function () {
    /**
     * @constructor
     */
    function Destroyable() {
        this.handles = [];
    }
    /**
     * Register handles for the instance that will be destroyed when `this.destroy` is called
     *
     * @param {Handle} handle The handle to add for the instance
     * @returns {Handle} a handle for the handle, removes the handle for the instance and calls destroy
     */
    Destroyable.prototype.own = function (handles) {
        var handle = Array.isArray(handles) ? lang_1.createCompositeHandle.apply(void 0, tslib_1.__spread(handles)) : handles;
        var _handles = this.handles;
        _handles.push(handle);
        return {
            destroy: function () {
                _handles.splice(_handles.indexOf(handle));
                handle.destroy();
            }
        };
    };
    /**
     * Destrpys all handers registered for the instance
     *
     * @returns {Promise<any} a promise that resolves once all handles have been destroyed
     */
    Destroyable.prototype.destroy = function () {
        var _this = this;
        return new Promise_1.default(function (resolve) {
            _this.handles.forEach(function (handle) {
                handle && handle.destroy && handle.destroy();
            });
            _this.destroy = noop;
            _this.own = destroyed;
            resolve(true);
        });
    };
    return Destroyable;
}());
exports.Destroyable = Destroyable;
exports.default = Destroyable;

/***/ }),

/***/ "./node_modules/@dojo/core/Evented.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var Map_1 = __webpack_require__("./node_modules/@dojo/shim/Map.js");
var Destroyable_1 = __webpack_require__("./node_modules/@dojo/core/Destroyable.js");
/**
 * Map of computed regular expressions, keyed by string
 */
var regexMap = new Map_1.default();
/**
 * Determines is the event type glob has been matched
 *
 * @returns boolean that indicates if the glob is matched
 */
function isGlobMatch(globString, targetString) {
    if (typeof targetString === 'string' && typeof globString === 'string' && globString.indexOf('*') !== -1) {
        var regex = void 0;
        if (regexMap.has(globString)) {
            regex = regexMap.get(globString);
        }
        else {
            regex = new RegExp("^" + globString.replace(/\*/g, '.*') + "$");
            regexMap.set(globString, regex);
        }
        return regex.test(targetString);
    }
    else {
        return globString === targetString;
    }
}
exports.isGlobMatch = isGlobMatch;
/**
 * Event Class
 */
var Evented = /** @class */ (function (_super) {
    tslib_1.__extends(Evented, _super);
    function Evented() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * map of listeners keyed by event type
         */
        _this.listenersMap = new Map_1.default();
        return _this;
    }
    Evented.prototype.emit = function (event) {
        var _this = this;
        this.listenersMap.forEach(function (methods, type) {
            if (isGlobMatch(type, event.type)) {
                methods.forEach(function (method) {
                    method.call(_this, event);
                });
            }
        });
    };
    Evented.prototype.on = function (type, listener) {
        var _this = this;
        if (Array.isArray(listener)) {
            var handles_1 = listener.map(function (listener) { return _this._addListener(type, listener); });
            return {
                destroy: function () {
                    handles_1.forEach(function (handle) { return handle.destroy(); });
                }
            };
        }
        return this._addListener(type, listener);
    };
    Evented.prototype._addListener = function (type, listener) {
        var _this = this;
        var listeners = this.listenersMap.get(type) || [];
        listeners.push(listener);
        this.listenersMap.set(type, listeners);
        return {
            destroy: function () {
                var listeners = _this.listenersMap.get(type) || [];
                listeners.splice(listeners.indexOf(listener), 1);
            }
        };
    };
    return Evented;
}(Destroyable_1.Destroyable));
exports.Evented = Evented;
exports.default = Evented;

/***/ }),

/***/ "./node_modules/@dojo/core/has.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
tslib_1.__exportStar(__webpack_require__("./node_modules/@dojo/shim/support/has.js"), exports);
exports.default = has_1.default;
has_1.add('object-assign', typeof global_1.default.Object.assign === 'function', true);
has_1.add('arraybuffer', typeof global_1.default.ArrayBuffer !== 'undefined', true);
has_1.add('formdata', typeof global_1.default.FormData !== 'undefined', true);
has_1.add('filereader', typeof global_1.default.FileReader !== 'undefined', true);
has_1.add('xhr', typeof global_1.default.XMLHttpRequest !== 'undefined', true);
has_1.add('xhr2', has_1.default('xhr') && 'responseType' in global_1.default.XMLHttpRequest.prototype, true);
has_1.add('blob', function () {
    if (!has_1.default('xhr2')) {
        return false;
    }
    var request = new global_1.default.XMLHttpRequest();
    request.open('GET', 'http://www.google.com', true);
    request.responseType = 'blob';
    request.abort();
    return request.responseType === 'blob';
}, true);
has_1.add('node-buffer', 'Buffer' in global_1.default && typeof global_1.default.Buffer === 'function', true);
has_1.add('fetch', 'fetch' in global_1.default && typeof global_1.default.fetch === 'function', true);
has_1.add('web-worker-xhr-upload', new Promise(function (resolve) {
    try {
        if (global_1.default.Worker !== undefined && global_1.default.URL && global_1.default.URL.createObjectURL) {
            var blob = new Blob([
                "(function () {\nself.addEventListener('message', function () {\n\tvar xhr = new XMLHttpRequest();\n\ttry {\n\t\txhr.upload;\n\t\tpostMessage('true');\n\t} catch (e) {\n\t\tpostMessage('false');\n\t}\n});\n\t\t})()"
            ], { type: 'application/javascript' });
            var worker = new Worker(URL.createObjectURL(blob));
            worker.addEventListener('message', function (_a) {
                var result = _a.data;
                resolve(result === 'true');
            });
            worker.postMessage({});
        }
        else {
            resolve(false);
        }
    }
    catch (e) {
        // IE11 on Winodws 8.1 encounters a security error.
        resolve(false);
    }
}), true);

/***/ }),

/***/ "./node_modules/@dojo/core/lang.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var object_1 = __webpack_require__("./node_modules/@dojo/shim/object.js");
var object_2 = __webpack_require__("./node_modules/@dojo/shim/object.js");
exports.assign = object_2.assign;
var slice = Array.prototype.slice;
var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * Type guard that ensures that the value can be coerced to Object
 * to weed out host objects that do not derive from Object.
 * This function is used to check if we want to deep copy an object or not.
 * Note: In ES6 it is possible to modify an object's Symbol.toStringTag property, which will
 * change the value returned by `toString`. This is a rare edge case that is difficult to handle,
 * so it is not handled here.
 * @param  value The value to check
 * @return       If the value is coercible into an Object
 */
function shouldDeepCopyObject(value) {
    return Object.prototype.toString.call(value) === '[object Object]';
}
function copyArray(array, inherited) {
    return array.map(function (item) {
        if (Array.isArray(item)) {
            return copyArray(item, inherited);
        }
        return !shouldDeepCopyObject(item)
            ? item
            : _mixin({
                deep: true,
                inherited: inherited,
                sources: [item],
                target: {}
            });
    });
}
function _mixin(kwArgs) {
    var deep = kwArgs.deep;
    var inherited = kwArgs.inherited;
    var target = kwArgs.target;
    var copied = kwArgs.copied || [];
    var copiedClone = tslib_1.__spread(copied);
    for (var i = 0; i < kwArgs.sources.length; i++) {
        var source = kwArgs.sources[i];
        if (source === null || source === undefined) {
            continue;
        }
        for (var key in source) {
            if (inherited || hasOwnProperty.call(source, key)) {
                var value = source[key];
                if (copiedClone.indexOf(value) !== -1) {
                    continue;
                }
                if (deep) {
                    if (Array.isArray(value)) {
                        value = copyArray(value, inherited);
                    }
                    else if (shouldDeepCopyObject(value)) {
                        var targetValue = target[key] || {};
                        copied.push(source);
                        value = _mixin({
                            deep: true,
                            inherited: inherited,
                            sources: [value],
                            target: targetValue,
                            copied: copied
                        });
                    }
                }
                target[key] = value;
            }
        }
    }
    return target;
}
function create(prototype) {
    var mixins = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        mixins[_i - 1] = arguments[_i];
    }
    if (!mixins.length) {
        throw new RangeError('lang.create requires at least one mixin object.');
    }
    var args = mixins.slice();
    args.unshift(Object.create(prototype));
    return object_1.assign.apply(null, args);
}
exports.create = create;
function deepAssign(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mixin({
        deep: true,
        inherited: false,
        sources: sources,
        target: target
    });
}
exports.deepAssign = deepAssign;
function deepMixin(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mixin({
        deep: true,
        inherited: true,
        sources: sources,
        target: target
    });
}
exports.deepMixin = deepMixin;
/**
 * Creates a new object using the provided source's prototype as the prototype for the new object, and then
 * deep copies the provided source's values into the new target.
 *
 * @param source The object to duplicate
 * @return The new object
 */
function duplicate(source) {
    var target = Object.create(Object.getPrototypeOf(source));
    return deepMixin(target, source);
}
exports.duplicate = duplicate;
/**
 * Determines whether two values are the same value.
 *
 * @param a First value to compare
 * @param b Second value to compare
 * @return true if the values are the same; false otherwise
 */
function isIdentical(a, b) {
    return (a === b ||
        /* both values are NaN */
        (a !== a && b !== b));
}
exports.isIdentical = isIdentical;
/**
 * Returns a function that binds a method to the specified object at runtime. This is similar to
 * `Function.prototype.bind`, but instead of a function it takes the name of a method on an object.
 * As a result, the function returned by `lateBind` will always call the function currently assigned to
 * the specified property on the object as of the moment the function it returns is called.
 *
 * @param instance The context object
 * @param method The name of the method on the context object to bind to itself
 * @param suppliedArgs An optional array of values to prepend to the `instance[method]` arguments list
 * @return The bound function
 */
function lateBind(instance, method) {
    var suppliedArgs = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        suppliedArgs[_i - 2] = arguments[_i];
    }
    return suppliedArgs.length
        ? function () {
            var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;
            // TS7017
            return instance[method].apply(instance, args);
        }
        : function () {
            // TS7017
            return instance[method].apply(instance, arguments);
        };
}
exports.lateBind = lateBind;
function mixin(target) {
    var sources = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        sources[_i - 1] = arguments[_i];
    }
    return _mixin({
        deep: false,
        inherited: true,
        sources: sources,
        target: target
    });
}
exports.mixin = mixin;
/**
 * Returns a function which invokes the given function with the given arguments prepended to its argument list.
 * Like `Function.prototype.bind`, but does not alter execution context.
 *
 * @param targetFunction The function that needs to be bound
 * @param suppliedArgs An optional array of arguments to prepend to the `targetFunction` arguments list
 * @return The bound function
 */
function partial(targetFunction) {
    var suppliedArgs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        suppliedArgs[_i - 1] = arguments[_i];
    }
    return function () {
        var args = arguments.length ? suppliedArgs.concat(slice.call(arguments)) : suppliedArgs;
        return targetFunction.apply(this, args);
    };
}
exports.partial = partial;
/**
 * Returns an object with a destroy method that, when called, calls the passed-in destructor.
 * This is intended to provide a unified interface for creating "remove" / "destroy" handlers for
 * event listeners, timers, etc.
 *
 * @param destructor A function that will be called when the handle's `destroy` method is invoked
 * @return The handle object
 */
function createHandle(destructor) {
    return {
        destroy: function () {
            this.destroy = function () { };
            destructor.call(this);
        }
    };
}
exports.createHandle = createHandle;
/**
 * Returns a single handle that can be used to destroy multiple handles simultaneously.
 *
 * @param handles An array of handles with `destroy` methods
 * @return The handle object
 */
function createCompositeHandle() {
    var handles = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        handles[_i] = arguments[_i];
    }
    return createHandle(function () {
        for (var i = 0; i < handles.length; i++) {
            handles[i].destroy();
        }
    });
}
exports.createCompositeHandle = createCompositeHandle;

/***/ }),

/***/ "./node_modules/@dojo/core/load/util.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
function isPlugin(value) {
    return Boolean(value) && typeof value.load === 'function';
}
exports.isPlugin = isPlugin;
function useDefault(modules) {
    if (iterator_1.isArrayLike(modules)) {
        var processedModules = [];
        for (var i = 0; i < modules.length; i++) {
            var module_1 = modules[i];
            processedModules.push(module_1.__esModule && module_1.default ? module_1.default : module_1);
        }
        return processedModules;
    }
    else if (iterator_1.isIterable(modules)) {
        var processedModules = [];
        try {
            for (var modules_1 = tslib_1.__values(modules), modules_1_1 = modules_1.next(); !modules_1_1.done; modules_1_1 = modules_1.next()) {
                var module_2 = modules_1_1.value;
                processedModules.push(module_2.__esModule && module_2.default ? module_2.default : module_2);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (modules_1_1 && !modules_1_1.done && (_a = modules_1.return)) _a.call(modules_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return processedModules;
    }
    else {
        return modules.__esModule && modules.default ? modules.default : modules;
    }
    var e_1, _a;
}
exports.useDefault = useDefault;

/***/ }),

/***/ "./node_modules/@dojo/core/uuid.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a v4 compliant UUID.
 *
 * @returns {string}
 */
function uuid() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        var r = (Math.random() * 16) | 0, v = c === 'x' ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
exports.default = uuid;

/***/ }),

/***/ "./node_modules/@dojo/has/has.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {
Object.defineProperty(exports, "__esModule", { value: true });
function isFeatureTestThenable(value) {
    return value && value.then;
}
/**
 * A cache of results of feature tests
 */
exports.testCache = {};
/**
 * A cache of the un-resolved feature tests
 */
exports.testFunctions = {};
/**
 * A cache of unresolved thenables (probably promises)
 * @type {{}}
 */
var testThenables = {};
/**
 * A reference to the global scope (`window` in a browser, `global` in NodeJS)
 */
var globalScope = (function () {
    /* istanbul ignore else */
    if (typeof window !== 'undefined') {
        // Browsers
        return window;
    }
    else if (typeof global !== 'undefined') {
        // Node
        return global;
    }
    else if (typeof self !== 'undefined') {
        // Web workers
        return self;
    }
    /* istanbul ignore next */
    return {};
})();
/* Grab the staticFeatures if there are available */
var staticFeatures = (globalScope.DojoHasEnvironment || {}).staticFeatures;
/* Cleaning up the DojoHasEnviornment */
if ('DojoHasEnvironment' in globalScope) {
    delete globalScope.DojoHasEnvironment;
}
/**
 * Custom type guard to narrow the `staticFeatures` to either a map or a function that
 * returns a map.
 *
 * @param value The value to guard for
 */
function isStaticFeatureFunction(value) {
    return typeof value === 'function';
}
/**
 * The cache of asserted features that were available in the global scope when the
 * module loaded
 */
var staticCache = staticFeatures
    ? isStaticFeatureFunction(staticFeatures)
        ? staticFeatures.apply(globalScope)
        : staticFeatures
    : {};/* Providing an empty cache, if none was in the environment

/**
* AMD plugin function.
*
* Conditional loads modules based on a has feature test value.
*
* @param resourceId Gives the resolved module id to load.
* @param require The loader require function with respect to the module that contained the plugin resource in its
*                dependency list.
* @param load Callback to loader that consumes result of plugin demand.
*/
function load(resourceId, require, load, config) {
    resourceId ? require([resourceId], load) : load();
}
exports.load = load;
/**
 * AMD plugin function.
 *
 * Resolves resourceId into a module id based on possibly-nested tenary expression that branches on has feature test
 * value(s).
 *
 * @param resourceId The id of the module
 * @param normalize Resolves a relative module id into an absolute module id
 */
function normalize(resourceId, normalize) {
    var tokens = resourceId.match(/[\?:]|[^:\?]*/g) || [];
    var i = 0;
    function get(skip) {
        var term = tokens[i++];
        if (term === ':') {
            // empty string module name, resolves to null
            return null;
        }
        else {
            // postfixed with a ? means it is a feature to branch on, the term is the name of the feature
            if (tokens[i++] === '?') {
                if (!skip && has(term)) {
                    // matched the feature, get the first value from the options
                    return get();
                }
                else {
                    // did not match, get the second value, passing over the first
                    get(true);
                    return get(skip);
                }
            }
            // a module
            return term;
        }
    }
    var id = get();
    return id && normalize(id);
}
exports.normalize = normalize;
/**
 * Check if a feature has already been registered
 *
 * @param feature the name of the feature
 */
function exists(feature) {
    var normalizedFeature = feature.toLowerCase();
    return Boolean(normalizedFeature in staticCache || normalizedFeature in exports.testCache || exports.testFunctions[normalizedFeature]);
}
exports.exists = exists;
/**
 * Register a new test for a named feature.
 *
 * @example
 * has.add('dom-addeventlistener', !!document.addEventListener);
 *
 * @example
 * has.add('touch-events', function () {
 *    return 'ontouchstart' in document
 * });
 *
 * @param feature the name of the feature
 * @param value the value reported of the feature, or a function that will be executed once on first test
 * @param overwrite if an existing value should be overwritten. Defaults to false.
 */
function add(feature, value, overwrite) {
    if (overwrite === void 0) { overwrite = false; }
    var normalizedFeature = feature.toLowerCase();
    if (exists(normalizedFeature) && !overwrite && !(normalizedFeature in staticCache)) {
        throw new TypeError("Feature \"" + feature + "\" exists and overwrite not true.");
    }
    if (typeof value === 'function') {
        exports.testFunctions[normalizedFeature] = value;
    }
    else if (isFeatureTestThenable(value)) {
        testThenables[feature] = value.then(function (resolvedValue) {
            exports.testCache[feature] = resolvedValue;
            delete testThenables[feature];
        }, function () {
            delete testThenables[feature];
        });
    }
    else {
        exports.testCache[normalizedFeature] = value;
        delete exports.testFunctions[normalizedFeature];
    }
}
exports.add = add;
/**
 * Return the current value of a named feature.
 *
 * @param feature The name (if a string) or identifier (if an integer) of the feature to test.
 */
function has(feature) {
    var result;
    var normalizedFeature = feature.toLowerCase();
    if (normalizedFeature in staticCache) {
        result = staticCache[normalizedFeature];
    }
    else if (exports.testFunctions[normalizedFeature]) {
        result = exports.testCache[normalizedFeature] = exports.testFunctions[normalizedFeature].call(null);
        delete exports.testFunctions[normalizedFeature];
    }
    else if (normalizedFeature in exports.testCache) {
        result = exports.testCache[normalizedFeature];
    }
    else if (feature in testThenables) {
        return false;
    }
    else {
        throw new TypeError("Attempt to detect unregistered has feature \"" + feature + "\"");
    }
    return result;
}
exports.default = has;
/*
 * Out of the box feature tests
 */
/* Environments */
/* Used as a value to provide a debug only code path */
add('debug', true);
/* Detects if the environment is "browser like" */
add('host-browser', typeof document !== 'undefined' && typeof location !== 'undefined');
/* Detects if the environment appears to be NodeJS */
add('host-node', function () {
    if (typeof process === 'object' && process.versions && process.versions.node) {
        return process.versions.node;
    }
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@dojo/i18n/cldr/load.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// required for Globalize/Cldr to properly resolve locales in the browser.
__webpack_require__("./node_modules/cldrjs/dist/cldr/unresolved.js");
var Globalize = __webpack_require__("./node_modules/globalize/dist/node-main.js");
var locales_1 = __webpack_require__("./node_modules/@dojo/i18n/cldr/locales.js");
var main_1 = __webpack_require__("./node_modules/@dojo/i18n/util/main.js");
/**
 * A list of all required CLDR packages for an individual locale.
 */
exports.mainPackages = Object.freeze([
    'dates/calendars/gregorian',
    'dates/fields',
    'dates/timeZoneNames',
    'numbers',
    'numbers/currencies',
    'units'
]);
/**
 * A list of all required CLDR supplement packages.
 */
exports.supplementalPackages = Object.freeze([
    'currencyData',
    'likelySubtags',
    'numberingSystems',
    'plurals-type-cardinal',
    'plurals-type-ordinal',
    'timeData',
    'weekData'
]);
/**
 * @private
 * A simple map containing boolean flags indicating whether a particular CLDR package has been loaded.
 */
var loadCache = {
    main: Object.create(null),
    supplemental: generateSupplementalCache()
};
/**
 * @private
 * Generate the locale-specific data cache from a list of keys. Nested objects will be generated from
 * slash-separated strings.
 *
 * @param cache
 * An empty locale cache object.
 *
 * @param keys
 * The list of keys.
 */
function generateLocaleCache(cache, keys) {
    return keys.reduce(function (tree, key) {
        var parts = key.split('/');
        if (parts.length === 1) {
            tree[key] = false;
            return tree;
        }
        parts.reduce(function (tree, key, i) {
            if (typeof tree[key] !== 'object') {
                tree[key] = i === parts.length - 1 ? false : Object.create(null);
            }
            return tree[key];
        }, tree);
        return tree;
    }, cache);
}
/**
 * @private
 * Generate the supplemental data cache.
 */
function generateSupplementalCache() {
    return exports.supplementalPackages.reduce(function (map, key) {
        map[key] = false;
        return map;
    }, Object.create(null));
}
/**
 * @private
 * Recursively determine whether a list of packages have been loaded for the specified CLDR group.
 *
 * @param group
 * The CLDR group object (e.g., the supplemental data, or a specific locale group)
 *
 * @param args
 * A list of keys to recursively check from left to right. For example, if [ "en", "numbers" ],
 * then `group.en.numbers` must exist for the test to pass.
 *
 * @return
 * `true` if the deepest value exists; `false` otherwise.
 */
function isLoadedForGroup(group, args) {
    return args.every(function (arg) {
        var next = group[arg];
        group = next;
        return Boolean(next);
    });
}
/**
 * @private
 * Recursively flag as loaded all recognized keys on the provided CLDR data object.
 *
 * @param cache
 * The load cache (either the entire object, or a nested segment of it).
 *
 * @param localeData
 * The CLDR data object being loaded (either the entire object, or a nested segment of it).
 */
function registerLocaleData(cache, localeData) {
    Object.keys(localeData).forEach(function (key) {
        if (key in cache) {
            var value = cache[key];
            if (typeof value === 'boolean') {
                cache[key] = true;
            }
            else {
                registerLocaleData(value, localeData[key]);
            }
        }
    });
}
/**
 * @private
 * Flag all supplied CLDR packages for a specific locale as loaded.
 *
 * @param data
 * The `main` locale data.
 */
function registerMain(data) {
    if (!data) {
        return;
    }
    Object.keys(data).forEach(function (locale) {
        if (locales_1.default.indexOf(locale) < 0) {
            return;
        }
        var loadedData = loadCache.main[locale];
        if (!loadedData) {
            loadedData = loadCache.main[locale] = generateLocaleCache(Object.create(null), exports.mainPackages);
        }
        registerLocaleData(loadedData, data[locale]);
    });
}
/**
 * @private
 * Flag all supplied CLDR supplemental packages as loaded.
 *
 * @param data
 * The supplemental data.
 */
function registerSupplemental(data) {
    if (!data) {
        return;
    }
    var supplemental = loadCache.supplemental;
    Object.keys(data).forEach(function (key) {
        if (key in supplemental) {
            supplemental[key] = true;
        }
    });
}
/**
 * Determine whether a particular CLDR package has been loaded.
 *
 * Example: to check that `supplemental.likelySubtags` has been loaded, `isLoaded` would be called as
 * `isLoaded('supplemental', 'likelySubtags')`.
 *
 * @param groupName
 * The group to check; either "main" or "supplemental".
 *
 * @param ...args
 * Any remaining keys in the path to the desired package.
 *
 * @return
 * `true` if the deepest value exists; `false` otherwise.
 */
function isLoaded(groupName) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    var group = loadCache[groupName];
    if (groupName === 'main' && args.length > 0) {
        var locale = args[0];
        if (!main_1.validateLocale(locale)) {
            return false;
        }
        args = args.slice(1);
        return main_1.generateLocales(locale).some(function (locale) {
            var next = group[locale];
            return next ? isLoadedForGroup(next, args) : false;
        });
    }
    return isLoadedForGroup(group, args);
}
exports.isLoaded = isLoaded;
/**
 * Load the specified CLDR data with the i18n ecosystem.
 *
 * @param data
 * A data object containing `main` and/or `supplemental` objects with CLDR data.
 */
function loadCldrData(data) {
    registerMain(data.main);
    registerSupplemental(data.supplemental);
    Globalize.load(data);
    return Promise.resolve();
}
exports.default = loadCldrData;
/**
 * Clear the load cache, either the entire cache for the specified group. After calling this method,
 * `isLoaded` will return false for keys within the specified group(s).
 *
 * @param group
 * An optional group name. If not provided, then both the "main" and "supplemental" caches will be cleared.
 */
function reset(group) {
    if (group !== 'supplemental') {
        loadCache.main = Object.create(null);
    }
    if (group !== 'main') {
        loadCache.supplemental = generateSupplementalCache();
    }
}
exports.reset = reset;

/***/ }),

/***/ "./node_modules/@dojo/i18n/cldr/locales.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A list of `cldr-data/main` directories used to load the correct CLDR data for a given locale.
 */
var localesList = [
    'af-NA',
    'af',
    'agq',
    'ak',
    'am',
    'ar-AE',
    'ar-BH',
    'ar-DJ',
    'ar-DZ',
    'ar-EG',
    'ar-EH',
    'ar-ER',
    'ar-IL',
    'ar-IQ',
    'ar-JO',
    'ar-KM',
    'ar-KW',
    'ar-LB',
    'ar-LY',
    'ar-MA',
    'ar-MR',
    'ar-OM',
    'ar-PS',
    'ar-QA',
    'ar-SA',
    'ar-SD',
    'ar-SO',
    'ar-SS',
    'ar-SY',
    'ar-TD',
    'ar-TN',
    'ar-YE',
    'ar',
    'as',
    'asa',
    'ast',
    'az-Cyrl',
    'az-Latn',
    'az',
    'bas',
    'be',
    'bem',
    'bez',
    'bg',
    'bm',
    'bn-IN',
    'bn',
    'bo-IN',
    'bo',
    'br',
    'brx',
    'bs-Cyrl',
    'bs-Latn',
    'bs',
    'ca-AD',
    'ca-ES-VALENCIA',
    'ca-FR',
    'ca-IT',
    'ca',
    'ce',
    'cgg',
    'chr',
    'ckb-IR',
    'ckb',
    'cs',
    'cu',
    'cy',
    'da-GL',
    'da',
    'dav',
    'de-AT',
    'de-BE',
    'de-CH',
    'de-IT',
    'de-LI',
    'de-LU',
    'de',
    'dje',
    'dsb',
    'dua',
    'dyo',
    'dz',
    'ebu',
    'ee-TG',
    'ee',
    'el-CY',
    'el',
    'en-001',
    'en-150',
    'en-AG',
    'en-AI',
    'en-AS',
    'en-AT',
    'en-AU',
    'en-BB',
    'en-BE',
    'en-BI',
    'en-BM',
    'en-BS',
    'en-BW',
    'en-BZ',
    'en-CA',
    'en-CC',
    'en-CH',
    'en-CK',
    'en-CM',
    'en-CX',
    'en-CY',
    'en-DE',
    'en-DG',
    'en-DK',
    'en-DM',
    'en-ER',
    'en-FI',
    'en-FJ',
    'en-FK',
    'en-FM',
    'en-GB',
    'en-GD',
    'en-GG',
    'en-GH',
    'en-GI',
    'en-GM',
    'en-GU',
    'en-GY',
    'en-HK',
    'en-IE',
    'en-IL',
    'en-IM',
    'en-IN',
    'en-IO',
    'en-JE',
    'en-JM',
    'en-KE',
    'en-KI',
    'en-KN',
    'en-KY',
    'en-LC',
    'en-LR',
    'en-LS',
    'en-MG',
    'en-MH',
    'en-MO',
    'en-MP',
    'en-MS',
    'en-MT',
    'en-MU',
    'en-MW',
    'en-MY',
    'en-NA',
    'en-NF',
    'en-NG',
    'en-NL',
    'en-NR',
    'en-NU',
    'en-NZ',
    'en-PG',
    'en-PH',
    'en-PK',
    'en-PN',
    'en-PR',
    'en-PW',
    'en-RW',
    'en-SB',
    'en-SC',
    'en-SD',
    'en-SE',
    'en-SG',
    'en-SH',
    'en-SI',
    'en-SL',
    'en-SS',
    'en-SX',
    'en-SZ',
    'en-TC',
    'en-TK',
    'en-TO',
    'en-TT',
    'en-TV',
    'en-TZ',
    'en-UG',
    'en-UM',
    'en-US-POSIX',
    'en-VC',
    'en-VG',
    'en-VI',
    'en-VU',
    'en-WS',
    'en-ZA',
    'en-ZM',
    'en-ZW',
    'en',
    'eo',
    'es-419',
    'es-AR',
    'es-BO',
    'es-BR',
    'es-CL',
    'es-CO',
    'es-CR',
    'es-CU',
    'es-DO',
    'es-EA',
    'es-EC',
    'es-GQ',
    'es-GT',
    'es-HN',
    'es-IC',
    'es-MX',
    'es-NI',
    'es-PA',
    'es-PE',
    'es-PH',
    'es-PR',
    'es-PY',
    'es-SV',
    'es-US',
    'es-UY',
    'es-VE',
    'es',
    'et',
    'eu',
    'ewo',
    'fa-AF',
    'fa',
    'ff-CM',
    'ff-GN',
    'ff-MR',
    'ff',
    'fi',
    'fil',
    'fo-DK',
    'fo',
    'fr-BE',
    'fr-BF',
    'fr-BI',
    'fr-BJ',
    'fr-BL',
    'fr-CA',
    'fr-CD',
    'fr-CF',
    'fr-CG',
    'fr-CH',
    'fr-CI',
    'fr-CM',
    'fr-DJ',
    'fr-DZ',
    'fr-GA',
    'fr-GF',
    'fr-GN',
    'fr-GP',
    'fr-GQ',
    'fr-HT',
    'fr-KM',
    'fr-LU',
    'fr-MA',
    'fr-MC',
    'fr-MF',
    'fr-MG',
    'fr-ML',
    'fr-MQ',
    'fr-MR',
    'fr-MU',
    'fr-NC',
    'fr-NE',
    'fr-PF',
    'fr-PM',
    'fr-RE',
    'fr-RW',
    'fr-SC',
    'fr-SN',
    'fr-SY',
    'fr-TD',
    'fr-TG',
    'fr-TN',
    'fr-VU',
    'fr-WF',
    'fr-YT',
    'fr',
    'fur',
    'fy',
    'ga',
    'gd',
    'gl',
    'gsw-FR',
    'gsw-LI',
    'gsw',
    'gu',
    'guz',
    'gv',
    'ha-GH',
    'ha-NE',
    'ha',
    'haw',
    'he',
    'hi',
    'hr-BA',
    'hr',
    'hsb',
    'hu',
    'hy',
    'id',
    'ig',
    'ii',
    'is',
    'it-CH',
    'it-SM',
    'it',
    'ja',
    'jgo',
    'jmc',
    'ka',
    'kab',
    'kam',
    'kde',
    'kea',
    'khq',
    'ki',
    'kk',
    'kkj',
    'kl',
    'kln',
    'km',
    'kn',
    'ko-KP',
    'ko',
    'kok',
    'ks',
    'ksb',
    'ksf',
    'ksh',
    'kw',
    'ky',
    'lag',
    'lb',
    'lg',
    'lkt',
    'ln-AO',
    'ln-CF',
    'ln-CG',
    'ln',
    'lo',
    'lrc-IQ',
    'lrc',
    'lt',
    'lu',
    'luo',
    'luy',
    'lv',
    'mas-TZ',
    'mas',
    'mer',
    'mfe',
    'mg',
    'mgh',
    'mgo',
    'mk',
    'ml',
    'mn',
    'mr',
    'ms-BN',
    'ms-SG',
    'ms',
    'mt',
    'mua',
    'my',
    'mzn',
    'naq',
    'nb-SJ',
    'nb',
    'nd',
    'nds-NL',
    'nds',
    'ne-IN',
    'ne',
    'nl-AW',
    'nl-BE',
    'nl-BQ',
    'nl-CW',
    'nl-SR',
    'nl-SX',
    'nl',
    'nmg',
    'nn',
    'nnh',
    'nus',
    'nyn',
    'om-KE',
    'om',
    'or',
    'os-RU',
    'os',
    'pa-Arab',
    'pa-Guru',
    'pa',
    'pl',
    'prg',
    'ps',
    'pt-AO',
    'pt-CH',
    'pt-CV',
    'pt-GQ',
    'pt-GW',
    'pt-LU',
    'pt-MO',
    'pt-MZ',
    'pt-PT',
    'pt-ST',
    'pt-TL',
    'pt',
    'qu-BO',
    'qu-EC',
    'qu',
    'rm',
    'rn',
    'ro-MD',
    'ro',
    'rof',
    'root',
    'ru-BY',
    'ru-KG',
    'ru-KZ',
    'ru-MD',
    'ru-UA',
    'ru',
    'rw',
    'rwk',
    'sah',
    'saq',
    'sbp',
    'se-FI',
    'se-SE',
    'se',
    'seh',
    'ses',
    'sg',
    'shi-Latn',
    'shi-Tfng',
    'shi',
    'si',
    'sk',
    'sl',
    'smn',
    'sn',
    'so-DJ',
    'so-ET',
    'so-KE',
    'so',
    'sq-MK',
    'sq-XK',
    'sq',
    'sr-Cyrl-BA',
    'sr-Cyrl-ME',
    'sr-Cyrl-XK',
    'sr-Cyrl',
    'sr-Latn-BA',
    'sr-Latn-ME',
    'sr-Latn-XK',
    'sr-Latn',
    'sr',
    'sv-AX',
    'sv-FI',
    'sv',
    'sw-CD',
    'sw-KE',
    'sw-UG',
    'sw',
    'ta-LK',
    'ta-MY',
    'ta-SG',
    'ta',
    'te',
    'teo-KE',
    'teo',
    'th',
    'ti-ER',
    'ti',
    'tk',
    'to',
    'tr-CY',
    'tr',
    'twq',
    'tzm',
    'ug',
    'uk',
    'ur-IN',
    'ur',
    'uz-Arab',
    'uz-Cyrl',
    'uz-Latn',
    'uz',
    'vai-Latn',
    'vai-Vaii',
    'vai',
    'vi',
    'vo',
    'vun',
    'wae',
    'xog',
    'yav',
    'yi',
    'yo-BJ',
    'yo',
    'yue',
    'zgh',
    'zh-Hans-HK',
    'zh-Hans-MO',
    'zh-Hans-SG',
    'zh-Hans',
    'zh-Hant-HK',
    'zh-Hant-MO',
    'zh-Hant',
    'zh',
    'zu'
];
exports.default = localesList;

/***/ }),

/***/ "./node_modules/@dojo/i18n/i18n.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
/* tslint:disable:interface-name */
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var Map_1 = __webpack_require__("./node_modules/@dojo/shim/Map.js");
var Evented_1 = __webpack_require__("./node_modules/@dojo/core/Evented.js");
var has_1 = __webpack_require__("./node_modules/@dojo/core/has.js");
var uuid_1 = __webpack_require__("./node_modules/@dojo/core/uuid.js");
var util_1 = __webpack_require__("./node_modules/@dojo/core/load/util.js");
var Globalize = __webpack_require__("./node_modules/globalize/dist/globalize/message.js");
var load_1 = __webpack_require__("./node_modules/@dojo/i18n/cldr/load.js");
var main_1 = __webpack_require__("./node_modules/@dojo/i18n/util/main.js");
var TOKEN_PATTERN = /\{([a-z0-9_]+)\}/gi;
var bundleMap = new Map_1.default();
var formatterMap = new Map_1.default();
var localeProducer = new Evented_1.default();
var rootLocale;
/**
 * Return the bundle's unique identifier, creating one if it does not already exist.
 *
 * @param bundle A message bundle
 * @return The bundle's unique identifier
 */
function getBundleId(bundle) {
    if (bundle.id) {
        return bundle.id;
    }
    var id = uuid_1.default();
    Object.defineProperty(bundle, 'id', {
        value: id
    });
    return id;
}
/**
 * @private
 * Return a function that formats an ICU-style message, and takes an optional value for token replacement.
 *
 * Usage:
 * const formatter = getMessageFormatter(bundle, 'guestInfo', 'fr');
 * const message = formatter({
 *   host: 'Miles',
 *   gender: 'male',
 *   guest: 'Oscar',
 *   guestCount: '15'
 * });
 *
 * @param id
 * The message's bundle id.
 *
 * @param key
 * The message's key.
 *
 * @param locale
 * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
 * default locale is used.
 *
 * @return
 * The message formatter.
 */
function getIcuMessageFormatter(id, key, locale) {
    locale = main_1.normalizeLocale(locale || getRootLocale());
    var formatterKey = locale + ":" + id + ":" + key;
    var formatter = formatterMap.get(formatterKey);
    if (formatter) {
        return formatter;
    }
    var globalize = locale !== getRootLocale() ? new Globalize(main_1.normalizeLocale(locale)) : Globalize;
    formatter = globalize.messageFormatter(id + "/" + key);
    var cached = bundleMap.get(id);
    if (cached && cached.get(locale)) {
        formatterMap.set(formatterKey, formatter);
    }
    return formatter;
}
/**
 * @private
 * Load the specified locale-specific bundles, mapping the default exports to simple `Messages` objects.
 */
function loadLocaleBundles(locales, supported) {
    return Promise.all(supported.map(function (locale) { return locales[locale](); })).then(function (bundles) {
        return bundles.map(function (bundle) { return util_1.useDefault(bundle); });
    });
}
/**
 * @private
 * Return the root locale. Defaults to the system locale.
 */
function getRootLocale() {
    return rootLocale || exports.systemLocale;
}
/**
 * @private
 * Retrieve a list of supported locales that can provide messages for the specified locale.
 *
 * @param locale
 * The target locale.
 *
 * @param supported
 * The locales that are supported by the bundle.
 *
 * @return
 * A list of supported locales that match the target locale.
 */
function getSupportedLocales(locale, supported) {
    if (supported === void 0) { supported = []; }
    return main_1.generateLocales(locale).filter(function (locale) { return supported.indexOf(locale) > -1; });
}
/**
 * @private
 * Inject messages for the specified locale into the i18n system.
 *
 * @param id
 * The bundle's unique identifier
 *
 * @param messages
 * The messages to inject
 *
 * @param locale
 * An optional locale. If not specified, then it is assumed that the messages are the defaults for the given
 * bundle path.
 */
function loadMessages(id, messages, locale) {
    if (locale === void 0) { locale = 'root'; }
    var cached = bundleMap.get(id);
    if (!cached) {
        cached = new Map_1.default();
        bundleMap.set(id, cached);
    }
    cached.set(locale, messages);
    Globalize.loadMessages((_a = {},
        _a[locale] = (_b = {},
            _b[id] = messages,
            _b),
        _a));
    var _a, _b;
}
/**
 * Return a formatted message.
 *
 * If both the "supplemental/likelySubtags" and "supplemental/plurals-type-cardinal" CLDR data have been loaded, then
 * the ICU message format is supported. Otherwise, a simple token-replacement mechanism is used.
 *
 * Usage:
 * formatMessage(bundle, 'guestInfo', {
 *   host: 'Bill',
 *   guest: 'John'
 * }, 'fr');
 *
 * @param bundle
 * The bundle containing the target message.
 *
 * @param key
 * The message's key.
 *
 * @param options
 * An optional value used by the formatter to replace tokens with values.
 *
 * @param locale
 * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
 * default locale is used.
 *
 * @return
 * The formatted message.
 */
function formatMessage(bundle, key, options, locale) {
    return getMessageFormatter(bundle, key, locale)(options);
}
exports.formatMessage = formatMessage;
/**
 * Return the cached messages for the specified bundle and locale. If messages have not been previously loaded for the
 * specified locale, no value will be returned.
 *
 * @param bundle
 * The default bundle that is used to determine where the locale-specific bundles are located.
 *
 * @param locale
 * The locale of the desired messages.
 *
 * @return The cached messages object, if it exists.
 */
function getCachedMessages(bundle, locale) {
    var _a = bundle.id, id = _a === void 0 ? getBundleId(bundle) : _a, locales = bundle.locales, messages = bundle.messages;
    var cached = bundleMap.get(id);
    if (!cached) {
        loadMessages(id, messages);
    }
    else {
        var localeMessages = cached.get(locale);
        if (localeMessages) {
            return localeMessages;
        }
    }
    var supportedLocales = getSupportedLocales(locale, locales && Object.keys(locales));
    if (!supportedLocales.length) {
        return messages;
    }
    if (cached) {
        return cached.get(supportedLocales[supportedLocales.length - 1]);
    }
}
exports.getCachedMessages = getCachedMessages;
/**
 * Return a function that formats a specific message, and takes an optional value for token replacement.
 *
 * If both the "supplemental/likelySubtags" and "supplemental/plurals-type-cardinal" CLDR data have been loaded, then
 * the returned function will have ICU message format support. Otherwise, the returned function will perform a simple
 * token replacement on the message string.
 *
 * Usage:
 * const formatter = getMessageFormatter(bundle, 'guestInfo', 'fr');
 * const message = formatter({
 *   host: 'Miles',
 *   gender: 'male',
 *   guest: 'Oscar',
 *   guestCount: '15'
 * });
 *
 * @param bundle
 * The bundle containing the target message.
 *
 * @param key
 * The message's key.
 *
 * @param locale
 * An optional locale for the formatter. If no locale is supplied, or if the locale is not supported, the
 * default locale is used.
 *
 * @return
 * The message formatter.
 */
function getMessageFormatter(bundle, key, locale) {
    var _a = bundle.id, id = _a === void 0 ? getBundleId(bundle) : _a;
    if (load_1.isLoaded('supplemental', 'likelySubtags') && load_1.isLoaded('supplemental', 'plurals-type-cardinal')) {
        return getIcuMessageFormatter(id, key, locale);
    }
    var cached = bundleMap.get(id);
    var messages = cached ? cached.get(locale || getRootLocale()) || cached.get('root') : null;
    if (!messages) {
        throw new Error("The bundle has not been registered.");
    }
    return function (options) {
        if (options === void 0) { options = Object.create(null); }
        return messages[key].replace(TOKEN_PATTERN, function (token, property) {
            var value = options[property];
            if (typeof value === 'undefined') {
                throw new Error("Missing property " + property);
            }
            return value;
        });
    };
}
exports.getMessageFormatter = getMessageFormatter;
/**
 * Load locale-specific messages for the specified bundle and locale.
 *
 * @param bundle
 * The default bundle that is used to determine where the locale-specific bundles are located.
 *
 * @param locale
 * An optional locale. If no locale is provided, then the current locale is assumed.
 *
 * @return A promise to the locale-specific messages.
 */
function i18n(bundle, locale) {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var currentLocale, cachedMessages, locales, supportedLocales, bundles;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    currentLocale = locale ? main_1.normalizeLocale(locale) : getRootLocale();
                    cachedMessages = getCachedMessages(bundle, currentLocale);
                    if (cachedMessages) {
                        return [2 /*return*/, cachedMessages];
                    }
                    locales = bundle.locales;
                    supportedLocales = getSupportedLocales(currentLocale, Object.keys(locales));
                    return [4 /*yield*/, loadLocaleBundles(locales, supportedLocales)];
                case 1:
                    bundles = _a.sent();
                    return [2 /*return*/, bundles.reduce(function (previous, partial) {
                            var localeMessages = tslib_1.__assign({}, previous, partial);
                            loadMessages(getBundleId(bundle), Object.freeze(localeMessages), currentLocale);
                            return localeMessages;
                        }, bundle.messages)];
            }
        });
    });
}
Object.defineProperty(i18n, 'locale', {
    get: getRootLocale
});
exports.default = i18n;
/**
 * Invalidate the cache for a particular bundle, or invalidate the entire cache. Note that cached messages for all
 * locales for a given bundle will be cleared.
 *
 * @param bundle
 * An optional bundle to invalidate. If no bundle is provided, then the cache is cleared for all bundles.
 */
function invalidate(bundle) {
    if (bundle) {
        bundle.id && bundleMap.delete(bundle.id);
    }
    else {
        bundleMap.clear();
    }
}
exports.invalidate = invalidate;
/**
 * Register an observer to be notified when the root locale changes.
 *
 * @param observer
 * The observer whose `next` method will receive the locale string on updates, and whose `error` method will receive
 * an Error object if the locale switch fails.
 *
 * @return
 * A subscription object that can be used to unsubscribe from updates.
 */
exports.observeLocale = function (callback) {
    return localeProducer.on('change', function (event) {
        callback(event.target);
    });
};
/**
 * Pre-load locale-specific messages into the i18n system.
 *
 * @param bundle
 * The default bundle that is used to merge locale-specific messages with the default messages.
 *
 * @param messages
 * The messages to cache.
 *
 * @param locale
 * The locale for the messages
 */
function setLocaleMessages(bundle, localeMessages, locale) {
    var messages = tslib_1.__assign({}, bundle.messages, localeMessages);
    loadMessages(getBundleId(bundle), Object.freeze(messages), locale);
}
exports.setLocaleMessages = setLocaleMessages;
/**
 * Change the root locale, and notify any registered observers.
 *
 * @param locale
 * The new locale.
 */
function switchLocale(locale) {
    var previous = rootLocale;
    rootLocale = locale ? main_1.normalizeLocale(locale) : '';
    if (previous !== rootLocale) {
        if (load_1.isLoaded('supplemental', 'likelySubtags')) {
            Globalize.load({
                main: (_a = {},
                    _a[rootLocale] = {},
                    _a)
            });
            Globalize.locale(rootLocale);
        }
        localeProducer.emit({ type: 'change', target: rootLocale });
    }
    var _a;
}
exports.switchLocale = switchLocale;
/**
 * The default environment locale.
 *
 * It should be noted that while the system locale will be normalized to a single
 * format when loading message bundles, this value represents the unaltered
 * locale returned directly by the environment.
 */
exports.systemLocale = (function () {
    var systemLocale = 'en';
    if (has_1.default('host-browser')) {
        var navigator_1 = global_1.default.navigator;
        systemLocale = navigator_1.language || navigator_1.userLanguage;
    }
    else if (has_1.default('host-node')) {
        systemLocale = process.env.LANG || systemLocale;
    }
    return main_1.normalizeLocale(systemLocale);
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/@dojo/i18n/util/main.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// Matches an ISO 639.1/639.2 compatible language, followed by optional subtags.
var VALID_LOCALE_PATTERN = /^[a-z]{2,3}(-[a-z0-9\-\_]+)?$/i;
/**
 * Retrieve a list of locales that can provide substitute for the specified locale
 * (including itself).
 *
 * For example, if 'fr-CA' is specified, then `[ 'fr', 'fr-CA' ]` is returned.
 *
 * @param locale
 * The target locale.
 *
 * @return
 * A list of locales that match the target locale.
 */
function generateLocales(locale) {
    var normalized = exports.normalizeLocale(locale);
    var parts = normalized.split('-');
    var current = parts[0];
    var result = [current];
    for (var i = 0; i < parts.length - 1; i += 1) {
        current += '-' + parts[i + 1];
        result.push(current);
    }
    return result;
}
exports.generateLocales = generateLocales;
/**
 * Normalize a locale so that it can be converted to a bundle path.
 *
 * @param locale
 * The target locale.
 *
 * @return The normalized locale.
 */
exports.normalizeLocale = (function () {
    function removeTrailingSeparator(value) {
        return value.replace(/(\-|_)$/, '');
    }
    function normalize(locale) {
        if (locale.indexOf('.') === -1) {
            return removeTrailingSeparator(locale);
        }
        return locale
            .split('.')
            .slice(0, -1)
            .map(function (part) {
            return removeTrailingSeparator(part).replace(/_/g, '-');
        })
            .join('-');
    }
    return function (locale) {
        var normalized = normalize(locale);
        if (!validateLocale(normalized)) {
            throw new Error(normalized + " is not a valid locale.");
        }
        return normalized;
    };
})();
/**
 * Validates that the provided locale at least begins with a ISO 639.1/639.2 comptabile language subtag,
 * and that any additional subtags contain only valid characters.
 *
 * While locales should adhere to the guidelines set forth by RFC 5646 (https://tools.ietf.org/html/rfc5646),
 * only the language subtag is strictly enforced.
 *
 * @param locale
 * The locale to validate.
 *
 * @return
 * `true` if the locale is valid; `false` otherwise.
 */
function validateLocale(locale) {
    return VALID_LOCALE_PATTERN.test(locale);
}
exports.validateLocale = validateLocale;

/***/ }),

/***/ "./node_modules/@dojo/shim/Map.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var iterator_1 = __webpack_require__("./node_modules/@dojo/shim/iterator.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var object_1 = __webpack_require__("./node_modules/@dojo/shim/object.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
exports.Map = global_1.default.Map;
if (!has_1.default('es6-map')) {
    exports.Map = (_a = /** @class */ (function () {
            function Map(iterable) {
                this._keys = [];
                this._values = [];
                this[Symbol.toStringTag] = 'Map';
                if (iterable) {
                    if (iterator_1.isArrayLike(iterable)) {
                        for (var i = 0; i < iterable.length; i++) {
                            var value = iterable[i];
                            this.set(value[0], value[1]);
                        }
                    }
                    else {
                        try {
                            for (var iterable_1 = tslib_1.__values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                                var value = iterable_1_1.value;
                                this.set(value[0], value[1]);
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                    }
                }
                var e_1, _a;
            }
            /**
             * An alternative to Array.prototype.indexOf using Object.is
             * to check for equality. See http://mzl.la/1zuKO2V
             */
            Map.prototype._indexOfKey = function (keys, key) {
                for (var i = 0, length_1 = keys.length; i < length_1; i++) {
                    if (object_1.is(keys[i], key)) {
                        return i;
                    }
                }
                return -1;
            };
            Object.defineProperty(Map.prototype, "size", {
                get: function () {
                    return this._keys.length;
                },
                enumerable: true,
                configurable: true
            });
            Map.prototype.clear = function () {
                this._keys.length = this._values.length = 0;
            };
            Map.prototype.delete = function (key) {
                var index = this._indexOfKey(this._keys, key);
                if (index < 0) {
                    return false;
                }
                this._keys.splice(index, 1);
                this._values.splice(index, 1);
                return true;
            };
            Map.prototype.entries = function () {
                var _this = this;
                var values = this._keys.map(function (key, i) {
                    return [key, _this._values[i]];
                });
                return new iterator_1.ShimIterator(values);
            };
            Map.prototype.forEach = function (callback, context) {
                var keys = this._keys;
                var values = this._values;
                for (var i = 0, length_2 = keys.length; i < length_2; i++) {
                    callback.call(context, values[i], keys[i], this);
                }
            };
            Map.prototype.get = function (key) {
                var index = this._indexOfKey(this._keys, key);
                return index < 0 ? undefined : this._values[index];
            };
            Map.prototype.has = function (key) {
                return this._indexOfKey(this._keys, key) > -1;
            };
            Map.prototype.keys = function () {
                return new iterator_1.ShimIterator(this._keys);
            };
            Map.prototype.set = function (key, value) {
                var index = this._indexOfKey(this._keys, key);
                index = index < 0 ? this._keys.length : index;
                this._keys[index] = key;
                this._values[index] = value;
                return this;
            };
            Map.prototype.values = function () {
                return new iterator_1.ShimIterator(this._values);
            };
            Map.prototype[Symbol.iterator] = function () {
                return this.entries();
            };
            return Map;
        }()),
        _a[Symbol.species] = _a,
        _a);
}
exports.default = exports.Map;
var _a;

/***/ }),

/***/ "./node_modules/@dojo/shim/Promise.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var queue_1 = __webpack_require__("./node_modules/@dojo/shim/support/queue.js");
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
exports.ShimPromise = global_1.default.Promise;
exports.isThenable = function isThenable(value) {
    return value && typeof value.then === 'function';
};
if (!has_1.default('es6-promise')) {
    global_1.default.Promise = exports.ShimPromise = (_a = /** @class */ (function () {
            /**
             * Creates a new Promise.
             *
             * @constructor
             *
             * @param executor
             * The executor function is called immediately when the Promise is instantiated. It is responsible for
             * starting the asynchronous operation when it is invoked.
             *
             * The executor must call either the passed `resolve` function when the asynchronous operation has completed
             * successfully, or the `reject` function when the operation fails.
             */
            function Promise(executor) {
                var _this = this;
                /**
                 * The current state of this promise.
                 */
                this.state = 1 /* Pending */;
                this[Symbol.toStringTag] = 'Promise';
                /**
                 * If true, the resolution of this promise is chained ("locked in") to another promise.
                 */
                var isChained = false;
                /**
                 * Whether or not this promise is in a resolved state.
                 */
                var isResolved = function () {
                    return _this.state !== 1 /* Pending */ || isChained;
                };
                /**
                 * Callbacks that should be invoked once the asynchronous operation has completed.
                 */
                var callbacks = [];
                /**
                 * Initially pushes callbacks onto a queue for execution once this promise settles. After the promise settles,
                 * enqueues callbacks for execution on the next event loop turn.
                 */
                var whenFinished = function (callback) {
                    if (callbacks) {
                        callbacks.push(callback);
                    }
                };
                /**
                 * Settles this promise.
                 *
                 * @param newState The resolved state for this promise.
                 * @param {T|any} value The resolved value for this promise.
                 */
                var settle = function (newState, value) {
                    // A promise can only be settled once.
                    if (_this.state !== 1 /* Pending */) {
                        return;
                    }
                    _this.state = newState;
                    _this.resolvedValue = value;
                    whenFinished = queue_1.queueMicroTask;
                    // Only enqueue a callback runner if there are callbacks so that initially fulfilled Promises don't have to
                    // wait an extra turn.
                    if (callbacks && callbacks.length > 0) {
                        queue_1.queueMicroTask(function () {
                            if (callbacks) {
                                var count = callbacks.length;
                                for (var i = 0; i < count; ++i) {
                                    callbacks[i].call(null);
                                }
                                callbacks = null;
                            }
                        });
                    }
                };
                /**
                 * Resolves this promise.
                 *
                 * @param newState The resolved state for this promise.
                 * @param {T|any} value The resolved value for this promise.
                 */
                var resolve = function (newState, value) {
                    if (isResolved()) {
                        return;
                    }
                    if (exports.isThenable(value)) {
                        value.then(settle.bind(null, 0 /* Fulfilled */), settle.bind(null, 2 /* Rejected */));
                        isChained = true;
                    }
                    else {
                        settle(newState, value);
                    }
                };
                this.then = function (onFulfilled, onRejected) {
                    return new Promise(function (resolve, reject) {
                        // whenFinished initially queues up callbacks for execution after the promise has settled. Once the
                        // promise has settled, whenFinished will schedule callbacks for execution on the next turn through the
                        // event loop.
                        whenFinished(function () {
                            var callback = _this.state === 2 /* Rejected */ ? onRejected : onFulfilled;
                            if (typeof callback === 'function') {
                                try {
                                    resolve(callback(_this.resolvedValue));
                                }
                                catch (error) {
                                    reject(error);
                                }
                            }
                            else if (_this.state === 2 /* Rejected */) {
                                reject(_this.resolvedValue);
                            }
                            else {
                                resolve(_this.resolvedValue);
                            }
                        });
                    });
                };
                try {
                    executor(resolve.bind(null, 0 /* Fulfilled */), resolve.bind(null, 2 /* Rejected */));
                }
                catch (error) {
                    settle(2 /* Rejected */, error);
                }
            }
            Promise.all = function (iterable) {
                return new this(function (resolve, reject) {
                    var values = [];
                    var complete = 0;
                    var total = 0;
                    var populating = true;
                    function fulfill(index, value) {
                        values[index] = value;
                        ++complete;
                        finish();
                    }
                    function finish() {
                        if (populating || complete < total) {
                            return;
                        }
                        resolve(values);
                    }
                    function processItem(index, item) {
                        ++total;
                        if (exports.isThenable(item)) {
                            // If an item Promise rejects, this Promise is immediately rejected with the item
                            // Promise's rejection error.
                            item.then(fulfill.bind(null, index), reject);
                        }
                        else {
                            Promise.resolve(item).then(fulfill.bind(null, index));
                        }
                    }
                    var i = 0;
                    try {
                        for (var iterable_1 = tslib_1.__values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
                            var value = iterable_1_1.value;
                            processItem(i, value);
                            i++;
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return)) _a.call(iterable_1);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    populating = false;
                    finish();
                    var e_1, _a;
                });
            };
            Promise.race = function (iterable) {
                return new this(function (resolve, reject) {
                    try {
                        for (var iterable_2 = tslib_1.__values(iterable), iterable_2_1 = iterable_2.next(); !iterable_2_1.done; iterable_2_1 = iterable_2.next()) {
                            var item = iterable_2_1.value;
                            if (item instanceof Promise) {
                                // If a Promise item rejects, this Promise is immediately rejected with the item
                                // Promise's rejection error.
                                item.then(resolve, reject);
                            }
                            else {
                                Promise.resolve(item).then(resolve);
                            }
                        }
                    }
                    catch (e_2_1) { e_2 = { error: e_2_1 }; }
                    finally {
                        try {
                            if (iterable_2_1 && !iterable_2_1.done && (_a = iterable_2.return)) _a.call(iterable_2);
                        }
                        finally { if (e_2) throw e_2.error; }
                    }
                    var e_2, _a;
                });
            };
            Promise.reject = function (reason) {
                return new this(function (resolve, reject) {
                    reject(reason);
                });
            };
            Promise.resolve = function (value) {
                return new this(function (resolve) {
                    resolve(value);
                });
            };
            Promise.prototype.catch = function (onRejected) {
                return this.then(undefined, onRejected);
            };
            return Promise;
        }()),
        _a[Symbol.species] = exports.ShimPromise,
        _a);
}
exports.default = exports.ShimPromise;
var _a;

/***/ }),

/***/ "./node_modules/@dojo/shim/Symbol.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var util_1 = __webpack_require__("./node_modules/@dojo/shim/support/util.js");
exports.Symbol = global_1.default.Symbol;
if (!has_1.default('es6-symbol')) {
    /**
     * Throws if the value is not a symbol, used internally within the Shim
     * @param  {any}    value The value to check
     * @return {symbol}       Returns the symbol or throws
     */
    var validateSymbol_1 = function validateSymbol(value) {
        if (!isSymbol(value)) {
            throw new TypeError(value + ' is not a symbol');
        }
        return value;
    };
    var defineProperties_1 = Object.defineProperties;
    var defineProperty_1 = Object.defineProperty;
    var create_1 = Object.create;
    var objPrototype_1 = Object.prototype;
    var globalSymbols_1 = {};
    var getSymbolName_1 = (function () {
        var created = create_1(null);
        return function (desc) {
            var postfix = 0;
            var name;
            while (created[String(desc) + (postfix || '')]) {
                ++postfix;
            }
            desc += String(postfix || '');
            created[desc] = true;
            name = '@@' + desc;
            // FIXME: Temporary guard until the duplicate execution when testing can be
            // pinned down.
            if (!Object.getOwnPropertyDescriptor(objPrototype_1, name)) {
                defineProperty_1(objPrototype_1, name, {
                    set: function (value) {
                        defineProperty_1(this, name, util_1.getValueDescriptor(value));
                    }
                });
            }
            return name;
        };
    })();
    var InternalSymbol_1 = function Symbol(description) {
        if (this instanceof InternalSymbol_1) {
            throw new TypeError('TypeError: Symbol is not a constructor');
        }
        return Symbol(description);
    };
    exports.Symbol = global_1.default.Symbol = function Symbol(description) {
        if (this instanceof Symbol) {
            throw new TypeError('TypeError: Symbol is not a constructor');
        }
        var sym = Object.create(InternalSymbol_1.prototype);
        description = description === undefined ? '' : String(description);
        return defineProperties_1(sym, {
            __description__: util_1.getValueDescriptor(description),
            __name__: util_1.getValueDescriptor(getSymbolName_1(description))
        });
    };
    /* Decorate the Symbol function with the appropriate properties */
    defineProperty_1(exports.Symbol, 'for', util_1.getValueDescriptor(function (key) {
        if (globalSymbols_1[key]) {
            return globalSymbols_1[key];
        }
        return (globalSymbols_1[key] = exports.Symbol(String(key)));
    }));
    defineProperties_1(exports.Symbol, {
        keyFor: util_1.getValueDescriptor(function (sym) {
            var key;
            validateSymbol_1(sym);
            for (key in globalSymbols_1) {
                if (globalSymbols_1[key] === sym) {
                    return key;
                }
            }
        }),
        hasInstance: util_1.getValueDescriptor(exports.Symbol.for('hasInstance'), false, false),
        isConcatSpreadable: util_1.getValueDescriptor(exports.Symbol.for('isConcatSpreadable'), false, false),
        iterator: util_1.getValueDescriptor(exports.Symbol.for('iterator'), false, false),
        match: util_1.getValueDescriptor(exports.Symbol.for('match'), false, false),
        observable: util_1.getValueDescriptor(exports.Symbol.for('observable'), false, false),
        replace: util_1.getValueDescriptor(exports.Symbol.for('replace'), false, false),
        search: util_1.getValueDescriptor(exports.Symbol.for('search'), false, false),
        species: util_1.getValueDescriptor(exports.Symbol.for('species'), false, false),
        split: util_1.getValueDescriptor(exports.Symbol.for('split'), false, false),
        toPrimitive: util_1.getValueDescriptor(exports.Symbol.for('toPrimitive'), false, false),
        toStringTag: util_1.getValueDescriptor(exports.Symbol.for('toStringTag'), false, false),
        unscopables: util_1.getValueDescriptor(exports.Symbol.for('unscopables'), false, false)
    });
    /* Decorate the InternalSymbol object */
    defineProperties_1(InternalSymbol_1.prototype, {
        constructor: util_1.getValueDescriptor(exports.Symbol),
        toString: util_1.getValueDescriptor(function () {
            return this.__name__;
        }, false, false)
    });
    /* Decorate the Symbol.prototype */
    defineProperties_1(exports.Symbol.prototype, {
        toString: util_1.getValueDescriptor(function () {
            return 'Symbol (' + validateSymbol_1(this).__description__ + ')';
        }),
        valueOf: util_1.getValueDescriptor(function () {
            return validateSymbol_1(this);
        })
    });
    defineProperty_1(exports.Symbol.prototype, exports.Symbol.toPrimitive, util_1.getValueDescriptor(function () {
        return validateSymbol_1(this);
    }));
    defineProperty_1(exports.Symbol.prototype, exports.Symbol.toStringTag, util_1.getValueDescriptor('Symbol', false, false, true));
    defineProperty_1(InternalSymbol_1.prototype, exports.Symbol.toPrimitive, util_1.getValueDescriptor(exports.Symbol.prototype[exports.Symbol.toPrimitive], false, false, true));
    defineProperty_1(InternalSymbol_1.prototype, exports.Symbol.toStringTag, util_1.getValueDescriptor(exports.Symbol.prototype[exports.Symbol.toStringTag], false, false, true));
}
/**
 * A custom guard function that determines if an object is a symbol or not
 * @param  {any}       value The value to check to see if it is a symbol or not
 * @return {is symbol}       Returns true if a symbol or not (and narrows the type guard)
 */
function isSymbol(value) {
    return (value && (typeof value === 'symbol' || value['@@toStringTag'] === 'Symbol')) || false;
}
exports.isSymbol = isSymbol;
/**
 * Fill any missing well known symbols if the native Symbol is missing them
 */
[
    'hasInstance',
    'isConcatSpreadable',
    'iterator',
    'species',
    'replace',
    'search',
    'split',
    'match',
    'toPrimitive',
    'toStringTag',
    'unscopables',
    'observable'
].forEach(function (wellKnown) {
    if (!exports.Symbol[wellKnown]) {
        Object.defineProperty(exports.Symbol, wellKnown, util_1.getValueDescriptor(exports.Symbol.for(wellKnown), false, false));
    }
});
exports.default = exports.Symbol;

/***/ }),

/***/ "./node_modules/@dojo/shim/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// !has('dom-pointer-events')
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__("./node_modules/pepjs/dist/pep.js");
// !has('dom-intersection-observer')
__webpack_require__("./node_modules/intersection-observer/intersection-observer.js");
// !has('dom-webanimation')
__webpack_require__("./node_modules/web-animations-js/web-animations-next-lite.min.js");

/***/ }),

/***/ "./node_modules/@dojo/shim/global.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var globalObject = (function () {
    if (typeof global !== 'undefined') {
        // global spec defines a reference to the global object called 'global'
        // https://github.com/tc39/proposal-global
        // `global` is also defined in NodeJS
        return global;
    }
    else if (typeof window !== 'undefined') {
        // window is defined in browsers
        return window;
    }
    else if (typeof self !== 'undefined') {
        // self is defined in WebWorkers
        return self;
    }
})();
exports.default = globalObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@dojo/shim/iterator.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__("./node_modules/@dojo/shim/Symbol.js");
var string_1 = __webpack_require__("./node_modules/@dojo/shim/string.js");
var staticDone = { done: true, value: undefined };
/**
 * A class that _shims_ an iterator interface on array like objects.
 */
var ShimIterator = /** @class */ (function () {
    function ShimIterator(list) {
        this._nextIndex = -1;
        if (isIterable(list)) {
            this._nativeIterator = list[Symbol.iterator]();
        }
        else {
            this._list = list;
        }
    }
    /**
     * Return the next iteration result for the Iterator
     */
    ShimIterator.prototype.next = function () {
        if (this._nativeIterator) {
            return this._nativeIterator.next();
        }
        if (!this._list) {
            return staticDone;
        }
        if (++this._nextIndex < this._list.length) {
            return {
                done: false,
                value: this._list[this._nextIndex]
            };
        }
        return staticDone;
    };
    ShimIterator.prototype[Symbol.iterator] = function () {
        return this;
    };
    return ShimIterator;
}());
exports.ShimIterator = ShimIterator;
/**
 * A type guard for checking if something has an Iterable interface
 *
 * @param value The value to type guard against
 */
function isIterable(value) {
    return value && typeof value[Symbol.iterator] === 'function';
}
exports.isIterable = isIterable;
/**
 * A type guard for checking if something is ArrayLike
 *
 * @param value The value to type guard against
 */
function isArrayLike(value) {
    return value && typeof value.length === 'number';
}
exports.isArrayLike = isArrayLike;
/**
 * Returns the iterator for an object
 *
 * @param iterable The iterable object to return the iterator for
 */
function get(iterable) {
    if (isIterable(iterable)) {
        return iterable[Symbol.iterator]();
    }
    else if (isArrayLike(iterable)) {
        return new ShimIterator(iterable);
    }
}
exports.get = get;
/**
 * Shims the functionality of `for ... of` blocks
 *
 * @param iterable The object the provides an interator interface
 * @param callback The callback which will be called for each item of the iterable
 * @param thisArg Optional scope to pass the callback
 */
function forOf(iterable, callback, thisArg) {
    var broken = false;
    function doBreak() {
        broken = true;
    }
    /* We need to handle iteration of double byte strings properly */
    if (isArrayLike(iterable) && typeof iterable === 'string') {
        var l = iterable.length;
        for (var i = 0; i < l; ++i) {
            var char = iterable[i];
            if (i + 1 < l) {
                var code = char.charCodeAt(0);
                if (code >= string_1.HIGH_SURROGATE_MIN && code <= string_1.HIGH_SURROGATE_MAX) {
                    char += iterable[++i];
                }
            }
            callback.call(thisArg, char, iterable, doBreak);
            if (broken) {
                return;
            }
        }
    }
    else {
        var iterator = get(iterable);
        if (iterator) {
            var result = iterator.next();
            while (!result.done) {
                callback.call(thisArg, result.value, iterable, doBreak);
                if (broken) {
                    return;
                }
                result = iterator.next();
            }
        }
    }
}
exports.forOf = forOf;

/***/ }),

/***/ "./node_modules/@dojo/shim/object.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
var Symbol_1 = __webpack_require__("./node_modules/@dojo/shim/Symbol.js");
if (has_1.default('es6-object')) {
    var globalObject = global_1.default.Object;
    exports.assign = globalObject.assign;
    exports.getOwnPropertyDescriptor = globalObject.getOwnPropertyDescriptor;
    exports.getOwnPropertyNames = globalObject.getOwnPropertyNames;
    exports.getOwnPropertySymbols = globalObject.getOwnPropertySymbols;
    exports.is = globalObject.is;
    exports.keys = globalObject.keys;
}
else {
    exports.keys = function symbolAwareKeys(o) {
        return Object.keys(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });
    };
    exports.assign = function assign(target) {
        var sources = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            sources[_i - 1] = arguments[_i];
        }
        if (target == null) {
            // TypeError if undefined or null
            throw new TypeError('Cannot convert undefined or null to object');
        }
        var to = Object(target);
        sources.forEach(function (nextSource) {
            if (nextSource) {
                // Skip over if undefined or null
                exports.keys(nextSource).forEach(function (nextKey) {
                    to[nextKey] = nextSource[nextKey];
                });
            }
        });
        return to;
    };
    exports.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(o, prop) {
        if (Symbol_1.isSymbol(prop)) {
            return Object.getOwnPropertyDescriptor(o, prop);
        }
        else {
            return Object.getOwnPropertyDescriptor(o, prop);
        }
    };
    exports.getOwnPropertyNames = function getOwnPropertyNames(o) {
        return Object.getOwnPropertyNames(o).filter(function (key) { return !Boolean(key.match(/^@@.+/)); });
    };
    exports.getOwnPropertySymbols = function getOwnPropertySymbols(o) {
        return Object.getOwnPropertyNames(o)
            .filter(function (key) { return Boolean(key.match(/^@@.+/)); })
            .map(function (key) { return Symbol.for(key.substring(2)); });
    };
    exports.is = function is(value1, value2) {
        if (value1 === value2) {
            return value1 !== 0 || 1 / value1 === 1 / value2; // -0
        }
        return value1 !== value1 && value2 !== value2; // NaN
    };
}
if (has_1.default('es2017-object')) {
    var globalObject = global_1.default.Object;
    exports.getOwnPropertyDescriptors = globalObject.getOwnPropertyDescriptors;
    exports.entries = globalObject.entries;
    exports.values = globalObject.values;
}
else {
    exports.getOwnPropertyDescriptors = function getOwnPropertyDescriptors(o) {
        return exports.getOwnPropertyNames(o).reduce(function (previous, key) {
            previous[key] = exports.getOwnPropertyDescriptor(o, key);
            return previous;
        }, {});
    };
    exports.entries = function entries(o) {
        return exports.keys(o).map(function (key) { return [key, o[key]]; });
    };
    exports.values = function values(o) {
        return exports.keys(o).map(function (key) { return o[key]; });
    };
}

/***/ }),

/***/ "./node_modules/@dojo/shim/string.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
var util_1 = __webpack_require__("./node_modules/@dojo/shim/support/util.js");
/**
 * The minimum location of high surrogates
 */
exports.HIGH_SURROGATE_MIN = 0xd800;
/**
 * The maximum location of high surrogates
 */
exports.HIGH_SURROGATE_MAX = 0xdbff;
/**
 * The minimum location of low surrogates
 */
exports.LOW_SURROGATE_MIN = 0xdc00;
/**
 * The maximum location of low surrogates
 */
exports.LOW_SURROGATE_MAX = 0xdfff;
if (has_1.default('es6-string') && has_1.default('es6-string-raw')) {
    exports.fromCodePoint = global_1.default.String.fromCodePoint;
    exports.raw = global_1.default.String.raw;
    exports.codePointAt = util_1.wrapNative(global_1.default.String.prototype.codePointAt);
    exports.endsWith = util_1.wrapNative(global_1.default.String.prototype.endsWith);
    exports.includes = util_1.wrapNative(global_1.default.String.prototype.includes);
    exports.normalize = util_1.wrapNative(global_1.default.String.prototype.normalize);
    exports.repeat = util_1.wrapNative(global_1.default.String.prototype.repeat);
    exports.startsWith = util_1.wrapNative(global_1.default.String.prototype.startsWith);
}
else {
    /**
     * Validates that text is defined, and normalizes position (based on the given default if the input is NaN).
     * Used by startsWith, includes, and endsWith.
     *
     * @return Normalized position.
     */
    var normalizeSubstringArgs_1 = function (name, text, search, position, isEnd) {
        if (isEnd === void 0) { isEnd = false; }
        if (text == null) {
            throw new TypeError('string.' + name + ' requires a valid string to search against.');
        }
        var length = text.length;
        position = position !== position ? (isEnd ? length : 0) : position;
        return [text, String(search), Math.min(Math.max(position, 0), length)];
    };
    exports.fromCodePoint = function fromCodePoint() {
        var codePoints = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            codePoints[_i] = arguments[_i];
        }
        // Adapted from https://github.com/mathiasbynens/String.fromCodePoint
        var length = arguments.length;
        if (!length) {
            return '';
        }
        var fromCharCode = String.fromCharCode;
        var MAX_SIZE = 0x4000;
        var codeUnits = [];
        var index = -1;
        var result = '';
        while (++index < length) {
            var codePoint = Number(arguments[index]);
            // Code points must be finite integers within the valid range
            var isValid = isFinite(codePoint) && Math.floor(codePoint) === codePoint && codePoint >= 0 && codePoint <= 0x10ffff;
            if (!isValid) {
                throw RangeError('string.fromCodePoint: Invalid code point ' + codePoint);
            }
            if (codePoint <= 0xffff) {
                // BMP code point
                codeUnits.push(codePoint);
            }
            else {
                // Astral code point; split in surrogate halves
                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                codePoint -= 0x10000;
                var highSurrogate = (codePoint >> 10) + exports.HIGH_SURROGATE_MIN;
                var lowSurrogate = codePoint % 0x400 + exports.LOW_SURROGATE_MIN;
                codeUnits.push(highSurrogate, lowSurrogate);
            }
            if (index + 1 === length || codeUnits.length > MAX_SIZE) {
                result += fromCharCode.apply(null, codeUnits);
                codeUnits.length = 0;
            }
        }
        return result;
    };
    exports.raw = function raw(callSite) {
        var substitutions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            substitutions[_i - 1] = arguments[_i];
        }
        var rawStrings = callSite.raw;
        var result = '';
        var numSubstitutions = substitutions.length;
        if (callSite == null || callSite.raw == null) {
            throw new TypeError('string.raw requires a valid callSite object with a raw value');
        }
        for (var i = 0, length_1 = rawStrings.length; i < length_1; i++) {
            result += rawStrings[i] + (i < numSubstitutions && i < length_1 - 1 ? substitutions[i] : '');
        }
        return result;
    };
    exports.codePointAt = function codePointAt(text, position) {
        if (position === void 0) { position = 0; }
        // Adapted from https://github.com/mathiasbynens/String.prototype.codePointAt
        if (text == null) {
            throw new TypeError('string.codePointAt requries a valid string.');
        }
        var length = text.length;
        if (position !== position) {
            position = 0;
        }
        if (position < 0 || position >= length) {
            return undefined;
        }
        // Get the first code unit
        var first = text.charCodeAt(position);
        if (first >= exports.HIGH_SURROGATE_MIN && first <= exports.HIGH_SURROGATE_MAX && length > position + 1) {
            // Start of a surrogate pair (high surrogate and there is a next code unit); check for low surrogate
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            var second = text.charCodeAt(position + 1);
            if (second >= exports.LOW_SURROGATE_MIN && second <= exports.LOW_SURROGATE_MAX) {
                return (first - exports.HIGH_SURROGATE_MIN) * 0x400 + second - exports.LOW_SURROGATE_MIN + 0x10000;
            }
        }
        return first;
    };
    exports.endsWith = function endsWith(text, search, endPosition) {
        if (endPosition == null) {
            endPosition = text.length;
        }
        _a = tslib_1.__read(normalizeSubstringArgs_1('endsWith', text, search, endPosition, true), 3), text = _a[0], search = _a[1], endPosition = _a[2];
        var start = endPosition - search.length;
        if (start < 0) {
            return false;
        }
        return text.slice(start, endPosition) === search;
        var _a;
    };
    exports.includes = function includes(text, search, position) {
        if (position === void 0) { position = 0; }
        _a = tslib_1.__read(normalizeSubstringArgs_1('includes', text, search, position), 3), text = _a[0], search = _a[1], position = _a[2];
        return text.indexOf(search, position) !== -1;
        var _a;
    };
    exports.repeat = function repeat(text, count) {
        if (count === void 0) { count = 0; }
        // Adapted from https://github.com/mathiasbynens/String.prototype.repeat
        if (text == null) {
            throw new TypeError('string.repeat requires a valid string.');
        }
        if (count !== count) {
            count = 0;
        }
        if (count < 0 || count === Infinity) {
            throw new RangeError('string.repeat requires a non-negative finite count.');
        }
        var result = '';
        while (count) {
            if (count % 2) {
                result += text;
            }
            if (count > 1) {
                text += text;
            }
            count >>= 1;
        }
        return result;
    };
    exports.startsWith = function startsWith(text, search, position) {
        if (position === void 0) { position = 0; }
        search = String(search);
        _a = tslib_1.__read(normalizeSubstringArgs_1('startsWith', text, search, position), 3), text = _a[0], search = _a[1], position = _a[2];
        var end = position + search.length;
        if (end > text.length) {
            return false;
        }
        return text.slice(position, end) === search;
        var _a;
    };
}
if (has_1.default('es2017-string')) {
    exports.padEnd = util_1.wrapNative(global_1.default.String.prototype.padEnd);
    exports.padStart = util_1.wrapNative(global_1.default.String.prototype.padStart);
}
else {
    exports.padEnd = function padEnd(text, maxLength, fillString) {
        if (fillString === void 0) { fillString = ' '; }
        if (text === null || text === undefined) {
            throw new TypeError('string.repeat requires a valid string.');
        }
        if (maxLength === Infinity) {
            throw new RangeError('string.padEnd requires a non-negative finite count.');
        }
        if (maxLength === null || maxLength === undefined || maxLength < 0) {
            maxLength = 0;
        }
        var strText = String(text);
        var padding = maxLength - strText.length;
        if (padding > 0) {
            strText +=
                exports.repeat(fillString, Math.floor(padding / fillString.length)) +
                    fillString.slice(0, padding % fillString.length);
        }
        return strText;
    };
    exports.padStart = function padStart(text, maxLength, fillString) {
        if (fillString === void 0) { fillString = ' '; }
        if (text === null || text === undefined) {
            throw new TypeError('string.repeat requires a valid string.');
        }
        if (maxLength === Infinity) {
            throw new RangeError('string.padStart requires a non-negative finite count.');
        }
        if (maxLength === null || maxLength === undefined || maxLength < 0) {
            maxLength = 0;
        }
        var strText = String(text);
        var padding = maxLength - strText.length;
        if (padding > 0) {
            strText =
                exports.repeat(fillString, Math.floor(padding / fillString.length)) +
                    fillString.slice(0, padding % fillString.length) +
                    strText;
        }
        return strText;
    };
}

/***/ }),

/***/ "./node_modules/@dojo/shim/support/has.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var has_1 = __webpack_require__("./node_modules/@dojo/has/has.js");
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
exports.default = has_1.default;
tslib_1.__exportStar(__webpack_require__("./node_modules/@dojo/has/has.js"), exports);
/* ECMAScript 6 and 7 Features */
/* Array */
has_1.add('es6-array', function () {
    return (['from', 'of'].every(function (key) { return key in global_1.default.Array; }) &&
        ['findIndex', 'find', 'copyWithin'].every(function (key) { return key in global_1.default.Array.prototype; }));
}, true);
has_1.add('es6-array-fill', function () {
    if ('fill' in global_1.default.Array.prototype) {
        /* Some versions of Safari do not properly implement this */
        return [1].fill(9, Number.POSITIVE_INFINITY)[0] === 1;
    }
    return false;
}, true);
has_1.add('es7-array', function () { return 'includes' in global_1.default.Array.prototype; }, true);
/* Map */
has_1.add('es6-map', function () {
    if (typeof global_1.default.Map === 'function') {
        /*
    IE11 and older versions of Safari are missing critical ES6 Map functionality
    We wrap this in a try/catch because sometimes the Map constructor exists, but does not
    take arguments (iOS 8.4)
     */
        try {
            var map = new global_1.default.Map([[0, 1]]);
            return (map.has(0) &&
                typeof map.keys === 'function' &&
                has_1.default('es6-symbol') &&
                typeof map.values === 'function' &&
                typeof map.entries === 'function');
        }
        catch (e) {
            /* istanbul ignore next: not testing on iOS at the moment */
            return false;
        }
    }
    return false;
}, true);
/* Math */
has_1.add('es6-math', function () {
    return [
        'clz32',
        'sign',
        'log10',
        'log2',
        'log1p',
        'expm1',
        'cosh',
        'sinh',
        'tanh',
        'acosh',
        'asinh',
        'atanh',
        'trunc',
        'fround',
        'cbrt',
        'hypot'
    ].every(function (name) { return typeof global_1.default.Math[name] === 'function'; });
}, true);
has_1.add('es6-math-imul', function () {
    if ('imul' in global_1.default.Math) {
        /* Some versions of Safari on ios do not properly implement this */
        return Math.imul(0xffffffff, 5) === -5;
    }
    return false;
}, true);
/* Object */
has_1.add('es6-object', function () {
    return (has_1.default('es6-symbol') &&
        ['assign', 'is', 'getOwnPropertySymbols', 'setPrototypeOf'].every(function (name) { return typeof global_1.default.Object[name] === 'function'; }));
}, true);
has_1.add('es2017-object', function () {
    return ['values', 'entries', 'getOwnPropertyDescriptors'].every(function (name) { return typeof global_1.default.Object[name] === 'function'; });
}, true);
/* Observable */
has_1.add('es-observable', function () { return typeof global_1.default.Observable !== 'undefined'; }, true);
/* Promise */
has_1.add('es6-promise', function () { return typeof global_1.default.Promise !== 'undefined' && has_1.default('es6-symbol'); }, true);
/* Set */
has_1.add('es6-set', function () {
    if (typeof global_1.default.Set === 'function') {
        /* IE11 and older versions of Safari are missing critical ES6 Set functionality */
        var set = new global_1.default.Set([1]);
        return set.has(1) && 'keys' in set && typeof set.keys === 'function' && has_1.default('es6-symbol');
    }
    return false;
}, true);
/* String */
has_1.add('es6-string', function () {
    return ([
        /* static methods */
        'fromCodePoint'
    ].every(function (key) { return typeof global_1.default.String[key] === 'function'; }) &&
        [
            /* instance methods */
            'codePointAt',
            'normalize',
            'repeat',
            'startsWith',
            'endsWith',
            'includes'
        ].every(function (key) { return typeof global_1.default.String.prototype[key] === 'function'; }));
}, true);
has_1.add('es6-string-raw', function () {
    function getCallSite(callSite) {
        var substitutions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            substitutions[_i - 1] = arguments[_i];
        }
        var result = tslib_1.__spread(callSite);
        result.raw = callSite.raw;
        return result;
    }
    if ('raw' in global_1.default.String) {
        var b = 1;
        var callSite = getCallSite(templateObject_1 || (templateObject_1 = tslib_1.__makeTemplateObject(["a\n", ""], ["a\\n", ""])), b);
        callSite.raw = ['a\\n'];
        var supportsTrunc = global_1.default.String.raw(callSite, 42) === 'a:\\n';
        return supportsTrunc;
    }
    return false;
}, true);
has_1.add('es2017-string', function () {
    return ['padStart', 'padEnd'].every(function (key) { return typeof global_1.default.String.prototype[key] === 'function'; });
}, true);
/* Symbol */
has_1.add('es6-symbol', function () { return typeof global_1.default.Symbol !== 'undefined' && typeof Symbol() === 'symbol'; }, true);
/* WeakMap */
has_1.add('es6-weakmap', function () {
    if (typeof global_1.default.WeakMap !== 'undefined') {
        /* IE11 and older versions of Safari are missing critical ES6 Map functionality */
        var key1 = {};
        var key2 = {};
        var map = new global_1.default.WeakMap([[key1, 1]]);
        Object.freeze(key1);
        return map.get(key1) === 1 && map.set(key2, 2) === map && has_1.default('es6-symbol');
    }
    return false;
}, true);
/* Miscellaneous features */
has_1.add('microtasks', function () { return has_1.default('es6-promise') || has_1.default('host-node') || has_1.default('dom-mutationobserver'); }, true);
has_1.add('postmessage', function () {
    // If window is undefined, and we have postMessage, it probably means we're in a web worker. Web workers have
    // post message but it doesn't work how we expect it to, so it's best just to pretend it doesn't exist.
    return typeof global_1.default.window !== 'undefined' && typeof global_1.default.postMessage === 'function';
}, true);
has_1.add('raf', function () { return typeof global_1.default.requestAnimationFrame === 'function'; }, true);
has_1.add('setimmediate', function () { return typeof global_1.default.setImmediate !== 'undefined'; }, true);
/* DOM Features */
has_1.add('dom-mutationobserver', function () {
    if (has_1.default('host-browser') && Boolean(global_1.default.MutationObserver || global_1.default.WebKitMutationObserver)) {
        // IE11 has an unreliable MutationObserver implementation where setProperty() does not
        // generate a mutation event, observers can crash, and the queue does not drain
        // reliably. The following feature test was adapted from
        // https://gist.github.com/t10ko/4aceb8c71681fdb275e33efe5e576b14
        var example = document.createElement('div');
        /* tslint:disable-next-line:variable-name */
        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;
        var observer = new HostMutationObserver(function () { });
        observer.observe(example, { attributes: true });
        example.style.setProperty('display', 'block');
        return Boolean(observer.takeRecords().length);
    }
    return false;
}, true);
has_1.add('dom-webanimation', function () { return has_1.default('host-browser') && global_1.default.Animation !== undefined && global_1.default.KeyframeEffect !== undefined; }, true);
var templateObject_1;

/***/ }),

/***/ "./node_modules/@dojo/shim/support/queue.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {
Object.defineProperty(exports, "__esModule", { value: true });
var global_1 = __webpack_require__("./node_modules/@dojo/shim/global.js");
var has_1 = __webpack_require__("./node_modules/@dojo/shim/support/has.js");
function executeTask(item) {
    if (item && item.isActive && item.callback) {
        item.callback();
    }
}
function getQueueHandle(item, destructor) {
    return {
        destroy: function () {
            this.destroy = function () { };
            item.isActive = false;
            item.callback = null;
            if (destructor) {
                destructor();
            }
        }
    };
}
var checkMicroTaskQueue;
var microTasks;
/**
 * Schedules a callback to the macrotask queue.
 *
 * @param callback the function to be queued and later executed.
 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
 */
exports.queueTask = (function () {
    var destructor;
    var enqueue;
    // Since the IE implementation of `setImmediate` is not flawless, we will test for `postMessage` first.
    if (has_1.default('postmessage')) {
        var queue_1 = [];
        global_1.default.addEventListener('message', function (event) {
            // Confirm that the event was triggered by the current window and by this particular implementation.
            if (event.source === global_1.default && event.data === 'dojo-queue-message') {
                event.stopPropagation();
                if (queue_1.length) {
                    executeTask(queue_1.shift());
                }
            }
        });
        enqueue = function (item) {
            queue_1.push(item);
            global_1.default.postMessage('dojo-queue-message', '*');
        };
    }
    else if (has_1.default('setimmediate')) {
        destructor = global_1.default.clearImmediate;
        enqueue = function (item) {
            return setImmediate(executeTask.bind(null, item));
        };
    }
    else {
        destructor = global_1.default.clearTimeout;
        enqueue = function (item) {
            return setTimeout(executeTask.bind(null, item), 0);
        };
    }
    function queueTask(callback) {
        var item = {
            isActive: true,
            callback: callback
        };
        var id = enqueue(item);
        return getQueueHandle(item, destructor &&
            function () {
                destructor(id);
            });
    }
    // TODO: Use aspect.before when it is available.
    return has_1.default('microtasks')
        ? queueTask
        : function (callback) {
            checkMicroTaskQueue();
            return queueTask(callback);
        };
})();
// When no mechanism for registering microtasks is exposed by the environment, microtasks will
// be queued and then executed in a single macrotask before the other macrotasks are executed.
if (!has_1.default('microtasks')) {
    var isMicroTaskQueued_1 = false;
    microTasks = [];
    checkMicroTaskQueue = function () {
        if (!isMicroTaskQueued_1) {
            isMicroTaskQueued_1 = true;
            exports.queueTask(function () {
                isMicroTaskQueued_1 = false;
                if (microTasks.length) {
                    var item = void 0;
                    while ((item = microTasks.shift())) {
                        executeTask(item);
                    }
                }
            });
        }
    };
}
/**
 * Schedules an animation task with `window.requestAnimationFrame` if it exists, or with `queueTask` otherwise.
 *
 * Since requestAnimationFrame's behavior does not match that expected from `queueTask`, it is not used there.
 * However, at times it makes more sense to delegate to requestAnimationFrame; hence the following method.
 *
 * @param callback the function to be queued and later executed.
 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
 */
exports.queueAnimationTask = (function () {
    if (!has_1.default('raf')) {
        return exports.queueTask;
    }
    function queueAnimationTask(callback) {
        var item = {
            isActive: true,
            callback: callback
        };
        var rafId = requestAnimationFrame(executeTask.bind(null, item));
        return getQueueHandle(item, function () {
            cancelAnimationFrame(rafId);
        });
    }
    // TODO: Use aspect.before when it is available.
    return has_1.default('microtasks')
        ? queueAnimationTask
        : function (callback) {
            checkMicroTaskQueue();
            return queueAnimationTask(callback);
        };
})();
/**
 * Schedules a callback to the microtask queue.
 *
 * Any callbacks registered with `queueMicroTask` will be executed before the next macrotask. If no native
 * mechanism for scheduling macrotasks is exposed, then any callbacks will be fired before any macrotask
 * registered with `queueTask` or `queueAnimationTask`.
 *
 * @param callback the function to be queued and later executed.
 * @returns An object with a `destroy` method that, when called, prevents the registered callback from executing.
 */
exports.queueMicroTask = (function () {
    var enqueue;
    if (has_1.default('host-node')) {
        enqueue = function (item) {
            global_1.default.process.nextTick(executeTask.bind(null, item));
        };
    }
    else if (has_1.default('es6-promise')) {
        enqueue = function (item) {
            global_1.default.Promise.resolve(item).then(executeTask);
        };
    }
    else if (has_1.default('dom-mutationobserver')) {
        /* tslint:disable-next-line:variable-name */
        var HostMutationObserver = global_1.default.MutationObserver || global_1.default.WebKitMutationObserver;
        var node_1 = document.createElement('div');
        var queue_2 = [];
        var observer = new HostMutationObserver(function () {
            while (queue_2.length > 0) {
                var item = queue_2.shift();
                if (item && item.isActive && item.callback) {
                    item.callback();
                }
            }
        });
        observer.observe(node_1, { attributes: true });
        enqueue = function (item) {
            queue_2.push(item);
            node_1.setAttribute('queueStatus', '1');
        };
    }
    else {
        enqueue = function (item) {
            checkMicroTaskQueue();
            microTasks.push(item);
        };
    }
    return function (callback) {
        var item = {
            isActive: true,
            callback: callback
        };
        enqueue(item);
        return getQueueHandle(item);
    };
})();
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/@dojo/shim/support/util.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Helper function to generate a value property descriptor
 *
 * @param value        The value the property descriptor should be set to
 * @param enumerable   If the property should be enumberable, defaults to false
 * @param writable     If the property should be writable, defaults to true
 * @param configurable If the property should be configurable, defaults to true
 * @return             The property descriptor object
 */
function getValueDescriptor(value, enumerable, writable, configurable) {
    if (enumerable === void 0) { enumerable = false; }
    if (writable === void 0) { writable = true; }
    if (configurable === void 0) { configurable = true; }
    return {
        value: value,
        enumerable: enumerable,
        writable: writable,
        configurable: configurable
    };
}
exports.getValueDescriptor = getValueDescriptor;
function wrapNative(nativeFunction) {
    return function (target) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return nativeFunction.apply(target, args);
    };
}
exports.wrapNative = wrapNative;

/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/i18n-plugin/templates/setLocaleData.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

const i18n = __webpack_require__("./node_modules/@dojo/i18n/i18n.js");
const loadCldrData = __webpack_require__("./node_modules/@dojo/i18n/cldr/load.js").default;
const systemLocale = i18n.systemLocale;
const userLocale = systemLocale.replace(/^([a-z]{2}).*/i, '$1');
const isUserLocaleSupported = userLocale === 'en' ||
    ["es"].some(function (locale) {
        return locale === systemLocale || locale === userLocale;
    });
loadCldrData({});
i18n.switchLocale(isUserLocaleSupported ? systemLocale : 'en');
//# sourceMappingURL=setLocaleData.js.map

/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,src/Foo!./src/Foo.ts":
/***/ (function(module, exports, __webpack_require__) {


module.exports = function () {
	return new Promise(function (resolve) {
	__webpack_require__.e/* require.ensure */("src/Foo").then((function (require) {
		resolve(__webpack_require__("./node_modules/@dojo/webpack-contrib/static-build-loader/index.js?{\"features\":{\"foo\":true,\"bar\":false}}!./node_modules/umd-compat-loader/index.js?{}!./node_modules/ts-loader/index.js?{\"onlyCompileBundledFiles\":true,\"instance\":\"dojo\"}!./node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.js?type=ts&instanceName=0_dojo!./src/Foo.ts"));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
	});
}

/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Bar.ts":
/***/ (function(module, exports, __webpack_require__) {


module.exports = function () {
	return new Promise(function (resolve) {
	__webpack_require__.e/* require.ensure */("widgets").then((function (require) {
		resolve(__webpack_require__("./node_modules/@dojo/webpack-contrib/static-build-loader/index.js?{\"features\":{\"foo\":true,\"bar\":false}}!./node_modules/umd-compat-loader/index.js?{}!./node_modules/ts-loader/index.js?{\"onlyCompileBundledFiles\":true,\"instance\":\"dojo\"}!./node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.js?type=ts&instanceName=0_dojo!./src/Bar.ts"));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
	});
}

/***/ }),

/***/ "./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Baz.ts":
/***/ (function(module, exports, __webpack_require__) {


module.exports = function () {
	return new Promise(function (resolve) {
	__webpack_require__.e/* require.ensure */("widgets").then((function (require) {
		resolve(__webpack_require__("./node_modules/@dojo/webpack-contrib/static-build-loader/index.js?{\"features\":{\"foo\":true,\"bar\":false}}!./node_modules/umd-compat-loader/index.js?{}!./node_modules/ts-loader/index.js?{\"onlyCompileBundledFiles\":true,\"instance\":\"dojo\"}!./node_modules/@dojo/webpack-contrib/css-module-dts-loader/index.js?type=ts&instanceName=0_dojo!./src/Baz.ts"));
	}).bind(null, __webpack_require__)).catch(__webpack_require__.oe);
	});
}

/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license © Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( root, factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory();
	} else {
		// Global
		root.Cldr = factory();
	}

}( this, function() {


	var arrayIsArray = Array.isArray || function( obj ) {
		return Object.prototype.toString.call( obj ) === "[object Array]";
	};




	var pathNormalize = function( path, attributes ) {
		if ( arrayIsArray( path ) ) {
			path = path.join( "/" );
		}
		if ( typeof path !== "string" ) {
			throw new Error( "invalid path \"" + path + "\"" );
		}
		// 1: Ignore leading slash `/`
		// 2: Ignore leading `cldr/`
		path = path
			.replace( /^\// , "" ) /* 1 */
			.replace( /^cldr\// , "" ); /* 2 */

		// Replace {attribute}'s
		path = path.replace( /{[a-zA-Z]+}/g, function( name ) {
			name = name.replace( /^{([^}]*)}$/, "$1" );
			return attributes[ name ];
		});

		return path.split( "/" );
	};




	var arraySome = function( array, callback ) {
		var i, length;
		if ( array.some ) {
			return array.some( callback );
		}
		for ( i = 0, length = array.length; i < length; i++ ) {
			if ( callback( array[ i ], i, array ) ) {
				return true;
			}
		}
		return false;
	};




	/**
	 * Return the maximized language id as defined in
	 * http://www.unicode.org/reports/tr35/#Likely_Subtags
	 * 1. Canonicalize.
	 * 1.1 Make sure the input locale is in canonical form: uses the right
	 * separator, and has the right casing.
	 * TODO Right casing? What df? It seems languages are lowercase, scripts are
	 * Capitalized, territory is uppercase. I am leaving this as an exercise to
	 * the user.
	 *
	 * 1.2 Replace any deprecated subtags with their canonical values using the
	 * <alias> data in supplemental metadata. Use the first value in the
	 * replacement list, if it exists. Language tag replacements may have multiple
	 * parts, such as "sh" ➞ "sr_Latn" or mo" ➞ "ro_MD". In such a case, the
	 * original script and/or region are retained if there is one. Thus
	 * "sh_Arab_AQ" ➞ "sr_Arab_AQ", not "sr_Latn_AQ".
	 * TODO What <alias> data?
	 *
	 * 1.3 If the tag is grandfathered (see <variable id="$grandfathered"
	 * type="choice"> in the supplemental data), then return it.
	 * TODO grandfathered?
	 *
	 * 1.4 Remove the script code 'Zzzz' and the region code 'ZZ' if they occur.
	 * 1.5 Get the components of the cleaned-up source tag (languages, scripts,
	 * and regions), plus any variants and extensions.
	 * 2. Lookup. Lookup each of the following in order, and stop on the first
	 * match:
	 * 2.1 languages_scripts_regions
	 * 2.2 languages_regions
	 * 2.3 languages_scripts
	 * 2.4 languages
	 * 2.5 und_scripts
	 * 3. Return
	 * 3.1 If there is no match, either return an error value, or the match for
	 * "und" (in APIs where a valid language tag is required).
	 * 3.2 Otherwise there is a match = languagem_scriptm_regionm
	 * 3.3 Let xr = xs if xs is not empty, and xm otherwise.
	 * 3.4 Return the language tag composed of languager _ scriptr _ regionr +
	 * variants + extensions.
	 *
	 * @subtags [Array] normalized language id subtags tuple (see init.js).
	 */
	var coreLikelySubtags = function( Cldr, cldr, subtags, options ) {
		var match, matchFound,
			language = subtags[ 0 ],
			script = subtags[ 1 ],
			sep = Cldr.localeSep,
			territory = subtags[ 2 ],
			variants = subtags.slice( 3, 4 );
		options = options || {};

		// Skip if (language, script, territory) is not empty [3.3]
		if ( language !== "und" && script !== "Zzzz" && territory !== "ZZ" ) {
			return [ language, script, territory ].concat( variants );
		}

		// Skip if no supplemental likelySubtags data is present
		if ( typeof cldr.get( "supplemental/likelySubtags" ) === "undefined" ) {
			return;
		}

		// [2]
		matchFound = arraySome([
			[ language, script, territory ],
			[ language, territory ],
			[ language, script ],
			[ language ],
			[ "und", script ]
		], function( test ) {
			return match = !(/\b(Zzzz|ZZ)\b/).test( test.join( sep ) ) /* [1.4] */ && cldr.get( [ "supplemental/likelySubtags", test.join( sep ) ] );
		});

		// [3]
		if ( matchFound ) {
			// [3.2 .. 3.4]
			match = match.split( sep );
			return [
				language !== "und" ? language : match[ 0 ],
				script !== "Zzzz" ? script : match[ 1 ],
				territory !== "ZZ" ? territory : match[ 2 ]
			].concat( variants );
		} else if ( options.force ) {
			// [3.1.2]
			return cldr.get( "supplemental/likelySubtags/und" ).split( sep );
		} else {
			// [3.1.1]
			return;
		}
	};



	/**
	 * Given a locale, remove any fields that Add Likely Subtags would add.
	 * http://www.unicode.org/reports/tr35/#Likely_Subtags
	 * 1. First get max = AddLikelySubtags(inputLocale). If an error is signaled,
	 * return it.
	 * 2. Remove the variants from max.
	 * 3. Then for trial in {language, language _ region, language _ script}. If
	 * AddLikelySubtags(trial) = max, then return trial + variants.
	 * 4. If you do not get a match, return max + variants.
	 * 
	 * @maxLanguageId [Array] maxLanguageId tuple (see init.js).
	 */
	var coreRemoveLikelySubtags = function( Cldr, cldr, maxLanguageId ) {
		var match, matchFound,
			language = maxLanguageId[ 0 ],
			script = maxLanguageId[ 1 ],
			territory = maxLanguageId[ 2 ],
			variants = maxLanguageId[ 3 ];

		// [3]
		matchFound = arraySome([
			[ [ language, "Zzzz", "ZZ" ], [ language ] ],
			[ [ language, "Zzzz", territory ], [ language, territory ] ],
			[ [ language, script, "ZZ" ], [ language, script ] ]
		], function( test ) {
			var result = coreLikelySubtags( Cldr, cldr, test[ 0 ] );
			match = test[ 1 ];
			return result && result[ 0 ] === maxLanguageId[ 0 ] &&
				result[ 1 ] === maxLanguageId[ 1 ] &&
				result[ 2 ] === maxLanguageId[ 2 ];
		});

		if ( matchFound ) {
			if ( variants ) {
				match.push( variants );
			}
			return match;
		}

		// [4]
		return maxLanguageId;
	};




	/**
	 * subtags( locale )
	 *
	 * @locale [String]
	 */
	var coreSubtags = function( locale ) {
		var aux, unicodeLanguageId,
			subtags = [];

		locale = locale.replace( /_/, "-" );

		// Unicode locale extensions.
		aux = locale.split( "-u-" );
		if ( aux[ 1 ] ) {
			aux[ 1 ] = aux[ 1 ].split( "-t-" );
			locale = aux[ 0 ] + ( aux[ 1 ][ 1 ] ? "-t-" + aux[ 1 ][ 1 ] : "");
			subtags[ 4 /* unicodeLocaleExtensions */ ] = aux[ 1 ][ 0 ];
		}

		// TODO normalize transformed extensions. Currently, skipped.
		// subtags[ x ] = locale.split( "-t-" )[ 1 ];
		unicodeLanguageId = locale.split( "-t-" )[ 0 ];

		// unicode_language_id = "root"
		//   | unicode_language_subtag         
		//     (sep unicode_script_subtag)? 
		//     (sep unicode_region_subtag)?
		//     (sep unicode_variant_subtag)* ;
		//
		// Although unicode_language_subtag = alpha{2,8}, I'm using alpha{2,3}. Because, there's no language on CLDR lengthier than 3.
		aux = unicodeLanguageId.match( /^(([a-z]{2,3})(-([A-Z][a-z]{3}))?(-([A-Z]{2}|[0-9]{3}))?)((-([a-zA-Z0-9]{5,8}|[0-9][a-zA-Z0-9]{3}))*)$|^(root)$/ );
		if ( aux === null ) {
			return [ "und", "Zzzz", "ZZ" ];
		}
		subtags[ 0 /* language */ ] = aux[ 10 ] /* root */ || aux[ 2 ] || "und";
		subtags[ 1 /* script */ ] = aux[ 4 ] || "Zzzz";
		subtags[ 2 /* territory */ ] = aux[ 6 ] || "ZZ";
		if ( aux[ 7 ] && aux[ 7 ].length ) {
			subtags[ 3 /* variant */ ] = aux[ 7 ].slice( 1 ) /* remove leading "-" */;
		}

		// 0: language
		// 1: script
		// 2: territory (aka region)
		// 3: variant
		// 4: unicodeLocaleExtensions
		return subtags;
	};




	var arrayForEach = function( array, callback ) {
		var i, length;
		if ( array.forEach ) {
			return array.forEach( callback );
		}
		for ( i = 0, length = array.length; i < length; i++ ) {
			callback( array[ i ], i, array );
		}
	};




	/**
	 * bundleLookup( minLanguageId )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @cldr [Cldr instance]
	 *
	 * @minLanguageId [String] requested languageId after applied remove likely subtags.
	 */
	var bundleLookup = function( Cldr, cldr, minLanguageId ) {
		var availableBundleMap = Cldr._availableBundleMap,
			availableBundleMapQueue = Cldr._availableBundleMapQueue;

		if ( availableBundleMapQueue.length ) {
			arrayForEach( availableBundleMapQueue, function( bundle ) {
				var existing, maxBundle, minBundle, subtags;
				subtags = coreSubtags( bundle );
				maxBundle = coreLikelySubtags( Cldr, cldr, subtags );
				minBundle = coreRemoveLikelySubtags( Cldr, cldr, maxBundle );
				minBundle = minBundle.join( Cldr.localeSep );
				existing = availableBundleMapQueue[ minBundle ];
				if ( existing && existing.length < bundle.length ) {
					return;
				}
				availableBundleMap[ minBundle ] = bundle;
			});
			Cldr._availableBundleMapQueue = [];
		}

		return availableBundleMap[ minLanguageId ] || null;
	};




	var objectKeys = function( object ) {
		var i,
			result = [];

		if ( Object.keys ) {
			return Object.keys( object );
		}

		for ( i in object ) {
			result.push( i );
		}

		return result;
	};




	var createError = function( code, attributes ) {
		var error, message;

		message = code + ( attributes && JSON ? ": " + JSON.stringify( attributes ) : "" );
		error = new Error( message );
		error.code = code;

		// extend( error, attributes );
		arrayForEach( objectKeys( attributes ), function( attribute ) {
			error[ attribute ] = attributes[ attribute ];
		});

		return error;
	};




	var validate = function( code, check, attributes ) {
		if ( !check ) {
			throw createError( code, attributes );
		}
	};




	var validatePresence = function( value, name ) {
		validate( "E_MISSING_PARAMETER", typeof value !== "undefined", {
			name: name
		});
	};




	var validateType = function( value, name, check, expected ) {
		validate( "E_INVALID_PAR_TYPE", check, {
			expected: expected,
			name: name,
			value: value
		});
	};




	var validateTypePath = function( value, name ) {
		validateType( value, name, typeof value === "string" || arrayIsArray( value ), "String or Array" );
	};




	/**
	 * Function inspired by jQuery Core, but reduced to our use case.
	 */
	var isPlainObject = function( obj ) {
		return obj !== null && "" + obj === "[object Object]";
	};




	var validateTypePlainObject = function( value, name ) {
		validateType( value, name, typeof value === "undefined" || isPlainObject( value ), "Plain Object" );
	};




	var validateTypeString = function( value, name ) {
		validateType( value, name, typeof value === "string", "a string" );
	};




	// @path: normalized path
	var resourceGet = function( data, path ) {
		var i,
			node = data,
			length = path.length;

		for ( i = 0; i < length - 1; i++ ) {
			node = node[ path[ i ] ];
			if ( !node ) {
				return undefined;
			}
		}
		return node[ path[ i ] ];
	};




	/**
	 * setAvailableBundles( Cldr, json )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @json resolved/unresolved cldr data.
	 *
	 * Set available bundles queue based on passed json CLDR data. Considers a bundle as any String at /main/{bundle}.
	 */
	var coreSetAvailableBundles = function( Cldr, json ) {
		var bundle,
			availableBundleMapQueue = Cldr._availableBundleMapQueue,
			main = resourceGet( json, [ "main" ] );

		if ( main ) {
			for ( bundle in main ) {
				if ( main.hasOwnProperty( bundle ) && bundle !== "root" &&
							availableBundleMapQueue.indexOf( bundle ) === -1 ) {
					availableBundleMapQueue.push( bundle );
				}
			}
		}
	};



	var alwaysArray = function( somethingOrArray ) {
		return arrayIsArray( somethingOrArray ) ?  somethingOrArray : [ somethingOrArray ];
	};


	var jsonMerge = (function() {

	// Returns new deeply merged JSON.
	//
	// Eg.
	// merge( { a: { b: 1, c: 2 } }, { a: { b: 3, d: 4 } } )
	// -> { a: { b: 3, c: 2, d: 4 } }
	//
	// @arguments JSON's
	// 
	var merge = function() {
		var destination = {},
			sources = [].slice.call( arguments, 0 );
		arrayForEach( sources, function( source ) {
			var prop;
			for ( prop in source ) {
				if ( prop in destination && typeof destination[ prop ] === "object" && !arrayIsArray( destination[ prop ] ) ) {

					// Merge Objects
					destination[ prop ] = merge( destination[ prop ], source[ prop ] );

				} else {

					// Set new values
					destination[ prop ] = source[ prop ];

				}
			}
		});
		return destination;
	};

	return merge;

}());


	/**
	 * load( Cldr, source, jsons )
	 *
	 * @Cldr [Cldr class]
	 *
	 * @source [Object]
	 *
	 * @jsons [arguments]
	 */
	var coreLoad = function( Cldr, source, jsons ) {
		var i, j, json;

		validatePresence( jsons[ 0 ], "json" );

		// Support arbitrary parameters, e.g., `Cldr.load({...}, {...})`.
		for ( i = 0; i < jsons.length; i++ ) {

			// Support array parameters, e.g., `Cldr.load([{...}, {...}])`.
			json = alwaysArray( jsons[ i ] );

			for ( j = 0; j < json.length; j++ ) {
				validateTypePlainObject( json[ j ], "json" );
				source = jsonMerge( source, json[ j ] );
				coreSetAvailableBundles( Cldr, json[ j ] );
			}
		}

		return source;
	};



	var itemGetResolved = function( Cldr, path, attributes ) {
		// Resolve path
		var normalizedPath = pathNormalize( path, attributes );

		return resourceGet( Cldr._resolved, normalizedPath );
	};




	/**
	 * new Cldr()
	 */
	var Cldr = function( locale ) {
		this.init( locale );
	};

	// Build optimization hack to avoid duplicating functions across modules.
	Cldr._alwaysArray = alwaysArray;
	Cldr._coreLoad = coreLoad;
	Cldr._createError = createError;
	Cldr._itemGetResolved = itemGetResolved;
	Cldr._jsonMerge = jsonMerge;
	Cldr._pathNormalize = pathNormalize;
	Cldr._resourceGet = resourceGet;
	Cldr._validatePresence = validatePresence;
	Cldr._validateType = validateType;
	Cldr._validateTypePath = validateTypePath;
	Cldr._validateTypePlainObject = validateTypePlainObject;

	Cldr._availableBundleMap = {};
	Cldr._availableBundleMapQueue = [];
	Cldr._resolved = {};

	// Allow user to override locale separator "-" (default) | "_". According to http://www.unicode.org/reports/tr35/#Unicode_language_identifier, both "-" and "_" are valid locale separators (eg. "en_GB", "en-GB"). According to http://unicode.org/cldr/trac/ticket/6786 its usage must be consistent throughout the data set.
	Cldr.localeSep = "-";

	/**
	 * Cldr.load( json [, json, ...] )
	 *
	 * @json [JSON] CLDR data or [Array] Array of @json's.
	 *
	 * Load resolved cldr data.
	 */
	Cldr.load = function() {
		Cldr._resolved = coreLoad( Cldr, Cldr._resolved, arguments );
	};

	/**
	 * .init() automatically run on instantiation/construction.
	 */
	Cldr.prototype.init = function( locale ) {
		var attributes, language, maxLanguageId, minLanguageId, script, subtags, territory, unicodeLocaleExtensions, variant,
			sep = Cldr.localeSep,
			unicodeLocaleExtensionsRaw = "";

		validatePresence( locale, "locale" );
		validateTypeString( locale, "locale" );

		subtags = coreSubtags( locale );

		if ( subtags.length === 5 ) {
			unicodeLocaleExtensions = subtags.pop();
			unicodeLocaleExtensionsRaw = sep + "u" + sep + unicodeLocaleExtensions;
			// Remove trailing null when there is unicodeLocaleExtensions but no variants.
			if ( !subtags[ 3 ] ) {
				subtags.pop();
			}
		}
		variant = subtags[ 3 ];

		// Normalize locale code.
		// Get (or deduce) the "triple subtags": language, territory (also aliased as region), and script subtags.
		// Get the variant subtags (calendar, collation, currency, etc).
		// refs:
		// - http://www.unicode.org/reports/tr35/#Field_Definitions
		// - http://www.unicode.org/reports/tr35/#Language_and_Locale_IDs
		// - http://www.unicode.org/reports/tr35/#Unicode_locale_identifier

		// When a locale id does not specify a language, or territory (region), or script, they are obtained by Likely Subtags.
		maxLanguageId = coreLikelySubtags( Cldr, this, subtags, { force: true } ) || subtags;
		language = maxLanguageId[ 0 ];
		script = maxLanguageId[ 1 ];
		territory = maxLanguageId[ 2 ];

		minLanguageId = coreRemoveLikelySubtags( Cldr, this, maxLanguageId ).join( sep );

		// Set attributes
		this.attributes = attributes = {
			bundle: bundleLookup( Cldr, this, minLanguageId ),

			// Unicode Language Id
			minLanguageId: minLanguageId + unicodeLocaleExtensionsRaw,
			maxLanguageId: maxLanguageId.join( sep ) + unicodeLocaleExtensionsRaw,

			// Unicode Language Id Subtabs
			language: language,
			script: script,
			territory: territory,
			region: territory, /* alias */
			variant: variant
		};

		// Unicode locale extensions.
		unicodeLocaleExtensions && ( "-" + unicodeLocaleExtensions ).replace( /-[a-z]{3,8}|(-[a-z]{2})-([a-z]{3,8})/g, function( attribute, key, type ) {

			if ( key ) {

				// Extension is in the `keyword` form.
				attributes[ "u" + key ] = type;
			} else {

				// Extension is in the `attribute` form.
				attributes[ "u" + attribute ] = true;
			}
		});

		this.locale = locale;
	};

	/**
	 * .get()
	 */
	Cldr.prototype.get = function( path ) {

		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		return itemGetResolved( Cldr, path, this.attributes );
	};

	/**
	 * .main()
	 */
	Cldr.prototype.main = function( path ) {
		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		validate( "E_MISSING_BUNDLE", this.attributes.bundle !== null, {
			locale: this.locale
		});

		path = alwaysArray( path );
		return this.get( [ "main/{bundle}" ].concat( path ) );
	};

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr/event.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license © Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__("./node_modules/cldrjs/dist/cldr.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var pathNormalize = Cldr._pathNormalize,
		validatePresence = Cldr._validatePresence,
		validateType = Cldr._validateType;

/*!
 * EventEmitter v4.2.7 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

var EventEmitter;
/* jshint ignore:start */
EventEmitter = (function () {


	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class EventEmitter Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size
	var proto = EventEmitter.prototype;
	var exports = this;
	var originalGlobalValue = exports.EventEmitter;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @param {Function} listener Method to look for.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listeners, listener) {
		var i = listeners.length;
		while (i--) {
			if (listeners[i].listener === listener) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Alias a method while keeping the context correct, to allow for overwriting of target method.
	 *
	 * @param {String} name The name of the target method.
	 * @return {Function} The aliased method
	 * @api private
	 */
	function alias(name) {
		return function aliasClosure() {
			return this[name].apply(this, arguments);
		};
	}

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function getListeners(evt) {
		var events = this._getEvents();
		var response;
		var key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (evt instanceof RegExp) {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Takes a list of listener objects and flattens it into a list of listener functions.
	 *
	 * @param {Object[]} listeners Raw listener objects.
	 * @return {Function[]} Just the listener functions.
	 */
	proto.flattenListeners = function flattenListeners(listeners) {
		var flatListeners = [];
		var i;

		for (i = 0; i < listeners.length; i += 1) {
			flatListeners.push(listeners[i].listener);
		}

		return flatListeners;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function getListenersAsObject(evt) {
		var listeners = this.getListeners(evt);
		var response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function addListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var listenerIsWrapped = typeof listener === 'object';
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
				listeners[key].push(listenerIsWrapped ? listener : {
					listener: listener,
					once: false
				});
			}
		}

		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = alias('addListener');

	/**
	 * Semi-alias of addListener. It will add a listener that will be
	 * automatically removed after it's first execution.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addOnceListener = function addOnceListener(evt, listener) {
		return this.addListener(evt, {
			listener: listener,
			once: true
		});
	};

	/**
	 * Alias of addOnceListener.
	 */
	proto.once = alias('addOnceListener');

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function defineEvent(evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function defineEvents(evts) {
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function removeListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var index;
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listeners[key], listener);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = alias('removeListener');

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function addListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function removeListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		var i;
		var value;
		var single = remove ? this.removeListener : this.addListener;
		var multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function removeEvent(evt) {
		var type = typeof evt;
		var events = this._getEvents();
		var key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (evt instanceof RegExp) {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		return this;
	};

	/**
	 * Alias of removeEvent.
	 *
	 * Added to mirror the node API.
	 */
	proto.removeAllListeners = alias('removeEvent');

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function emitEvent(evt, args) {
		var listeners = this.getListenersAsObject(evt);
		var listener;
		var i;
		var key;
		var response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					listener = listeners[key][i];

					if (listener.once === true) {
						this.removeListener(evt, listener.listener);
					}

					response = listener.listener.apply(this, args || []);

					if (response === this._getOnceReturnValue()) {
						this.removeListener(evt, listener.listener);
					}
				}
			}
		}

		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = alias('emitEvent');

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function emit(evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	/**
	 * Sets the current value to check against when executing listeners. If a
	 * listeners return value matches the one set here then it will be removed
	 * after execution. This value defaults to true.
	 *
	 * @param {*} value The new value to check for when executing listeners.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.setOnceReturnValue = function setOnceReturnValue(value) {
		this._onceReturnValue = value;
		return this;
	};

	/**
	 * Fetches the current value to check against when executing listeners. If
	 * the listeners return value matches this one then it should be removed
	 * automatically. It will return true by default.
	 *
	 * @return {*|Boolean} The current value to check for or the default, true.
	 * @api private
	 */
	proto._getOnceReturnValue = function _getOnceReturnValue() {
		if (this.hasOwnProperty('_onceReturnValue')) {
			return this._onceReturnValue;
		}
		else {
			return true;
		}
	};

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function _getEvents() {
		return this._events || (this._events = {});
	};

	/**
	 * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
	 *
	 * @return {Function} Non conflicting EventEmitter class.
	 */
	EventEmitter.noConflict = function noConflict() {
		exports.EventEmitter = originalGlobalValue;
		return EventEmitter;
	};

	return EventEmitter;
}());
/* jshint ignore:end */



	var validateTypeFunction = function( value, name ) {
		validateType( value, name, typeof value === "undefined" || typeof value === "function", "Function" );
	};




	var superGet, superInit,
		globalEe = new EventEmitter();

	function validateTypeEvent( value, name ) {
		validateType( value, name, typeof value === "string" || value instanceof RegExp, "String or RegExp" );
	}

	function validateThenCall( method, self ) {
		return function( event, listener ) {
			validatePresence( event, "event" );
			validateTypeEvent( event, "event" );

			validatePresence( listener, "listener" );
			validateTypeFunction( listener, "listener" );

			return self[ method ].apply( self, arguments );
		};
	}

	function off( self ) {
		return validateThenCall( "off", self );
	}

	function on( self ) {
		return validateThenCall( "on", self );
	}

	function once( self ) {
		return validateThenCall( "once", self );
	}

	Cldr.off = off( globalEe );
	Cldr.on = on( globalEe );
	Cldr.once = once( globalEe );

	/**
	 * Overload Cldr.prototype.init().
	 */
	superInit = Cldr.prototype.init;
	Cldr.prototype.init = function() {
		var ee;
		this.ee = ee = new EventEmitter();
		this.off = off( ee );
		this.on = on( ee );
		this.once = once( ee );
		superInit.apply( this, arguments );
	};

	/**
	 * getOverload is encapsulated, because of cldr/unresolved. If it's loaded
	 * after cldr/event (and note it overwrites .get), it can trigger this
	 * overload again.
	 */
	function getOverload() {

		/**
		 * Overload Cldr.prototype.get().
		 */
		superGet = Cldr.prototype.get;
		Cldr.prototype.get = function( path ) {
			var value = superGet.apply( this, arguments );
			path = pathNormalize( path, this.attributes ).join( "/" );
			globalEe.trigger( "get", [ path, value ] );
			this.ee.trigger( "get", [ path, value ] );
			return value;
		};
	}

	Cldr._eventInit = getOverload;
	getOverload();

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr/supplemental.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license © Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__("./node_modules/cldrjs/dist/cldr.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var alwaysArray = Cldr._alwaysArray;



	var supplementalMain = function( cldr ) {

		var prepend, supplemental;
		
		prepend = function( prepend ) {
			return function( path ) {
				path = alwaysArray( path );
				return cldr.get( [ prepend ].concat( path ) );
			};
		};

		supplemental = prepend( "supplemental" );

		// Week Data
		// http://www.unicode.org/reports/tr35/tr35-dates.html#Week_Data
		supplemental.weekData = prepend( "supplemental/weekData" );

		supplemental.weekData.firstDay = function() {
			return cldr.get( "supplemental/weekData/firstDay/{territory}" ) ||
				cldr.get( "supplemental/weekData/firstDay/001" );
		};

		supplemental.weekData.minDays = function() {
			var minDays = cldr.get( "supplemental/weekData/minDays/{territory}" ) ||
				cldr.get( "supplemental/weekData/minDays/001" );
			return parseInt( minDays, 10 );
		};

		// Time Data
		// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
		supplemental.timeData = prepend( "supplemental/timeData" );

		supplemental.timeData.allowed = function() {
			return cldr.get( "supplemental/timeData/{territory}/_allowed" ) ||
				cldr.get( "supplemental/timeData/001/_allowed" );
		};

		supplemental.timeData.preferred = function() {
			return cldr.get( "supplemental/timeData/{territory}/_preferred" ) ||
				cldr.get( "supplemental/timeData/001/_preferred" );
		};

		return supplemental;

	};




	var initSuper = Cldr.prototype.init;

	/**
	 * .init() automatically ran on construction.
	 *
	 * Overload .init().
	 */
	Cldr.prototype.init = function() {
		initSuper.apply( this, arguments );
		this.supplemental = supplementalMain( this );
	};

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/cldr/unresolved.js":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license © Rafael Xavier
 * http://git.io/h4lmVg
 */
(function( factory ) {

	if ( true ) {
		// AMD.
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [ __webpack_require__("./node_modules/cldrjs/dist/cldr.js") ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else if ( typeof module === "object" && typeof module.exports === "object" ) {
		// Node. CommonJS.
		module.exports = factory( require( "../cldr" ) );
	} else {
		// Global
		factory( Cldr );
	}

}(function( Cldr ) {

	// Build optimization hack to avoid duplicating functions across modules.
	var coreLoad = Cldr._coreLoad;
	var jsonMerge = Cldr._jsonMerge;
	var pathNormalize = Cldr._pathNormalize;
	var resourceGet = Cldr._resourceGet;
	var validatePresence = Cldr._validatePresence;
	var validateTypePath = Cldr._validateTypePath;



	var bundleParentLookup = function( Cldr, locale ) {
		var normalizedPath, parent;

		if ( locale === "root" ) {
			return;
		}

		// First, try to find parent on supplemental data.
		normalizedPath = pathNormalize( [ "supplemental/parentLocales/parentLocale", locale ] );
		parent = resourceGet( Cldr._resolved, normalizedPath ) || resourceGet( Cldr._raw, normalizedPath );
		if ( parent ) {
			return parent;
		}

		// Or truncate locale.
		parent = locale.substr( 0, locale.lastIndexOf( Cldr.localeSep ) );
		if ( !parent ) {
			return "root";
		}

		return parent;
	};




	// @path: normalized path
	var resourceSet = function( data, path, value ) {
		var i,
			node = data,
			length = path.length;

		for ( i = 0; i < length - 1; i++ ) {
			if ( !node[ path[ i ] ] ) {
				node[ path[ i ] ] = {};
			}
			node = node[ path[ i ] ];
		}
		node[ path[ i ] ] = value;
	};


	var itemLookup = (function() {

	var lookup;

	lookup = function( Cldr, locale, path, attributes, childLocale ) {
		var normalizedPath, parent, value;

		// 1: Finish recursion
		// 2: Avoid infinite loop
		if ( typeof locale === "undefined" /* 1 */ || locale === childLocale /* 2 */ ) {
			return;
		}

		// Resolve path
		normalizedPath = pathNormalize( path, attributes );

		// Check resolved (cached) data first
		// 1: Due to #16, never use the cached resolved non-leaf nodes. It may not
		//    represent its leafs in its entirety.
		value = resourceGet( Cldr._resolved, normalizedPath );
		if ( value && typeof value !== "object" /* 1 */ ) {
			return value;
		}

		// Check raw data
		value = resourceGet( Cldr._raw, normalizedPath );

		if ( !value ) {
			// Or, lookup at parent locale
			parent = bundleParentLookup( Cldr, locale );
			value = lookup( Cldr, parent, path, jsonMerge( attributes, { bundle: parent }), locale );
		}

		if ( value ) {
			// Set resolved (cached)
			resourceSet( Cldr._resolved, normalizedPath, value );
		}

		return value;
	};

	return lookup;

}());


	Cldr._raw = {};

	/**
	 * Cldr.load( json [, json, ...] )
	 *
	 * @json [JSON] CLDR data or [Array] Array of @json's.
	 *
	 * Load resolved or unresolved cldr data.
	 * Overwrite Cldr.load().
	 */
	Cldr.load = function() {
		Cldr._raw = coreLoad( Cldr, Cldr._raw, arguments );
	};

	/**
	 * Overwrite Cldr.prototype.get().
	 */
	Cldr.prototype.get = function( path ) {
		validatePresence( path, "path" );
		validateTypePath( path, "path" );

		// 1: use bundle as locale on item lookup for simplification purposes, because no other extended subtag is used anyway on bundle parent lookup.
		// 2: during init(), this method is called, but bundle is yet not defined. Use "" as a workaround in this very specific scenario.
		return itemLookup( Cldr, this.attributes && this.attributes.bundle /* 1 */ || "" /* 2 */, path, this.attributes );
	};

	// In case cldr/unresolved is loaded after cldr/event, we trigger its overloads again. Because, .get is overwritten in here.
	if ( Cldr._eventInit ) {
		Cldr._eventInit();
	}

	return Cldr;




}));


/***/ }),

/***/ "./node_modules/cldrjs/dist/node_main.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * CLDR JavaScript Library v0.4.8
 * http://jquery.com/
 *
 * Copyright 2013 Rafael Xavier de Souza
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-11-26T15:03Z
 */
/*!
 * CLDR JavaScript Library v0.4.8 2016-11-26T15:03Z MIT license © Rafael Xavier
 * http://git.io/h4lmVg
 */

// Cldr
module.exports = __webpack_require__( "./node_modules/cldrjs/dist/cldr.js" );

// Extent Cldr with the following modules
__webpack_require__( "./node_modules/cldrjs/dist/cldr/event.js" );
__webpack_require__( "./node_modules/cldrjs/dist/cldr/supplemental.js" );
__webpack_require__( "./node_modules/cldrjs/dist/cldr/unresolved.js" );


/***/ }),

/***/ "./node_modules/globalize/dist/globalize.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"cldr/event"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ) );
	} else {

		// Global
		root.Globalize = factory( root.Cldr );
	}
}( this, function( Cldr ) {


/**
 * A toString method that outputs meaningful values for objects or arrays and
 * still performs as fast as a plain string in case variable is string, or as
 * fast as `"" + number` in case variable is a number.
 * Ref: http://jsperf.com/my-stringify
 */
var toString = function( variable ) {
	return typeof variable === "string" ? variable : ( typeof variable === "number" ? "" +
		variable : JSON.stringify( variable ) );
};




/**
 * formatMessage( message, data )
 *
 * @message [String] A message with optional {vars} to be replaced.
 *
 * @data [Array or JSON] Object with replacing-variables content.
 *
 * Return the formatted message. For example:
 *
 * - formatMessage( "{0} second", [ 1 ] ); // 1 second
 *
 * - formatMessage( "{0}/{1}", ["m", "s"] ); // m/s
 *
 * - formatMessage( "{name} <{email}>", {
 *     name: "Foo",
 *     email: "bar@baz.qux"
 *   }); // Foo <bar@baz.qux>
 */
var formatMessage = function( message, data ) {

	// Replace {attribute}'s
	message = message.replace( /{[0-9a-zA-Z-_. ]+}/g, function( name ) {
		name = name.replace( /^{([^}]*)}$/, "$1" );
		return toString( data[ name ] );
	});

	return message;
};




var objectExtend = function() {
	var destination = arguments[ 0 ],
		sources = [].slice.call( arguments, 1 );

	sources.forEach(function( source ) {
		var prop;
		for ( prop in source ) {
			destination[ prop ] = source[ prop ];
		}
	});

	return destination;
};




var createError = function( code, message, attributes ) {
	var error;

	message = code + ( message ? ": " + formatMessage( message, attributes ) : "" );
	error = new Error( message );
	error.code = code;

	objectExtend( error, attributes );

	return error;
};




// Based on http://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript-jquery
var stringHash = function( str ) {
	return [].reduce.call( str, function( hash, i ) {
		var chr = i.charCodeAt( 0 );
		hash = ( ( hash << 5 ) - hash ) + chr;
		return hash | 0;
	}, 0 );
};




var runtimeKey = function( fnName, locale, args, argsStr ) {
	var hash;
	argsStr = argsStr || JSON.stringify( args );
	hash = stringHash( fnName + locale + argsStr );
	return hash > 0 ? "a" + hash : "b" + Math.abs( hash );
};




var functionName = function( fn ) {
	if ( fn.name !== undefined ) {
		return fn.name;
	}

	// fn.name is not supported by IE.
	var matches = /^function\s+([\w\$]+)\s*\(/.exec( fn.toString() );

	if ( matches && matches.length > 0 ) {
		return matches[ 1 ];
	}
};




var runtimeBind = function( args, cldr, fn, runtimeArgs ) {

	var argsStr = JSON.stringify( args ),
		fnName = functionName( fn ),
		locale = cldr.locale;

	// If name of the function is not available, this is most likely due to uglification,
	// which most likely means we are in production, and runtimeBind here is not necessary.
	if ( !fnName ) {
		return fn;
	}

	fn.runtimeKey = runtimeKey( fnName, locale, null, argsStr );

	fn.generatorString = function() {
		return "Globalize(\"" + locale + "\")." + fnName + "(" + argsStr.slice( 1, -1 ) + ")";
	};

	fn.runtimeArgs = runtimeArgs;

	return fn;
};




var validate = function( code, message, check, attributes ) {
	if ( !check ) {
		throw createError( code, message, attributes );
	}
};




var alwaysArray = function( stringOrArray ) {
	return Array.isArray( stringOrArray ) ? stringOrArray : stringOrArray ? [ stringOrArray ] : [];
};




var validateCldr = function( path, value, options ) {
	var skipBoolean;
	options = options || {};

	skipBoolean = alwaysArray( options.skip ).some(function( pathRe ) {
		return pathRe.test( path );
	});

	validate( "E_MISSING_CLDR", "Missing required CLDR content `{path}`.", value || skipBoolean, {
		path: path
	});
};




var validateDefaultLocale = function( value ) {
	validate( "E_DEFAULT_LOCALE_NOT_DEFINED", "Default locale has not been defined.",
		value !== undefined, {} );
};




var validateParameterPresence = function( value, name ) {
	validate( "E_MISSING_PARAMETER", "Missing required parameter `{name}`.",
		value !== undefined, { name: name });
};




/**
 * range( value, name, minimum, maximum )
 *
 * @value [Number].
 *
 * @name [String] name of variable.
 *
 * @minimum [Number]. The lowest valid value, inclusive.
 *
 * @maximum [Number]. The greatest valid value, inclusive.
 */
var validateParameterRange = function( value, name, minimum, maximum ) {
	validate(
		"E_PAR_OUT_OF_RANGE",
		"Parameter `{name}` has value `{value}` out of range [{minimum}, {maximum}].",
		value === undefined || value >= minimum && value <= maximum,
		{
			maximum: maximum,
			minimum: minimum,
			name: name,
			value: value
		}
	);
};




var validateParameterType = function( value, name, check, expected ) {
	validate(
		"E_INVALID_PAR_TYPE",
		"Invalid `{name}` parameter ({value}). {expected} expected.",
		check,
		{
			expected: expected,
			name: name,
			value: value
		}
	);
};




var validateParameterTypeLocale = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string" || value instanceof Cldr,
		"String or Cldr instance"
	);
};




/**
 * Function inspired by jQuery Core, but reduced to our use case.
 */
var isPlainObject = function( obj ) {
	return obj !== null && "" + obj === "[object Object]";
};




var validateParameterTypePlainObject = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || isPlainObject( value ),
		"Plain Object"
	);
};




var alwaysCldr = function( localeOrCldr ) {
	return localeOrCldr instanceof Cldr ? localeOrCldr : new Cldr( localeOrCldr );
};




// ref: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions?redirectlocale=en-US&redirectslug=JavaScript%2FGuide%2FRegular_Expressions
var regexpEscape = function( string ) {
	return string.replace( /([.*+?^=!:${}()|\[\]\/\\])/g, "\\$1" );
};




var stringPad = function( str, count, right ) {
	var length;
	if ( typeof str !== "string" ) {
		str = String( str );
	}
	for ( length = str.length; length < count; length += 1 ) {
		str = ( right ? ( str + "0" ) : ( "0" + str ) );
	}
	return str;
};




function validateLikelySubtags( cldr ) {
	cldr.once( "get", validateCldr );
	cldr.get( "supplemental/likelySubtags" );
}

/**
 * [new] Globalize( locale|cldr )
 *
 * @locale [String]
 *
 * @cldr [Cldr instance]
 *
 * Create a Globalize instance.
 */
function Globalize( locale ) {
	if ( !( this instanceof Globalize ) ) {
		return new Globalize( locale );
	}

	validateParameterPresence( locale, "locale" );
	validateParameterTypeLocale( locale, "locale" );

	this.cldr = alwaysCldr( locale );

	validateLikelySubtags( this.cldr );
}

/**
 * Globalize.load( json, ... )
 *
 * @json [JSON]
 *
 * Load resolved or unresolved cldr data.
 * Somewhat equivalent to previous Globalize.addCultureInfo(...).
 */
Globalize.load = function() {

	// validations are delegated to Cldr.load().
	Cldr.load.apply( Cldr, arguments );
};

/**
 * Globalize.locale( [locale|cldr] )
 *
 * @locale [String]
 *
 * @cldr [Cldr instance]
 *
 * Set default Cldr instance if locale or cldr argument is passed.
 *
 * Return the default Cldr instance.
 */
Globalize.locale = function( locale ) {
	validateParameterTypeLocale( locale, "locale" );

	if ( arguments.length ) {
		this.cldr = alwaysCldr( locale );
		validateLikelySubtags( this.cldr );
	}
	return this.cldr;
};

/**
 * Optimization to avoid duplicating some internal functions across modules.
 */
Globalize._alwaysArray = alwaysArray;
Globalize._createError = createError;
Globalize._formatMessage = formatMessage;
Globalize._isPlainObject = isPlainObject;
Globalize._objectExtend = objectExtend;
Globalize._regexpEscape = regexpEscape;
Globalize._runtimeBind = runtimeBind;
Globalize._stringPad = stringPad;
Globalize._validate = validate;
Globalize._validateCldr = validateCldr;
Globalize._validateDefaultLocale = validateDefaultLocale;
Globalize._validateParameterPresence = validateParameterPresence;
Globalize._validateParameterRange = validateParameterRange;
Globalize._validateParameterTypePlainObject = validateParameterTypePlainObject;
Globalize._validateParameterType = validateParameterType;

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/currency.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/*!
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var alwaysArray = Globalize._alwaysArray,
	formatMessage = Globalize._formatMessage,
	numberNumberingSystem = Globalize._numberNumberingSystem,
	numberPattern = Globalize._numberPattern,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;


var validateParameterTypeCurrency = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string" && ( /^[A-Za-z]{3}$/ ).test( value ),
		"3-letter currency code string as defined by ISO 4217"
	);
};




/**
 * supplementalOverride( currency, pattern, cldr )
 *
 * Return pattern with fraction digits overriden by supplemental currency data.
 */
var currencySupplementalOverride = function( currency, pattern, cldr ) {
	var digits,
		fraction = "",
		fractionData = cldr.supplemental([ "currencyData/fractions", currency ]) ||
			cldr.supplemental( "currencyData/fractions/DEFAULT" );

	digits = +fractionData._digits;

	if ( digits ) {
		fraction = "." + stringPad( "0", digits ).slice( 0, -1 ) + fractionData._rounding;
	}

	return pattern.replace( /\.(#+|0*[0-9]|0+[0-9]?)/g, fraction );
};




var objectFilter = function( object, testRe ) {
	var key,
		copy = {};

	for ( key in object ) {
		if ( testRe.test( key ) ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




var currencyUnitPatterns = function( cldr ) {
	return objectFilter( cldr.main([
		"numbers",
		"currencyFormats-numberSystem-" + numberNumberingSystem( cldr )
	]), /^unitPattern/ );
};




/**
 * codeProperties( currency, cldr )
 *
 * Return number pattern with the appropriate currency code in as literal.
 */
var currencyCodeProperties = function( currency, cldr ) {
	var pattern = numberPattern( "decimal", cldr );

	// The number of decimal places and the rounding for each currency is not locale-specific. Those
	// values overridden by Supplemental Currency Data.
	pattern = currencySupplementalOverride( currency, pattern, cldr );

	return {
		currency: currency,
		pattern: pattern,
		unitPatterns: currencyUnitPatterns( cldr )
	};
};




/**
 * nameFormat( formattedNumber, pluralForm, properties )
 *
 * Return the appropriate name form currency format.
 */
var currencyNameFormat = function( formattedNumber, pluralForm, properties ) {
	var displayName, unitPattern,
		displayNames = properties.displayNames || {},
		unitPatterns = properties.unitPatterns;

	displayName = displayNames[ "displayName-count-" + pluralForm ] ||
		displayNames[ "displayName-count-other" ] ||
		displayNames.displayName ||
		properties.currency;
	unitPattern = unitPatterns[ "unitPattern-count-" + pluralForm ] ||
		unitPatterns[ "unitPattern-count-other" ];

	return formatMessage( unitPattern, [ formattedNumber, displayName ]);
};




var currencyFormatterFn = function( numberFormatter, pluralGenerator, properties ) {
	var fn;

	// Return formatter when style is "code" or "name".
	if ( pluralGenerator && properties ) {
		fn = function currencyFormatter( value ) {
			validateParameterPresence( value, "value" );
			validateParameterTypeNumber( value, "value" );
			return currencyNameFormat(
				numberFormatter( value ),
				pluralGenerator( value ),
				properties
			);
		};

	// Return formatter when style is "symbol" or "accounting".
	} else {
		fn = function currencyFormatter( value ) {
			return numberFormatter( value );
		};
	}

	return fn;
};




/**
 * nameProperties( currency, cldr )
 *
 * Return number pattern with the appropriate currency code in as literal.
 */
var currencyNameProperties = function( currency, cldr ) {
	var properties = currencyCodeProperties( currency, cldr );

	properties.displayNames = objectFilter( cldr.main([
		"numbers/currencies",
		currency
	]), /^displayName/ );

	return properties;
};




/**
 * Unicode regular expression for: everything except math symbols, currency signs, dingbats, and
 * box-drawing characters.
 *
 * Generated by:
 *
 * regenerate()
 *   .addRange( 0x0, 0x10FFFF )
 *   .remove( require( "unicode-7.0.0/categories/S/symbols" ) ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-7.0.0
 */
var regexpNotS = /[\0-#%-\*,-;\?-\]_a-\{\}\x7F-\xA1\xA7\xAA\xAB\xAD\xB2\xB3\xB5-\xB7\xB9-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376-\u0383\u0386-\u03F5\u03F7-\u0481\u0483-\u058C\u0590-\u0605\u0609\u060A\u060C\u060D\u0610-\u06DD\u06DF-\u06E8\u06EA-\u06FC\u06FF-\u07F5\u07F7-\u09F1\u09F4-\u09F9\u09FC-\u0AF0\u0AF2-\u0B6F\u0B71-\u0BF2\u0BFB-\u0C7E\u0C80-\u0D78\u0D7A-\u0E3E\u0E40-\u0F00\u0F04-\u0F12\u0F14\u0F18\u0F19\u0F20-\u0F33\u0F35\u0F37\u0F39-\u0FBD\u0FC6\u0FCD\u0FD0-\u0FD4\u0FD9-\u109D\u10A0-\u138F\u139A-\u17DA\u17DC-\u193F\u1941-\u19DD\u1A00-\u1B60\u1B6B-\u1B73\u1B7D-\u1FBC\u1FBE\u1FC2-\u1FCC\u1FD0-\u1FDC\u1FE0-\u1FEC\u1FF0-\u1FFC\u1FFF-\u2043\u2045-\u2051\u2053-\u2079\u207D-\u2089\u208D-\u209F\u20BE-\u20FF\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2150-\u218F\u2308-\u230B\u2329\u232A\u23FB-\u23FF\u2427-\u243F\u244B-\u249B\u24EA-\u24FF\u2768-\u2793\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2B74\u2B75\u2B96\u2B97\u2BBA-\u2BBC\u2BC9\u2BD2-\u2CE4\u2CEB-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u3003\u3005-\u3011\u3014-\u301F\u3021-\u3035\u3038-\u303D\u3040-\u309A\u309D-\u318F\u3192-\u3195\u31A0-\u31BF\u31E4-\u31FF\u321F-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\u32FF\u3400-\u4DBF\u4E00-\uA48F\uA4C7-\uA6FF\uA717-\uA71F\uA722-\uA788\uA78B-\uA827\uA82C-\uA835\uA83A-\uAA76\uAA7A-\uAB5A\uAB5C-\uD7FF\uDC00-\uFB28\uFB2A-\uFBB1\uFBC2-\uFDFB\uFDFE-\uFE61\uFE63\uFE67\uFE68\uFE6A-\uFF03\uFF05-\uFF0A\uFF0C-\uFF1B\uFF1F-\uFF3D\uFF3F\uFF41-\uFF5B\uFF5D\uFF5F-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]|\uD800[\uDC00-\uDD36\uDD40-\uDD78\uDD8A\uDD8B\uDD8D-\uDD8F\uDD9C-\uDD9F\uDDA1-\uDDCF\uDDFD-\uDFFF]|[\uD801\uD803-\uD819\uD81B-\uD82E\uD830-\uD833\uD836-\uD83A\uD83F-\uDBFF][\uDC00-\uDFFF]|\uD802[\uDC00-\uDC76\uDC79-\uDEC7\uDEC9-\uDFFF]|\uD81A[\uDC00-\uDF3B\uDF40-\uDF44\uDF46-\uDFFF]|\uD82F[\uDC00-\uDC9B\uDC9D-\uDFFF]|\uD834[\uDCF6-\uDCFF\uDD27\uDD28\uDD65-\uDD69\uDD6D-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDDDE-\uDDFF\uDE42-\uDE44\uDE46-\uDEFF\uDF57-\uDFFF]|\uD835[\uDC00-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFFF]|\uD83B[\uDC00-\uDEEF\uDEF2-\uDFFF]|\uD83C[\uDC2C-\uDC2F\uDC94-\uDC9F\uDCAF\uDCB0\uDCC0\uDCD0\uDCF6-\uDD0F\uDD2F\uDD6C-\uDD6F\uDD9B-\uDDE5\uDE03-\uDE0F\uDE3B-\uDE3F\uDE49-\uDE4F\uDE52-\uDEFF\uDF2D-\uDF2F\uDF7E\uDF7F\uDFCF-\uDFD3\uDFF8-\uDFFF]|\uD83D[\uDCFF\uDD4B-\uDD4F\uDD7A\uDDA4\uDE43\uDE44\uDED0-\uDEDF\uDEED-\uDEEF\uDEF4-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDFFF]|[\uD800-\uDBFF]/;




/**
 * symbolProperties( currency, cldr )
 *
 * Return pattern replacing `¤` with the appropriate currency symbol literal.
 */
var currencySymbolProperties = function( currency, cldr, options ) {
	var currencySpacing, pattern,
		regexp = {
			"[:digit:]": /\d/,
			"[:^S:]": regexpNotS
		},
		symbol = cldr.main([
			"numbers/currencies",
			currency,
			"symbol"
		]);

	currencySpacing = [ "beforeCurrency", "afterCurrency" ].map(function( position ) {
		return cldr.main([
			"numbers",
			"currencyFormats-numberSystem-" + numberNumberingSystem( cldr ),
			"currencySpacing",
			position
		]);
	});

	pattern = cldr.main([
		"numbers",
		"currencyFormats-numberSystem-" + numberNumberingSystem( cldr ),
		options.style === "accounting" ? "accounting" : "standard"
	]);

	pattern =

		// The number of decimal places and the rounding for each currency is not locale-specific.
		// Those values are overridden by Supplemental Currency Data.
		currencySupplementalOverride( currency, pattern, cldr )

		// Replace "¤" (\u00A4) with the appropriate symbol literal.
		.split( ";" ).map(function( pattern ) {

			return pattern.split( "\u00A4" ).map(function( part, i ) {
				var currencyMatch = regexp[ currencySpacing[ i ].currencyMatch ],
					surroundingMatch = regexp[ currencySpacing[ i ].surroundingMatch ],
					insertBetween = "";

				// For currencyMatch and surroundingMatch definitions, read [1].
				// When i === 0, beforeCurrency is being handled. Otherwise, afterCurrency.
				// 1: http://www.unicode.org/reports/tr35/tr35-numbers.html#Currencies
				currencyMatch = currencyMatch.test( symbol.charAt( i ? symbol.length - 1 : 0 ) );
				surroundingMatch = surroundingMatch.test(
					part.charAt( i ? 0 : part.length - 1 ).replace( /[#@,.]/g, "0" )
				);

				if ( currencyMatch && part && surroundingMatch ) {
					insertBetween = currencySpacing[ i ].insertBetween;
				}

				return ( i ? insertBetween : "" ) + part + ( i ? "" : insertBetween );
			}).join( "'" + symbol + "'" );
		}).join( ";" );

	return {
		pattern: pattern
	};
};




/**
 * objectOmit( object, keys )
 *
 * Return a copy of the object, filtered to omit the blacklisted key or array of keys.
 */
var objectOmit = function( object, keys ) {
	var key,
		copy = {};

	keys = alwaysArray( keys );

	for ( key in object ) {
		if ( keys.indexOf( key ) === -1 ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




function validateRequiredCldr( path, value ) {
	validateCldr( path, value, {
		skip: [ /supplemental\/currencyData\/fractions\/[A-Za-z]{3}$/ ]
	});
}

/**
 * .currencyFormatter( currency [, options] )
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object]:
 * - style: [String] "symbol" (default), "accounting", "code" or "name".
 * - see also number/format options.
 *
 * Return a function that formats a currency according to the given options and default/instance
 * locale.
 */
Globalize.currencyFormatter =
Globalize.prototype.currencyFormatter = function( currency, options ) {
	var args, cldr, numberFormatter, pluralGenerator, properties, returnFn, style;

	validateParameterPresence( currency, "currency" );
	validateParameterTypeCurrency( currency, "currency" );

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};

	args = [ currency, options ];
	style = options.style || "symbol";

	validateDefaultLocale( cldr );

	// Get properties given style ("symbol" default, "code" or "name").
	cldr.on( "get", validateRequiredCldr );
	properties = ({
		accounting: currencySymbolProperties,
		code: currencyCodeProperties,
		name: currencyNameProperties,
		symbol: currencySymbolProperties
	}[ style ] )( currency, cldr, options );
	cldr.off( "get", validateRequiredCldr );

	// options = options minus style, plus raw pattern.
	options = objectOmit( options, "style" );
	options.raw = properties.pattern;

	// Return formatter when style is "symbol" or "accounting".
	if ( style === "symbol" || style === "accounting" ) {
		numberFormatter = this.numberFormatter( options );

		returnFn = currencyFormatterFn( numberFormatter );

		runtimeBind( args, cldr, returnFn, [ numberFormatter ] );

	// Return formatter when style is "code" or "name".
	} else {
		numberFormatter = this.numberFormatter( options );
		pluralGenerator = this.pluralGenerator();

		returnFn = currencyFormatterFn( numberFormatter, pluralGenerator, properties );

		runtimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );
	}

	return returnFn;
};

/**
 * .currencyParser( currency [, options] )
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object] see currencyFormatter.
 *
 * Return the currency parser according to the given options and the default/instance locale.
 */
Globalize.currencyParser =
Globalize.prototype.currencyParser = function( /* currency, options */ ) {

	// TODO implement parser.

};

/**
 * .formatCurrency( value, currency [, options] )
 *
 * @value [Number] number to be formatted.
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object] see currencyFormatter.
 *
 * Format a currency according to the given options and the default/instance locale.
 */
Globalize.formatCurrency =
Globalize.prototype.formatCurrency = function( value, currency, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.currencyFormatter( currency, options )( value );
};

/**
 * .parseCurrency( value, currency [, options] )
 *
 * @value [String]
 *
 * @currency [String] 3-letter currency code as defined by ISO 4217.
 *
 * @options [Object]: See currencyFormatter.
 *
 * Return the parsed currency or NaN when value is invalid.
 */
Globalize.parseCurrency =
Globalize.prototype.parseCurrency = function( /* value, currency, options */ ) {
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/date.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var createError = Globalize._createError,
	createErrorUnsupportedFeature = Globalize._createErrorUnsupportedFeature,
	formatMessage = Globalize._formatMessage,
	isPlainObject = Globalize._isPlainObject,
	looseMatching = Globalize._looseMatching,
	numberNumberingSystemDigitsMap = Globalize._numberNumberingSystemDigitsMap,
	numberSymbol = Globalize._numberSymbol,
	regexpEscape = Globalize._regexpEscape,
	removeLiteralQuotes = Globalize._removeLiteralQuotes,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validate = Globalize._validate,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,
	validateParameterTypeString = Globalize._validateParameterTypeString;


var validateParameterTypeDate = function( value, name ) {
	validateParameterType( value, name, value === undefined || value instanceof Date, "Date" );
};




var createErrorInvalidParameterValue = function( name, value ) {
	return createError( "E_INVALID_PAR_VALUE", "Invalid `{name}` value ({value}).", {
		name: name,
		value: value
	});
};




/**
 * Create a map between the skeleton fields and their positions, e.g.,
 * {
 *   G: 0
 *   y: 1
 *   ...
 * }
 */
var validateSkeletonFieldsPosMap = "GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx".split( "" ).reduce(function( memo, item, i ) {
	memo[ item ] = i;
	return memo;
}, {});




/**
 * validateSkeleton( skeleton )
 *
 * skeleton: Assume `j` has already been converted into a localized hour field.
 */
var validateSkeleton = function validateSkeleton( skeleton ) {
	var last,

		// Using easier to read variable.
		fieldsPosMap = validateSkeletonFieldsPosMap;

	// "The fields are from the Date Field Symbol Table in Date Format Patterns"
	// Ref: http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems
	// I.e., check for invalid characters.
	skeleton.replace( /[^GyYuUrQqMLlwWEecdDFghHKkmsSAzZOvVXx]/, function( field ) {
		throw createError(
			"E_INVALID_OPTIONS", "Invalid field `{invalidField}` of skeleton `{value}`",
			{
				invalidField: field,
				type: "skeleton",
				value: skeleton
			}
		);
	});

	// "The canonical order is from top to bottom in that table; that is, yM not My".
	// http://www.unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems
	// I.e., check for invalid order.
	skeleton.split( "" ).every(function( field ) {
		if ( fieldsPosMap[ field ] < last ) {
			throw createError(
				"E_INVALID_OPTIONS", "Invalid order `{invalidField}` of skeleton `{value}`",
				{
					invalidField: field,
					type: "skeleton",
					value: skeleton
				}
			);
		}
		last = fieldsPosMap[ field ];
		return true;
	});
};




/**
 * Returns a new object created by using `object`'s values as keys, and the keys as values.
 */
var objectInvert = function( object, fn ) {
	fn = fn || function( object, key, value ) {
		object[ value ] = key;
		return object;
	};
	return Object.keys( object ).reduce(function( newObject, key ) {
		return fn( newObject, key, object[ key ] );
	}, {});
};




// Invert key and values, e.g., {"e": "eEc"} ==> {"e": "e", "E": "e", "c": "e"}.
var dateExpandPatternSimilarFieldsMap = objectInvert({
	"e": "eEc",
	"L": "ML"
}, function( object, key, value ) {
	value.split( "" ).forEach(function( field ) {
		object[ field ] = key;
	});
	return object;
});




var dateExpandPatternNormalizePatternType = function( character ) {
	return dateExpandPatternSimilarFieldsMap[ character ] || character;
};




var datePatternRe = ( /([a-z])\1*|'([^']|'')+'|''|./ig );




var stringRepeat = function( str, count ) {
	var i, result = "";
	for ( i = 0; i < count; i++ ) {
		result = result + str;
	}
	return result;
};




var dateExpandPatternAugmentFormat = function( requestedSkeleton, bestMatchFormat ) {
	var i, j, matchedType, matchedLength, requestedType, requestedLength,

		// Using an easier to read variable.
		normalizePatternType = dateExpandPatternNormalizePatternType;

	requestedSkeleton = requestedSkeleton.match( datePatternRe );
	bestMatchFormat = bestMatchFormat.match( datePatternRe );

	for ( i = 0; i < bestMatchFormat.length; i++ ) {
		matchedType = bestMatchFormat[i].charAt( 0 );
		matchedLength = bestMatchFormat[i].length;
		for ( j = 0; j < requestedSkeleton.length; j++ ) {
			requestedType = requestedSkeleton[j].charAt( 0 );
			requestedLength = requestedSkeleton[j].length;
			if ( normalizePatternType( matchedType ) === normalizePatternType( requestedType ) &&
				matchedLength < requestedLength
			) {
				bestMatchFormat[i] = stringRepeat( matchedType, requestedLength );
			}
		}
	}

	return bestMatchFormat.join( "" );
};




var dateExpandPatternCompareFormats = function( formatA, formatB ) {
	var a, b, distance, lenA, lenB, typeA, typeB, i, j,

		// Using easier to read variables.
		normalizePatternType = dateExpandPatternNormalizePatternType;

	if ( formatA === formatB ) {
		return 0;
	}

	formatA = formatA.match( datePatternRe );
	formatB = formatB.match( datePatternRe );

	if ( formatA.length !== formatB.length ) {
		return -1;
	}

	distance = 1;
	for ( i = 0; i < formatA.length; i++ ) {
		a = formatA[ i ].charAt( 0 );
		typeA = normalizePatternType( a );
		typeB = null;
		for ( j = 0; j < formatB.length; j++ ) {
			b = formatB[ j ].charAt( 0 );
			typeB = normalizePatternType( b );
			if ( typeA === typeB ) {
				break;
			} else {
				typeB = null;
			}
		}
		if ( typeB === null ) {
			return -1;
		}
		lenA = formatA[ i ].length;
		lenB = formatB[ j ].length;
		distance = distance + Math.abs( lenA - lenB );

		// Most symbols have a small distance from each other, e.g., M ≅ L; E ≅ c; a ≅ b ≅ B;
		// H ≅ k ≅ h ≅ K; ...
		if ( a !== b ) {
			distance += 1;
		}

		// Numeric (l<3) and text fields (l>=3) are given a larger distance from each other.
		if ( ( lenA < 3 && lenB >= 3 ) || ( lenA >= 3 && lenB < 3 ) ) {
			distance += 20;
		}
	}
	return distance;
};




var dateExpandPatternGetBestMatchPattern = function( cldr, askedSkeleton ) {
	var availableFormats, pattern, ratedFormats, skeleton,
		path = "dates/calendars/gregorian/dateTimeFormats/availableFormats",

		// Using easier to read variables.
		augmentFormat = dateExpandPatternAugmentFormat,
		compareFormats = dateExpandPatternCompareFormats;

	pattern = cldr.main([ path, askedSkeleton ]);

	if ( askedSkeleton && !pattern ) {
		availableFormats = cldr.main([ path ]);
		ratedFormats = [];

		for ( skeleton in availableFormats ) {
			ratedFormats.push({
				skeleton: skeleton,
				pattern: availableFormats[ skeleton ],
				rate: compareFormats( askedSkeleton, skeleton )
			});
		}

		ratedFormats = ratedFormats
			.filter( function( format ) {
				return format.rate > -1;
			} )
			.sort( function( formatA, formatB ) {
				return formatA.rate - formatB.rate;
			});

		if ( ratedFormats.length ) {
			pattern = augmentFormat( askedSkeleton, ratedFormats[0].pattern );
		}
	}

	return pattern;
};




/**
 * expandPattern( options, cldr )
 *
 * @options [Object] if String, it's considered a skeleton. Object accepts:
 * - skeleton: [String] lookup availableFormat;
 * - date: [String] ( "full" | "long" | "medium" | "short" );
 * - time: [String] ( "full" | "long" | "medium" | "short" );
 * - datetime: [String] ( "full" | "long" | "medium" | "short" );
 * - raw: [String] For more info see datetime/format.js.
 *
 * @cldr [Cldr instance].
 *
 * Return the corresponding pattern.
 * Eg for "en":
 * - "GyMMMd" returns "MMM d, y G";
 * - { skeleton: "GyMMMd" } returns "MMM d, y G";
 * - { date: "full" } returns "EEEE, MMMM d, y";
 * - { time: "full" } returns "h:mm:ss a zzzz";
 * - { datetime: "full" } returns "EEEE, MMMM d, y 'at' h:mm:ss a zzzz";
 * - { raw: "dd/mm" } returns "dd/mm";
 */
var dateExpandPattern = function( options, cldr ) {
	var dateSkeleton, result, skeleton, timeSkeleton, type,

		// Using easier to read variables.
		getBestMatchPattern = dateExpandPatternGetBestMatchPattern;

	function combineDateTime( type, datePattern, timePattern ) {
		return formatMessage(
			cldr.main([
				"dates/calendars/gregorian/dateTimeFormats",
				type
			]),
			[ timePattern, datePattern ]
		);
	}

	switch ( true ) {
		case "skeleton" in options:
			skeleton = options.skeleton;

			// Preferred hour (j).
			skeleton = skeleton.replace( /j/g, function() {
				return cldr.supplemental.timeData.preferred();
			});

			validateSkeleton( skeleton );

			// Try direct map (note that getBestMatchPattern handles it).
			// ... or, try to "best match" the whole skeleton.
			result = getBestMatchPattern(
				cldr,
				skeleton
			);
			if ( result ) {
				break;
			}

			// ... or, try to "best match" the date and time parts individually.
			timeSkeleton = skeleton.split( /[^hHKkmsSAzZOvVXx]/ ).slice( -1 )[ 0 ];
			dateSkeleton = skeleton.split( /[^GyYuUrQqMLlwWdDFgEec]/ )[ 0 ];
			dateSkeleton = getBestMatchPattern(
				cldr,
				dateSkeleton
			);
			timeSkeleton = getBestMatchPattern(
				cldr,
				timeSkeleton
			);

			if ( /(MMMM|LLLL).*[Ec]/.test( dateSkeleton ) ) {
				type = "full";
			} else if ( /MMMM|LLLL/.test( dateSkeleton ) ) {
				type = "long";
			} else if ( /MMM|LLL/.test( dateSkeleton ) ) {
				type = "medium";
			} else {
				type = "short";
			}

			if ( dateSkeleton && timeSkeleton ) {
				result = combineDateTime( type, dateSkeleton, timeSkeleton );
			} else {
				result = dateSkeleton || timeSkeleton;
			}

			break;

		case "date" in options:
		case "time" in options:
			result = cldr.main([
				"dates/calendars/gregorian",
				"date" in options ? "dateFormats" : "timeFormats",
				( options.date || options.time )
			]);
			break;

		case "datetime" in options:
			result = combineDateTime( options.datetime,
				cldr.main([ "dates/calendars/gregorian/dateFormats", options.datetime ]),
				cldr.main([ "dates/calendars/gregorian/timeFormats", options.datetime ])
			);
			break;

		case "raw" in options:
			result = options.raw;
			break;

		default:
			throw createErrorInvalidParameterValue({
				name: "options",
				value: options
			});
	}

	return result;
};




var dateWeekDays = [ "sun", "mon", "tue", "wed", "thu", "fri", "sat" ];




/**
 * firstDayOfWeek
 */
var dateFirstDayOfWeek = function( cldr ) {
	return dateWeekDays.indexOf( cldr.supplemental.weekData.firstDay() );
};




/**
 * getTimeZoneName( length, type )
 */
var dateGetTimeZoneName = function( length, type, timeZone, cldr ) {
	var metaZone, result;

	if ( !timeZone ) {
		return;
	}

	result = cldr.main([
		"dates/timeZoneNames/zone",
		timeZone,
		length < 4 ? "short" : "long",
		type
	]);

	if ( result ) {
		return result;
	}

	// The latest metazone data of the metazone array.
	// TODO expand to support the historic metazones based on the given date.
	metaZone = cldr.supplemental([
		"metaZones/metazoneInfo/timezone", timeZone, 0,
		"usesMetazone/_mzone"
	]);

	return cldr.main([
		"dates/timeZoneNames/metazone",
		metaZone,
		length < 4 ? "short" : "long",
		type
	]);
};




/**
 * timezoneHourFormatShortH( hourFormat )
 *
 * @hourFormat [String]
 *
 * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.
 * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293
 *
 * Example:
 * - "+HH.mm;-HH.mm" => "+H;-H"
 * - "+HH:mm;-HH:mm" => "+H;-H"
 * - "+HH:mm;−HH:mm" => "+H;−H" (Note MINUS SIGN \u2212)
 * - "+HHmm;-HHmm" => "+H:-H"
 */
var dateTimezoneHourFormatH = function( hourFormat ) {
	return hourFormat
		.split( ";" )
		.map(function( format ) {
			return format.slice( 0, format.indexOf( "H" ) + 1 );
		})
		.join( ";" );
};




/**
 * timezoneHourFormatLongHm( hourFormat )
 *
 * @hourFormat [String]
 *
 * Unofficial deduction of the short hourFormat given time zone `hourFormat` element.
 * Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293
 *
 * Example (hFormat === "H"): (used for short Hm)
 * - "+HH.mm;-HH.mm" => "+H.mm;-H.mm"
 * - "+HH:mm;-HH:mm" => "+H:mm;-H:mm"
 * - "+HH:mm;−HH:mm" => "+H:mm;−H:mm" (Note MINUS SIGN \u2212)
 * - "+HHmm;-HHmm" => "+Hmm:-Hmm"
 *
 * Example (hFormat === "HH": (used for long Hm)
 * - "+HH.mm;-HH.mm" => "+HH.mm;-HH.mm"
 * - "+HH:mm;-HH:mm" => "+HH:mm;-HH:mm"
 * - "+H:mm;-H:mm"   => "+HH:mm;-HH:mm"
 * - "+HH:mm;−HH:mm" => "+HH:mm;−HH:mm" (Note MINUS SIGN \u2212)
 * - "+HHmm;-HHmm" => "+HHmm:-HHmm"
 */
var dateTimezoneHourFormatHm = function( hourFormat, hFormat ) {
	return hourFormat
		.split( ";" )
		.map(function( format ) {
			var parts = format.split( /H+/ );
			parts.splice( 1, 0, hFormat );
			return parts.join( "" );
		})
		.join( ";" );
};




var runtimeCacheDataBind = function( key, data ) {
	var fn = function() {
		return data;
	};
	fn.dataCacheKey = key;
	return fn;
};




/**
 * properties( pattern, cldr )
 *
 * @pattern [String] raw pattern.
 * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
 *
 * @cldr [Cldr instance].
 *
 * Return the properties given the pattern and cldr.
 *
 * TODO Support other calendar types.
 */
var dateFormatProperties = function( pattern, cldr, timeZone ) {
	var properties = {
			numberFormatters: {},
			pattern: pattern,
			timeSeparator: numberSymbol( "timeSeparator", cldr )
		},
		widths = [ "abbreviated", "wide", "narrow" ];

	function setNumberFormatterPattern( pad ) {
		properties.numberFormatters[ pad ] = stringPad( "", pad );
	}

	if ( timeZone ) {
		properties.timeZoneData = runtimeCacheDataBind( "iana/" + timeZone, {
			offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
			untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
			isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
		});
	}

	pattern.replace( datePatternRe, function( current ) {
		var aux, chr, daylightTzName, formatNumber, genericTzName, length, standardTzName;

		chr = current.charAt( 0 );
		length = current.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			properties.preferredTime = chr = cldr.supplemental.timeData.preferred();
		}

		// ZZZZ: same as "OOOO".
		if ( chr === "Z" && length === 4 ) {
			chr = "O";
			length = 4;
		}

		// z...zzz: "{shortRegion}", eg. "PST" or "PDT".
		// zzzz: "{regionName} {Standard Time}" or "{regionName} {Daylight Time}",
		//       e.g., "Pacific Standard Time" or "Pacific Daylight Time".
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "z" ) {
			standardTzName = dateGetTimeZoneName( length, "standard", timeZone, cldr );
			daylightTzName = dateGetTimeZoneName( length, "daylight", timeZone, cldr );
			if ( standardTzName ) {
				properties.standardTzName = standardTzName;
			}
			if ( daylightTzName ) {
				properties.daylightTzName = daylightTzName;
			}

			// Fall through the "O" format in case one name is missing.
			if ( !standardTzName || !daylightTzName ) {
				chr = "O";
				if ( length < 4 ) {
					length = 1;
				}
			}
		}

		// v...vvv: "{shortRegion}", eg. "PT".
		// vvvv: "{regionName} {Time}" or "{regionName} {Time}",
		// e.g., "Pacific Time"
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "v" ) {
			genericTzName = dateGetTimeZoneName( length, "generic", timeZone, cldr );

			// Fall back to "V" format.
			if ( !genericTzName ) {
				chr = "V";
				length = 4;
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				properties.eras = cldr.main([
					"dates/calendars/gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "y":

				// Plain year.
				formatNumber = true;
				break;

			case "Y":

				// Year in "Week of Year"
				properties.firstDay = dateFirstDayOfWeek( cldr );
				properties.minDays = cldr.supplemental.weekData.minDays();
				formatNumber = true;
				break;

			case "u": // Extended year. Need to be implemented.
			case "U": // Cyclic year name. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter
			case "Q":
			case "q":
				if ( length > 2 ) {
					if ( !properties.quarters ) {
						properties.quarters = {};
					}
					if ( !properties.quarters[ chr ] ) {
						properties.quarters[ chr ] = {};
					}
					properties.quarters[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				} else {
					formatNumber = true;
				}
				break;

			// Month
			case "M":
			case "L":
				if ( length > 2 ) {
					if ( !properties.months ) {
						properties.months = {};
					}
					if ( !properties.months[ chr ] ) {
						properties.months[ chr ] = {};
					}
					properties.months[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/months",
						chr === "M" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				} else {
					formatNumber = true;
				}
				break;

			// Week - Week of Year (w) or Week of Month (W).
			case "w":
			case "W":
				properties.firstDay = dateFirstDayOfWeek( cldr );
				properties.minDays = cldr.supplemental.weekData.minDays();
				formatNumber = true;
				break;

			// Day
			case "d":
			case "D":
			case "F":
				formatNumber = true;
				break;

			case "g":

				// Modified Julian day. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "Julian day pattern `g`"
				});

			// Week day
			case "e":
			case "c":
				if ( length <= 2 ) {
					properties.firstDay = dateFirstDayOfWeek( cldr );
					formatNumber = true;
					break;
				}

			/* falls through */
			case "E":
				if ( !properties.days ) {
					properties.days = {};
				}
				if ( !properties.days[ chr ] ) {
					properties.days[ chr ] = {};
				}
				if ( length === 6 ) {

					// If short day names are not explicitly specified, abbreviated day names are
					// used instead.
					// http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					// http://unicode.org/cldr/trac/ticket/6790
					properties.days[ chr ][ length ] = cldr.main([
							"dates/calendars/gregorian/days",
							chr === "c" ? "stand-alone" : "format",
							"short"
						]) || cldr.main([
							"dates/calendars/gregorian/days",
							chr === "c" ? "stand-alone" : "format",
							"abbreviated"
						]);
				} else {
					properties.days[ chr ][ length ] = cldr.main([
						"dates/calendars/gregorian/days",
						chr === "c" ? "stand-alone" : "format",
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				properties.dayPeriods = {
					am: cldr.main(
						"dates/calendars/gregorian/dayPeriods/format/wide/am"
					),
					pm: cldr.main(
						"dates/calendars/gregorian/dayPeriods/format/wide/pm"
					)
				};
				break;

			// Hour
			case "h": // 1-12
			case "H": // 0-23
			case "K": // 0-11
			case "k": // 1-24

			// Minute
			case "m":

			// Second
			case "s":
			case "S":
			case "A":
				formatNumber = true;
				break;

			// Zone
			case "v":
				if ( length !== 1 && length !== 4 ) {
					throw createErrorUnsupportedFeature({
						feature: "timezone pattern `" + pattern + "`"
					});
				}
				properties.genericTzName = genericTzName;
				break;

			case "V":

				if ( length === 1 ) {
					throw createErrorUnsupportedFeature({
						feature: "timezone pattern `" + pattern + "`"
					});
				}

				if ( timeZone ) {
					if ( length === 2 ) {
						properties.timeZoneName = timeZone;
						break;
					}

					var timeZoneName,
						exemplarCity = cldr.main([
							"dates/timeZoneNames/zone", timeZone, "exemplarCity"
						]);

					if ( length === 3 ) {
						if ( !exemplarCity ) {
							exemplarCity = cldr.main([
								"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity"
							]);
						}
						timeZoneName = exemplarCity;
					}

					if ( exemplarCity && length === 4 ) {
						timeZoneName = formatMessage(
							cldr.main(
								"dates/timeZoneNames/regionFormat"
							),
							[ exemplarCity ]
						);
					}

					if ( timeZoneName ) {
						properties.timeZoneName = timeZoneName;
						break;
					}
				}

				if ( current === "v" ) {
					length = 1;
				}

			/* falls through */
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				properties.gmtFormat = cldr.main( "dates/timeZoneNames/gmtFormat" );
				properties.gmtZeroFormat = cldr.main( "dates/timeZoneNames/gmtZeroFormat" );

				// Unofficial deduction of the hourFormat variations.
				// Official spec is pending resolution: http://unicode.org/cldr/trac/ticket/8293
				aux = cldr.main( "dates/timeZoneNames/hourFormat" );
				properties.hourFormat = length < 4 ?
					[ dateTimezoneHourFormatH( aux ), dateTimezoneHourFormatHm( aux, "H" ) ] :
					dateTimezoneHourFormatHm( aux, "HH" );

			/* falls through */
			case "Z":
			case "X":
			case "x":
				setNumberFormatterPattern( 1 );
				setNumberFormatterPattern( 2 );
				break;
		}

		if ( formatNumber ) {
			setNumberFormatterPattern( length );
		}
	});

	return properties;
};




var dateFormatterFn = function( dateToPartsFormatter ) {
	return function dateFormatter( value ) {
		return dateToPartsFormatter( value ).map( function( part ) {
			return part.value;
		}).join( "" );
	};
};




/**
 * parseProperties( cldr )
 *
 * @cldr [Cldr instance].
 *
 * @timeZone [String] FIXME.
 *
 * Return parser properties.
 */
var dateParseProperties = function( cldr, timeZone ) {
	var properties = {
		preferredTimeData: cldr.supplemental.timeData.preferred()
	};

	if ( timeZone ) {
		properties.timeZoneData = runtimeCacheDataBind( "iana/" + timeZone, {
			offsets: cldr.get([ "globalize-iana/zoneData", timeZone, "offsets" ]),
			untils: cldr.get([ "globalize-iana/zoneData", timeZone, "untils" ]),
			isdsts: cldr.get([ "globalize-iana/zoneData", timeZone, "isdsts" ])
		});
	}

	return properties;
};


var ZonedDateTime = (function() {
function definePrivateProperty(object, property, value) {
  Object.defineProperty(object, property, {
    value: value
  });
}

function getUntilsIndex(original, untils) {
  var index = 0;
  var originalTime = original.getTime();

  // TODO Should we do binary search for improved performance?
  while (index < untils.length - 1 && originalTime >= untils[index]) {
    index++;
  }
  return index;
}

function setWrap(fn) {
  var offset1 = this.getTimezoneOffset();
  var ret = fn();
  this.original.setTime(new Date(this.getTime()));
  var offset2 = this.getTimezoneOffset();
  if (offset2 - offset1) {
    this.original.setMinutes(this.original.getMinutes() + offset2 - offset1);
  }
  return ret;
}

var ZonedDateTime = function(date, timeZoneData) {
  definePrivateProperty(this, "original", new Date(date.getTime()));
  definePrivateProperty(this, "local", new Date(date.getTime()));
  definePrivateProperty(this, "timeZoneData", timeZoneData);
  definePrivateProperty(this, "setWrap", setWrap);
  if (!(timeZoneData.untils && timeZoneData.offsets && timeZoneData.isdsts)) {
    throw new Error("Invalid IANA data");
  }
  this.setTime(this.local.getTime() - this.getTimezoneOffset() * 60 * 1000);
};

ZonedDateTime.prototype.clone = function() {
  return new ZonedDateTime(this.original, this.timeZoneData);
};

// Date field getters.
["getFullYear", "getMonth", "getDate", "getDay", "getHours", "getMinutes",
"getSeconds", "getMilliseconds"].forEach(function(method) {
  // Corresponding UTC method, e.g., "getUTCFullYear" if method === "getFullYear".
  var utcMethod = "getUTC" + method.substr(3);
  ZonedDateTime.prototype[method] = function() {
    return this.local[utcMethod]();
  };
});

// Note: Define .valueOf = .getTime for arithmetic operations like date1 - date2.
ZonedDateTime.prototype.valueOf =
ZonedDateTime.prototype.getTime = function() {
  return this.local.getTime() + this.getTimezoneOffset() * 60 * 1000;
};

ZonedDateTime.prototype.getTimezoneOffset = function() {
  var index = getUntilsIndex(this.original, this.timeZoneData.untils);
  return this.timeZoneData.offsets[index];
};

// Date field setters.
["setFullYear", "setMonth", "setDate", "setHours", "setMinutes", "setSeconds", "setMilliseconds"].forEach(function(method) {
  // Corresponding UTC method, e.g., "setUTCFullYear" if method === "setFullYear".
  var utcMethod = "setUTC" + method.substr(3);
  ZonedDateTime.prototype[method] = function(value) {
    var local = this.local;
    // Note setWrap is needed for seconds and milliseconds just because
    // abs(value) could be >= a minute.
    return this.setWrap(function() {
      return local[utcMethod](value);
    });
  };
});

ZonedDateTime.prototype.setTime = function(time) {
  return this.local.setTime(time);
};

ZonedDateTime.prototype.isDST = function() {
  var index = getUntilsIndex(this.original, this.timeZoneData.untils);
  return Boolean(this.timeZoneData.isdsts[index]);
};

ZonedDateTime.prototype.inspect = function() {
  var index = getUntilsIndex(this.original, this.timeZoneData.untils);
  var abbrs = this.timeZoneData.abbrs;
  return this.local.toISOString().replace(/Z$/, "") + " " +
    (abbrs && abbrs[index] + " " || (this.getTimezoneOffset() * -1) + " ") +
    (this.isDST() ? "(daylight savings)" : "");
};

ZonedDateTime.prototype.toDate = function() {
  return new Date(this.getTime());
};

// Type cast getters.
["toISOString", "toJSON", "toUTCString"].forEach(function(method) {
  ZonedDateTime.prototype[method] = function() {
    return this.toDate()[method]();
  };
});

return ZonedDateTime;
}());


/**
 * isLeapYear( year )
 *
 * @year [Number]
 *
 * Returns an indication whether the specified year is a leap year.
 */
var dateIsLeapYear = function( year ) {
	return new Date( year, 1, 29 ).getMonth() === 1;
};




/**
 * lastDayOfMonth( date )
 *
 * @date [Date]
 *
 * Return the last day of the given date's month
 */
var dateLastDayOfMonth = function( date ) {
	return new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();
};




/**
 * startOf changes the input to the beginning of the given unit.
 *
 * For example, starting at the start of a day, resets hours, minutes
 * seconds and milliseconds to 0. Starting at the month does the same, but
 * also sets the date to 1.
 *
 * Returns the modified date
 */
var dateStartOf = function( date, unit ) {
	date = date instanceof ZonedDateTime ? date.clone() : new Date( date.getTime() );
	switch ( unit ) {
		case "year":
			date.setMonth( 0 );
		/* falls through */
		case "month":
			date.setDate( 1 );
		/* falls through */
		case "day":
			date.setHours( 0 );
		/* falls through */
		case "hour":
			date.setMinutes( 0 );
		/* falls through */
		case "minute":
			date.setSeconds( 0 );
		/* falls through */
		case "second":
			date.setMilliseconds( 0 );
	}
	return date;
};




/**
 * Differently from native date.setDate(), this function returns a date whose
 * day remains inside the month boundaries. For example:
 *
 * setDate( FebDate, 31 ): a "Feb 28" date.
 * setDate( SepDate, 31 ): a "Sep 30" date.
 */
var dateSetDate = function( date, day ) {
	var lastDay = new Date( date.getFullYear(), date.getMonth() + 1, 0 ).getDate();

	date.setDate( day < 1 ? 1 : day < lastDay ? day : lastDay );
};




/**
 * Differently from native date.setMonth(), this function adjusts date if
 * needed, so final month is always the one set.
 *
 * setMonth( Jan31Date, 1 ): a "Feb 28" date.
 * setDate( Jan31Date, 8 ): a "Sep 30" date.
 */
var dateSetMonth = function( date, month ) {
	var originalDate = date.getDate();

	date.setDate( 1 );
	date.setMonth( month );
	dateSetDate( date, originalDate );
};




var outOfRange = function( value, low, high ) {
	return value < low || value > high;
};




/**
 * parse( value, tokens, properties )
 *
 * @value [String] string date.
 *
 * @tokens [Object] tokens returned by date/tokenizer.
 *
 * @properties [Object] output returned by date/tokenizer-properties.
 *
 * ref: http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
 */
var dateParse = function( value, tokens, properties ) {
	var amPm, day, daysOfYear, month, era, hour, hour12, timezoneOffset, valid,
		YEAR = 0,
		MONTH = 1,
		DAY = 2,
		HOUR = 3,
		MINUTE = 4,
		SECOND = 5,
		MILLISECONDS = 6,
		date = new Date(),
		truncateAt = [],
		units = [ "year", "month", "day", "hour", "minute", "second", "milliseconds" ];

	// Create globalize date with given timezone data.
	if ( properties.timeZoneData ) {
		date = new ZonedDateTime( date, properties.timeZoneData() );
	}

	if ( !tokens.length ) {
		return null;
	}

	valid = tokens.every(function( token ) {
		var century, chr, value, length;

		if ( token.type === "literal" ) {

			// continue
			return true;
		}

		chr = token.type.charAt( 0 );
		length = token.type.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			chr = properties.preferredTimeData;
		}

		switch ( chr ) {

			// Era
			case "G":
				truncateAt.push( YEAR );
				era = +token.value;
				break;

			// Year
			case "y":
				value = token.value;
				if ( length === 2 ) {
					if ( outOfRange( value, 0, 99 ) ) {
						return false;
					}

					// mimic dojo/date/locale: choose century to apply, according to a sliding
					// window of 80 years before and 20 years after present year.
					century = Math.floor( date.getFullYear() / 100 ) * 100;
					value += century;
					if ( value > date.getFullYear() + 20 ) {
						value -= 100;
					}
				}
				date.setFullYear( value );
				truncateAt.push( YEAR );
				break;

			case "Y": // Year in "Week of Year"
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter (skip)
			case "Q":
			case "q":
				break;

			// Month
			case "M":
			case "L":
				if ( length <= 2 ) {
					value = token.value;
				} else {
					value = +token.value;
				}
				if ( outOfRange( value, 1, 12 ) ) {
					return false;
				}

				// Setting the month later so that we have the correct year and can determine
				// the correct last day of February in case of leap year.
				month = value;
				truncateAt.push( MONTH );
				break;

			// Week (skip)
			case "w": // Week of Year.
			case "W": // Week of Month.
				break;

			// Day
			case "d":
				day = token.value;
				truncateAt.push( DAY );
				break;

			case "D":
				daysOfYear = token.value;
				truncateAt.push( DAY );
				break;

			case "F":

				// Day of Week in month. eg. 2nd Wed in July.
				// Skip
				break;

			// Week day
			case "e":
			case "c":
			case "E":

				// Skip.
				// value = arrayIndexOf( dateWeekDays, token.value );
				break;

			// Period (AM or PM)
			case "a":
				amPm = token.value;
				break;

			// Hour
			case "h": // 1-12
				value = token.value;
				if ( outOfRange( value, 1, 12 ) ) {
					return false;
				}
				hour = hour12 = true;
				date.setHours( value === 12 ? 0 : value );
				truncateAt.push( HOUR );
				break;

			case "K": // 0-11
				value = token.value;
				if ( outOfRange( value, 0, 11 ) ) {
					return false;
				}
				hour = hour12 = true;
				date.setHours( value );
				truncateAt.push( HOUR );
				break;

			case "k": // 1-24
				value = token.value;
				if ( outOfRange( value, 1, 24 ) ) {
					return false;
				}
				hour = true;
				date.setHours( value === 24 ? 0 : value );
				truncateAt.push( HOUR );
				break;

			case "H": // 0-23
				value = token.value;
				if ( outOfRange( value, 0, 23 ) ) {
					return false;
				}
				hour = true;
				date.setHours( value );
				truncateAt.push( HOUR );
				break;

			// Minute
			case "m":
				value = token.value;
				if ( outOfRange( value, 0, 59 ) ) {
					return false;
				}
				date.setMinutes( value );
				truncateAt.push( MINUTE );
				break;

			// Second
			case "s":
				value = token.value;
				if ( outOfRange( value, 0, 59 ) ) {
					return false;
				}
				date.setSeconds( value );
				truncateAt.push( SECOND );
				break;

			case "A":
				date.setHours( 0 );
				date.setMinutes( 0 );
				date.setSeconds( 0 );

			/* falls through */
			case "S":
				value = Math.round( token.value * Math.pow( 10, 3 - length ) );
				date.setMilliseconds( value );
				truncateAt.push( MILLISECONDS );
				break;

			// Zone
			case "z":
			case "Z":
			case "O":
			case "v":
			case "V":
			case "X":
			case "x":
				if ( typeof token.value === "number" ) {
					timezoneOffset = token.value;
				}
				break;
		}

		return true;
	});

	if ( !valid ) {
		return null;
	}

	// 12-hour format needs AM or PM, 24-hour format doesn't, ie. return null
	// if amPm && !hour12 || !amPm && hour12.
	if ( hour && !( !amPm ^ hour12 ) ) {
		return null;
	}

	if ( era === 0 ) {

		// 1 BC = year 0
		date.setFullYear( date.getFullYear() * -1 + 1 );
	}

	if ( month !== undefined ) {
		dateSetMonth( date, month - 1 );
	}

	if ( day !== undefined ) {
		if ( outOfRange( day, 1, dateLastDayOfMonth( date ) ) ) {
			return null;
		}
		date.setDate( day );
	} else if ( daysOfYear !== undefined ) {
		if ( outOfRange( daysOfYear, 1, dateIsLeapYear( date.getFullYear() ) ? 366 : 365 ) ) {
			return null;
		}
		date.setMonth( 0 );
		date.setDate( daysOfYear );
	}

	if ( hour12 && amPm === "pm" ) {
		date.setHours( date.getHours() + 12 );
	}

	if ( timezoneOffset !== undefined ) {
		date.setMinutes( date.getMinutes() + timezoneOffset - date.getTimezoneOffset() );
	}

	// Truncate date at the most precise unit defined. Eg.
	// If value is "12/31", and pattern is "MM/dd":
	// => new Date( <current Year>, 12, 31, 0, 0, 0, 0 );
	truncateAt = Math.max.apply( null, truncateAt );
	date = dateStartOf( date, units[ truncateAt ] );

	// Get date back from globalize date.
	if ( date instanceof ZonedDateTime ) {
		date = date.toDate();
	}

	return date;
};




/**
 * tokenizer( value, numberParser, properties )
 *
 * @value [String] string date.
 *
 * @numberParser [Function]
 *
 * @properties [Object] output returned by date/tokenizer-properties.
 *
 * Returns an Array of tokens, eg. value "5 o'clock PM", pattern "h 'o''clock' a":
 * [{
 *   type: "h",
 *   lexeme: "5"
 * }, {
 *   type: "literal",
 *   lexeme: " "
 * }, {
 *   type: "literal",
 *   lexeme: "o'clock"
 * }, {
 *   type: "literal",
 *   lexeme: " "
 * }, {
 *   type: "a",
 *   lexeme: "PM",
 *   value: "pm"
 * }]
 *
 * OBS: lexeme's are always String and may return invalid ranges depending of the token type.
 * Eg. "99" for month number.
 *
 * Return an empty Array when not successfully parsed.
 */
var dateTokenizer = function( value, numberParser, properties ) {
	var digitsRe, valid,
		tokens = [],
		widths = [ "abbreviated", "wide", "narrow" ];

	digitsRe = properties.digitsRe;
	value = looseMatching( value );

	valid = properties.pattern.match( datePatternRe ).every(function( current ) {
		var aux, chr, length, numeric, tokenRe,
			token = {};

		function hourFormatParse( tokenRe, numberParser ) {
			var aux, isPositive,
				match = value.match( tokenRe );
			numberParser = numberParser || function( value ) {
				return +value;
			};

			if ( !match ) {
				return false;
			}

			isPositive = match[ 1 ];

			// hourFormat containing H only, e.g., `+H;-H`
			if ( match.length < 6 ) {
				aux = isPositive ? 1 : 3;
				token.value = numberParser( match[ aux ] ) * 60;

			// hourFormat containing H and m, e.g., `+HHmm;-HHmm`
			} else if ( match.length < 10 ) {
				aux = isPositive ? [ 1, 3 ] : [ 5, 7 ];
				token.value = numberParser( match[ aux[ 0 ] ] ) * 60 +
					numberParser( match[ aux[ 1 ] ] );

			// hourFormat containing H, m, and s e.g., `+HHmmss;-HHmmss`
			} else {
				aux = isPositive ? [ 1, 3, 5 ] : [ 7, 9, 11 ];
				token.value = numberParser( match[ aux[ 0 ] ] ) * 60 +
					numberParser( match[ aux[ 1 ] ] ) +
					numberParser( match[ aux[ 2 ] ] ) / 60;
			}

			if ( isPositive ) {
				token.value *= -1;
			}

			return true;
		}

		function oneDigitIfLengthOne() {
			if ( length === 1 ) {

				// Unicode equivalent to /\d/
				numeric = true;
				return tokenRe = digitsRe;
			}
		}

		function oneOrTwoDigitsIfLengthOne() {
			if ( length === 1 ) {

				// Unicode equivalent to /\d\d?/
				numeric = true;
				return tokenRe = new RegExp( "^(" + digitsRe.source + "){1,2}" );
			}
		}

		function oneOrTwoDigitsIfLengthOneOrTwo() {
			if ( length === 1 || length === 2 ) {

				// Unicode equivalent to /\d\d?/
				numeric = true;
				return tokenRe = new RegExp( "^(" + digitsRe.source + "){1,2}" );
			}
		}

		function twoDigitsIfLengthTwo() {
			if ( length === 2 ) {

				// Unicode equivalent to /\d\d/
				numeric = true;
				return tokenRe = new RegExp( "^(" + digitsRe.source + "){2}" );
			}
		}

		// Brute-force test every locale entry in an attempt to match the given value.
		// Return the first found one (and set token accordingly), or null.
		function lookup( path ) {
			var array = properties[ path.join( "/" ) ];

			if ( !array ) {
				return null;
			}

			// array of pairs [key, value] sorted by desc value length.
			array.some(function( item ) {
				var valueRe = item[ 1 ];
				if ( valueRe.test( value ) ) {
					token.value = item[ 0 ];
					tokenRe = item[ 1 ];
					return true;
				}
			});
			return null;
		}

		token.type = current;
		chr = current.charAt( 0 );
		length = current.length;

		if ( chr === "Z" ) {

			// Z..ZZZ: same as "xxxx".
			if ( length < 4 ) {
				chr = "x";
				length = 4;

			// ZZZZ: same as "OOOO".
			} else if ( length < 5 ) {
				chr = "O";
				length = 4;

			// ZZZZZ: same as "XXXXX"
			} else {
				chr = "X";
				length = 5;
			}
		}

		if ( chr === "z" ) {
			if ( properties.standardOrDaylightTzName ) {
				token.value = null;
				tokenRe = properties.standardOrDaylightTzName;
			}
		}

		// v...vvv: "{shortRegion}", eg. "PT".
		// vvvv: "{regionName} {Time}" or "{regionName} {Time}",
		// e.g., "Pacific Time"
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "v" ) {
			if ( properties.genericTzName ) {
				token.value = null;
				tokenRe = properties.genericTzName;

			// Fall back to "V" format.
			} else {
				chr = "V";
				length = 4;
			}
		}

		if ( chr === "V" && properties.timeZoneName ) {
			token.value = length === 2 ? properties.timeZoneName : null;
			tokenRe = properties.timeZoneNameRe;
		}

		switch ( chr ) {

			// Era
			case "G":
				lookup([
					"gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "y":
			case "Y":
				numeric = true;

				// number l=1:+, l=2:{2}, l=3:{3,}, l=4:{4,}, ...
				if ( length === 1 ) {

					// Unicode equivalent to /\d+/.
					tokenRe = new RegExp( "^(" + digitsRe.source + ")+" );
				} else if ( length === 2 ) {

					// Lenient parsing: there's no year pattern to indicate non-zero-padded 2-digits
					// year, so parser accepts both zero-padded and non-zero-padded for `yy`.
					//
					// Unicode equivalent to /\d\d?/
					tokenRe = new RegExp( "^(" + digitsRe.source + "){1,2}" );
				} else {

					// Unicode equivalent to /\d{length,}/
					tokenRe = new RegExp( "^(" + digitsRe.source + "){" + length + ",}" );
				}
				break;

			// Quarter
			case "Q":
			case "q":

				// number l=1:{1}, l=2:{2}.
				// lookup l=3...
				oneDigitIfLengthOne() || twoDigitsIfLengthTwo() ||
					lookup([
						"gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				break;

			// Month
			case "M":
			case "L":

				// number l=1:{1,2}, l=2:{2}.
				// lookup l=3...
				//
				// Lenient parsing: skeleton "yMd" (i.e., one M) may include MM for the pattern,
				// therefore parser accepts both zero-padded and non-zero-padded for M and MM.
				// Similar for L.
				oneOrTwoDigitsIfLengthOneOrTwo() || lookup([
					"gregorian/months",
					chr === "M" ? "format" : "stand-alone",
					widths[ length - 3 ]
				]);
				break;

			// Day
			case "D":

				// number {l,3}.
				if ( length <= 3 ) {

					// Equivalent to /\d{length,3}/
					numeric = true;
					tokenRe = new RegExp( "^(" + digitsRe.source + "){" + length + ",3}" );
				}
				break;

			case "W":
			case "F":

				// number l=1:{1}.
				oneDigitIfLengthOne();
				break;

			// Week day
			case "e":
			case "c":

				// number l=1:{1}, l=2:{2}.
				// lookup for length >=3.
				if ( length <= 2 ) {
					oneDigitIfLengthOne() || twoDigitsIfLengthTwo();
					break;
				}

			/* falls through */
			case "E":
				if ( length === 6 ) {

					// Note: if short day names are not explicitly specified, abbreviated day
					// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"short"
					]) || lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"abbreviated"
					]);
				} else {
					lookup([
						"gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				lookup([
					"gregorian/dayPeriods/format/wide"
				]);
				break;

			// Week
			case "w":

				// number l1:{1,2}, l2:{2}.
				oneOrTwoDigitsIfLengthOne() || twoDigitsIfLengthTwo();
				break;

			// Day, Hour, Minute, or Second
			case "d":
			case "h":
			case "H":
			case "K":
			case "k":
			case "j":
			case "m":
			case "s":

				// number l1:{1,2}, l2:{2}.
				//
				// Lenient parsing:
				// - skeleton "hms" (i.e., one m) always includes mm for the pattern, i.e., it's
				//   impossible to use a different skeleton to parse non-zero-padded minutes,
				//   therefore parser accepts both zero-padded and non-zero-padded for m. Similar
				//   for seconds s.
				// - skeleton "hms" (i.e., one h) may include h or hh for the pattern, i.e., it's
				//   impossible to use a different skeleton to parser non-zero-padded hours for some
				//   locales, therefore parser accepts both zero-padded and non-zero-padded for h.
				//   Similar for d (in skeleton yMd).
				oneOrTwoDigitsIfLengthOneOrTwo();
				break;

			case "S":

				// number {l}.

				// Unicode equivalent to /\d{length}/
				numeric = true;
				tokenRe = new RegExp( "^(" + digitsRe.source + "){" + length + "}" );
				break;

			case "A":

				// number {l+5}.

				// Unicode equivalent to /\d{length+5}/
				numeric = true;
				tokenRe = new RegExp( "^(" + digitsRe.source + "){" + ( length + 5 ) + "}" );
				break;

			// Zone
			case "v":
			case "V":
			case "z":
				if ( tokenRe && tokenRe.test( value ) ) {
					break;
				}
				if ( chr === "V" && length === 2 ) {
					break;
				}

			/* falls through */
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				if ( value === properties[ "timeZoneNames/gmtZeroFormat" ] ) {
					token.value = 0;
					tokenRe = properties[ "timeZoneNames/gmtZeroFormatRe" ];
				} else {
					aux = properties[ "timeZoneNames/hourFormat" ].some(function( hourFormatRe ) {
						if ( hourFormatParse( hourFormatRe, numberParser ) ) {
							tokenRe = hourFormatRe;
							return true;
						}
					});
					if ( !aux ) {
						return null;
					}
				}
				break;

			case "X":

				// Same as x*, except it uses "Z" for zero offset.
				if ( value === "Z" ) {
					token.value = 0;
					tokenRe = /^Z/;
					break;
				}

			/* falls through */
			case "x":

				// x: hourFormat("+HH[mm];-HH[mm]")
				// xx: hourFormat("+HHmm;-HHmm")
				// xxx: hourFormat("+HH:mm;-HH:mm")
				// xxxx: hourFormat("+HHmm[ss];-HHmm[ss]")
				// xxxxx: hourFormat("+HH:mm[:ss];-HH:mm[:ss]")
				aux = properties.x.some(function( hourFormatRe ) {
					if ( hourFormatParse( hourFormatRe ) ) {
						tokenRe = hourFormatRe;
						return true;
					}
				});
				if ( !aux ) {
					return null;
				}
				break;

			case "'":
				token.type = "literal";
				tokenRe = new RegExp( "^" + regexpEscape( removeLiteralQuotes( current ) ) );
				break;

			default:
				token.type = "literal";
				tokenRe = new RegExp( "^" + regexpEscape( current ) );
		}

		if ( !tokenRe ) {
			return false;
		}

		// Get lexeme and consume it.
		value = value.replace( tokenRe, function( lexeme ) {
			token.lexeme = lexeme;
			if ( numeric ) {
				token.value = numberParser( lexeme );
			}
			return "";
		});

		if ( !token.lexeme ) {
			return false;
		}

		if ( numeric && isNaN( token.value ) ) {
			return false;
		}

		tokens.push( token );
		return true;
	});

	if ( value !== "" ) {
		valid = false;
	}

	return valid ? tokens : [];
};




var dateParserFn = function( numberParser, parseProperties, tokenizerProperties ) {
	return function dateParser( value ) {
		var tokens;

		validateParameterPresence( value, "value" );
		validateParameterTypeString( value, "value" );

		tokens = dateTokenizer( value, numberParser, tokenizerProperties );
		return dateParse( value, tokens, parseProperties ) || null;
	};
};




var objectFilter = function( object, testRe ) {
	var key,
		copy = {};

	for ( key in object ) {
		if ( testRe.test( key ) ) {
			copy[ key ] = object[ key ];
		}
	}

	return copy;
};




/**
 * tokenizerProperties( pattern, cldr )
 *
 * @pattern [String] raw pattern.
 *
 * @cldr [Cldr instance].
 *
 * Return Object with data that will be used by tokenizer.
 */
var dateTokenizerProperties = function( pattern, cldr, timeZone ) {
	var digitsReSource,
		properties = {
			pattern: looseMatching( pattern )
		},
		timeSeparator = numberSymbol( "timeSeparator", cldr ),
		widths = [ "abbreviated", "wide", "narrow" ];

	digitsReSource = numberNumberingSystemDigitsMap( cldr );
	digitsReSource = digitsReSource ? "[" + digitsReSource + "]" : "\\d";
	properties.digitsRe = new RegExp( digitsReSource );

	// Transform:
	// - "+H;-H" -> /\+(\d\d?)|-(\d\d?)/
	// - "+HH;-HH" -> /\+(\d\d)|-(\d\d)/
	// - "+HHmm;-HHmm" -> /\+(\d\d)(\d\d)|-(\d\d)(\d\d)/
	// - "+HH:mm;-HH:mm" -> /\+(\d\d):(\d\d)|-(\d\d):(\d\d)/
	//
	// If gmtFormat is GMT{0}, the regexp must fill {0} in each side, e.g.:
	// - "+H;-H" -> /GMT\+(\d\d?)|GMT-(\d\d?)/
	function hourFormatRe( hourFormat, gmtFormat, digitsReSource, timeSeparator ) {
		var re;

		if ( !digitsReSource ) {
			digitsReSource = "\\d";
		}
		if ( !gmtFormat ) {
			gmtFormat = "{0}";
		}

		re = hourFormat
			.replace( "+", "\\+" )

			// Unicode equivalent to (\\d\\d)
			.replace( /HH|mm|ss/g, "((" + digitsReSource + "){2})" )

			// Unicode equivalent to (\\d\\d?)
			.replace( /H|m/g, "((" + digitsReSource + "){1,2})" );

		if ( timeSeparator ) {
			re = re.replace( /:/g, timeSeparator );
		}

		re = re.split( ";" ).map(function( part ) {
			return gmtFormat.replace( "{0}", part );
		}).join( "|" );

		return new RegExp( "^" + re );
	}

	function populateProperties( path, value ) {

		// Skip
		var skipRe = /(timeZoneNames\/zone|supplemental\/metaZones|timeZoneNames\/metazone|timeZoneNames\/regionFormat|timeZoneNames\/gmtFormat)/;
		if ( skipRe.test( path ) ) {
			return;
		}

		if ( !value ) {
			return;
		}

		// The `dates` and `calendars` trim's purpose is to reduce properties' key size only.
		path = path.replace( /^.*\/dates\//, "" ).replace( /calendars\//, "" );

		// Specific filter for "gregorian/dayPeriods/format/wide".
		if ( path === "gregorian/dayPeriods/format/wide" ) {
			value = objectFilter( value, /^am|^pm/ );
		}

		// Transform object into array of pairs [key, /value/], sort by desc value length.
		if ( isPlainObject( value ) ) {
			value = Object.keys( value ).map(function( key ) {
				return [ key, new RegExp( "^" + regexpEscape( looseMatching( value[ key ] ) ) ) ];
			}).sort(function( a, b ) {
				return b[ 1 ].source.length - a[ 1 ].source.length;
			});

		// If typeof value === "string".
		} else {
			value = looseMatching( value );
		}
		properties[ path ] = value;
	}

	function regexpSourceSomeTerm( terms ) {
		return "(" + terms.filter(function( item ) {
			return item;
		}).reduce(function( memo, item ) {
			return memo + "|" + item;
		}) + ")";
	}

	cldr.on( "get", populateProperties );

	pattern.match( datePatternRe ).forEach(function( current ) {
		var aux, chr, daylightTzName, gmtFormat, length, standardTzName;

		chr = current.charAt( 0 );
		length = current.length;

		if ( chr === "Z" ) {
			if ( length < 5 ) {
				chr = "O";
				length = 4;
			} else {
				chr = "X";
				length = 5;
			}
		}

		// z...zzz: "{shortRegion}", eg. "PST" or "PDT".
		// zzzz: "{regionName} {Standard Time}" or "{regionName} {Daylight Time}",
		//       e.g., "Pacific Standard Time" or "Pacific Daylight Time".
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "z" ) {
			standardTzName = dateGetTimeZoneName( length, "standard", timeZone, cldr );
			daylightTzName = dateGetTimeZoneName( length, "daylight", timeZone, cldr );
			if ( standardTzName ) {
				standardTzName = regexpEscape( looseMatching( standardTzName ) );
			}
			if ( daylightTzName ) {
				daylightTzName = regexpEscape( looseMatching( daylightTzName ) );
			}
			if ( standardTzName || daylightTzName ) {
				properties.standardOrDaylightTzName = new RegExp(
					"^" + regexpSourceSomeTerm([ standardTzName, daylightTzName ])
				);
			}

			// Fall through the "O" format in case one name is missing.
			if ( !standardTzName || !daylightTzName ) {
				chr = "O";
				if ( length < 4 ) {
					length = 1;
				}
			}
		}

		// v...vvv: "{shortRegion}", eg. "PT".
		// vvvv: "{regionName} {Time}" or "{regionName} {Time}",
		// e.g., "Pacific Time"
		// http://unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns
		if ( chr === "v" ) {
			if ( length !== 1 && length !== 4 ) {
				throw createErrorUnsupportedFeature({
					feature: "timezone pattern `" + pattern + "`"
				});
			}
			var genericTzName = dateGetTimeZoneName( length, "generic", timeZone, cldr );
			if ( genericTzName ) {
				properties.genericTzName = new RegExp(
					"^" + regexpEscape( looseMatching( genericTzName ) )
				);
				chr = "O";

			// Fall back to "V" format.
			} else {
				chr = "V";
				length = 4;
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				cldr.main([
					"dates/calendars/gregorian/eras",
					length <= 3 ? "eraAbbr" : ( length === 4 ? "eraNames" : "eraNarrow" )
				]);
				break;

			// Year
			case "u": // Extended year. Need to be implemented.
			case "U": // Cyclic year name. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "year pattern `" + chr + "`"
				});

			// Quarter
			case "Q":
			case "q":
				if ( length > 2 ) {
					cldr.main([
						"dates/calendars/gregorian/quarters",
						chr === "Q" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				}
				break;

			// Month
			case "M":
			case "L":

				// number l=1:{1,2}, l=2:{2}.
				// lookup l=3...
				if ( length > 2 ) {
					cldr.main([
						"dates/calendars/gregorian/months",
						chr === "M" ? "format" : "stand-alone",
						widths[ length - 3 ]
					]);
				}
				break;

			// Day
			case "g":

				// Modified Julian day. Need to be implemented.
				throw createErrorUnsupportedFeature({
					feature: "Julian day pattern `g`"
				});

			// Week day
			case "e":
			case "c":

				// lookup for length >=3.
				if ( length <= 2 ) {
					break;
				}

			/* falls through */
			case "E":
				if ( length === 6 ) {

					// Note: if short day names are not explicitly specified, abbreviated day
					// names are used instead http://www.unicode.org/reports/tr35/tr35-dates.html#months_days_quarters_eras
					cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"short"
					]) || cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						"abbreviated"
					]);
				} else {
					cldr.main([
						"dates/calendars/gregorian/days",
						[ chr === "c" ? "stand-alone" : "format" ],
						widths[ length < 3 ? 0 : length - 3 ]
					]);
				}
				break;

			// Period (AM or PM)
			case "a":
				cldr.main(
					"dates/calendars/gregorian/dayPeriods/format/wide"
				);
				break;

			// Zone
			case "V":

				if ( length === 1 ) {
					throw createErrorUnsupportedFeature({
						feature: "timezone pattern `" + pattern + "`"
					});
				}

				if ( timeZone ) {
					if ( length === 2 ) {

						// Skip looseMatching processing since timeZone is a canonical posix value.
						properties.timeZoneName = timeZone;
						properties.timeZoneNameRe = new RegExp( "^" + regexpEscape( timeZone ) );
						break;
					}

					var timeZoneName,
						exemplarCity = cldr.main([
							"dates/timeZoneNames/zone", timeZone, "exemplarCity"
						]);

					if ( length === 3 ) {
						if ( !exemplarCity ) {
							exemplarCity = cldr.main([
								"dates/timeZoneNames/zone/Etc/Unknown/exemplarCity"
							]);
						}
						timeZoneName = exemplarCity;
					}

					if ( exemplarCity && length === 4 ) {
						timeZoneName = formatMessage(
							cldr.main(
								"dates/timeZoneNames/regionFormat"
							),
							[ exemplarCity ]
						);
					}

					if ( timeZoneName ) {
						timeZoneName = looseMatching( timeZoneName );
						properties.timeZoneName = timeZoneName;
						properties.timeZoneNameRe = new RegExp(
							"^" + regexpEscape( timeZoneName )
						);
					}
				}

				if ( current === "v" ) {
					length = 1;
				}

			/* falls through */
			case "z":
			case "O":
				gmtFormat = cldr.main( "dates/timeZoneNames/gmtFormat" );
				cldr.main( "dates/timeZoneNames/gmtZeroFormat" );
				cldr.main( "dates/timeZoneNames/hourFormat" );
				properties[ "timeZoneNames/gmtZeroFormatRe" ] =
					new RegExp( "^" + regexpEscape( properties[ "timeZoneNames/gmtZeroFormat" ] ) );
				aux = properties[ "timeZoneNames/hourFormat" ];
				properties[ "timeZoneNames/hourFormat" ] = (
					length < 4 ?
						[ dateTimezoneHourFormatHm( aux, "H" ), dateTimezoneHourFormatH( aux ) ] :
						[ dateTimezoneHourFormatHm( aux, "HH" ) ]
				).map(function( hourFormat ) {
					return hourFormatRe(
						hourFormat,
						gmtFormat,
						digitsReSource,
						timeSeparator
					);
				});

			/* falls through */
			case "X":
			case "x":

				// x: hourFormat("+HH[mm];-HH[mm]")
				// xx: hourFormat("+HHmm;-HHmm")
				// xxx: hourFormat("+HH:mm;-HH:mm")
				// xxxx: hourFormat("+HHmm[ss];-HHmm[ss]")
				// xxxxx: hourFormat("+HH:mm[:ss];-HH:mm[:ss]")
				properties.x = [
					[ "+HHmm;-HHmm", "+HH;-HH" ],
					[ "+HHmm;-HHmm" ],
					[ "+HH:mm;-HH:mm" ],
					[ "+HHmmss;-HHmmss", "+HHmm;-HHmm" ],
					[ "+HH:mm:ss;-HH:mm:ss", "+HH:mm;-HH:mm" ]
				][ length - 1 ].map(function( hourFormat ) {
					return hourFormatRe( hourFormat );
				});
		}
	});

	cldr.off( "get", populateProperties );

	return properties;
};




/**
 * dayOfWeek( date, firstDay )
 *
 * @date
 *
 * @firstDay the result of `dateFirstDayOfWeek( cldr )`
 *
 * Return the day of the week normalized by the territory's firstDay [0-6].
 * Eg for "mon":
 * - return 0 if territory is GB, or BR, or DE, or FR (week starts on "mon");
 * - return 1 if territory is US (week starts on "sun");
 * - return 2 if territory is EG (week starts on "sat");
 */
var dateDayOfWeek = function( date, firstDay ) {
	return ( date.getDay() - firstDay + 7 ) % 7;
};




/**
 * distanceInDays( from, to )
 *
 * Return the distance in days between from and to Dates.
 */
var dateDistanceInDays = function( from, to ) {
	var inDays = 864e5;
	return ( to.getTime() - from.getTime() ) / inDays;
};




/**
 * dayOfYear
 *
 * Return the distance in days of the date to the begin of the year [0-d].
 */
var dateDayOfYear = function( date ) {
	return Math.floor( dateDistanceInDays( dateStartOf( date, "year" ), date ) );
};




// Invert key and values, e.g., {"year": "yY"} ==> {"y": "year", "Y": "year"}
var dateFieldsMap = objectInvert({
	"era": "G",
	"year": "yY",
	"quarter": "qQ",
	"month": "ML",
	"week": "wW",
	"day": "dDF",
	"weekday": "ecE",
	"dayperiod": "a",
	"hour": "hHkK",
	"minute": "m",
	"second": "sSA",
	"zone": "zvVOxX"
}, function( object, key, value ) {
	value.split( "" ).forEach(function( symbol ) {
		object[ symbol ] = key;
	});
	return object;
});




/**
 * millisecondsInDay
 */
var dateMillisecondsInDay = function( date ) {

	// TODO Handle daylight savings discontinuities
	return date - dateStartOf( date, "day" );
};




/**
 * hourFormat( date, format, timeSeparator, formatNumber )
 *
 * Return date's timezone offset according to the format passed.
 * Eg for format when timezone offset is 180:
 * - "+H;-H": -3
 * - "+HHmm;-HHmm": -0300
 * - "+HH:mm;-HH:mm": -03:00
 * - "+HH:mm:ss;-HH:mm:ss": -03:00:00
 */
var dateTimezoneHourFormat = function( date, format, timeSeparator, formatNumber ) {
	var absOffset,
		offset = date.getTimezoneOffset();

	absOffset = Math.abs( offset );
	formatNumber = formatNumber || {
		1: function( value ) {
			return stringPad( value, 1 );
		},
		2: function( value ) {
			return stringPad( value, 2 );
		}
	};

	return format

		// Pick the correct sign side (+ or -).
		.split( ";" )[ offset > 0 ? 1 : 0 ]

		// Localize time separator
		.replace( ":", timeSeparator )

		// Update hours offset.
		.replace( /HH?/, function( match ) {
			return formatNumber[ match.length ]( Math.floor( absOffset / 60 ) );
		})

		// Update minutes offset and return.
		.replace( /mm/, function() {
			return formatNumber[ 2 ]( Math.floor( absOffset % 60 ) );
		})

		// Update minutes offset and return.
		.replace( /ss/, function() {
			return formatNumber[ 2 ]( Math.floor( absOffset % 1 * 60 ) );
		});
};




/**
 * format( date, properties )
 *
 * @date [Date instance].
 *
 * @properties
 *
 * TODO Support other calendar types.
 *
 * Disclosure: this function borrows excerpts of dojo/date/locale.
 */
var dateFormat = function( date, numberFormatters, properties ) {
	var parts = [];

	var timeSeparator = properties.timeSeparator;

	// create globalize date with given timezone data
	if ( properties.timeZoneData ) {
		date = new ZonedDateTime( date, properties.timeZoneData() );
	}

	properties.pattern.replace( datePatternRe, function( current ) {
		var aux, dateField, type, value,
			chr = current.charAt( 0 ),
			length = current.length;

		if ( chr === "j" ) {

			// Locale preferred hHKk.
			// http://www.unicode.org/reports/tr35/tr35-dates.html#Time_Data
			chr = properties.preferredTime;
		}

		if ( chr === "Z" ) {

			// Z..ZZZ: same as "xxxx".
			if ( length < 4 ) {
				chr = "x";
				length = 4;

			// ZZZZ: same as "OOOO".
			} else if ( length < 5 ) {
				chr = "O";
				length = 4;

			// ZZZZZ: same as "XXXXX"
			} else {
				chr = "X";
				length = 5;
			}
		}

		// z...zzz: "{shortRegion}", e.g., "PST" or "PDT".
		// zzzz: "{regionName} {Standard Time}" or "{regionName} {Daylight Time}",
		//       e.g., "Pacific Standard Time" or "Pacific Daylight Time".
		if ( chr === "z" ) {
			if ( date.isDST ) {
				value = date.isDST() ? properties.daylightTzName : properties.standardTzName;
			}

			// Fall back to "O" format.
			if ( !value ) {
				chr = "O";
				if ( length < 4 ) {
					length = 1;
				}
			}
		}

		switch ( chr ) {

			// Era
			case "G":
				value = properties.eras[ date.getFullYear() < 0 ? 0 : 1 ];
				break;

			// Year
			case "y":

				// Plain year.
				// The length specifies the padding, but for two letters it also specifies the
				// maximum length.
				value = date.getFullYear();
				if ( length === 2 ) {
					value = String( value );
					value = +value.substr( value.length - 2 );
				}
				break;

			case "Y":

				// Year in "Week of Year"
				// The length specifies the padding, but for two letters it also specifies the
				// maximum length.
				// yearInWeekofYear = date + DaysInAWeek - (dayOfWeek - firstDay) - minDays
				value = new Date( date.getTime() );
				value.setDate(
					value.getDate() + 7 -
					dateDayOfWeek( date, properties.firstDay ) -
					properties.firstDay -
					properties.minDays
				);
				value = value.getFullYear();
				if ( length === 2 ) {
					value = String( value );
					value = +value.substr( value.length - 2 );
				}
				break;

			// Quarter
			case "Q":
			case "q":
				value = Math.ceil( ( date.getMonth() + 1 ) / 3 );
				if ( length > 2 ) {
					value = properties.quarters[ chr ][ length ][ value ];
				}
				break;

			// Month
			case "M":
			case "L":
				value = date.getMonth() + 1;
				if ( length > 2 ) {
					value = properties.months[ chr ][ length ][ value ];
				}
				break;

			// Week
			case "w":

				// Week of Year.
				// woy = ceil( ( doy + dow of 1/1 ) / 7 ) - minDaysStuff ? 1 : 0.
				// TODO should pad on ww? Not documented, but I guess so.
				value = dateDayOfWeek( dateStartOf( date, "year" ), properties.firstDay );
				value = Math.ceil( ( dateDayOfYear( date ) + value ) / 7 ) -
					( 7 - value >= properties.minDays ? 0 : 1 );
				break;

			case "W":

				// Week of Month.
				// wom = ceil( ( dom + dow of `1/month` ) / 7 ) - minDaysStuff ? 1 : 0.
				value = dateDayOfWeek( dateStartOf( date, "month" ), properties.firstDay );
				value = Math.ceil( ( date.getDate() + value ) / 7 ) -
					( 7 - value >= properties.minDays ? 0 : 1 );
				break;

			// Day
			case "d":
				value = date.getDate();
				break;

			case "D":
				value = dateDayOfYear( date ) + 1;
				break;

			case "F":

				// Day of Week in month. eg. 2nd Wed in July.
				value = Math.floor( date.getDate() / 7 ) + 1;
				break;

			// Week day
			case "e":
			case "c":
				if ( length <= 2 ) {

					// Range is [1-7] (deduced by example provided on documentation)
					// TODO Should pad with zeros (not specified in the docs)?
					value = dateDayOfWeek( date, properties.firstDay ) + 1;
					break;
				}

			/* falls through */
			case "E":
				value = dateWeekDays[ date.getDay() ];
				value = properties.days[ chr ][ length ][ value ];
				break;

			// Period (AM or PM)
			case "a":
				value = properties.dayPeriods[ date.getHours() < 12 ? "am" : "pm" ];
				break;

			// Hour
			case "h": // 1-12
				value = ( date.getHours() % 12 ) || 12;
				break;

			case "H": // 0-23
				value = date.getHours();
				break;

			case "K": // 0-11
				value = date.getHours() % 12;
				break;

			case "k": // 1-24
				value = date.getHours() || 24;
				break;

			// Minute
			case "m":
				value = date.getMinutes();
				break;

			// Second
			case "s":
				value = date.getSeconds();
				break;

			case "S":
				value = Math.round( date.getMilliseconds() * Math.pow( 10, length - 3 ) );
				break;

			case "A":
				value = Math.round( dateMillisecondsInDay( date ) * Math.pow( 10, length - 3 ) );
				break;

			// Zone
			case "z":
				break;

			case "v":

				// v...vvv: "{shortRegion}", eg. "PT".
				// vvvv: "{regionName} {Time}",
				//       e.g., "Pacific Time".
				if ( properties.genericTzName ) {
					value = properties.genericTzName;
					break;
				}

			/* falls through */
			case "V":

				//VVVV: "{explarCity} {Time}", e.g., "Los Angeles Time"
				if ( properties.timeZoneName ) {
					value = properties.timeZoneName;
					break;
				}

				if ( current === "v" ) {
					length = 1;
				}

			/* falls through */
			case "O":

				// O: "{gmtFormat}+H;{gmtFormat}-H" or "{gmtZeroFormat}", eg. "GMT-8" or "GMT".
				// OOOO: "{gmtFormat}{hourFormat}" or "{gmtZeroFormat}", eg. "GMT-08:00" or "GMT".
				if ( date.getTimezoneOffset() === 0 ) {
					value = properties.gmtZeroFormat;
				} else {

					// If O..OOO and timezone offset has non-zero minutes, show minutes.
					if ( length < 4 ) {
						aux = date.getTimezoneOffset();
						aux = properties.hourFormat[ aux % 60 - aux % 1 === 0 ? 0 : 1 ];
					} else {
						aux = properties.hourFormat;
					}

					value = dateTimezoneHourFormat(
						date,
						aux,
						timeSeparator,
						numberFormatters
					);
					value = properties.gmtFormat.replace( /\{0\}/, value );
				}
				break;

			case "X":

				// Same as x*, except it uses "Z" for zero offset.
				if ( date.getTimezoneOffset() === 0 ) {
					value = "Z";
					break;
				}

			/* falls through */
			case "x":

				// x: hourFormat("+HH[mm];-HH[mm]")
				// xx: hourFormat("+HHmm;-HHmm")
				// xxx: hourFormat("+HH:mm;-HH:mm")
				// xxxx: hourFormat("+HHmm[ss];-HHmm[ss]")
				// xxxxx: hourFormat("+HH:mm[:ss];-HH:mm[:ss]")
				aux = date.getTimezoneOffset();

				// If x and timezone offset has non-zero minutes, use xx (i.e., show minutes).
				if ( length === 1 && aux % 60 - aux % 1 !== 0 ) {
					length += 1;
				}

				// If (xxxx or xxxxx) and timezone offset has zero seconds, use xx or xxx
				// respectively (i.e., don't show optional seconds).
				if ( ( length === 4 || length === 5 ) && aux % 1 === 0 ) {
					length -= 2;
				}

				value = [
					"+HH;-HH",
					"+HHmm;-HHmm",
					"+HH:mm;-HH:mm",
					"+HHmmss;-HHmmss",
					"+HH:mm:ss;-HH:mm:ss"
				][ length - 1 ];

				value = dateTimezoneHourFormat( date, value, ":" );
				break;

			// timeSeparator
			case ":":
				value = timeSeparator;
				break;

			// ' literals.
			case "'":
				value = removeLiteralQuotes( current );
				break;

			// Anything else is considered a literal, including [ ,:/.@#], chinese, japonese, and
			// arabic characters.
			default:
				value = current;

		}
		if ( typeof value === "number" ) {
			value = numberFormatters[ length ]( value );
		}

		dateField = dateFieldsMap[ chr ];
		type = dateField ? dateField : "literal";

		// Concat two consecutive literals
		if ( type === "literal" && parts.length && parts[ parts.length - 1 ].type === "literal" ) {
			parts[ parts.length - 1 ].value += value;
			return;
		}

		parts.push( { type: type, value: value } );

	});

	return parts;

};




var dateToPartsFormatterFn = function( numberFormatters, properties ) {
	return function dateToPartsFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeDate( value, "value" );

		return dateFormat( value, numberFormatters, properties );
	};

};




function optionsHasStyle( options ) {
	return options.skeleton !== undefined ||
		options.date !== undefined ||
		options.time !== undefined ||
		options.datetime !== undefined ||
		options.raw !== undefined;
}

function validateRequiredCldr( path, value ) {
	validateCldr( path, value, {
		skip: [
			/dates\/calendars\/gregorian\/dateTimeFormats\/availableFormats/,
			/dates\/calendars\/gregorian\/days\/.*\/short/,
			/dates\/timeZoneNames\/zone/,
			/dates\/timeZoneNames\/metazone/,
			/globalize-iana/,
			/supplemental\/metaZones/,
			/supplemental\/timeData\/(?!001)/,
			/supplemental\/weekData\/(?!001)/
		]
	});
}

function validateOptionsPreset( options ) {
	validateOptionsPresetEach( "date", options );
	validateOptionsPresetEach( "time", options );
	validateOptionsPresetEach( "datetime", options );
}

function validateOptionsPresetEach( type, options ) {
	var value = options[ type ];
	validate(
		"E_INVALID_OPTIONS",
		"Invalid `{{type}: \"{value}\"}`.",
		value === undefined || [ "short", "medium", "long", "full" ].indexOf( value ) !== -1,
		{ type: type, value: value }
	);
}

function validateOptionsSkeleton( pattern, skeleton ) {
	validate(
		"E_INVALID_OPTIONS",
		"Invalid `{skeleton: \"{value}\"}` based on provided CLDR.",
		skeleton === undefined || ( typeof pattern === "string" && pattern ),
		{ type: "skeleton", value: skeleton }
	);
}

function validateRequiredIana( timeZone ) {
	return function( path, value ) {

		if ( !/globalize-iana/.test( path ) ) {
			return;
		}

		validate(
			"E_MISSING_IANA_TZ",
			"Missing required IANA timezone content for `{timeZone}`: `{path}`.",
			value,
			{
				path: path.replace( /globalize-iana\//, "" ),
				timeZone: timeZone
			}
		);
	};
}

/**
 * .loadTimeZone( json )
 *
 * @json [JSON]
 *
 * Load IANA timezone data.
 */
Globalize.loadTimeZone = function( json ) {
	var customData = {
			"globalize-iana": json
		};

	validateParameterPresence( json, "json" );
	validateParameterTypePlainObject( json, "json" );

	Cldr.load( customData );
};

/**
 * .dateFormatter( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a date formatter function (of the form below) according to the given options and the
 * default/instance locale.
 *
 * fn( value )
 *
 * @value [Date]
 *
 * Return a function that formats a date according to the given `format` and the default/instance
 * locale.
 */
Globalize.dateFormatter =
Globalize.prototype.dateFormatter = function( options ) {
	var args, dateToPartsFormatter, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	if ( !optionsHasStyle( options ) ) {
		options.skeleton = "yMd";
	}
	args = [ options ];

	dateToPartsFormatter = this.dateToPartsFormatter( options );
	returnFn = dateFormatterFn( dateToPartsFormatter );
	runtimeBind( args, this.cldr, returnFn, [ dateToPartsFormatter ] );

	return returnFn;
};

/**
 * .dateToPartsFormatter( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a date formatter function (of the form below) according to the given options and the
 * default/instance locale.
 *
 * fn( value )
 *
 * @value [Date]
 *
 * Return a function that formats a date to parts according to the given `format`
 * and the default/instance
 * locale.
 */
Globalize.dateToPartsFormatter =
Globalize.prototype.dateToPartsFormatter = function( options ) {
	var args, cldr, numberFormatters, pad, pattern, properties, returnFn,
		timeZone;

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};
	if ( !optionsHasStyle( options ) ) {
		options.skeleton = "yMd";
	}

	validateOptionsPreset( options );
	validateDefaultLocale( cldr );

	timeZone = options.timeZone;
	validateParameterTypeString( timeZone, "options.timeZone" );

	args = [ options ];

	cldr.on( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.on( "get", validateRequiredIana( timeZone ) );
	}
	pattern = dateExpandPattern( options, cldr );
	validateOptionsSkeleton( pattern, options.skeleton );
	properties = dateFormatProperties( pattern, cldr, timeZone );
	cldr.off( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.off( "get", validateRequiredIana( timeZone ) );
	}

	// Create needed number formatters.
	numberFormatters = properties.numberFormatters;
	delete properties.numberFormatters;
	for ( pad in numberFormatters ) {
		numberFormatters[ pad ] = this.numberFormatter({
			raw: numberFormatters[ pad ]
		});
	}

	returnFn = dateToPartsFormatterFn( numberFormatters, properties );

	runtimeBind( args, cldr, returnFn, [ numberFormatters, properties ] );

	return returnFn;
};

/**
 * .dateParser( options )
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a function that parses a string date according to the given `formats` and the
 * default/instance locale.
 */
Globalize.dateParser =
Globalize.prototype.dateParser = function( options ) {
	var args, cldr, numberParser, parseProperties, pattern, returnFn, timeZone,
		tokenizerProperties;

	validateParameterTypePlainObject( options, "options" );

	cldr = this.cldr;
	options = options || {};
	if ( !optionsHasStyle( options ) ) {
		options.skeleton = "yMd";
	}

	validateOptionsPreset( options );
	validateDefaultLocale( cldr );

	timeZone = options.timeZone;
	validateParameterTypeString( timeZone, "options.timeZone" );

	args = [ options ];

	cldr.on( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.on( "get", validateRequiredIana( timeZone ) );
	}
	pattern = dateExpandPattern( options, cldr );
	validateOptionsSkeleton( pattern, options.skeleton );
	tokenizerProperties = dateTokenizerProperties( pattern, cldr, timeZone );
	parseProperties = dateParseProperties( cldr, timeZone );
	cldr.off( "get", validateRequiredCldr );
	if ( timeZone ) {
		cldr.off( "get", validateRequiredIana( timeZone ) );
	}

	numberParser = this.numberParser({ raw: "0" });

	returnFn = dateParserFn( numberParser, parseProperties, tokenizerProperties );

	runtimeBind( args, cldr, returnFn, [ numberParser, parseProperties, tokenizerProperties ] );

	return returnFn;
};

/**
 * .formatDate( value, options )
 *
 * @value [Date]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Formats a date or number according to the given options string and the default/instance locale.
 */
Globalize.formatDate =
Globalize.prototype.formatDate = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeDate( value, "value" );

	return this.dateFormatter( options )( value );
};

/**
 * .formatDateToParts( value, options )
 *
 * @value [Date]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Formats a date or number to parts according to the given options and the default/instance locale.
 */
Globalize.formatDateToParts =
Globalize.prototype.formatDateToParts = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeDate( value, "value" );

	return this.dateToPartsFormatter( options )( value );
};

/**
 * .parseDate( value, options )
 *
 * @value [String]
 *
 * @options [Object] see date/expand_pattern for more info.
 *
 * Return a Date instance or null.
 */
Globalize.parseDate =
Globalize.prototype.parseDate = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeString( value, "value" );

	return this.dateParser( options )( value );
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/message.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var alwaysArray = Globalize._alwaysArray,
	createError = Globalize._createError,
	isPlainObject = Globalize._isPlainObject,
	runtimeBind = Globalize._runtimeBind,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validate = Globalize._validate,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;
var MessageFormat;
/* jshint ignore:start */
MessageFormat = (function() {
MessageFormat._parse = (function() {

  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = [],
        peg$c1 = function(st) {
              return { type: 'messageFormatPattern', statements: st };
            },
        peg$c2 = peg$FAILED,
        peg$c3 = "{",
        peg$c4 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c5 = null,
        peg$c6 = ",",
        peg$c7 = { type: "literal", value: ",", description: "\",\"" },
        peg$c8 = "}",
        peg$c9 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c10 = function(argIdx, efmt) {
              var res = {
                type: "messageFormatElement",
                argumentIndex: argIdx
              };
              if (efmt && efmt.length) {
                res.elementFormat = efmt[1];
              } else {
                res.output = true;
              }
              return res;
            },
        peg$c11 = "plural",
        peg$c12 = { type: "literal", value: "plural", description: "\"plural\"" },
        peg$c13 = function(t, s) {
              return { type: "elementFormat", key: t, val: s };
            },
        peg$c14 = "selectordinal",
        peg$c15 = { type: "literal", value: "selectordinal", description: "\"selectordinal\"" },
        peg$c16 = "select",
        peg$c17 = { type: "literal", value: "select", description: "\"select\"" },
        peg$c18 = function(t, p) {
              return { type: "elementFormat", key: t, val: p };
            },
        peg$c19 = function(op, pf) {
              return { type: "pluralFormatPattern", pluralForms: pf, offset: op || 0 };
            },
        peg$c20 = "offset",
        peg$c21 = { type: "literal", value: "offset", description: "\"offset\"" },
        peg$c22 = ":",
        peg$c23 = { type: "literal", value: ":", description: "\":\"" },
        peg$c24 = function(d) { return d; },
        peg$c25 = function(k, mfp) {
              return { key: k, val: mfp };
            },
        peg$c26 = function(i) { return i; },
        peg$c27 = "=",
        peg$c28 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c29 = function(pf) { return { type: "selectFormatPattern", pluralForms: pf }; },
        peg$c30 = function(p) { return p; },
        peg$c31 = "#",
        peg$c32 = { type: "literal", value: "#", description: "\"#\"" },
        peg$c33 = function() { return {type: 'octothorpe'}; },
        peg$c34 = function(s) { return { type: "string", val: s.join('') }; },
        peg$c35 = { type: "other", description: "identifier" },
        peg$c36 = /^[0-9a-zA-Z$_]/,
        peg$c37 = { type: "class", value: "[0-9a-zA-Z$_]", description: "[0-9a-zA-Z$_]" },
        peg$c38 = /^[^ \t\n\r,.+={}]/,
        peg$c39 = { type: "class", value: "[^ \\t\\n\\r,.+={}]", description: "[^ \\t\\n\\r,.+={}]" },
        peg$c40 = function(s) { return s; },
        peg$c41 = function(chars) { return chars.join(''); },
        peg$c42 = /^[^{}#\\\0-\x1F \t\n\r]/,
        peg$c43 = { type: "class", value: "[^{}#\\\\\\0-\\x1F \\t\\n\\r]", description: "[^{}#\\\\\\0-\\x1F \\t\\n\\r]" },
        peg$c44 = function(x) { return x; },
        peg$c45 = "\\\\",
        peg$c46 = { type: "literal", value: "\\\\", description: "\"\\\\\\\\\"" },
        peg$c47 = function() { return "\\"; },
        peg$c48 = "\\#",
        peg$c49 = { type: "literal", value: "\\#", description: "\"\\\\#\"" },
        peg$c50 = function() { return "#"; },
        peg$c51 = "\\{",
        peg$c52 = { type: "literal", value: "\\{", description: "\"\\\\{\"" },
        peg$c53 = function() { return "\u007B"; },
        peg$c54 = "\\}",
        peg$c55 = { type: "literal", value: "\\}", description: "\"\\\\}\"" },
        peg$c56 = function() { return "\u007D"; },
        peg$c57 = "\\u",
        peg$c58 = { type: "literal", value: "\\u", description: "\"\\\\u\"" },
        peg$c59 = function(h1, h2, h3, h4) {
              return String.fromCharCode(parseInt("0x" + h1 + h2 + h3 + h4));
            },
        peg$c60 = /^[0-9]/,
        peg$c61 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c62 = function(ds) {
            //the number might start with 0 but must not be interpreted as an octal number
            //Hence, the base is passed to parseInt explicitely
            return parseInt((ds.join('')), 10);
          },
        peg$c63 = /^[0-9a-fA-F]/,
        peg$c64 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
        peg$c65 = { type: "other", description: "whitespace" },
        peg$c66 = function(w) { return w.join(''); },
        peg$c67 = /^[ \t\n\r]/,
        peg$c68 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsestart() {
      var s0;

      s0 = peg$parsemessageFormatPattern();

      return s0;
    }

    function peg$parsemessageFormatPattern() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsemessageFormatElement();
      if (s2 === peg$FAILED) {
        s2 = peg$parsestring();
        if (s2 === peg$FAILED) {
          s2 = peg$parseoctothorpe();
        }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsemessageFormatElement();
        if (s2 === peg$FAILED) {
          s2 = peg$parsestring();
          if (s2 === peg$FAILED) {
            s2 = peg$parseoctothorpe();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsemessageFormatElement() {
      var s0, s1, s2, s3, s4, s5, s6;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c3;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c4); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse_();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseid();
          if (s3 !== peg$FAILED) {
            s4 = peg$currPos;
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c6;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parseelementFormat();
              if (s6 !== peg$FAILED) {
                s5 = [s5, s6];
                s4 = s5;
              } else {
                peg$currPos = s4;
                s4 = peg$c2;
              }
            } else {
              peg$currPos = s4;
              s4 = peg$c2;
            }
            if (s4 === peg$FAILED) {
              s4 = peg$c5;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s6 = peg$c8;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c9); }
                }
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c10(s3, s4);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseelementFormat() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c11) {
          s2 = peg$c11;
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s4 = peg$c6;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c7); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsepluralFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c13(s2, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parse_();
        if (s1 !== peg$FAILED) {
          if (input.substr(peg$currPos, 13) === peg$c14) {
            s2 = peg$c14;
            peg$currPos += 13;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c15); }
          }
          if (s2 !== peg$FAILED) {
            s3 = peg$parse_();
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 44) {
                s4 = peg$c6;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c7); }
              }
              if (s4 !== peg$FAILED) {
                s5 = peg$parse_();
                if (s5 !== peg$FAILED) {
                  s6 = peg$parsepluralFormatPattern();
                  if (s6 !== peg$FAILED) {
                    s7 = peg$parse_();
                    if (s7 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c13(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parse_();
          if (s1 !== peg$FAILED) {
            if (input.substr(peg$currPos, 6) === peg$c16) {
              s2 = peg$c16;
              peg$currPos += 6;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c17); }
            }
            if (s2 !== peg$FAILED) {
              s3 = peg$parse_();
              if (s3 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 44) {
                  s4 = peg$c6;
                  peg$currPos++;
                } else {
                  s4 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c7); }
                }
                if (s4 !== peg$FAILED) {
                  s5 = peg$parse_();
                  if (s5 !== peg$FAILED) {
                    s6 = peg$parseselectFormatPattern();
                    if (s6 !== peg$FAILED) {
                      s7 = peg$parse_();
                      if (s7 !== peg$FAILED) {
                        peg$reportedPos = s0;
                        s1 = peg$c13(s2, s6);
                        s0 = s1;
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parse_();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseid();
              if (s2 !== peg$FAILED) {
                s3 = [];
                s4 = peg$parseargStylePattern();
                while (s4 !== peg$FAILED) {
                  s3.push(s4);
                  s4 = peg$parseargStylePattern();
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c18(s2, s3);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          }
        }
      }

      return s0;
    }

    function peg$parsepluralFormatPattern() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseoffsetPattern();
      if (s1 === peg$FAILED) {
        s1 = peg$c5;
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsepluralForm();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parsepluralForm();
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c19(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseoffsetPattern() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 6) === peg$c20) {
          s2 = peg$c20;
          peg$currPos += 6;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c21); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c22;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsedigits();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c24(s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsepluralForm() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsepluralKey();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c4); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemessageFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c25(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsepluralKey() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseid();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c26(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.charCodeAt(peg$currPos) === 61) {
          s1 = peg$c27;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c28); }
        }
        if (s1 !== peg$FAILED) {
          s2 = peg$parsedigits();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c24(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parseselectFormatPattern() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseselectForm();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parseselectForm();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c29(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseselectForm() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseid();
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 123) {
              s4 = peg$c3;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c4); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemessageFormatPattern();
                if (s6 !== peg$FAILED) {
                  s7 = peg$parse_();
                  if (s7 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 125) {
                      s8 = peg$c8;
                      peg$currPos++;
                    } else {
                      s8 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c9); }
                    }
                    if (s8 !== peg$FAILED) {
                      peg$reportedPos = s0;
                      s1 = peg$c25(s2, s6);
                      s0 = s1;
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseargStylePattern() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseid();
            if (s4 !== peg$FAILED) {
              s5 = peg$parse_();
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c30(s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseoctothorpe() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c31;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c32); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c33();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechars();
      if (s2 === peg$FAILED) {
        s2 = peg$parsewhitespace();
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechars();
          if (s2 === peg$FAILED) {
            s2 = peg$parsewhitespace();
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c34(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseid() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parse_();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        if (peg$c36.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        if (s4 !== peg$FAILED) {
          s5 = [];
          if (peg$c38.test(input.charAt(peg$currPos))) {
            s6 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s6 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c39); }
          }
          while (s6 !== peg$FAILED) {
            s5.push(s6);
            if (peg$c38.test(input.charAt(peg$currPos))) {
              s6 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s6 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c39); }
            }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c2;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c2;
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          s3 = peg$parse_();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c40(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c35); }
      }

      return s0;
    }

    function peg$parsechars() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechar();
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parsechar();
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c41(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsechar() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (peg$c42.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c44(s1);
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c45) {
          s1 = peg$c45;
          peg$currPos += 2;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c46); }
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c47();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c48) {
            s1 = peg$c48;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c49); }
          }
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c50();
          }
          s0 = s1;
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            if (input.substr(peg$currPos, 2) === peg$c51) {
              s1 = peg$c51;
              peg$currPos += 2;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c52); }
            }
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c53();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              if (input.substr(peg$currPos, 2) === peg$c54) {
                s1 = peg$c54;
                peg$currPos += 2;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c55); }
              }
              if (s1 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c56();
              }
              s0 = s1;
              if (s0 === peg$FAILED) {
                s0 = peg$currPos;
                if (input.substr(peg$currPos, 2) === peg$c57) {
                  s1 = peg$c57;
                  peg$currPos += 2;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c58); }
                }
                if (s1 !== peg$FAILED) {
                  s2 = peg$parsehexDigit();
                  if (s2 !== peg$FAILED) {
                    s3 = peg$parsehexDigit();
                    if (s3 !== peg$FAILED) {
                      s4 = peg$parsehexDigit();
                      if (s4 !== peg$FAILED) {
                        s5 = peg$parsehexDigit();
                        if (s5 !== peg$FAILED) {
                          peg$reportedPos = s0;
                          s1 = peg$c59(s2, s3, s4, s5);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$c2;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$c2;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$c2;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c2;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c2;
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsedigits() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c60.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c60.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c61); }
          }
        }
      } else {
        s1 = peg$c2;
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c62(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsehexDigit() {
      var s0;

      if (peg$c63.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c64); }
      }

      return s0;
    }

    function peg$parse_() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsewhitespace();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsewhitespace();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c66(s1);
      }
      s0 = s1;
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c65); }
      }

      return s0;
    }

    function peg$parsewhitespace() {
      var s0;

      if (peg$c67.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c68); }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
}()).parse;


/** @file messageformat.js - ICU PluralFormat + SelectFormat for JavaScript
 *  @author Alex Sexton - @SlexAxton
 *  @version 0.3.0-1
 *  @copyright 2012-2015 Alex Sexton, Eemeli Aro, and Contributors
 *  @license To use or fork, MIT. To contribute back, Dojo CLA  */


/** Utility function for quoting an Object's key value iff required
 *  @private  */
function propname(key, obj) {
  if (/^[A-Z_$][0-9A-Z_$]*$/i.test(key)) {
    return obj ? obj + '.' + key : key;
  } else {
    var jkey = JSON.stringify(key);
    return obj ? obj + '[' + jkey + ']' : jkey;
  }
};


/** Create a new message formatter
 *
 *  @class
 *  @global
 *  @param {string|string[]} [locale="en"] - The locale to use, with fallbacks
 *  @param {function} [pluralFunc] - Optional custom pluralization function
 *  @param {function[]} [formatters] - Optional custom formatting functions  */
function MessageFormat(locale, pluralFunc, formatters) {
  this.lc = [locale];  
  this.runtime.pluralFuncs = {};
  this.runtime.pluralFuncs[this.lc[0]] = pluralFunc;
  this.runtime.fmt = {};
  if (formatters) for (var f in formatters) {
    this.runtime.fmt[f] = formatters[f];
  }
}




/** Parse an input string to its AST
 *
 *  Precompiled from `lib/messageformat-parser.pegjs` by
 *  {@link http://pegjs.org/ PEG.js}. Included in MessageFormat object
 *  to enable testing.
 *
 *  @private  */



/** Pluralization functions from
 *  {@link http://github.com/eemeli/make-plural.js make-plural}
 *
 *  @memberof MessageFormat
 *  @type Object.<string,function>  */
MessageFormat.plurals = {};


/** Default number formatting functions in the style of ICU's
 *  {@link http://icu-project.org/apiref/icu4j/com/ibm/icu/text/MessageFormat.html simpleArg syntax}
 *  implemented using the
 *  {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl Intl}
 *  object defined by ECMA-402.
 *
 *  **Note**: Intl is not defined in default Node until 0.11.15 / 0.12.0, so
 *  earlier versions require a {@link https://www.npmjs.com/package/intl polyfill}.
 *  Therefore {@link MessageFormat.withIntlSupport} needs to be true for these
 *  functions to be available for inclusion in the output.
 *
 *  @see MessageFormat#setIntlSupport
 *
 *  @namespace
 *  @memberof MessageFormat
 *  @property {function} number - Represent a number as an integer, percent or currency value
 *  @property {function} date - Represent a date as a full/long/default/short string
 *  @property {function} time - Represent a time as a full/long/default/short string
 *
 *  @example
 *  > var MessageFormat = require('messageformat');
 *  > var mf = (new MessageFormat('en')).setIntlSupport(true);
 *  > mf.currency = 'EUR';
 *  > var mfunc = mf.compile("The total is {V,number,currency}.");
 *  > mfunc({V:5.5})
 *  "The total is €5.50."
 *
 *  @example
 *  > var MessageFormat = require('messageformat');
 *  > var mf = new MessageFormat('en', null, {number: MessageFormat.number});
 *  > mf.currency = 'EUR';
 *  > var mfunc = mf.compile("The total is {V,number,currency}.");
 *  > mfunc({V:5.5})
 *  "The total is €5.50."  */
MessageFormat.formatters = {};

/** Enable or disable support for the default formatters, which require the
 *  `Intl` object. Note that this can't be autodetected, as the environment
 *  in which the formatted text is compiled into Javascript functions is not
 *  necessarily the same environment in which they will get executed.
 *
 *  @see MessageFormat.formatters
 *
 *  @memberof MessageFormat
 *  @param {boolean} [enable=true]
 *  @returns {Object} The MessageFormat instance, to allow for chaining
 *  @example
 *  > var Intl = require('intl');
 *  > var MessageFormat = require('messageformat');
 *  > var mf = (new MessageFormat('en')).setIntlSupport(true);
 *  > mf.currency = 'EUR';
 *  > mf.compile("The total is {V,number,currency}.")({V:5.5});
 *  "The total is €5.50."  */



/** A set of utility functions that are called by the compiled Javascript
 *  functions, these are included locally in the output of {@link
 *  MessageFormat#compile compile()}.
 *
 *  @namespace
 *  @memberof MessageFormat  */
MessageFormat.prototype.runtime = {

  /** Utility function for `#` in plural rules
   *
   *  @param {number} value - The value to operate on
   *  @param {number} [offset=0] - An optional offset, set by the surrounding context  */
  number: function(value, offset) {
    if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
    return value - (offset || 0);
  },

  /** Utility function for `{N, plural|selectordinal, ...}`
   *
   *  @param {number} value - The key to use to find a pluralization rule
   *  @param {number} offset - An offset to apply to `value`
   *  @param {function} lcfunc - A locale function from `pluralFuncs`
   *  @param {Object.<string,string>} data - The object from which results are looked up
   *  @param {?boolean} isOrdinal - If true, use ordinal rather than cardinal rules
   *  @returns {string} The result of the pluralization  */
  plural: function(value, offset, lcfunc, data, isOrdinal) {
    if ({}.hasOwnProperty.call(data, value)) return data[value]();
    if (offset) value -= offset;
    var key = lcfunc(value, isOrdinal);
    if (key in data) return data[key]();
    return data.other();
  },

  /** Utility function for `{N, select, ...}`
   *
   *  @param {number} value - The key to use to find a selection
   *  @param {Object.<string,string>} data - The object from which results are looked up
   *  @returns {string} The result of the select statement  */
  select: function(value, data) {
    if ({}.hasOwnProperty.call(data, value)) return data[value]();
    return data.other()
  },

  /** Pluralization functions included in compiled output
   *  @instance
   *  @type Object.<string,function>  */
  pluralFuncs: {},

  /** Custom formatting functions called by `{var, fn[, args]*}` syntax
   *
   *  For examples, see {@link MessageFormat.formatters}
   *
   *  @instance
   *  @see MessageFormat.formatters
   *  @type Object.<string,function>  */
  fmt: {},

  /** Custom stringifier to clean up browser inconsistencies
   *  @instance  */
  toString: function () {
    var _stringify = function(o, level) {
      if (typeof o != 'object') {
        var funcStr = o.toString().replace(/^(function )\w*/, '$1');
        var indent = /([ \t]*)\S.*$/.exec(funcStr);
        return indent ? funcStr.replace(new RegExp('^' + indent[1], 'mg'), '') : funcStr;
      }
      var s = [];
      for (var i in o) if (i != 'toString') {
        if (level == 0) s.push('var ' + i + ' = ' + _stringify(o[i], level + 1) + ';\n');
        else s.push(propname(i) + ': ' + _stringify(o[i], level + 1));
      }
      if (level == 0) return s.join('');
      if (s.length == 0) return '{}';
      var indent = '  '; while (--level) indent += '  ';
      return '{\n' + s.join(',\n').replace(/^/gm, indent) + '\n}';
    };
    return _stringify(this, 0);
  }
};


/** Recursively map an AST to its resulting string
 *
 *  @memberof MessageFormat
 *
 *  @param ast - the Ast node for which the JS code should be generated
 *
 *  @private  */
MessageFormat.prototype._precompile = function(ast, data) {
  data = data || { keys: {}, offset: {} };
  var r = [], i, tmp, args = [];

  switch ( ast.type ) {
    case 'messageFormatPattern':
      for ( i = 0; i < ast.statements.length; ++i ) {
        r.push(this._precompile( ast.statements[i], data ));
      }
      tmp = r.join(' + ') || '""';
      return data.pf_count ? tmp : 'function(d) { return ' + tmp + '; }';

    case 'messageFormatElement':
      data.pf_count = data.pf_count || 0;
      if ( ast.output ) {
        return propname(ast.argumentIndex, 'd');
      }
      else {
        data.keys[data.pf_count] = ast.argumentIndex;
        return this._precompile( ast.elementFormat, data );
      }
      return '';

    case 'elementFormat':
      args = [ propname(data.keys[data.pf_count], 'd') ];
      switch (ast.key) {
        case 'select':
          args.push(this._precompile(ast.val, data));
          return 'select(' + args.join(', ') + ')';
        case 'selectordinal':
          args = args.concat([ 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data), 1 ]);
          return 'plural(' + args.join(', ') + ')';
        case 'plural':
          data.offset[data.pf_count || 0] = ast.val.offset || 0;
          args = args.concat([ data.offset[data.pf_count] || 0, propname(this.lc[0], 'pluralFuncs'), this._precompile(ast.val, data) ]);
          return 'plural(' + args.join(', ') + ')';
        default:
          if (this.withIntlSupport && !(ast.key in this.runtime.fmt) && (ast.key in MessageFormat.formatters)) {
            tmp = MessageFormat.formatters[ast.key];
            this.runtime.fmt[ast.key] = (typeof tmp(this) == 'function') ? tmp(this) : tmp;
          }
          args.push(JSON.stringify(this.lc));
          if (ast.val && ast.val.length) args.push(JSON.stringify(ast.val.length == 1 ? ast.val[0] : ast.val));
          return 'fmt.' + ast.key + '(' + args.join(', ') + ')';
      }

    case 'pluralFormatPattern':
    case 'selectFormatPattern':
      data.pf_count = data.pf_count || 0;
      if (ast.type == 'selectFormatPattern') data.offset[data.pf_count] = 0;
      var needOther = true;
      for (i = 0; i < ast.pluralForms.length; ++i) {
        var key = ast.pluralForms[i].key;
        if (key === 'other') needOther = false;
        var data_copy = JSON.parse(JSON.stringify(data));
        data_copy.pf_count++;
        r.push(propname(key) + ': function() { return ' + this._precompile(ast.pluralForms[i].val, data_copy) + ';}');
      }
      if (needOther) throw new Error("No 'other' form found in " + ast.type + " " + data.pf_count);
      return '{ ' + r.join(', ') + ' }';

    case 'string':
      return JSON.stringify(ast.val || "");

    case 'octothorpe':
      if (!data.pf_count) return '"#"';
      args = [ propname(data.keys[data.pf_count-1], 'd') ];
      if (data.offset[data.pf_count-1]) args.push(data.offset[data.pf_count-1]);
      return 'number(' + args.join(', ') + ')';

    default:
      throw new Error( 'Bad AST type: ' + ast.type );
  }
};

/** Compile messages into an executable function with clean string
 *  representation.
 *
 *  If `messages` is a single string including ICU MessageFormat declarations,
 *  `opt` is ignored and the returned function takes a single Object parameter
 *  `d` representing each of the input's defined variables. The returned
 *  function will be defined in a local scope that includes all the required
 *  runtime variables.
 *
 *  If `messages` is a map of keys to strings, or a map of namespace keys to
 *  such key/string maps, the returned function will fill the specified global
 *  with javascript functions matching the structure of the input. In such use,
 *  the output of `compile()` is expected to be serialized using `.toString()`,
 *  and will include definitions of the runtime functions. If `opt.global` is
 *  null, calling the output function will return the object itself.
 *
 *  Together, the input parameters should match the following patterns:
 *  ```js
 *  messages = "string" || { key0: "string0", key1: "string1", ... } || {
 *    ns0: { key0: "string0", key1: "string1", ...  },
 *    ns1: { key0: "string0", key1: "string1", ...  },
 *    ...
 *  }
 *
 *  opt = null || {
 *    locale: null || {
 *      ns0: "lc0" || [ "lc0", ... ],
 *      ns1: "lc1" || [ "lc1", ... ],
 *      ...
 *    },
 *    global: null || "module.exports" || "exports" || "i18n" || ...
 *  }
 *  ```
 *
 *  @memberof MessageFormat
 *  @param {string|Object}
 *      messages - The input message(s) to be compiled, in ICU MessageFormat
 *  @param {Object} [opt={}] - Options controlling output for non-simple intput
 *  @param {Object} [opt.locale] - The locales to use for the messages, with a
 *      structure matching that of `messages`
 *  @param {string} [opt.global=""] - The global variable that the output
 *      function should use, or a null string for none. "exports" and
 *      "module.exports" are recognised as special cases.
 *  @returns {function} The first match found for the given locale(s)
 *
 *  @example
 * > var MessageFormat = require('messageformat'),
 * ...   mf = new MessageFormat('en'),
 * ...   mfunc0 = mf.compile('A {TYPE} example.');
 * > mfunc0({TYPE:'simple'})
 * 'A simple example.'
 * > mfunc0.toString()
 * 'function (d) { return "A " + d.TYPE + " example."; }'
 *
 *  @example
 * > var msgSet = { a: 'A {TYPE} example.',
 * ...              b: 'This has {COUNT, plural, one{one member} other{# members}}.' },
 * ...   mfuncSet = mf.compile(msgSet);
 * > mfuncSet().a({TYPE:'more complex'})
 * 'A more complex example.'
 * > mfuncSet().b({COUNT:2})
 * 'This has 2 members.'
 *
 * > console.log(mfuncSet.toString())
 * function anonymous() {
 * var number = function (value, offset) {
 *   if (isNaN(value)) throw new Error("'" + value + "' isn't a number.");
 *   return value - (offset || 0);
 * };
 * var plural = function (value, offset, lcfunc, data, isOrdinal) {
 *   if ({}.hasOwnProperty.call(data, value)) return data[value]();
 *   if (offset) value -= offset;
 *   var key = lcfunc(value, isOrdinal);
 *   if (key in data) return data[key]();
 *   return data.other();
 * };
 * var select = function (value, data) {
 *   if ({}.hasOwnProperty.call(data, value)) return data[value]();
 *   return data.other()
 * };
 * var pluralFuncs = {
 *   en: function (n, ord) {
 *     var s = String(n).split('.'), v0 = !s[1], t0 = Number(s[0]) == n,
 *         n10 = t0 && s[0].slice(-1), n100 = t0 && s[0].slice(-2);
 *     if (ord) return (n10 == 1 && n100 != 11) ? 'one'
 *         : (n10 == 2 && n100 != 12) ? 'two'
 *         : (n10 == 3 && n100 != 13) ? 'few'
 *         : 'other';
 *     return (n == 1 && v0) ? 'one' : 'other';
 *   }
 * };
 * var fmt = {};
 *
 * return {
 *   a: function(d) { return "A " + d.TYPE + " example."; },
 *   b: function(d) { return "This has " + plural(d.COUNT, 0, pluralFuncs.en, { one: function() { return "one member";}, other: function() { return number(d.COUNT)+" members";} }) + "."; }
 * }
 * }
 *
 *  @example
 * > mf.runtime.pluralFuncs.fi = MessageFormat.plurals.fi;
 * > var multiSet = { en: { a: 'A {TYPE} example.',
 * ...                      b: 'This is the {COUNT, selectordinal, one{#st} two{#nd} few{#rd} other{#th}} example.' },
 * ...                fi: { a: '{TYPE} esimerkki.',
 * ...                      b: 'Tämä on {COUNT, selectordinal, other{#.}} esimerkki.' } },
 * ...   multiSetLocales = { en: 'en', fi: 'fi' },
 * ...   mfuncSet = mf.compile(multiSet, { locale: multiSetLocales, global: 'i18n' });
 * > mfuncSet(this);
 * > i18n.en.b({COUNT:3})
 * 'This is the 3rd example.'
 * > i18n.fi.b({COUNT:3})
 * 'Tämä on 3. esimerkki.'  */
MessageFormat.prototype.compile = function ( messages, opt ) {
  var r = {}, lc0 = this.lc,
      compileMsg = function(self, msg) {
        try {
          var ast = MessageFormat._parse(msg);
          return self._precompile(ast);
        } catch (e) {
          throw new Error((ast ? 'Precompiler' : 'Parser') + ' error: ' + e.toString());
        }
      },
      stringify = function(r, level) {
        if (!level) level = 0;
        if (typeof r != 'object') return r;
        var o = [], indent = '';
        for (var i = 0; i < level; ++i) indent += '  ';
        for (var k in r) o.push('\n' + indent + '  ' + propname(k) + ': ' + stringify(r[k], level + 1));
        return '{' + o.join(',') + '\n' + indent + '}';
      };

  if (typeof messages == 'string') {
    var f = new Function(
        'number, plural, select, pluralFuncs, fmt',
        'return ' + compileMsg(this, messages));
    return f(this.runtime.number, this.runtime.plural, this.runtime.select,
        this.runtime.pluralFuncs, this.runtime.fmt);
  }

  opt = opt || {};

  for (var ns in messages) {
    if (opt.locale) this.lc = opt.locale[ns] && [].concat(opt.locale[ns]) || lc0;
    if (typeof messages[ns] == 'string') {
      try { r[ns] = compileMsg(this, messages[ns]); }
      catch (e) { e.message = e.message.replace(':', ' with `' + ns + '`:'); throw e; }
    } else {
      r[ns] = {};
      for (var key in messages[ns]) {
        try { r[ns][key] = compileMsg(this, messages[ns][key]); }
        catch (e) { e.message = e.message.replace(':', ' with `' + key + '` in `' + ns + '`:'); throw e; }
      }
    }
  }

  this.lc = lc0;
  var s = this.runtime.toString() + '\n';
  switch (opt.global || '') {
    case 'exports':
      var o = [];
      for (var k in r) o.push(propname(k, 'exports') + ' = ' + stringify(r[k]));
      return new Function(s + o.join(';\n'));
    case 'module.exports':
      return new Function(s + 'module.exports = ' + stringify(r));
    case '':
      return new Function(s + 'return ' + stringify(r));
    default:
      return new Function('G', s + propname(opt.global, 'G') + ' = ' + stringify(r));
  }
};


return MessageFormat;
}());
/* jshint ignore:end */


var createErrorPluralModulePresence = function() {
	return createError( "E_MISSING_PLURAL_MODULE", "Plural module not loaded." );
};




var validateMessageBundle = function( cldr ) {
	validate(
		"E_MISSING_MESSAGE_BUNDLE",
		"Missing message bundle for locale `{locale}`.",
		cldr.attributes.bundle && cldr.get( "globalize-messages/{bundle}" ) !== undefined,
		{
			locale: cldr.locale
		}
	);
};




var validateMessagePresence = function( path, value ) {
	path = path.join( "/" );
	validate( "E_MISSING_MESSAGE", "Missing required message content `{path}`.",
		value !== undefined, { path: path } );
};




var validateMessageType = function( path, value ) {
	path = path.join( "/" );
	validate(
		"E_INVALID_MESSAGE",
		"Invalid message content `{path}`. {expected} expected.",
		typeof value === "string",
		{
			expected: "a string",
			path: path
		}
	);
};




var validateParameterTypeMessageVariables = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || isPlainObject( value ) || Array.isArray( value ),
		"Array or Plain Object"
	);
};




var messageFormatterFn = function( formatter ) {
	return function messageFormatter( variables ) {
		if ( typeof variables === "number" || typeof variables === "string" ) {
			variables = [].slice.call( arguments, 0 );
		}
		validateParameterTypeMessageVariables( variables, "variables" );
		return formatter( variables );
	};
};




var messageFormatterRuntimeBind = function( cldr, messageformatter ) {
	var locale = cldr.locale,
		origToString = messageformatter.toString;

	messageformatter.toString = function() {
		var argNames, argValues, output,
			args = {};

		// Properly adjust SlexAxton/messageformat.js compiled variables with Globalize variables:
		output = origToString.call( messageformatter );

		if ( /number\(/.test( output ) ) {
			args.number = "messageFormat.number";
		}

		if ( /plural\(/.test( output ) ) {
			args.plural = "messageFormat.plural";
		}

		if ( /select\(/.test( output ) ) {
			args.select = "messageFormat.select";
		}

		output.replace( /pluralFuncs(\[([^\]]+)\]|\.([a-zA-Z]+))/, function( match ) {
			args.pluralFuncs = "{" +
				"\"" + locale + "\": Globalize(\"" + locale + "\").pluralGenerator()" +
				"}";
			return match;
		});

		argNames = Object.keys( args ).join( ", " );
		argValues = Object.keys( args ).map(function( key ) {
			return args[ key ];
		}).join( ", " );

		return "(function( " + argNames + " ) {\n" +
			"  return " + output + "\n" +
			"})(" + argValues + ")";
	};

	return messageformatter;
};




var slice = [].slice;

/**
 * .loadMessages( json )
 *
 * @json [JSON]
 *
 * Load translation data.
 */
Globalize.loadMessages = function( json ) {
	var locale,
		customData = {
			"globalize-messages": json,
			"main": {}
		};

	validateParameterPresence( json, "json" );
	validateParameterTypePlainObject( json, "json" );

	// Set available bundles by populating customData main dataset.
	for ( locale in json ) {
		if ( json.hasOwnProperty( locale ) ) {
			customData.main[ locale ] = {};
		}
	}

	Cldr.load( customData );
};

/**
 * .messageFormatter( path )
 *
 * @path [String or Array]
 *
 * Format a message given its path.
 */
Globalize.messageFormatter =
Globalize.prototype.messageFormatter = function( path ) {
	var cldr, formatter, message, pluralGenerator, returnFn,
		args = slice.call( arguments, 0 );

	validateParameterPresence( path, "path" );
	validateParameterType( path, "path", typeof path === "string" || Array.isArray( path ),
		"a String nor an Array" );

	path = alwaysArray( path );
	cldr = this.cldr;

	validateDefaultLocale( cldr );
	validateMessageBundle( cldr );

	message = cldr.get( [ "globalize-messages/{bundle}" ].concat( path ) );
	validateMessagePresence( path, message );

	// If message is an Array, concatenate it.
	if ( Array.isArray( message ) ) {
		message = message.join( " " );
	}
	validateMessageType( path, message );

	// Is plural module present? Yes, use its generator. Nope, use an error generator.
	pluralGenerator = this.plural !== undefined ?
		this.pluralGenerator() :
		createErrorPluralModulePresence;

	formatter = new MessageFormat( cldr.locale, pluralGenerator ).compile( message );

	returnFn = messageFormatterFn( formatter );

	runtimeBind( args, cldr, returnFn,
		[ messageFormatterRuntimeBind( cldr, formatter ), pluralGenerator ] );

	return returnFn;
};

/**
 * .formatMessage( path [, variables] )
 *
 * @path [String or Array]
 *
 * @variables [Number, String, Array or Object]
 *
 * Format a message given its path.
 */
Globalize.formatMessage =
Globalize.prototype.formatMessage = function( path /* , variables */ ) {
	return this.messageFormatter( path ).apply( {}, slice.call( arguments, 1 ) );
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/number.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var createError = Globalize._createError,
	regexpEscape = Globalize._regexpEscape,
	runtimeBind = Globalize._runtimeBind,
	stringPad = Globalize._stringPad,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterRange = Globalize._validateParameterRange,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;


var createErrorUnsupportedFeature = function( feature ) {
	return createError( "E_UNSUPPORTED", "Unsupported {feature}.", {
		feature: feature
	});
};




var validateParameterTypeNumber = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "number",
		"Number"
	);
};




var validateParameterTypeString = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "string",
		"a string"
	);
};




/**
 * goupingSeparator( number, primaryGroupingSize, secondaryGroupingSize )
 *
 * @number [Number].
 *
 * @primaryGroupingSize [Number]
 *
 * @secondaryGroupingSize [Number]
 *
 * Return the formatted number with group separator.
 */
var numberFormatGroupingSeparator = function( number, primaryGroupingSize, secondaryGroupingSize ) {
	var index,
		currentGroupingSize = primaryGroupingSize,
		ret = "",
		sep = ",",
		switchToSecondary = secondaryGroupingSize ? true : false;

	number = String( number ).split( "." );
	index = number[ 0 ].length;

	while ( index > currentGroupingSize ) {
		ret = number[ 0 ].slice( index - currentGroupingSize, index ) +
			( ret.length ? sep : "" ) + ret;
		index -= currentGroupingSize;
		if ( switchToSecondary ) {
			currentGroupingSize = secondaryGroupingSize;
			switchToSecondary = false;
		}
	}

	number[ 0 ] = number[ 0 ].slice( 0, index ) + ( ret.length ? sep : "" ) + ret;
	return number.join( "." );
};




/**
 * integerFractionDigits( number, minimumIntegerDigits, minimumFractionDigits,
 * maximumFractionDigits, round, roundIncrement )
 *
 * @number [Number]
 *
 * @minimumIntegerDigits [Number]
 *
 * @minimumFractionDigits [Number]
 *
 * @maximumFractionDigits [Number]
 *
 * @round [Function]
 *
 * @roundIncrement [Function]
 *
 * Return the formatted integer and fraction digits.
 */
var numberFormatIntegerFractionDigits = function( number, minimumIntegerDigits, minimumFractionDigits, maximumFractionDigits, round,
	roundIncrement ) {

	// Fraction
	if ( maximumFractionDigits ) {

		// Rounding
		if ( roundIncrement ) {
			number = round( number, roundIncrement );

		// Maximum fraction digits
		} else {
			number = round( number, { exponent: -maximumFractionDigits } );
		}

	} else {
		number = round( number );
	}

	number = String( number );

	// Maximum integer digits (post string phase)
	if ( maximumFractionDigits && /e-/.test( number ) ) {

		// Use toFixed( maximumFractionDigits ) to make sure small numbers like 1e-7 are
		// displayed using plain digits instead of scientific notation.
		// 1: Remove leading decimal zeros.
		// 2: Remove leading decimal separator.
		// Note: String() is still preferred so it doesn't mess up with a number precision
		// unnecessarily, e.g., (123456789.123).toFixed(10) === "123456789.1229999959",
		// String(123456789.123) === "123456789.123".
		number = ( +number ).toFixed( maximumFractionDigits )
			.replace( /0+$/, "" ) /* 1 */
			.replace( /\.$/, "" ) /* 2 */;
	}

	// Minimum fraction digits (post string phase)
	if ( minimumFractionDigits ) {
		number = number.split( "." );
		number[ 1 ] = stringPad( number[ 1 ] || "", minimumFractionDigits, true );
		number = number.join( "." );
	}

	// Minimum integer digits
	if ( minimumIntegerDigits ) {
		number = number.split( "." );
		number[ 0 ] = stringPad( number[ 0 ], minimumIntegerDigits );
		number = number.join( "." );
	}

	return number;
};




/**
 * toPrecision( number, precision, round )
 *
 * @number (Number)
 *
 * @precision (Number) significant figures precision (not decimal precision).
 *
 * @round (Function)
 *
 * Return number.toPrecision( precision ) using the given round function.
 */
var numberToPrecision = function( number, precision, round ) {
	var roundOrder;

	// Get number at two extra significant figure precision.
	number = number.toPrecision( precision + 2 );

	// Then, round it to the required significant figure precision.
	roundOrder = Math.ceil( Math.log( Math.abs( number ) ) / Math.log( 10 ) );
	roundOrder -= precision;

	return round( number, { exponent: roundOrder } );
};




/**
 * toPrecision( number, minimumSignificantDigits, maximumSignificantDigits, round )
 *
 * @number [Number]
 *
 * @minimumSignificantDigits [Number]
 *
 * @maximumSignificantDigits [Number]
 *
 * @round [Function]
 *
 * Return the formatted significant digits number.
 */
var numberFormatSignificantDigits = function( number, minimumSignificantDigits, maximumSignificantDigits, round ) {
	var atMinimum, atMaximum;

	// Sanity check.
	if ( minimumSignificantDigits > maximumSignificantDigits ) {
		maximumSignificantDigits = minimumSignificantDigits;
	}

	atMinimum = numberToPrecision( number, minimumSignificantDigits, round );
	atMaximum = numberToPrecision( number, maximumSignificantDigits, round );

	// Use atMaximum only if it has more significant digits than atMinimum.
	number = +atMinimum === +atMaximum ? atMinimum : atMaximum;

	// Expand integer numbers, eg. 123e5 to 12300.
	number = ( +number ).toString( 10 );

	if ( ( /e/ ).test( number ) ) {
		throw createErrorUnsupportedFeature({
			feature: "integers out of (1e21, 1e-7)"
		});
	}

	// Add trailing zeros if necessary.
	if ( minimumSignificantDigits - number.replace( /^0+|\./g, "" ).length > 0 ) {
		number = number.split( "." );
		number[ 1 ] = stringPad( number[ 1 ] || "", minimumSignificantDigits - number[ 0 ].replace( /^0+/, "" ).length, true );
		number = number.join( "." );
	}

	return number;
};




/**
 * removeLiteralQuotes( string )
 *
 * Return:
 * - `` if input string is `''`.
 * - `o'clock` if input string is `'o''clock'`.
 * - `foo` if input string is `foo`, i.e., return the same value in case it isn't a single-quoted
 *   string.
 */
var removeLiteralQuotes = function( string ) {
	if ( string[ 0 ] + string[ string.length - 1 ] !== "''" ) {
		return string;
	}
	if ( string === "''" ) {
		return "";
	}
	return string.replace( /''/g, "'" ).slice( 1, -1 );
};




/**
 * format( number, properties )
 *
 * @number [Number].
 *
 * @properties [Object] Output of number/format-properties.
 *
 * Return the formatted number.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberFormat = function( number, properties ) {
	var infinitySymbol, maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,
	minimumIntegerDigits, minimumSignificantDigits, nanSymbol, nuDigitsMap, padding, prefix,
	primaryGroupingSize, pattern, ret, round, roundIncrement, secondaryGroupingSize, suffix,
	symbolMap;

	padding = properties[ 1 ];
	minimumIntegerDigits = properties[ 2 ];
	minimumFractionDigits = properties[ 3 ];
	maximumFractionDigits = properties[ 4 ];
	minimumSignificantDigits = properties[ 5 ];
	maximumSignificantDigits = properties[ 6 ];
	roundIncrement = properties[ 7 ];
	primaryGroupingSize = properties[ 8 ];
	secondaryGroupingSize = properties[ 9 ];
	round = properties[ 15 ];
	infinitySymbol = properties[ 16 ];
	nanSymbol = properties[ 17 ];
	symbolMap = properties[ 18 ];
	nuDigitsMap = properties[ 19 ];

	// NaN
	if ( isNaN( number ) ) {
		return nanSymbol;
	}

	if ( number < 0 ) {
		pattern = properties[ 12 ];
		prefix = properties[ 13 ];
		suffix = properties[ 14 ];
	} else {
		pattern = properties[ 11 ];
		prefix = properties[ 0 ];
		suffix = properties[ 10 ];
	}

	// Infinity
	if ( !isFinite( number ) ) {
		return prefix + infinitySymbol + suffix;
	}

	ret = prefix;

	// Percent
	if ( pattern.indexOf( "%" ) !== -1 ) {
		number *= 100;

	// Per mille
	} else if ( pattern.indexOf( "\u2030" ) !== -1 ) {
		number *= 1000;
	}

	// Significant digit format
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {
		number = numberFormatSignificantDigits( number, minimumSignificantDigits,
			maximumSignificantDigits, round );

	// Integer and fractional format
	} else {
		number = numberFormatIntegerFractionDigits( number, minimumIntegerDigits,
			minimumFractionDigits, maximumFractionDigits, round, roundIncrement );
	}

	// Remove the possible number minus sign
	number = number.replace( /^-/, "" );

	// Grouping separators
	if ( primaryGroupingSize ) {
		number = numberFormatGroupingSeparator( number, primaryGroupingSize,
			secondaryGroupingSize );
	}

	ret += number;

	// Scientific notation
	// TODO implement here

	// Padding/'([^']|'')+'|''|[.,\-+E%\u2030]/g
	// TODO implement here

	ret += suffix;

	return ret.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {

		// Literals
		if ( literal ) {
			return removeLiteralQuotes( literal );
		}

		// Symbols
		character = character.replace( /[.,\-+E%\u2030]/, function( symbol ) {
			return symbolMap[ symbol ];
		});

		// Numbering system
		if ( nuDigitsMap ) {
			character = character.replace( /[0-9]/, function( digit ) {
				return nuDigitsMap[ +digit ];
			});
		}

		return character;
	});
};




var numberFormatterFn = function( properties ) {
	return function numberFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return numberFormat( value, properties );
	};
};




/**
 * NumberingSystem( cldr )
 *
 * - http://www.unicode.org/reports/tr35/tr35-numbers.html#otherNumberingSystems
 * - http://cldr.unicode.org/index/bcp47-extension
 * - http://www.unicode.org/reports/tr35/#u_Extension
 */
var numberNumberingSystem = function( cldr ) {
	var nu = cldr.attributes[ "u-nu" ];

	if ( nu ) {
		if ( nu === "traditio" ) {
			nu = "traditional";
		}
		if ( [ "native", "traditional", "finance" ].indexOf( nu ) !== -1 ) {

			// Unicode locale extension `u-nu` is set using either (native, traditional or
			// finance). So, lookup the respective locale's numberingSystem and return it.
			return cldr.main([ "numbers/otherNumberingSystems", nu ]);
		}

		// Unicode locale extension `u-nu` is set with an explicit numberingSystem. Return it.
		return nu;
	}

	// Return the default numberingSystem.
	return cldr.main( "numbers/defaultNumberingSystem" );
};




/**
 * nuMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return digits map if numbering system is different than `latn`.
 */
var numberNumberingSystemDigitsMap = function( cldr ) {
	var aux,
		nu = numberNumberingSystem( cldr );

	if ( nu === "latn" ) {
		return;
	}

	aux = cldr.supplemental([ "numberingSystems", nu ]);

	if ( aux._type !== "numeric" ) {
		throw createErrorUnsupportedFeature( "`" + aux._type + "` numbering system" );
	}

	return aux._digits;
};




/**
 * EBNF representation:
 *
 * number_pattern_re =        prefix?
 *                            padding?
 *                            (integer_fraction_pattern | significant_pattern)
 *                            scientific_notation?
 *                            suffix?
 *
 * prefix =                   non_number_stuff
 *
 * padding =                  "*" regexp(.)
 *
 * integer_fraction_pattern = integer_pattern
 *                            fraction_pattern?
 *
 * integer_pattern =          regexp([#,]*[0,]*0+)
 *
 * fraction_pattern =         "." regexp(0*[0-9]*#*)
 *
 * significant_pattern =      regexp([#,]*@+#*)
 *
 * scientific_notation =      regexp(E\+?0+)
 *
 * suffix =                   non_number_stuff
 *
 * non_number_stuff =         regexp(('[^']+'|''|[^*#@0,.E])*)
 *
 *
 * Regexp groups:
 *
 *  0: number_pattern_re
 *  1: prefix
 *  2: -
 *  3: -
 *  4: padding
 *  5: (integer_fraction_pattern | significant_pattern)
 *  6: integer_fraction_pattern
 *  7: integer_pattern
 *  8: fraction_pattern
 *  9: significant_pattern
 * 10: scientific_notation
 * 11: suffix
 * 12: -
 */
var numberPatternRe = ( /^(('([^']|'')*'|[^*#@0,.E])*)(\*.)?((([#,]*[0,]*0+)(\.0*[0-9]*#*)?)|([#,]*@+#*))(E\+?0+)?(('[^']+'|''|[^*#@0,.E])*)$/ );




/**
 * format( number, pattern )
 *
 * @number [Number].
 *
 * @pattern [String] raw pattern for numbers.
 *
 * Return the formatted number.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberPatternProperties = function( pattern ) {
	var aux1, aux2, fractionPattern, integerFractionOrSignificantPattern, integerPattern,
		maximumFractionDigits, maximumSignificantDigits, minimumFractionDigits,
		minimumIntegerDigits, minimumSignificantDigits, padding, prefix, primaryGroupingSize,
		roundIncrement, scientificNotation, secondaryGroupingSize, significantPattern, suffix;

	pattern = pattern.match( numberPatternRe );
	if ( !pattern ) {
		throw new Error( "Invalid pattern: " + pattern );
	}

	prefix = pattern[ 1 ];
	padding = pattern[ 4 ];
	integerFractionOrSignificantPattern = pattern[ 5 ];
	significantPattern = pattern[ 9 ];
	scientificNotation = pattern[ 10 ];
	suffix = pattern[ 11 ];

	// Significant digit format
	if ( significantPattern ) {
		significantPattern.replace( /(@+)(#*)/, function( match, minimumSignificantDigitsMatch, maximumSignificantDigitsMatch ) {
			minimumSignificantDigits = minimumSignificantDigitsMatch.length;
			maximumSignificantDigits = minimumSignificantDigits +
				maximumSignificantDigitsMatch.length;
		});

	// Integer and fractional format
	} else {
		fractionPattern = pattern[ 8 ];
		integerPattern = pattern[ 7 ];

		if ( fractionPattern ) {

			// Minimum fraction digits, and rounding.
			fractionPattern.replace( /[0-9]+/, function( match ) {
				minimumFractionDigits = match;
			});
			if ( minimumFractionDigits ) {
				roundIncrement = +( "0." + minimumFractionDigits );
				minimumFractionDigits = minimumFractionDigits.length;
			} else {
				minimumFractionDigits = 0;
			}

			// Maximum fraction digits
			// 1: ignore decimal character
			maximumFractionDigits = fractionPattern.length - 1 /* 1 */;
		}

		// Minimum integer digits
		integerPattern.replace( /0+$/, function( match ) {
			minimumIntegerDigits = match.length;
		});
	}

	// Scientific notation
	if ( scientificNotation ) {
		throw createErrorUnsupportedFeature({
			feature: "scientific notation (not implemented)"
		});
	}

	// Padding
	if ( padding ) {
		throw createErrorUnsupportedFeature({
			feature: "padding (not implemented)"
		});
	}

	// Grouping
	if ( ( aux1 = integerFractionOrSignificantPattern.lastIndexOf( "," ) ) !== -1 ) {

		// Primary grouping size is the interval between the last group separator and the end of
		// the integer (or the end of the significant pattern).
		aux2 = integerFractionOrSignificantPattern.split( "." )[ 0 ];
		primaryGroupingSize = aux2.length - aux1 - 1;

		// Secondary grouping size is the interval between the last two group separators.
		if ( ( aux2 = integerFractionOrSignificantPattern.lastIndexOf( ",", aux1 - 1 ) ) !== -1 ) {
			secondaryGroupingSize = aux1 - 1 - aux2;
		}
	}

	// Return:
	//  0: @prefix String
	//  1: @padding Array [ <character>, <count> ] TODO
	//  2: @minimumIntegerDigits non-negative integer Number value indicating the minimum integer
	//        digits to be used. Numbers will be padded with leading zeroes if necessary.
	//  3: @minimumFractionDigits and
	//  4: @maximumFractionDigits are non-negative integer Number values indicating the minimum and
	//        maximum fraction digits to be used. Numbers will be rounded or padded with trailing
	//        zeroes if necessary.
	//  5: @minimumSignificantDigits and
	//  6: @maximumSignificantDigits are positive integer Number values indicating the minimum and
	//        maximum fraction digits to be shown. Either none or both of these properties are
	//        present; if they are, they override minimum and maximum integer and fraction digits
	//        – the formatter uses however many integer and fraction digits are required to display
	//        the specified number of significant digits.
	//  7: @roundIncrement Decimal round increment or null
	//  8: @primaryGroupingSize
	//  9: @secondaryGroupingSize
	// 10: @suffix String
	return [
		prefix,
		padding,
		minimumIntegerDigits,
		minimumFractionDigits,
		maximumFractionDigits,
		minimumSignificantDigits,
		maximumSignificantDigits,
		roundIncrement,
		primaryGroupingSize,
		secondaryGroupingSize,
		suffix
	];
};




/**
 * Symbol( name, cldr )
 *
 * @name [String] Symbol name.
 *
 * @cldr [Cldr instance].
 *
 * Return the localized symbol given its name.
 */
var numberSymbol = function( name, cldr ) {
	return cldr.main([
		"numbers/symbols-numberSystem-" + numberNumberingSystem( cldr ),
		name
	]);
};




var numberSymbolName = {
	".": "decimal",
	",": "group",
	"%": "percentSign",
	"+": "plusSign",
	"-": "minusSign",
	"E": "exponential",
	"\u2030": "perMille"
};




/**
 * symbolMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return the (localized symbol, pattern symbol) key value pair, eg. {
 *   ".": "٫",
 *   ",": "٬",
 *   "%": "٪",
 *   ...
 * };
 */
var numberSymbolMap = function( cldr ) {
	var symbol,
		symbolMap = {};

	for ( symbol in numberSymbolName ) {
		symbolMap[ symbol ] = numberSymbol( numberSymbolName[ symbol ], cldr );
	}

	return symbolMap;
};




var numberTruncate = function( value ) {
	if ( isNaN( value ) ) {
		return NaN;
	}
	return Math[ value < 0 ? "ceil" : "floor" ]( value );
};




/**
 * round( method )
 *
 * @method [String] with either "round", "ceil", "floor", or "truncate".
 *
 * Return function( value, incrementOrExp ):
 *
 *   @value [Number] eg. 123.45.
 *
 *   @incrementOrExp [Number] optional, eg. 0.1; or
 *     [Object] Either { increment: <value> } or { exponent: <value> }
 *
 *   Return the rounded number, eg:
 *   - round( "round" )( 123.45 ): 123;
 *   - round( "ceil" )( 123.45 ): 124;
 *   - round( "floor" )( 123.45 ): 123;
 *   - round( "truncate" )( 123.45 ): 123;
 *   - round( "round" )( 123.45, 0.1 ): 123.5;
 *   - round( "round" )( 123.45, 10 ): 120;
 *
 *   Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round
 *   Ref: #376
 */
var numberRound = function( method ) {
	method = method || "round";
	method = method === "truncate" ? numberTruncate : Math[ method ];

	return function( value, incrementOrExp ) {
		var exp, increment;

		value = +value;

		// If the value is not a number, return NaN.
		if ( isNaN( value ) ) {
			return NaN;
		}

		// Exponent given.
		if ( typeof incrementOrExp === "object" && incrementOrExp.exponent ) {
			exp = +incrementOrExp.exponent;
			increment = 1;

			if ( exp === 0 ) {
				return method( value );
			}

			// If the exp is not an integer, return NaN.
			if ( !( typeof exp === "number" && exp % 1 === 0 ) ) {
				return NaN;
			}

		// Increment given.
		} else {
			increment = +incrementOrExp || 1;

			if ( increment === 1 ) {
				return method( value );
			}

			// If the increment is not a number, return NaN.
			if ( isNaN( increment ) ) {
				return NaN;
			}

			increment = increment.toExponential().split( "e" );
			exp = +increment[ 1 ];
			increment = +increment[ 0 ];
		}

		// Shift & Round
		value = value.toString().split( "e" );
		value[ 0 ] = +value[ 0 ] / increment;
		value[ 1 ] = value[ 1 ] ? ( +value[ 1 ] - exp ) : -exp;
		value = method( +( value[ 0 ] + "e" + value[ 1 ] ) );

		// Shift back
		value = value.toString().split( "e" );
		value[ 0 ] = +value[ 0 ] * increment;
		value[ 1 ] = value[ 1 ] ? ( +value[ 1 ] + exp ) : exp;
		return +( value[ 0 ] + "e" + value[ 1 ] );
	};
};




/**
 * formatProperties( pattern, cldr [, options] )
 *
 * @pattern [String] raw pattern for numbers.
 *
 * @cldr [Cldr instance].
 *
 * @options [Object]:
 * - minimumIntegerDigits [Number]
 * - minimumFractionDigits, maximumFractionDigits [Number]
 * - minimumSignificantDigits, maximumSignificantDigits [Number]
 * - round [String] "ceil", "floor", "round" (default), or "truncate".
 * - useGrouping [Boolean] default true.
 *
 * Return the processed properties that will be used in number/format.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberFormatProperties = function( pattern, cldr, options ) {
	var negativePattern, negativePrefix, negativeProperties, negativeSuffix, positivePattern,
		roundFn, properties;

	function getOptions( attribute, propertyIndex ) {
		if ( attribute in options ) {
			properties[ propertyIndex ] = options[ attribute ];
		}
	}

	options = options || {};
	pattern = pattern.split( ";" );

	positivePattern = pattern[ 0 ];

	negativePattern = pattern[ 1 ] || "-" + positivePattern;
	negativeProperties = numberPatternProperties( negativePattern );
	negativePrefix = negativeProperties[ 0 ];
	negativeSuffix = negativeProperties[ 10 ];

	// Have runtime code to refer to numberRound() instead of including it explicitly.
	roundFn = numberRound( options.round );
	roundFn.generatorString = function() {
		return "numberRound(" + ( options.round ? "\"" + options.round + "\"" : "" ) + ")";
	};

	properties = numberPatternProperties( positivePattern ).concat([
		positivePattern,
		negativePrefix + positivePattern + negativeSuffix,
		negativePrefix,
		negativeSuffix,
		roundFn,
		numberSymbol( "infinity", cldr ),
		numberSymbol( "nan", cldr ),
		numberSymbolMap( cldr ),
		numberNumberingSystemDigitsMap( cldr )
	]);

	getOptions( "minimumIntegerDigits", 2 );
	getOptions( "minimumFractionDigits", 3 );
	getOptions( "maximumFractionDigits", 4 );
	getOptions( "minimumSignificantDigits", 5 );
	getOptions( "maximumSignificantDigits", 6 );

	// Grouping separators
	if ( options.useGrouping === false ) {
		properties[ 8 ] = null;
	}

	// Normalize number of digits if only one of either minimumFractionDigits or
	// maximumFractionDigits is passed in as an option
	if ( "minimumFractionDigits" in options && !( "maximumFractionDigits" in options ) ) {

		// maximumFractionDigits = Math.max( minimumFractionDigits, maximumFractionDigits );
		properties[ 4 ] = Math.max( properties[ 3 ], properties[ 4 ] );
	} else if ( !( "minimumFractionDigits" in options ) &&
			"maximumFractionDigits" in options ) {

		// minimumFractionDigits = Math.min( minimumFractionDigits, maximumFractionDigits );
		properties[ 3 ] = Math.min( properties[ 3 ], properties[ 4 ] );
	}

	// Return:
	// 0-10: see number/pattern-properties.
	// 11: @positivePattern [String] Positive pattern.
	// 12: @negativePattern [String] Negative pattern.
	// 13: @negativePrefix [String] Negative prefix.
	// 14: @negativeSuffix [String] Negative suffix.
	// 15: @round [Function] Round function.
	// 16: @infinitySymbol [String] Infinity symbol.
	// 17: @nanSymbol [String] NaN symbol.
	// 18: @symbolMap [Object] A bunch of other symbols.
	// 19: @nuDigitsMap [Array] Digits map if numbering system is different than `latn`.
	return properties;
};




/**
 * Generated by:
 *
 * var regenerate = require( "regenerate" );
 * var formatSymbols = require( * "unicode-8.0.0/General_Category/Format/symbols" );
 * regenerate().add( formatSymbols ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-8.0.0
 */
var regexpCfG = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804\uDCBD|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/g;




/**
 * Generated by:
 *
 * var regenerate = require( "regenerate" );
 * var dashSymbols = require( * "unicode-8.0.0/General_Category/Dash_Punctuation/symbols" );
 * regenerate().add( dashSymbols ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-8.0.0
 *
 * NOTE: In addition to [:dash:],  the below includes MINUS SIGN U+2212.
 */
var regexpDashG = /[\-\u058A\u05BE\u1400\u1806\u2010-\u2015\u2E17\u2E1A\u2E3A\u2E3B\u2E40\u301C\u3030\u30A0\uFE31\uFE32\uFE58\uFE63\uFF0D\u2212]/g;




/**
 * Generated by:
 *
 * var regenerate = require( "regenerate" );
 * var spaceSeparatorSymbols = require( "unicode-8.0.0/General_Category/Space_Separator/symbols" );
 * regenerate().add( spaceSeparatorSymbols ).toString();
 *
 * https://github.com/mathiasbynens/regenerate
 * https://github.com/mathiasbynens/unicode-8.0.0
 */
var regexpZsG = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/g;




/**
 * Loose Matching:
 * - Ignore all format characters, which includes RLM, LRM or ALM used to control BIDI
 *   formatting.
 * - Map all characters in [:Zs:] to U+0020 SPACE;
 * - Map all characters in [:Dash:] to U+002D HYPHEN-MINUS;
 */
var looseMatching = function( value ) {
	return value
		.replace( regexpCfG, "" )
		.replace( regexpDashG, "-" )
		.replace( regexpZsG, " " );
};




/**
 * parse( value, properties )
 *
 * @value [String].
 *
 * @properties [Object] Parser properties is a reduced pre-processed cldr
 * data set returned by numberParserProperties().
 *
 * Return the parsed Number (including Infinity) or NaN when value is invalid.
 * ref: http://www.unicode.org/reports/tr35/tr35-numbers.html
 */
var numberParse = function( value, properties ) {
	var grammar, invertedNuDigitsMap, invertedSymbolMap, negative, number, prefix, prefixNSuffix,
		suffix, tokenizer, valid;

	// Grammar:
	// - Value <=           NaN | PositiveNumber | NegativeNumber
	// - PositiveNumber <=  PositivePrefix NumberOrInf PositiveSufix
	// - NegativeNumber <=  NegativePrefix NumberOrInf
	// - NumberOrInf <=     Number | Inf
	grammar = [
		[ "nan" ],
		[ "prefix", "infinity", "suffix" ],
		[ "prefix", "number", "suffix" ],
		[ "negativePrefix", "infinity", "negativeSuffix" ],
		[ "negativePrefix", "number", "negativeSuffix" ]
	];

	invertedSymbolMap = properties[ 0 ];
	invertedNuDigitsMap = properties[ 1 ] || {};
	tokenizer = properties[ 2 ];

	value = looseMatching( value );

	function parse( type ) {
		return function( lexeme ) {

			// Reverse localized symbols and numbering system.
			lexeme = lexeme.split( "" ).map(function( character ) {
				return invertedSymbolMap[ character ] ||
					invertedNuDigitsMap[ character ] ||
					character;
			}).join( "" );

			switch ( type ) {
				case "infinity":
					number = Infinity;
					break;

				case "nan":
					number = NaN;
					break;

				case "number":

					// Remove grouping separators.
					lexeme = lexeme.replace( /,/g, "" );

					number = +lexeme;
					break;

				case "prefix":
				case "negativePrefix":
					prefix = lexeme;
					break;

				case "suffix":
					suffix = lexeme;
					break;

				case "negativeSuffix":
					suffix = lexeme;
					negative = true;
					break;

				// This should never be reached.
				default:
					throw new Error( "Internal error" );
			}
			return "";
		};
	}

	function tokenizeNParse( _value, grammar ) {
		return grammar.some(function( statement ) {
			var value = _value;

			// The whole grammar statement should be used (i.e., .every() return true) and value be
			// entirely consumed (i.e., !value.length).
			return statement.every(function( type ) {
				if ( value.match( tokenizer[ type ] ) === null ) {
					return false;
				}

				// Consume and parse it.
				value = value.replace( tokenizer[ type ], parse( type ) );
				return true;
			}) && !value.length;
		});
	}

	valid = tokenizeNParse( value, grammar );

	// NaN
	if ( !valid || isNaN( number ) ) {
		return NaN;
	}

	prefixNSuffix = "" + prefix + suffix;

	// Percent
	if ( prefixNSuffix.indexOf( "%" ) !== -1 ) {
		number /= 100;

	// Per mille
	} else if ( prefixNSuffix.indexOf( "\u2030" ) !== -1 ) {
		number /= 1000;
	}

	// Negative number
	if ( negative ) {
		number *= -1;
	}

	return number;
};




var numberParserFn = function( properties ) {
	return function numberParser( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeString( value, "value" );

		return numberParse( value, properties );
	};

};




/**
 * symbolMap( cldr )
 *
 * @cldr [Cldr instance].
 *
 * Return the (localized symbol, pattern symbol) key value pair, eg. {
 *   "٫": ".",
 *   "٬": ",",
 *   "٪": "%",
 *   ...
 * };
 */
var numberSymbolInvertedMap = function( cldr ) {
	var symbol,
		symbolMap = {};

	for ( symbol in numberSymbolName ) {
		symbolMap[ numberSymbol( numberSymbolName[ symbol ], cldr ) ] = symbol;
	}

	return symbolMap;
};




/**
 * objectMap( object, fn)
 *
 * - object
 *
 * - fn( pair ) => pair
 */
var objectMap = function( object, fn ) {
	return Object.keys( object ).map(function( key ) {
		return fn([ key, object[ key ] ]);
	}).reduce(function( object, pair ) {
		object[ pair[ 0 ] ] = pair[ 1 ];
		return object;
	}, {});
};




/**
 * parseProperties( pattern, cldr )
 *
 * @pattern [String] raw pattern for numbers.
 *
 * @cldr [Cldr instance].
 *
 * Return parser properties, used to feed parser function.
 *
 * TODO:
 * - Scientific_notation;
 * - Padding;
 */
var numberParseProperties = function( pattern, cldr, options ) {
	var aux, decimalSymbolRe, digitsRe, groupingSeparatorRe, infinitySymbol, invertedNuDigitsMap,
		invertedSymbolMap, maximumFractionDigits, maximumSignificantDigits,
		minimumSignificantDigits, nanSymbol, negativePrefix, negativeSuffix, nuDigitsMap,
		numberTokenizer, prefix, primaryGroupingSize, secondaryGroupingSize, suffix, symbolMap,
		formatProperties = numberFormatProperties( pattern, cldr, options );

	prefix = looseMatching( formatProperties[ 0 ] );
	maximumFractionDigits = formatProperties[ 4 ];
	minimumSignificantDigits = formatProperties[ 5 ];
	maximumSignificantDigits = formatProperties[ 6 ];
	primaryGroupingSize = formatProperties[ 8 ];
	secondaryGroupingSize = formatProperties[ 9 ];
	suffix = looseMatching( formatProperties[ 10 ] );
	negativePrefix = looseMatching( formatProperties[ 13 ] );
	negativeSuffix = looseMatching( formatProperties[ 14 ] );
	infinitySymbol = looseMatching( formatProperties[ 16 ] );
	nanSymbol = looseMatching( formatProperties[ 17 ] );
	symbolMap = objectMap( formatProperties[ 18 ], function( pair ) {
		return [ pair[ 0 ], looseMatching( pair[ 1 ] ) ];
	});
	nuDigitsMap = formatProperties[ 19 ];

	invertedSymbolMap = objectMap( numberSymbolInvertedMap( cldr ), function( pair ) {
		return [ looseMatching( pair[ 0 ] ), pair[ 1 ] ];
	});

	digitsRe = nuDigitsMap ? "[" + nuDigitsMap + "]" : "\\d";
	groupingSeparatorRe = regexpEscape( symbolMap[ "," ] );
	decimalSymbolRe = regexpEscape( symbolMap[ "." ] );

	if ( nuDigitsMap ) {
		invertedNuDigitsMap = nuDigitsMap.split( "" ).reduce(function( object, localizedDigit, i ) {
			object[ localizedDigit ] = String( i );
			return object;
		}, {} );
	}

	aux = [ prefix, suffix, negativePrefix, negativeSuffix ].map(function( value ) {
		return value.replace( /('([^']|'')+'|'')|./g, function( character, literal ) {

			// Literals
			if ( literal ) {
				return removeLiteralQuotes( literal );
			}

			// Symbols
			character = character.replace( /[\-+E%\u2030]/, function( symbol ) {
				return symbolMap[ symbol ];
			});

			return character;
		});
	});

	prefix = aux[ 0 ];
	suffix = aux[ 1 ];
	negativePrefix = aux[ 2 ];
	negativeSuffix = aux[ 3 ];

	// Number
	//
	// number_re =                       integer fraction?
	//
	// integer =                         digits | digits_using_grouping_separators
	//
	// fraction =                        regexp((.\d+)?)
	//
	// digits =                          regexp(\d+)
	//
	// digits_w_grouping_separators =    digits_w_1_grouping_separators |
	//                                   digits_w_2_grouping_separators
	//
	// digits_w_1_grouping_separators =  regexp(\d{1,3}(,\d{3})+)
	//
	// digits_w_2_grouping_separators =  regexp(\d{1,2}((,\d{2})*(,\d{3})))

	// Integer part
	numberTokenizer = digitsRe + "+";

	// Grouping separators
	if ( primaryGroupingSize ) {
		if ( secondaryGroupingSize ) {
			aux = digitsRe + "{1," + secondaryGroupingSize + "}((" + groupingSeparatorRe +
				digitsRe + "{" + secondaryGroupingSize + "})*(" + groupingSeparatorRe +
				digitsRe + "{" + primaryGroupingSize + "}))";
		} else {
			aux = digitsRe + "{1," + primaryGroupingSize + "}(" + groupingSeparatorRe +
				digitsRe + "{" + primaryGroupingSize + "})+";
		}
		numberTokenizer = "(" + aux + "|" + numberTokenizer + ")";
	}

	// Fraction part? Only included if 1 or 2.
	// 1: Using significant digit format.
	// 2: Using integer and fractional format && it has a maximumFractionDigits.
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) || /* 1 */
				maximumFractionDigits /* 2 */ ) {

		// 1: Handle trailing decimal separator, e.g., `"1." => `1``.
		aux = decimalSymbolRe + digitsRe + "+";
		numberTokenizer = numberTokenizer + "(" + aux + "|" + decimalSymbolRe /* 1 */ + ")?" +

			// Handle non-padded decimals, e.g., `".12"` => `0.12` by making the integer part
			// optional.
			"|(" + numberTokenizer + ")?" + aux;

		numberTokenizer = "(" + numberTokenizer + ")";
	}

	// 0: @invertedSymbolMap [Object] Inverted symbol map.
	// 1: @invertedNuDigitsMap [Object] Inverted digits map if numbering system is different than
	//    `latn`.
	// 2: @tokenizer [Object] Tokenizer map, used by parser to consume input.
	return [
		invertedSymbolMap,
		invertedNuDigitsMap,
		{
			infinity: new RegExp( "^" + regexpEscape( infinitySymbol ) ),
			nan:  new RegExp( "^" + regexpEscape( nanSymbol ) ),
			negativePrefix: new RegExp( "^" + regexpEscape( negativePrefix ) ),
			negativeSuffix: new RegExp( "^" + regexpEscape( negativeSuffix ) ),
			number: new RegExp( "^" + numberTokenizer ),
			prefix: new RegExp( "^" + regexpEscape( prefix ) ),
			suffix: new RegExp( "^" + regexpEscape( suffix ) )
		}
	];

};




/**
 * Pattern( style )
 *
 * @style [String] "decimal" (default) or "percent".
 *
 * @cldr [Cldr instance].
 */
var numberPattern = function( style, cldr ) {
	if ( style !== "decimal" && style !== "percent" ) {
		throw new Error( "Invalid style" );
	}

	return cldr.main([
		"numbers",
		style + "Formats-numberSystem-" + numberNumberingSystem( cldr ),
		"standard"
	]);
};




function validateDigits( properties ) {
	var minimumIntegerDigits = properties[ 2 ],
		minimumFractionDigits = properties[ 3 ],
		maximumFractionDigits = properties[ 4 ],
		minimumSignificantDigits = properties[ 5 ],
		maximumSignificantDigits = properties[ 6 ];

	// Validate significant digit format properties
	if ( !isNaN( minimumSignificantDigits * maximumSignificantDigits ) ) {
		validateParameterRange( minimumSignificantDigits, "minimumSignificantDigits", 1, 21 );
		validateParameterRange( maximumSignificantDigits, "maximumSignificantDigits",
			minimumSignificantDigits, 21 );

	} else if ( !isNaN( minimumSignificantDigits ) || !isNaN( maximumSignificantDigits ) ) {
		throw new Error( "Neither or both the minimum and maximum significant digits must be " +
			"present" );

	// Validate integer and fractional format
	} else {
		validateParameterRange( minimumIntegerDigits, "minimumIntegerDigits", 1, 21 );
		validateParameterRange( minimumFractionDigits, "minimumFractionDigits", 0, 20 );
		validateParameterRange( maximumFractionDigits, "maximumFractionDigits",
			minimumFractionDigits, 20 );
	}
}

/**
 * .numberFormatter( [options] )
 *
 * @options [Object]:
 * - style: [String] "decimal" (default) or "percent".
 * - see also number/format options.
 *
 * Return a function that formats a number according to the given options and default/instance
 * locale.
 */
Globalize.numberFormatter =
Globalize.prototype.numberFormatter = function( options ) {
	var args, cldr, pattern, properties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );

	if ( options.raw ) {
		pattern = options.raw;
	} else {
		pattern = numberPattern( options.style || "decimal", cldr );
	}

	properties = numberFormatProperties( pattern, cldr, options );

	cldr.off( "get", validateCldr );

	validateDigits( properties );

	returnFn = numberFormatterFn( properties );

	runtimeBind( args, cldr, returnFn, [ properties ] );

	return returnFn;
};

/**
 * .numberParser( [options] )
 *
 * @options [Object]:
 * - style: [String] "decimal" (default) or "percent".
 *
 * Return the number parser according to the default/instance locale.
 */
Globalize.numberParser =
Globalize.prototype.numberParser = function( options ) {
	var args, cldr, pattern, properties, returnFn;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );

	if ( options.raw ) {
		pattern = options.raw;
	} else {
		pattern = numberPattern( options.style || "decimal", cldr );
	}

	properties = numberParseProperties( pattern, cldr, options );

	cldr.off( "get", validateCldr );

	returnFn = numberParserFn( properties );

	runtimeBind( args, cldr, returnFn, [ properties ] );

	return returnFn;
};

/**
 * .formatNumber( value [, options] )
 *
 * @value [Number] number to be formatted.
 *
 * @options [Object]: see number/format-properties.
 *
 * Format a number according to the given options and default/instance locale.
 */
Globalize.formatNumber =
Globalize.prototype.formatNumber = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.numberFormatter( options )( value );
};

/**
 * .parseNumber( value [, options] )
 *
 * @value [String]
 *
 * @options [Object]: See numberParser().
 *
 * Return the parsed Number (including Infinity) or NaN when value is invalid.
 */
Globalize.parseNumber =
Globalize.prototype.parseNumber = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeString( value, "value" );

	return this.numberParser( options )( value );
};

/**
 * Optimization to avoid duplicating some internal functions across modules.
 */
Globalize._createErrorUnsupportedFeature = createErrorUnsupportedFeature;
Globalize._numberNumberingSystem = numberNumberingSystem;
Globalize._numberNumberingSystemDigitsMap = numberNumberingSystemDigitsMap;
Globalize._numberPattern = numberPattern;
Globalize._numberSymbol = numberSymbol;
Globalize._looseMatching = looseMatching;
Globalize._removeLiteralQuotes = removeLiteralQuotes;
Globalize._stringPad = stringPad;
Globalize._validateParameterTypeNumber = validateParameterTypeNumber;
Globalize._validateParameterTypeString = validateParameterTypeString;

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/plural.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var runtimeBind = Globalize._runtimeBind,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterType = Globalize._validateParameterType,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject;
var MakePlural;
/* jshint ignore:start */
MakePlural = (function() {
'use strict';

var _toArray = function (arr) { return Array.isArray(arr) ? arr : Array.from(arr); };

var _toConsumableArray = function (arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } };

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } };

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();


/**
 * make-plural.js -- https://github.com/eemeli/make-plural.js/
 * Copyright (c) 2014-2015 by Eemeli Aro <eemeli@gmail.com>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * The software is provided "as is" and the author disclaims all warranties
 * with regard to this software including all implied warranties of
 * merchantability and fitness. In no event shall the author be liable for
 * any special, direct, indirect, or consequential damages or any damages
 * whatsoever resulting from loss of use, data or profits, whether in an
 * action of contract, negligence or other tortious action, arising out of
 * or in connection with the use or performance of this software.
 */

var Parser = (function () {
    function Parser() {
        _classCallCheck(this, Parser);
    }

    _createClass(Parser, [{
        key: 'parse',
        value: function parse(cond) {
            var _this = this;

            if (cond === 'i = 0 or n = 1') {
                return 'n >= 0 && n <= 1';
            }if (cond === 'i = 0,1') {
                return 'n >= 0 && n < 2';
            }if (cond === 'i = 1 and v = 0') {
                this.v0 = 1;
                return 'n == 1 && v0';
            }
            return cond.replace(/([tv]) (!?)= 0/g, function (m, sym, noteq) {
                var sn = sym + '0';
                _this[sn] = 1;
                return noteq ? '!' + sn : sn;
            }).replace(/\b[fintv]\b/g, function (m) {
                _this[m] = 1;
                return m;
            }).replace(/([fin]) % (10+)/g, function (m, sym, num) {
                var sn = sym + num;
                _this[sn] = 1;
                return sn;
            }).replace(/n10+ = 0/g, 't0 && $&').replace(/(\w+ (!?)= )([0-9.]+,[0-9.,]+)/g, function (m, se, noteq, x) {
                if (m === 'n = 0,1') return '(n == 0 || n == 1)';
                if (noteq) return se + x.split(',').join(' && ' + se);
                return '(' + se + x.split(',').join(' || ' + se) + ')';
            }).replace(/(\w+) (!?)= ([0-9]+)\.\.([0-9]+)/g, function (m, sym, noteq, x0, x1) {
                if (Number(x0) + 1 === Number(x1)) {
                    if (noteq) return '' + sym + ' != ' + x0 + ' && ' + sym + ' != ' + x1;
                    return '(' + sym + ' == ' + x0 + ' || ' + sym + ' == ' + x1 + ')';
                }
                if (noteq) return '(' + sym + ' < ' + x0 + ' || ' + sym + ' > ' + x1 + ')';
                if (sym === 'n') {
                    _this.t0 = 1;return '(t0 && n >= ' + x0 + ' && n <= ' + x1 + ')';
                }
                return '(' + sym + ' >= ' + x0 + ' && ' + sym + ' <= ' + x1 + ')';
            }).replace(/ and /g, ' && ').replace(/ or /g, ' || ').replace(/ = /g, ' == ');
        }
    }, {
        key: 'vars',
        value: (function (_vars) {
            function vars() {
                return _vars.apply(this, arguments);
            }

            vars.toString = function () {
                return _vars.toString();
            };

            return vars;
        })(function () {
            var vars = [];
            if (this.i) vars.push('i = s[0]');
            if (this.f || this.v) vars.push('f = s[1] || \'\'');
            if (this.t) vars.push('t = (s[1] || \'\').replace(/0+$/, \'\')');
            if (this.v) vars.push('v = f.length');
            if (this.v0) vars.push('v0 = !s[1]');
            if (this.t0 || this.n10 || this.n100) vars.push('t0 = Number(s[0]) == n');
            for (var k in this) {
                if (/^.10+$/.test(k)) {
                    var k0 = k[0] === 'n' ? 't0 && s[0]' : k[0];
                    vars.push('' + k + ' = ' + k0 + '.slice(-' + k.substr(2).length + ')');
                }
            }if (!vars.length) return '';
            return 'var ' + ['s = String(n).split(\'.\')'].concat(vars).join(', ');
        })
    }]);

    return Parser;
})();



var MakePlural = (function () {
    function MakePlural(lc) {
        var _ref = arguments[1] === undefined ? MakePlural : arguments[1];

        var cardinals = _ref.cardinals;
        var ordinals = _ref.ordinals;

        _classCallCheck(this, MakePlural);

        if (!cardinals && !ordinals) throw new Error('At least one type of plural is required');
        this.lc = lc;
        this.categories = { cardinal: [], ordinal: [] };
        this.parser = new Parser();
        
        this.fn = this.buildFunction(cardinals, ordinals);
        this.fn._obj = this;
        this.fn.categories = this.categories;
        
        this.fn.toString = this.fnToString.bind(this);
        return this.fn;
    }

    _createClass(MakePlural, [{
        key: 'compile',
        value: function compile(type, req) {
            var cases = [];
            var rules = MakePlural.rules[type][this.lc];
            if (!rules) {
                if (req) throw new Error('Locale "' + this.lc + '" ' + type + ' rules not found');
                this.categories[type] = ['other'];
                return '\'other\'';
            }
            for (var r in rules) {
                var _rules$r$trim$split = rules[r].trim().split(/\s*@\w*/);

                var _rules$r$trim$split2 = _toArray(_rules$r$trim$split);

                var cond = _rules$r$trim$split2[0];
                var examples = _rules$r$trim$split2.slice(1);
                var cat = r.replace('pluralRule-count-', '');
                if (cond) cases.push([this.parser.parse(cond), cat]);
                
            }
            this.categories[type] = cases.map(function (c) {
                return c[1];
            }).concat('other');
            if (cases.length === 1) {
                return '(' + cases[0][0] + ') ? \'' + cases[0][1] + '\' : \'other\'';
            } else {
                return [].concat(_toConsumableArray(cases.map(function (c) {
                    return '(' + c[0] + ') ? \'' + c[1] + '\'';
                })), ['\'other\'']).join('\n      : ');
            }
        }
    }, {
        key: 'buildFunction',
        value: function buildFunction(cardinals, ordinals) {
            var _this3 = this;

            var compile = function compile(c) {
                return c ? (c[1] ? 'return ' : 'if (ord) return ') + _this3.compile.apply(_this3, _toConsumableArray(c)) : '';
            },
                fold = { vars: function vars(str) {
                    return ('  ' + str + ';').replace(/(.{1,78})(,|$) ?/g, '$1$2\n      ');
                },
                cond: function cond(str) {
                    return ('  ' + str + ';').replace(/(.{1,78}) (\|\| |$) ?/gm, '$1\n          $2');
                } },
                cond = [ordinals && ['ordinal', !cardinals], cardinals && ['cardinal', true]].map(compile).map(fold.cond),
                body = [fold.vars(this.parser.vars())].concat(_toConsumableArray(cond)).join('\n').replace(/\s+$/gm, '').replace(/^[\s;]*[\r\n]+/gm, ''),
                args = ordinals && cardinals ? 'n, ord' : 'n';
            return new Function(args, body);
        }
    }, {
        key: 'fnToString',
        value: function fnToString(name) {
            return Function.prototype.toString.call(this.fn).replace(/^function( \w+)?/, name ? 'function ' + name : 'function').replace('\n/**/', '');
        }
    }], [{
        key: 'load',
        value: function load() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            args.forEach(function (cldr) {
                var data = cldr && cldr.supplemental || null;
                if (!data) throw new Error('Data does not appear to be CLDR data');
                MakePlural.rules = {
                    cardinal: data['plurals-type-cardinal'] || MakePlural.rules.cardinal,
                    ordinal: data['plurals-type-ordinal'] || MakePlural.rules.ordinal
                };
            });
            return MakePlural;
        }
    }]);

    return MakePlural;
})();



MakePlural.cardinals = true;
MakePlural.ordinals = false;
MakePlural.rules = { cardinal: {}, ordinal: {} };


return MakePlural;
}());
/* jshint ignore:end */


var validateParameterTypeNumber = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || typeof value === "number",
		"Number"
	);
};




var validateParameterTypePluralType = function( value, name ) {
	validateParameterType(
		value,
		name,
		value === undefined || value === "cardinal" || value === "ordinal",
		"String \"cardinal\" or \"ordinal\""
	);
};




var pluralGeneratorFn = function( plural ) {
	return function pluralGenerator( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return plural( value );
	};
};




/**
 * .plural( value )
 *
 * @value [Number]
 *
 * Return the corresponding form (zero | one | two | few | many | other) of a
 * value given locale.
 */
Globalize.plural =
Globalize.prototype.plural = function( value, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );
	return this.pluralGenerator( options )( value );
};

/**
 * .pluralGenerator( [options] )
 *
 * Return a plural function (of the form below).
 *
 * fn( value )
 *
 * @value [Number]
 *
 * Return the corresponding form (zero | one | two | few | many | other) of a value given the
 * default/instance locale.
 */
Globalize.pluralGenerator =
Globalize.prototype.pluralGenerator = function( options ) {
	var args, cldr, isOrdinal, plural, returnFn, type;

	validateParameterTypePlainObject( options, "options" );

	options = options || {};
	cldr = this.cldr;

	args = [ options ];
	type = options.type || "cardinal";

	validateParameterTypePluralType( options.type, "options.type" );

	validateDefaultLocale( cldr );

	isOrdinal = type === "ordinal";

	cldr.on( "get", validateCldr );
	cldr.supplemental([ "plurals-type-" + type, "{language}" ]);
	cldr.off( "get", validateCldr );

	MakePlural.rules = {};
	MakePlural.rules[ type ] = cldr.supplemental( "plurals-type-" + type );

	plural = new MakePlural( cldr.attributes.language, {
		"ordinals": isOrdinal,
		"cardinals": !isOrdinal
	});

	returnFn = pluralGeneratorFn( plural );

	runtimeBind( args, cldr, returnFn, [ plural ] );

	return returnFn;
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/relative-time.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"./plural",
			"cldr/event",
			"cldr/supplemental"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var formatMessage = Globalize._formatMessage,
	runtimeBind = Globalize._runtimeBind,
	validateCldr = Globalize._validateCldr,
	validateDefaultLocale = Globalize._validateDefaultLocale,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterTypeString = Globalize._validateParameterTypeString,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber;


/**
 * format( value, numberFormatter, pluralGenerator, properties )
 *
 * @value [Number] The number to format
 *
 * @numberFormatter [String] A numberFormatter from Globalize.numberFormatter
 *
 * @pluralGenerator [String] A pluralGenerator from Globalize.pluralGenerator
 *
 * @properties [Object] containing relative time plural message.
 *
 * Format relative time.
 */
var relativeTimeFormat = function( value, numberFormatter, pluralGenerator, properties ) {

	var relativeTime,
		message = properties[ "relative-type-" + value ];

	if ( message ) {
		return message;
	}

	relativeTime = value <= 0 ? properties[ "relativeTime-type-past" ]
		: properties[ "relativeTime-type-future" ];

	value = Math.abs( value );

	message = relativeTime[ "relativeTimePattern-count-" + pluralGenerator( value ) ];
	return formatMessage( message, [ numberFormatter( value ) ] );
};




var relativeTimeFormatterFn = function( numberFormatter, pluralGenerator, properties ) {
	return function relativeTimeFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return relativeTimeFormat( value, numberFormatter, pluralGenerator, properties );
	};

};




/**
 * properties( unit, cldr, options )
 *
 * @unit [String] eg. "day", "week", "month", etc.
 *
 * @cldr [Cldr instance].
 *
 * @options [Object]
 * - form: [String] eg. "short" or "narrow". Or falsy for default long form.
 *
 * Return relative time properties.
 */
var relativeTimeProperties = function( unit, cldr, options ) {

	var form = options.form,
		raw, properties, key, match;

	if ( form ) {
		unit = unit + "-" + form;
	}

	raw = cldr.main( [ "dates", "fields", unit ] );
	properties = {
		"relativeTime-type-future": raw[ "relativeTime-type-future" ],
		"relativeTime-type-past": raw[ "relativeTime-type-past" ]
	};
	for ( key in raw ) {
		if ( raw.hasOwnProperty( key ) ) {
			match = /relative-type-(-?[0-9]+)/.exec( key );
			if ( match ) {
				properties[ key ] = raw[ key ];
			}
		}
	}

	return properties;
};




/**
 * .formatRelativeTime( value, unit [, options] )
 *
 * @value [Number] The number of unit to format.
 *
 * @unit [String] see .relativeTimeFormatter() for details.
 *
 * @options [Object] see .relativeTimeFormatter() for details.
 *
 * Formats a relative time according to the given unit, options, and the default/instance locale.
 */
Globalize.formatRelativeTime =
Globalize.prototype.formatRelativeTime = function( value, unit, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.relativeTimeFormatter( unit, options )( value );
};

/**
 * .relativeTimeFormatter( unit [, options ])
 *
 * @unit [String] String value indicating the unit to be formatted. eg. "day", "week", "month", etc.
 *
 * @options [Object]
 * - form: [String] eg. "short" or "narrow". Or falsy for default long form.
 *
 * Returns a function that formats a relative time according to the given unit, options, and the
 * default/instance locale.
 */
Globalize.relativeTimeFormatter =
Globalize.prototype.relativeTimeFormatter = function( unit, options ) {
	var args, cldr, numberFormatter, pluralGenerator, properties, returnFn;

	validateParameterPresence( unit, "unit" );
	validateParameterTypeString( unit, "unit" );

	cldr = this.cldr;
	options = options || {};

	args = [ unit, options ];

	validateDefaultLocale( cldr );

	cldr.on( "get", validateCldr );
	properties = relativeTimeProperties( unit, cldr, options );
	cldr.off( "get", validateCldr );

	numberFormatter = this.numberFormatter( options );
	pluralGenerator = this.pluralGenerator();

	returnFn = relativeTimeFormatterFn( numberFormatter, pluralGenerator, properties );

	runtimeBind( args, cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );

	return returnFn;
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/globalize/unit.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/**
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */
/*!
 * Globalize v1.3.0 2017-07-03T21:37Z Released under the MIT license
 * http://git.io/TrdQbw
 */
(function( root, factory ) {

	// UMD returnExports
	if ( typeof define === "function" && define.amd ) {

		// AMD
		define([
			"cldr",
			"../globalize",
			"./number",
			"./plural"
		], factory );
	} else if ( true ) {

		// Node, CommonJS
		module.exports = factory( __webpack_require__( "./node_modules/cldrjs/dist/node_main.js" ), __webpack_require__( "./node_modules/globalize/dist/globalize.js" ) );
	} else {

		// Extend global
		factory( root.Cldr, root.Globalize );
	}
}(this, function( Cldr, Globalize ) {

var formatMessage = Globalize._formatMessage,
	runtimeBind = Globalize._runtimeBind,
	validateParameterPresence = Globalize._validateParameterPresence,
	validateParameterTypePlainObject = Globalize._validateParameterTypePlainObject,
	validateParameterTypeNumber = Globalize._validateParameterTypeNumber,
	validateParameterTypeString = Globalize._validateParameterTypeString;


/**
 * format( value, numberFormatter, pluralGenerator, unitProperies )
 *
 * @value [Number]
 *
 * @numberFormatter [Object]: A numberFormatter from Globalize.numberFormatter.
 *
 * @pluralGenerator [Object]: A pluralGenerator from Globalize.pluralGenerator.
 *
 * @unitProperies [Object]: localized unit data from cldr.
 *
 * Format units such as seconds, minutes, days, weeks, etc.
 *
 * OBS:
 *
 * Unit Sequences are not implemented.
 * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#Unit_Sequences
 *
 * Duration Unit (for composed time unit durations) is not implemented.
 * http://www.unicode.org/reports/tr35/tr35-35/tr35-general.html#durationUnit
 */
var unitFormat = function( value, numberFormatter, pluralGenerator, unitProperties ) {
	var compoundUnitPattern = unitProperties.compoundUnitPattern, dividend, dividendProperties,
		formattedValue, divisor, divisorProperties, message, pluralValue;

	unitProperties = unitProperties.unitProperties;
	formattedValue = numberFormatter( value );
	pluralValue = pluralGenerator( value );

	// computed compound unit, eg. "megabyte-per-second".
	if ( unitProperties instanceof Array ) {
		dividendProperties = unitProperties[ 0 ];
		divisorProperties = unitProperties[ 1 ];

		dividend = formatMessage( dividendProperties[ pluralValue ], [ value ] );
		divisor = formatMessage( divisorProperties.one, [ "" ] ).trim();

		return formatMessage( compoundUnitPattern, [ dividend, divisor ] );
	}

	message = unitProperties[ pluralValue ];

	return formatMessage( message, [ formattedValue ] );
};




var unitFormatterFn = function( numberFormatter, pluralGenerator, unitProperties ) {
	return function unitFormatter( value ) {
		validateParameterPresence( value, "value" );
		validateParameterTypeNumber( value, "value" );

		return unitFormat( value, numberFormatter, pluralGenerator, unitProperties );
	};

};




/**
 * categories()
 *
 * Return all unit categories.
 */
var unitCategories = [ "acceleration", "angle", "area", "digital", "duration", "length", "mass", "power",
"pressure", "speed", "temperature", "volume" ];




function stripPluralGarbage( data ) {
	var aux, pluralCount;

	if ( data ) {
		aux = {};
		for ( pluralCount in data ) {
			aux[ pluralCount.replace( /unitPattern-count-/, "" ) ] = data[ pluralCount ];
		}
	}

	return aux;
}

/**
 * get( unit, form, cldr )
 *
 * @unit [String] The full type-unit name (eg. duration-second), or the short unit name
 * (eg. second).
 *
 * @form [String] A string describing the form of the unit representation (eg. long,
 * short, narrow).
 *
 * @cldr [Cldr instance].
 *
 * Return the plural map of a unit, eg: "second"
 * { "one": "{0} second",
 *   "other": "{0} seconds" }
 * }
 *
 * Or the Array of plural maps of a compound-unit, eg: "foot-per-second"
 * [ { "one": "{0} foot",
 *     "other": "{0} feet" },
 *   { "one": "{0} second",
 *     "other": "{0} seconds" } ]
 *
 * Uses the precomputed form of a compound-unit if available, eg: "mile-per-hour"
 * { "displayName": "miles per hour",
 *    "unitPattern-count-one": "{0} mile per hour",
 *    "unitPattern-count-other": "{0} miles per hour"
 * },
 *
 * Also supports "/" instead of "-per-", eg. "foot/second", using the precomputed form if
 * available.
 *
 * Or the Array of plural maps of a compound-unit, eg: "foot-per-second"
 * [ { "one": "{0} foot",
 *     "other": "{0} feet" },
 *   { "one": "{0} second",
 *     "other": "{0} seconds" } ]
 *
 * Or undefined in case the unit (or a unit of the compound-unit) doesn't exist.
 */
var get = function( unit, form, cldr ) {
	var ret;

	// Ensure that we get the 'precomputed' form, if present.
	unit = unit.replace( /\//, "-per-" );

	// Get unit or <category>-unit (eg. "duration-second").
	[ "" ].concat( unitCategories ).some(function( category ) {
		return ret = cldr.main([
			"units",
			form,
			category.length ? category + "-" + unit : unit
		]);
	});

	// Rename keys s/unitPattern-count-//g.
	ret = stripPluralGarbage( ret );

	// Compound Unit, eg. "foot-per-second" or "foot/second".
	if ( !ret && ( /-per-/ ).test( unit ) ) {

		// "Some units already have 'precomputed' forms, such as kilometer-per-hour;
		// where such units exist, they should be used in preference" UTS#35.
		// Note that precomputed form has already been handled above (!ret).

		// Get both recursively.
		unit = unit.split( "-per-" );
		ret = unit.map(function( unit ) {
			return get( unit, form, cldr );
		});
		if ( !ret[ 0 ] || !ret[ 1 ] ) {
			return;
		}
	}

	return ret;
};

var unitGet = get;




/**
 * properties( unit, form, cldr )
 *
 * @unit [String] The full type-unit name (eg. duration-second), or the short unit name
 * (eg. second).
 *
 * @form [String] A string describing the form of the unit representation (eg. long,
 * short, narrow).
 *
 * @cldr [Cldr instance].
 */
var unitProperties = function( unit, form, cldr ) {
	var compoundUnitPattern, unitProperties;

	compoundUnitPattern = cldr.main( [ "units", form, "per/compoundUnitPattern" ] );
	unitProperties = unitGet( unit, form, cldr );

	return {
		compoundUnitPattern: compoundUnitPattern,
		unitProperties: unitProperties
	};
};




/**
 * Globalize.formatUnit( value, unit, options )
 *
 * @value [Number]
 *
 * @unit [String]: The unit (e.g "second", "day", "year")
 *
 * @options [Object]
 * - form: [String] "long", "short" (default), or "narrow".
 *
 * Format units such as seconds, minutes, days, weeks, etc.
 */
Globalize.formatUnit =
Globalize.prototype.formatUnit = function( value, unit, options ) {
	validateParameterPresence( value, "value" );
	validateParameterTypeNumber( value, "value" );

	return this.unitFormatter( unit, options )( value );
};

/**
 * Globalize.unitFormatter( unit, options )
 *
 * @unit [String]: The unit (e.g "second", "day", "year")
 *
 * @options [Object]
 * - form: [String] "long", "short" (default), or "narrow".
 *
 * - numberFormatter: [Function] a number formatter function. Defaults to Globalize
 *   `.numberFormatter()` for the current locale using the default options.
 */
Globalize.unitFormatter =
Globalize.prototype.unitFormatter = function( unit, options ) {
	var args, form, numberFormatter, pluralGenerator, returnFn, properties;

	validateParameterPresence( unit, "unit" );
	validateParameterTypeString( unit, "unit" );

	validateParameterTypePlainObject( options, "options" );

	options = options || {};

	args = [ unit, options ];
	form = options.form || "long";
	properties = unitProperties( unit, form, this.cldr );

	numberFormatter = options.numberFormatter || this.numberFormatter();
	pluralGenerator = this.pluralGenerator();
	returnFn = unitFormatterFn( numberFormatter, pluralGenerator, properties );

	runtimeBind( args, this.cldr, returnFn, [ numberFormatter, pluralGenerator, properties ] );

	return returnFn;
};

return Globalize;




}));



/***/ }),

/***/ "./node_modules/globalize/dist/node-main.js":
/***/ (function(module, exports, __webpack_require__) {

/*** IMPORTS FROM imports-loader ***/
var define = false;

/*!
 * Globalize v1.3.0
 *
 * http://github.com/jquery/globalize
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2017-07-03T21:37Z
 */

// Core
module.exports = __webpack_require__( "./node_modules/globalize/dist/globalize.js" );

// Extent core with the following modules
__webpack_require__( "./node_modules/globalize/dist/globalize/message.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/number.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/plural.js" );

// Load after globalize/number
__webpack_require__( "./node_modules/globalize/dist/globalize/currency.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/date.js" );

// Load after globalize/number and globalize/plural
__webpack_require__( "./node_modules/globalize/dist/globalize/relative-time.js" );
__webpack_require__( "./node_modules/globalize/dist/globalize/unit.js" );



/***/ }),

/***/ "./node_modules/intersection-observer/intersection-observer.js":
/***/ (function(module, exports) {

/**
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

(function(window, document) {
'use strict';


// Exits early if all IntersectionObserver and IntersectionObserverEntry
// features are natively supported.
if ('IntersectionObserver' in window &&
    'IntersectionObserverEntry' in window &&
    'intersectionRatio' in window.IntersectionObserverEntry.prototype) {

  // Minimal polyfill for Edge 15's lack of `isIntersecting`
  // See: https://github.com/WICG/IntersectionObserver/issues/211
  if (!('isIntersecting' in window.IntersectionObserverEntry.prototype)) {
    Object.defineProperty(window.IntersectionObserverEntry.prototype,
      'isIntersecting', {
      get: function () {
        return this.intersectionRatio > 0;
      }
    });
  }
  return;
}


/**
 * An IntersectionObserver registry. This registry exists to hold a strong
 * reference to IntersectionObserver instances currently observering a target
 * element. Without this registry, instances without another reference may be
 * garbage collected.
 */
var registry = [];


/**
 * Creates the global IntersectionObserverEntry constructor.
 * https://wicg.github.io/IntersectionObserver/#intersection-observer-entry
 * @param {Object} entry A dictionary of instance properties.
 * @constructor
 */
function IntersectionObserverEntry(entry) {
  this.time = entry.time;
  this.target = entry.target;
  this.rootBounds = entry.rootBounds;
  this.boundingClientRect = entry.boundingClientRect;
  this.intersectionRect = entry.intersectionRect || getEmptyRect();
  this.isIntersecting = !!entry.intersectionRect;

  // Calculates the intersection ratio.
  var targetRect = this.boundingClientRect;
  var targetArea = targetRect.width * targetRect.height;
  var intersectionRect = this.intersectionRect;
  var intersectionArea = intersectionRect.width * intersectionRect.height;

  // Sets intersection ratio.
  if (targetArea) {
    this.intersectionRatio = intersectionArea / targetArea;
  } else {
    // If area is zero and is intersecting, sets to 1, otherwise to 0
    this.intersectionRatio = this.isIntersecting ? 1 : 0;
  }
}


/**
 * Creates the global IntersectionObserver constructor.
 * https://wicg.github.io/IntersectionObserver/#intersection-observer-interface
 * @param {Function} callback The function to be invoked after intersection
 *     changes have queued. The function is not invoked if the queue has
 *     been emptied by calling the `takeRecords` method.
 * @param {Object=} opt_options Optional configuration options.
 * @constructor
 */
function IntersectionObserver(callback, opt_options) {

  var options = opt_options || {};

  if (typeof callback != 'function') {
    throw new Error('callback must be a function');
  }

  if (options.root && options.root.nodeType != 1) {
    throw new Error('root must be an Element');
  }

  // Binds and throttles `this._checkForIntersections`.
  this._checkForIntersections = throttle(
      this._checkForIntersections.bind(this), this.THROTTLE_TIMEOUT);

  // Private properties.
  this._callback = callback;
  this._observationTargets = [];
  this._queuedEntries = [];
  this._rootMarginValues = this._parseRootMargin(options.rootMargin);

  // Public properties.
  this.thresholds = this._initThresholds(options.threshold);
  this.root = options.root || null;
  this.rootMargin = this._rootMarginValues.map(function(margin) {
    return margin.value + margin.unit;
  }).join(' ');
}


/**
 * The minimum interval within which the document will be checked for
 * intersection changes.
 */
IntersectionObserver.prototype.THROTTLE_TIMEOUT = 100;


/**
 * The frequency in which the polyfill polls for intersection changes.
 * this can be updated on a per instance basis and must be set prior to
 * calling `observe` on the first target.
 */
IntersectionObserver.prototype.POLL_INTERVAL = null;


/**
 * Starts observing a target element for intersection changes based on
 * the thresholds values.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.observe = function(target) {
  // If the target is already being observed, do nothing.
  if (this._observationTargets.some(function(item) {
    return item.element == target;
  })) {
    return;
  }

  if (!(target && target.nodeType == 1)) {
    throw new Error('target must be an Element');
  }

  this._registerInstance();
  this._observationTargets.push({element: target, entry: null});
  this._monitorIntersections();
  this._checkForIntersections();
};


/**
 * Stops observing a target element for intersection changes.
 * @param {Element} target The DOM element to observe.
 */
IntersectionObserver.prototype.unobserve = function(target) {
  this._observationTargets =
      this._observationTargets.filter(function(item) {

    return item.element != target;
  });
  if (!this._observationTargets.length) {
    this._unmonitorIntersections();
    this._unregisterInstance();
  }
};


/**
 * Stops observing all target elements for intersection changes.
 */
IntersectionObserver.prototype.disconnect = function() {
  this._observationTargets = [];
  this._unmonitorIntersections();
  this._unregisterInstance();
};


/**
 * Returns any queue entries that have not yet been reported to the
 * callback and clears the queue. This can be used in conjunction with the
 * callback to obtain the absolute most up-to-date intersection information.
 * @return {Array} The currently queued entries.
 */
IntersectionObserver.prototype.takeRecords = function() {
  var records = this._queuedEntries.slice();
  this._queuedEntries = [];
  return records;
};


/**
 * Accepts the threshold value from the user configuration object and
 * returns a sorted array of unique threshold values. If a value is not
 * between 0 and 1 and error is thrown.
 * @private
 * @param {Array|number=} opt_threshold An optional threshold value or
 *     a list of threshold values, defaulting to [0].
 * @return {Array} A sorted list of unique and valid threshold values.
 */
IntersectionObserver.prototype._initThresholds = function(opt_threshold) {
  var threshold = opt_threshold || [0];
  if (!Array.isArray(threshold)) threshold = [threshold];

  return threshold.sort().filter(function(t, i, a) {
    if (typeof t != 'number' || isNaN(t) || t < 0 || t > 1) {
      throw new Error('threshold must be a number between 0 and 1 inclusively');
    }
    return t !== a[i - 1];
  });
};


/**
 * Accepts the rootMargin value from the user configuration object
 * and returns an array of the four margin values as an object containing
 * the value and unit properties. If any of the values are not properly
 * formatted or use a unit other than px or %, and error is thrown.
 * @private
 * @param {string=} opt_rootMargin An optional rootMargin value,
 *     defaulting to '0px'.
 * @return {Array<Object>} An array of margin objects with the keys
 *     value and unit.
 */
IntersectionObserver.prototype._parseRootMargin = function(opt_rootMargin) {
  var marginString = opt_rootMargin || '0px';
  var margins = marginString.split(/\s+/).map(function(margin) {
    var parts = /^(-?\d*\.?\d+)(px|%)$/.exec(margin);
    if (!parts) {
      throw new Error('rootMargin must be specified in pixels or percent');
    }
    return {value: parseFloat(parts[1]), unit: parts[2]};
  });

  // Handles shorthand.
  margins[1] = margins[1] || margins[0];
  margins[2] = margins[2] || margins[0];
  margins[3] = margins[3] || margins[1];

  return margins;
};


/**
 * Starts polling for intersection changes if the polling is not already
 * happening, and if the page's visibilty state is visible.
 * @private
 */
IntersectionObserver.prototype._monitorIntersections = function() {
  if (!this._monitoringIntersections) {
    this._monitoringIntersections = true;

    // If a poll interval is set, use polling instead of listening to
    // resize and scroll events or DOM mutations.
    if (this.POLL_INTERVAL) {
      this._monitoringInterval = setInterval(
          this._checkForIntersections, this.POLL_INTERVAL);
    }
    else {
      addEvent(window, 'resize', this._checkForIntersections, true);
      addEvent(document, 'scroll', this._checkForIntersections, true);

      if ('MutationObserver' in window) {
        this._domObserver = new MutationObserver(this._checkForIntersections);
        this._domObserver.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      }
    }
  }
};


/**
 * Stops polling for intersection changes.
 * @private
 */
IntersectionObserver.prototype._unmonitorIntersections = function() {
  if (this._monitoringIntersections) {
    this._monitoringIntersections = false;

    clearInterval(this._monitoringInterval);
    this._monitoringInterval = null;

    removeEvent(window, 'resize', this._checkForIntersections, true);
    removeEvent(document, 'scroll', this._checkForIntersections, true);

    if (this._domObserver) {
      this._domObserver.disconnect();
      this._domObserver = null;
    }
  }
};


/**
 * Scans each observation target for intersection changes and adds them
 * to the internal entries queue. If new entries are found, it
 * schedules the callback to be invoked.
 * @private
 */
IntersectionObserver.prototype._checkForIntersections = function() {
  var rootIsInDom = this._rootIsInDom();
  var rootRect = rootIsInDom ? this._getRootRect() : getEmptyRect();

  this._observationTargets.forEach(function(item) {
    var target = item.element;
    var targetRect = getBoundingClientRect(target);
    var rootContainsTarget = this._rootContainsTarget(target);
    var oldEntry = item.entry;
    var intersectionRect = rootIsInDom && rootContainsTarget &&
        this._computeTargetAndRootIntersection(target, rootRect);

    var newEntry = item.entry = new IntersectionObserverEntry({
      time: now(),
      target: target,
      boundingClientRect: targetRect,
      rootBounds: rootRect,
      intersectionRect: intersectionRect
    });

    if (!oldEntry) {
      this._queuedEntries.push(newEntry);
    } else if (rootIsInDom && rootContainsTarget) {
      // If the new entry intersection ratio has crossed any of the
      // thresholds, add a new entry.
      if (this._hasCrossedThreshold(oldEntry, newEntry)) {
        this._queuedEntries.push(newEntry);
      }
    } else {
      // If the root is not in the DOM or target is not contained within
      // root but the previous entry for this target had an intersection,
      // add a new record indicating removal.
      if (oldEntry && oldEntry.isIntersecting) {
        this._queuedEntries.push(newEntry);
      }
    }
  }, this);

  if (this._queuedEntries.length) {
    this._callback(this.takeRecords(), this);
  }
};


/**
 * Accepts a target and root rect computes the intersection between then
 * following the algorithm in the spec.
 * TODO(philipwalton): at this time clip-path is not considered.
 * https://wicg.github.io/IntersectionObserver/#calculate-intersection-rect-algo
 * @param {Element} target The target DOM element
 * @param {Object} rootRect The bounding rect of the root after being
 *     expanded by the rootMargin value.
 * @return {?Object} The final intersection rect object or undefined if no
 *     intersection is found.
 * @private
 */
IntersectionObserver.prototype._computeTargetAndRootIntersection =
    function(target, rootRect) {

  // If the element isn't displayed, an intersection can't happen.
  if (window.getComputedStyle(target).display == 'none') return;

  var targetRect = getBoundingClientRect(target);
  var intersectionRect = targetRect;
  var parent = getParentNode(target);
  var atRoot = false;

  while (!atRoot) {
    var parentRect = null;
    var parentComputedStyle = parent.nodeType == 1 ?
        window.getComputedStyle(parent) : {};

    // If the parent isn't displayed, an intersection can't happen.
    if (parentComputedStyle.display == 'none') return;

    if (parent == this.root || parent == document) {
      atRoot = true;
      parentRect = rootRect;
    } else {
      // If the element has a non-visible overflow, and it's not the <body>
      // or <html> element, update the intersection rect.
      // Note: <body> and <html> cannot be clipped to a rect that's not also
      // the document rect, so no need to compute a new intersection.
      if (parent != document.body &&
          parent != document.documentElement &&
          parentComputedStyle.overflow != 'visible') {
        parentRect = getBoundingClientRect(parent);
      }
    }

    // If either of the above conditionals set a new parentRect,
    // calculate new intersection data.
    if (parentRect) {
      intersectionRect = computeRectIntersection(parentRect, intersectionRect);

      if (!intersectionRect) break;
    }
    parent = getParentNode(parent);
  }
  return intersectionRect;
};


/**
 * Returns the root rect after being expanded by the rootMargin value.
 * @return {Object} The expanded root rect.
 * @private
 */
IntersectionObserver.prototype._getRootRect = function() {
  var rootRect;
  if (this.root) {
    rootRect = getBoundingClientRect(this.root);
  } else {
    // Use <html>/<body> instead of window since scroll bars affect size.
    var html = document.documentElement;
    var body = document.body;
    rootRect = {
      top: 0,
      left: 0,
      right: html.clientWidth || body.clientWidth,
      width: html.clientWidth || body.clientWidth,
      bottom: html.clientHeight || body.clientHeight,
      height: html.clientHeight || body.clientHeight
    };
  }
  return this._expandRectByRootMargin(rootRect);
};


/**
 * Accepts a rect and expands it by the rootMargin value.
 * @param {Object} rect The rect object to expand.
 * @return {Object} The expanded rect.
 * @private
 */
IntersectionObserver.prototype._expandRectByRootMargin = function(rect) {
  var margins = this._rootMarginValues.map(function(margin, i) {
    return margin.unit == 'px' ? margin.value :
        margin.value * (i % 2 ? rect.width : rect.height) / 100;
  });
  var newRect = {
    top: rect.top - margins[0],
    right: rect.right + margins[1],
    bottom: rect.bottom + margins[2],
    left: rect.left - margins[3]
  };
  newRect.width = newRect.right - newRect.left;
  newRect.height = newRect.bottom - newRect.top;

  return newRect;
};


/**
 * Accepts an old and new entry and returns true if at least one of the
 * threshold values has been crossed.
 * @param {?IntersectionObserverEntry} oldEntry The previous entry for a
 *    particular target element or null if no previous entry exists.
 * @param {IntersectionObserverEntry} newEntry The current entry for a
 *    particular target element.
 * @return {boolean} Returns true if a any threshold has been crossed.
 * @private
 */
IntersectionObserver.prototype._hasCrossedThreshold =
    function(oldEntry, newEntry) {

  // To make comparing easier, an entry that has a ratio of 0
  // but does not actually intersect is given a value of -1
  var oldRatio = oldEntry && oldEntry.isIntersecting ?
      oldEntry.intersectionRatio || 0 : -1;
  var newRatio = newEntry.isIntersecting ?
      newEntry.intersectionRatio || 0 : -1;

  // Ignore unchanged ratios
  if (oldRatio === newRatio) return;

  for (var i = 0; i < this.thresholds.length; i++) {
    var threshold = this.thresholds[i];

    // Return true if an entry matches a threshold or if the new ratio
    // and the old ratio are on the opposite sides of a threshold.
    if (threshold == oldRatio || threshold == newRatio ||
        threshold < oldRatio !== threshold < newRatio) {
      return true;
    }
  }
};


/**
 * Returns whether or not the root element is an element and is in the DOM.
 * @return {boolean} True if the root element is an element and is in the DOM.
 * @private
 */
IntersectionObserver.prototype._rootIsInDom = function() {
  return !this.root || containsDeep(document, this.root);
};


/**
 * Returns whether or not the target element is a child of root.
 * @param {Element} target The target element to check.
 * @return {boolean} True if the target element is a child of root.
 * @private
 */
IntersectionObserver.prototype._rootContainsTarget = function(target) {
  return containsDeep(this.root || document, target);
};


/**
 * Adds the instance to the global IntersectionObserver registry if it isn't
 * already present.
 * @private
 */
IntersectionObserver.prototype._registerInstance = function() {
  if (registry.indexOf(this) < 0) {
    registry.push(this);
  }
};


/**
 * Removes the instance from the global IntersectionObserver registry.
 * @private
 */
IntersectionObserver.prototype._unregisterInstance = function() {
  var index = registry.indexOf(this);
  if (index != -1) registry.splice(index, 1);
};


/**
 * Returns the result of the performance.now() method or null in browsers
 * that don't support the API.
 * @return {number} The elapsed time since the page was requested.
 */
function now() {
  return window.performance && performance.now && performance.now();
}


/**
 * Throttles a function and delays its executiong, so it's only called at most
 * once within a given time period.
 * @param {Function} fn The function to throttle.
 * @param {number} timeout The amount of time that must pass before the
 *     function can be called again.
 * @return {Function} The throttled function.
 */
function throttle(fn, timeout) {
  var timer = null;
  return function () {
    if (!timer) {
      timer = setTimeout(function() {
        fn();
        timer = null;
      }, timeout);
    }
  };
}


/**
 * Adds an event handler to a DOM node ensuring cross-browser compatibility.
 * @param {Node} node The DOM node to add the event handler to.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to add.
 * @param {boolean} opt_useCapture Optionally adds the even to the capture
 *     phase. Note: this only works in modern browsers.
 */
function addEvent(node, event, fn, opt_useCapture) {
  if (typeof node.addEventListener == 'function') {
    node.addEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.attachEvent == 'function') {
    node.attachEvent('on' + event, fn);
  }
}


/**
 * Removes a previously added event handler from a DOM node.
 * @param {Node} node The DOM node to remove the event handler from.
 * @param {string} event The event name.
 * @param {Function} fn The event handler to remove.
 * @param {boolean} opt_useCapture If the event handler was added with this
 *     flag set to true, it should be set to true here in order to remove it.
 */
function removeEvent(node, event, fn, opt_useCapture) {
  if (typeof node.removeEventListener == 'function') {
    node.removeEventListener(event, fn, opt_useCapture || false);
  }
  else if (typeof node.detatchEvent == 'function') {
    node.detatchEvent('on' + event, fn);
  }
}


/**
 * Returns the intersection between two rect objects.
 * @param {Object} rect1 The first rect.
 * @param {Object} rect2 The second rect.
 * @return {?Object} The intersection rect or undefined if no intersection
 *     is found.
 */
function computeRectIntersection(rect1, rect2) {
  var top = Math.max(rect1.top, rect2.top);
  var bottom = Math.min(rect1.bottom, rect2.bottom);
  var left = Math.max(rect1.left, rect2.left);
  var right = Math.min(rect1.right, rect2.right);
  var width = right - left;
  var height = bottom - top;

  return (width >= 0 && height >= 0) && {
    top: top,
    bottom: bottom,
    left: left,
    right: right,
    width: width,
    height: height
  };
}


/**
 * Shims the native getBoundingClientRect for compatibility with older IE.
 * @param {Element} el The element whose bounding rect to get.
 * @return {Object} The (possibly shimmed) rect of the element.
 */
function getBoundingClientRect(el) {
  var rect;

  try {
    rect = el.getBoundingClientRect();
  } catch (err) {
    // Ignore Windows 7 IE11 "Unspecified error"
    // https://github.com/WICG/IntersectionObserver/pull/205
  }

  if (!rect) return getEmptyRect();

  // Older IE
  if (!(rect.width && rect.height)) {
    rect = {
      top: rect.top,
      right: rect.right,
      bottom: rect.bottom,
      left: rect.left,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };
  }
  return rect;
}


/**
 * Returns an empty rect object. An empty rect is returned when an element
 * is not in the DOM.
 * @return {Object} The empty rect.
 */
function getEmptyRect() {
  return {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0,
    width: 0,
    height: 0
  };
}

/**
 * Checks to see if a parent element contains a child elemnt (including inside
 * shadow DOM).
 * @param {Node} parent The parent element.
 * @param {Node} child The child element.
 * @return {boolean} True if the parent node contains the child node.
 */
function containsDeep(parent, child) {
  var node = child;
  while (node) {
    if (node == parent) return true;

    node = getParentNode(node);
  }
  return false;
}


/**
 * Gets the parent node of an element or its host element if the parent node
 * is a shadow root.
 * @param {Node} node The node whose parent to get.
 * @return {Node|null} The parent node or null if no parent exists.
 */
function getParentNode(node) {
  var parent = node.parentNode;

  if (parent && parent.nodeType == 11 && parent.host) {
    // If the parent is a shadow root, return the host element.
    return parent.host;
  }
  return parent;
}


// Exposes the constructors globally.
window.IntersectionObserver = IntersectionObserver;
window.IntersectionObserverEntry = IntersectionObserverEntry;

}(window, document));


/***/ }),

/***/ "./node_modules/pepjs/dist/pep.js":
/***/ (function(module, exports, __webpack_require__) {

/*!
 * PEP v0.4.2 | https://github.com/jquery/PEP
 * Copyright jQuery Foundation and other contributors | http://jquery.org/license
 */

(function (global, factory) {
   true ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.PointerEventsPolyfill = factory());
}(this, function () { 'use strict';

  /**
   * This is the constructor for new PointerEvents.
   *
   * New Pointer Events must be given a type, and an optional dictionary of
   * initialization properties.
   *
   * Due to certain platform requirements, events returned from the constructor
   * identify as MouseEvents.
   *
   * @constructor
   * @param {String} inType The type of the event to create.
   * @param {Object} [inDict] An optional dictionary of initial event properties.
   * @return {Event} A new PointerEvent of type `inType`, initialized with properties from `inDict`.
   */
  var MOUSE_PROPS = [
    'bubbles',
    'cancelable',
    'view',
    'detail',
    'screenX',
    'screenY',
    'clientX',
    'clientY',
    'ctrlKey',
    'altKey',
    'shiftKey',
    'metaKey',
    'button',
    'relatedTarget',
    'pageX',
    'pageY'
  ];

  var MOUSE_DEFAULTS = [
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,
    0,
    0
  ];

  function PointerEvent(inType, inDict) {
    inDict = inDict || Object.create(null);

    var e = document.createEvent('Event');
    e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);

    // define inherited MouseEvent properties
    // skip bubbles and cancelable since they're set above in initEvent()
    for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
      p = MOUSE_PROPS[i];
      e[p] = inDict[p] || MOUSE_DEFAULTS[i];
    }
    e.buttons = inDict.buttons || 0;

    // Spec requires that pointers without pressure specified use 0.5 for down
    // state and 0 for up state.
    var pressure = 0;

    if (inDict.pressure && e.buttons) {
      pressure = inDict.pressure;
    } else {
      pressure = e.buttons ? 0.5 : 0;
    }

    // add x/y properties aliased to clientX/Y
    e.x = e.clientX;
    e.y = e.clientY;

    // define the properties of the PointerEvent interface
    e.pointerId = inDict.pointerId || 0;
    e.width = inDict.width || 0;
    e.height = inDict.height || 0;
    e.pressure = pressure;
    e.tiltX = inDict.tiltX || 0;
    e.tiltY = inDict.tiltY || 0;
    e.pointerType = inDict.pointerType || '';
    e.hwTimestamp = inDict.hwTimestamp || 0;
    e.isPrimary = inDict.isPrimary || false;
    return e;
  }

  /**
   * This module implements a map of pointer states
   */
  var USE_MAP = window.Map && window.Map.prototype.forEach;
  var PointerMap = USE_MAP ? Map : SparseArrayMap;

  function SparseArrayMap() {
    this.array = [];
    this.size = 0;
  }

  SparseArrayMap.prototype = {
    set: function(k, v) {
      if (v === undefined) {
        return this.delete(k);
      }
      if (!this.has(k)) {
        this.size++;
      }
      this.array[k] = v;
    },
    has: function(k) {
      return this.array[k] !== undefined;
    },
    delete: function(k) {
      if (this.has(k)) {
        delete this.array[k];
        this.size--;
      }
    },
    get: function(k) {
      return this.array[k];
    },
    clear: function() {
      this.array.length = 0;
      this.size = 0;
    },

    // return value, key, map
    forEach: function(callback, thisArg) {
      return this.array.forEach(function(v, k) {
        callback.call(thisArg, v, k, this);
      }, this);
    }
  };

  var CLONE_PROPS = [

    // MouseEvent
    'bubbles',
    'cancelable',
    'view',
    'detail',
    'screenX',
    'screenY',
    'clientX',
    'clientY',
    'ctrlKey',
    'altKey',
    'shiftKey',
    'metaKey',
    'button',
    'relatedTarget',

    // DOM Level 3
    'buttons',

    // PointerEvent
    'pointerId',
    'width',
    'height',
    'pressure',
    'tiltX',
    'tiltY',
    'pointerType',
    'hwTimestamp',
    'isPrimary',

    // event instance
    'type',
    'target',
    'currentTarget',
    'which',
    'pageX',
    'pageY',
    'timeStamp'
  ];

  var CLONE_DEFAULTS = [

    // MouseEvent
    false,
    false,
    null,
    null,
    0,
    0,
    0,
    0,
    false,
    false,
    false,
    false,
    0,
    null,

    // DOM Level 3
    0,

    // PointerEvent
    0,
    0,
    0,
    0,
    0,
    0,
    '',
    0,
    false,

    // event instance
    '',
    null,
    null,
    0,
    0,
    0,
    0
  ];

  var BOUNDARY_EVENTS = {
    'pointerover': 1,
    'pointerout': 1,
    'pointerenter': 1,
    'pointerleave': 1
  };

  var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');

  /**
   * This module is for normalizing events. Mouse and Touch events will be
   * collected here, and fire PointerEvents that have the same semantics, no
   * matter the source.
   * Events fired:
   *   - pointerdown: a pointing is added
   *   - pointerup: a pointer is removed
   *   - pointermove: a pointer is moved
   *   - pointerover: a pointer crosses into an element
   *   - pointerout: a pointer leaves an element
   *   - pointercancel: a pointer will no longer generate events
   */
  var dispatcher = {
    pointermap: new PointerMap(),
    eventMap: Object.create(null),
    captureInfo: Object.create(null),

    // Scope objects for native events.
    // This exists for ease of testing.
    eventSources: Object.create(null),
    eventSourceList: [],
    /**
     * Add a new event source that will generate pointer events.
     *
     * `inSource` must contain an array of event names named `events`, and
     * functions with the names specified in the `events` array.
     * @param {string} name A name for the event source
     * @param {Object} source A new source of platform events.
     */
    registerSource: function(name, source) {
      var s = source;
      var newEvents = s.events;
      if (newEvents) {
        newEvents.forEach(function(e) {
          if (s[e]) {
            this.eventMap[e] = s[e].bind(s);
          }
        }, this);
        this.eventSources[name] = s;
        this.eventSourceList.push(s);
      }
    },
    register: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {

        // call eventsource register
        es.register.call(es, element);
      }
    },
    unregister: function(element) {
      var l = this.eventSourceList.length;
      for (var i = 0, es; (i < l) && (es = this.eventSourceList[i]); i++) {

        // call eventsource register
        es.unregister.call(es, element);
      }
    },
    contains: /*scope.external.contains || */function(container, contained) {
      try {
        return container.contains(contained);
      } catch (ex) {

        // most likely: https://bugzilla.mozilla.org/show_bug.cgi?id=208427
        return false;
      }
    },

    // EVENTS
    down: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent('pointerdown', inEvent);
    },
    move: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent('pointermove', inEvent);
    },
    up: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent('pointerup', inEvent);
    },
    enter: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent('pointerenter', inEvent);
    },
    leave: function(inEvent) {
      inEvent.bubbles = false;
      this.fireEvent('pointerleave', inEvent);
    },
    over: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent('pointerover', inEvent);
    },
    out: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent('pointerout', inEvent);
    },
    cancel: function(inEvent) {
      inEvent.bubbles = true;
      this.fireEvent('pointercancel', inEvent);
    },
    leaveOut: function(event) {
      this.out(event);
      this.propagate(event, this.leave, false);
    },
    enterOver: function(event) {
      this.over(event);
      this.propagate(event, this.enter, true);
    },

    // LISTENER LOGIC
    eventHandler: function(inEvent) {

      // This is used to prevent multiple dispatch of pointerevents from
      // platform events. This can happen when two elements in different scopes
      // are set up to create pointer events, which is relevant to Shadow DOM.
      if (inEvent._handledByPE) {
        return;
      }
      var type = inEvent.type;
      var fn = this.eventMap && this.eventMap[type];
      if (fn) {
        fn(inEvent);
      }
      inEvent._handledByPE = true;
    },

    // set up event listeners
    listen: function(target, events) {
      events.forEach(function(e) {
        this.addEvent(target, e);
      }, this);
    },

    // remove event listeners
    unlisten: function(target, events) {
      events.forEach(function(e) {
        this.removeEvent(target, e);
      }, this);
    },
    addEvent: /*scope.external.addEvent || */function(target, eventName) {
      target.addEventListener(eventName, this.boundHandler);
    },
    removeEvent: /*scope.external.removeEvent || */function(target, eventName) {
      target.removeEventListener(eventName, this.boundHandler);
    },

    // EVENT CREATION AND TRACKING
    /**
     * Creates a new Event of type `inType`, based on the information in
     * `inEvent`.
     *
     * @param {string} inType A string representing the type of event to create
     * @param {Event} inEvent A platform event with a target
     * @return {Event} A PointerEvent of type `inType`
     */
    makeEvent: function(inType, inEvent) {

      // relatedTarget must be null if pointer is captured
      if (this.captureInfo[inEvent.pointerId]) {
        inEvent.relatedTarget = null;
      }
      var e = new PointerEvent(inType, inEvent);
      if (inEvent.preventDefault) {
        e.preventDefault = inEvent.preventDefault;
      }
      e._target = e._target || inEvent.target;
      return e;
    },

    // make and dispatch an event in one call
    fireEvent: function(inType, inEvent) {
      var e = this.makeEvent(inType, inEvent);
      return this.dispatchEvent(e);
    },
    /**
     * Returns a snapshot of inEvent, with writable properties.
     *
     * @param {Event} inEvent An event that contains properties to copy.
     * @return {Object} An object containing shallow copies of `inEvent`'s
     *    properties.
     */
    cloneEvent: function(inEvent) {
      var eventCopy = Object.create(null);
      var p;
      for (var i = 0; i < CLONE_PROPS.length; i++) {
        p = CLONE_PROPS[i];
        eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];

        // Work around SVGInstanceElement shadow tree
        // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
        // This is the behavior implemented by Firefox.
        if (HAS_SVG_INSTANCE && (p === 'target' || p === 'relatedTarget')) {
          if (eventCopy[p] instanceof SVGElementInstance) {
            eventCopy[p] = eventCopy[p].correspondingUseElement;
          }
        }
      }

      // keep the semantics of preventDefault
      if (inEvent.preventDefault) {
        eventCopy.preventDefault = function() {
          inEvent.preventDefault();
        };
      }
      return eventCopy;
    },
    getTarget: function(inEvent) {
      var capture = this.captureInfo[inEvent.pointerId];
      if (!capture) {
        return inEvent._target;
      }
      if (inEvent._target === capture || !(inEvent.type in BOUNDARY_EVENTS)) {
        return capture;
      }
    },
    propagate: function(event, fn, propagateDown) {
      var target = event.target;
      var targets = [];
      while (!target.contains(event.relatedTarget) && target !== document) {
        targets.push(target);
        target = target.parentNode;
      }
      if (propagateDown) {
        targets.reverse();
      }
      targets.forEach(function(target) {
        event.target = target;
        fn.call(this, event);
      }, this);
    },
    setCapture: function(inPointerId, inTarget) {
      if (this.captureInfo[inPointerId]) {
        this.releaseCapture(inPointerId);
      }
      this.captureInfo[inPointerId] = inTarget;
      var e = new PointerEvent('gotpointercapture');
      e.pointerId = inPointerId;
      this.implicitRelease = this.releaseCapture.bind(this, inPointerId);
      document.addEventListener('pointerup', this.implicitRelease);
      document.addEventListener('pointercancel', this.implicitRelease);
      e._target = inTarget;
      this.asyncDispatchEvent(e);
    },
    releaseCapture: function(inPointerId) {
      var t = this.captureInfo[inPointerId];
      if (t) {
        var e = new PointerEvent('lostpointercapture');
        e.pointerId = inPointerId;
        this.captureInfo[inPointerId] = undefined;
        document.removeEventListener('pointerup', this.implicitRelease);
        document.removeEventListener('pointercancel', this.implicitRelease);
        e._target = t;
        this.asyncDispatchEvent(e);
      }
    },
    /**
     * Dispatches the event to its target.
     *
     * @param {Event} inEvent The event to be dispatched.
     * @return {Boolean} True if an event handler returns true, false otherwise.
     */
    dispatchEvent: /*scope.external.dispatchEvent || */function(inEvent) {
      var t = this.getTarget(inEvent);
      if (t) {
        return t.dispatchEvent(inEvent);
      }
    },
    asyncDispatchEvent: function(inEvent) {
      requestAnimationFrame(this.dispatchEvent.bind(this, inEvent));
    }
  };
  dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);

  var targeting = {
    shadow: function(inEl) {
      if (inEl) {
        return inEl.shadowRoot || inEl.webkitShadowRoot;
      }
    },
    canTarget: function(shadow) {
      return shadow && Boolean(shadow.elementFromPoint);
    },
    targetingShadow: function(inEl) {
      var s = this.shadow(inEl);
      if (this.canTarget(s)) {
        return s;
      }
    },
    olderShadow: function(shadow) {
      var os = shadow.olderShadowRoot;
      if (!os) {
        var se = shadow.querySelector('shadow');
        if (se) {
          os = se.olderShadowRoot;
        }
      }
      return os;
    },
    allShadows: function(element) {
      var shadows = [];
      var s = this.shadow(element);
      while (s) {
        shadows.push(s);
        s = this.olderShadow(s);
      }
      return shadows;
    },
    searchRoot: function(inRoot, x, y) {
      if (inRoot) {
        var t = inRoot.elementFromPoint(x, y);
        var st, sr;

        // is element a shadow host?
        sr = this.targetingShadow(t);
        while (sr) {

          // find the the element inside the shadow root
          st = sr.elementFromPoint(x, y);
          if (!st) {

            // check for older shadows
            sr = this.olderShadow(sr);
          } else {

            // shadowed element may contain a shadow root
            var ssr = this.targetingShadow(st);
            return this.searchRoot(ssr, x, y) || st;
          }
        }

        // light dom element is the target
        return t;
      }
    },
    owner: function(element) {
      var s = element;

      // walk up until you hit the shadow root or document
      while (s.parentNode) {
        s = s.parentNode;
      }

      // the owner element is expected to be a Document or ShadowRoot
      if (s.nodeType !== Node.DOCUMENT_NODE && s.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
        s = document;
      }
      return s;
    },
    findTarget: function(inEvent) {
      var x = inEvent.clientX;
      var y = inEvent.clientY;

      // if the listener is in the shadow root, it is much faster to start there
      var s = this.owner(inEvent.target);

      // if x, y is not in this root, fall back to document search
      if (!s.elementFromPoint(x, y)) {
        s = document;
      }
      return this.searchRoot(s, x, y);
    }
  };

  var forEach = Array.prototype.forEach.call.bind(Array.prototype.forEach);
  var map = Array.prototype.map.call.bind(Array.prototype.map);
  var toArray = Array.prototype.slice.call.bind(Array.prototype.slice);
  var filter = Array.prototype.filter.call.bind(Array.prototype.filter);
  var MO = window.MutationObserver || window.WebKitMutationObserver;
  var SELECTOR = '[touch-action]';
  var OBSERVER_INIT = {
    subtree: true,
    childList: true,
    attributes: true,
    attributeOldValue: true,
    attributeFilter: ['touch-action']
  };

  function Installer(add, remove, changed, binder) {
    this.addCallback = add.bind(binder);
    this.removeCallback = remove.bind(binder);
    this.changedCallback = changed.bind(binder);
    if (MO) {
      this.observer = new MO(this.mutationWatcher.bind(this));
    }
  }

  Installer.prototype = {
    watchSubtree: function(target) {

      // Only watch scopes that can target find, as these are top-level.
      // Otherwise we can see duplicate additions and removals that add noise.
      //
      // TODO(dfreedman): For some instances with ShadowDOMPolyfill, we can see
      // a removal without an insertion when a node is redistributed among
      // shadows. Since it all ends up correct in the document, watching only
      // the document will yield the correct mutations to watch.
      if (this.observer && targeting.canTarget(target)) {
        this.observer.observe(target, OBSERVER_INIT);
      }
    },
    enableOnSubtree: function(target) {
      this.watchSubtree(target);
      if (target === document && document.readyState !== 'complete') {
        this.installOnLoad();
      } else {
        this.installNewSubtree(target);
      }
    },
    installNewSubtree: function(target) {
      forEach(this.findElements(target), this.addElement, this);
    },
    findElements: function(target) {
      if (target.querySelectorAll) {
        return target.querySelectorAll(SELECTOR);
      }
      return [];
    },
    removeElement: function(el) {
      this.removeCallback(el);
    },
    addElement: function(el) {
      this.addCallback(el);
    },
    elementChanged: function(el, oldValue) {
      this.changedCallback(el, oldValue);
    },
    concatLists: function(accum, list) {
      return accum.concat(toArray(list));
    },

    // register all touch-action = none nodes on document load
    installOnLoad: function() {
      document.addEventListener('readystatechange', function() {
        if (document.readyState === 'complete') {
          this.installNewSubtree(document);
        }
      }.bind(this));
    },
    isElement: function(n) {
      return n.nodeType === Node.ELEMENT_NODE;
    },
    flattenMutationTree: function(inNodes) {

      // find children with touch-action
      var tree = map(inNodes, this.findElements, this);

      // make sure the added nodes are accounted for
      tree.push(filter(inNodes, this.isElement));

      // flatten the list
      return tree.reduce(this.concatLists, []);
    },
    mutationWatcher: function(mutations) {
      mutations.forEach(this.mutationHandler, this);
    },
    mutationHandler: function(m) {
      if (m.type === 'childList') {
        var added = this.flattenMutationTree(m.addedNodes);
        added.forEach(this.addElement, this);
        var removed = this.flattenMutationTree(m.removedNodes);
        removed.forEach(this.removeElement, this);
      } else if (m.type === 'attributes') {
        this.elementChanged(m.target, m.oldValue);
      }
    }
  };

  function shadowSelector(v) {
    return 'body /shadow-deep/ ' + selector(v);
  }
  function selector(v) {
    return '[touch-action="' + v + '"]';
  }
  function rule(v) {
    return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + '; }';
  }
  var attrib2css = [
    'none',
    'auto',
    'pan-x',
    'pan-y',
    {
      rule: 'pan-x pan-y',
      selectors: [
        'pan-x pan-y',
        'pan-y pan-x'
      ]
    }
  ];
  var styles = '';

  // only install stylesheet if the browser has touch action support
  var hasNativePE = window.PointerEvent || window.MSPointerEvent;

  // only add shadow selectors if shadowdom is supported
  var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;

  function applyAttributeStyles() {
    if (hasNativePE) {
      attrib2css.forEach(function(r) {
        if (String(r) === r) {
          styles += selector(r) + rule(r) + '\n';
          if (hasShadowRoot) {
            styles += shadowSelector(r) + rule(r) + '\n';
          }
        } else {
          styles += r.selectors.map(selector) + rule(r.rule) + '\n';
          if (hasShadowRoot) {
            styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\n';
          }
        }
      });

      var el = document.createElement('style');
      el.textContent = styles;
      document.head.appendChild(el);
    }
  }

  var pointermap = dispatcher.pointermap;

  // radius around touchend that swallows mouse events
  var DEDUP_DIST = 25;

  // left, middle, right, back, forward
  var BUTTON_TO_BUTTONS = [1, 4, 2, 8, 16];

  var HAS_BUTTONS = false;
  try {
    HAS_BUTTONS = new MouseEvent('test', { buttons: 1 }).buttons === 1;
  } catch (e) {}

  // handler block for native mouse events
  var mouseEvents = {
    POINTER_ID: 1,
    POINTER_TYPE: 'mouse',
    events: [
      'mousedown',
      'mousemove',
      'mouseup',
      'mouseover',
      'mouseout'
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    lastTouches: [],

    // collide with the global mouse listener
    isEventSimulatedFromTouch: function(inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX;
      var y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {

        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x);
        var dy = Math.abs(y - t.y);
        if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
          return true;
        }
      }
    },
    prepareEvent: function(inEvent) {
      var e = dispatcher.cloneEvent(inEvent);

      // forward mouse preventDefault
      var pd = e.preventDefault;
      e.preventDefault = function() {
        inEvent.preventDefault();
        pd();
      };
      e.pointerId = this.POINTER_ID;
      e.isPrimary = true;
      e.pointerType = this.POINTER_TYPE;
      return e;
    },
    prepareButtonsForMove: function(e, inEvent) {
      var p = pointermap.get(this.POINTER_ID);

      // Update buttons state after possible out-of-document mouseup.
      if (inEvent.which === 0 || !p) {
        e.buttons = 0;
      } else {
        e.buttons = p.buttons;
      }
      inEvent.buttons = e.buttons;
    },
    mousedown: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          e.buttons = BUTTON_TO_BUTTONS[e.button];
          if (p) { e.buttons |= p.buttons; }
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);
        if (!p || p.buttons === 0) {
          dispatcher.down(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mousemove: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) { this.prepareButtonsForMove(e, inEvent); }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.move(e);
      }
    },
    mouseup: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var p = pointermap.get(this.POINTER_ID);
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) {
          var up = BUTTON_TO_BUTTONS[e.button];

          // Produces wrong state of buttons in Browsers without `buttons` support
          // when a mouse button that was pressed outside the document is released
          // inside and other buttons are still pressed down.
          e.buttons = p ? p.buttons & ~up : 0;
          inEvent.buttons = e.buttons;
        }
        pointermap.set(this.POINTER_ID, inEvent);

        // Support: Firefox <=44 only
        // FF Ubuntu includes the lifted button in the `buttons` property on
        // mouseup.
        // https://bugzilla.mozilla.org/show_bug.cgi?id=1223366
        e.buttons &= ~BUTTON_TO_BUTTONS[e.button];
        if (e.buttons === 0) {
          dispatcher.up(e);
        } else {
          dispatcher.move(e);
        }
      }
    },
    mouseover: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) { this.prepareButtonsForMove(e, inEvent); }
        e.button = -1;
        pointermap.set(this.POINTER_ID, inEvent);
        dispatcher.enterOver(e);
      }
    },
    mouseout: function(inEvent) {
      if (!this.isEventSimulatedFromTouch(inEvent)) {
        var e = this.prepareEvent(inEvent);
        if (!HAS_BUTTONS) { this.prepareButtonsForMove(e, inEvent); }
        e.button = -1;
        dispatcher.leaveOut(e);
      }
    },
    cancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.deactivateMouse();
    },
    deactivateMouse: function() {
      pointermap.delete(this.POINTER_ID);
    }
  };

  var captureInfo = dispatcher.captureInfo;
  var findTarget = targeting.findTarget.bind(targeting);
  var allShadows = targeting.allShadows.bind(targeting);
  var pointermap$1 = dispatcher.pointermap;

  // This should be long enough to ignore compat mouse events made by touch
  var DEDUP_TIMEOUT = 2500;
  var CLICK_COUNT_TIMEOUT = 200;
  var ATTRIB = 'touch-action';
  var INSTALLER;

  // handler block for native touch events
  var touchEvents = {
    events: [
      'touchstart',
      'touchmove',
      'touchend',
      'touchcancel'
    ],
    register: function(target) {
      INSTALLER.enableOnSubtree(target);
    },
    unregister: function() {

      // TODO(dfreedman): is it worth it to disconnect the MO?
    },
    elementAdded: function(el) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      if (st) {
        el._scrollType = st;
        dispatcher.listen(el, this.events);

        // set touch-action on shadows as well
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
          dispatcher.listen(s, this.events);
        }, this);
      }
    },
    elementRemoved: function(el) {
      el._scrollType = undefined;
      dispatcher.unlisten(el, this.events);

      // remove touch-action from shadow
      allShadows(el).forEach(function(s) {
        s._scrollType = undefined;
        dispatcher.unlisten(s, this.events);
      }, this);
    },
    elementChanged: function(el, oldValue) {
      var a = el.getAttribute(ATTRIB);
      var st = this.touchActionToScrollType(a);
      var oldSt = this.touchActionToScrollType(oldValue);

      // simply update scrollType if listeners are already established
      if (st && oldSt) {
        el._scrollType = st;
        allShadows(el).forEach(function(s) {
          s._scrollType = st;
        }, this);
      } else if (oldSt) {
        this.elementRemoved(el);
      } else if (st) {
        this.elementAdded(el);
      }
    },
    scrollTypes: {
      EMITTER: 'none',
      XSCROLLER: 'pan-x',
      YSCROLLER: 'pan-y',
      SCROLLER: /^(?:pan-x pan-y)|(?:pan-y pan-x)|auto$/
    },
    touchActionToScrollType: function(touchAction) {
      var t = touchAction;
      var st = this.scrollTypes;
      if (t === 'none') {
        return 'none';
      } else if (t === st.XSCROLLER) {
        return 'X';
      } else if (t === st.YSCROLLER) {
        return 'Y';
      } else if (st.SCROLLER.exec(t)) {
        return 'XY';
      }
    },
    POINTER_TYPE: 'touch',
    firstTouch: null,
    isPrimaryTouch: function(inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function(inTouch) {

      // set primary touch if there no pointers, or the only pointer is the mouse
      if (pointermap$1.size === 0 || (pointermap$1.size === 1 && pointermap$1.has(1))) {
        this.firstTouch = inTouch.identifier;
        this.firstXY = { X: inTouch.clientX, Y: inTouch.clientY };
        this.scrolling = false;
        this.cancelResetClickCount();
      }
    },
    removePrimaryPointer: function(inPointer) {
      if (inPointer.isPrimary) {
        this.firstTouch = null;
        this.firstXY = null;
        this.resetClickCount();
      }
    },
    clickCount: 0,
    resetId: null,
    resetClickCount: function() {
      var fn = function() {
        this.clickCount = 0;
        this.resetId = null;
      }.bind(this);
      this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
    },
    cancelResetClickCount: function() {
      if (this.resetId) {
        clearTimeout(this.resetId);
      }
    },
    typeToButtons: function(type) {
      var ret = 0;
      if (type === 'touchstart' || type === 'touchmove') {
        ret = 1;
      }
      return ret;
    },
    touchToPointer: function(inTouch) {
      var cte = this.currentTouchEvent;
      var e = dispatcher.cloneEvent(inTouch);

      // We reserve pointerId 1 for Mouse.
      // Touch identifiers can start at 0.
      // Add 2 to the touch identifier for compatibility.
      var id = e.pointerId = inTouch.identifier + 2;
      e.target = captureInfo[id] || findTarget(e);
      e.bubbles = true;
      e.cancelable = true;
      e.detail = this.clickCount;
      e.button = 0;
      e.buttons = this.typeToButtons(cte.type);
      e.width = inTouch.radiusX || inTouch.webkitRadiusX || 0;
      e.height = inTouch.radiusY || inTouch.webkitRadiusY || 0;
      e.pressure = inTouch.force || inTouch.webkitForce || 0.5;
      e.isPrimary = this.isPrimaryTouch(inTouch);
      e.pointerType = this.POINTER_TYPE;

      // forward modifier keys
      e.altKey = cte.altKey;
      e.ctrlKey = cte.ctrlKey;
      e.metaKey = cte.metaKey;
      e.shiftKey = cte.shiftKey;

      // forward touch preventDefaults
      var self = this;
      e.preventDefault = function() {
        self.scrolling = false;
        self.firstXY = null;
        cte.preventDefault();
      };
      return e;
    },
    processTouches: function(inEvent, inFunction) {
      var tl = inEvent.changedTouches;
      this.currentTouchEvent = inEvent;
      for (var i = 0, t; i < tl.length; i++) {
        t = tl[i];
        inFunction.call(this, this.touchToPointer(t));
      }
    },

    // For single axis scrollers, determines whether the element should emit
    // pointer events or behave as a scroller
    shouldScroll: function(inEvent) {
      if (this.firstXY) {
        var ret;
        var scrollAxis = inEvent.currentTarget._scrollType;
        if (scrollAxis === 'none') {

          // this element is a touch-action: none, should never scroll
          ret = false;
        } else if (scrollAxis === 'XY') {

          // this element should always scroll
          ret = true;
        } else {
          var t = inEvent.changedTouches[0];

          // check the intended scroll axis, and other axis
          var a = scrollAxis;
          var oa = scrollAxis === 'Y' ? 'X' : 'Y';
          var da = Math.abs(t['client' + a] - this.firstXY[a]);
          var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);

          // if delta in the scroll axis > delta other axis, scroll instead of
          // making events
          ret = da >= doa;
        }
        this.firstXY = null;
        return ret;
      }
    },
    findTouch: function(inTL, inId) {
      for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
        if (t.identifier === inId) {
          return true;
        }
      }
    },

    // In some instances, a touchstart can happen without a touchend. This
    // leaves the pointermap in a broken state.
    // Therefore, on every touchstart, we remove the touches that did not fire a
    // touchend event.
    // To keep state globally consistent, we fire a
    // pointercancel for this "abandoned" touch
    vacuumTouches: function(inEvent) {
      var tl = inEvent.touches;

      // pointermap.size should be < tl.length here, as the touchstart has not
      // been processed yet.
      if (pointermap$1.size >= tl.length) {
        var d = [];
        pointermap$1.forEach(function(value, key) {

          // Never remove pointerId == 1, which is mouse.
          // Touch identifiers are 2 smaller than their pointerId, which is the
          // index in pointermap.
          if (key !== 1 && !this.findTouch(tl, key - 2)) {
            var p = value.out;
            d.push(p);
          }
        }, this);
        d.forEach(this.cancelOut, this);
      }
    },
    touchstart: function(inEvent) {
      this.vacuumTouches(inEvent);
      this.setPrimaryTouch(inEvent.changedTouches[0]);
      this.dedupSynthMouse(inEvent);
      if (!this.scrolling) {
        this.clickCount++;
        this.processTouches(inEvent, this.overDown);
      }
    },
    overDown: function(inPointer) {
      pointermap$1.set(inPointer.pointerId, {
        target: inPointer.target,
        out: inPointer,
        outTarget: inPointer.target
      });
      dispatcher.enterOver(inPointer);
      dispatcher.down(inPointer);
    },
    touchmove: function(inEvent) {
      if (!this.scrolling) {
        if (this.shouldScroll(inEvent)) {
          this.scrolling = true;
          this.touchcancel(inEvent);
        } else {
          inEvent.preventDefault();
          this.processTouches(inEvent, this.moveOverOut);
        }
      }
    },
    moveOverOut: function(inPointer) {
      var event = inPointer;
      var pointer = pointermap$1.get(event.pointerId);

      // a finger drifted off the screen, ignore it
      if (!pointer) {
        return;
      }
      var outEvent = pointer.out;
      var outTarget = pointer.outTarget;
      dispatcher.move(event);
      if (outEvent && outTarget !== event.target) {
        outEvent.relatedTarget = event.target;
        event.relatedTarget = outTarget;

        // recover from retargeting by shadow
        outEvent.target = outTarget;
        if (event.target) {
          dispatcher.leaveOut(outEvent);
          dispatcher.enterOver(event);
        } else {

          // clean up case when finger leaves the screen
          event.target = outTarget;
          event.relatedTarget = null;
          this.cancelOut(event);
        }
      }
      pointer.out = event;
      pointer.outTarget = event.target;
    },
    touchend: function(inEvent) {
      this.dedupSynthMouse(inEvent);
      this.processTouches(inEvent, this.upOut);
    },
    upOut: function(inPointer) {
      if (!this.scrolling) {
        dispatcher.up(inPointer);
        dispatcher.leaveOut(inPointer);
      }
      this.cleanUpPointer(inPointer);
    },
    touchcancel: function(inEvent) {
      this.processTouches(inEvent, this.cancelOut);
    },
    cancelOut: function(inPointer) {
      dispatcher.cancel(inPointer);
      dispatcher.leaveOut(inPointer);
      this.cleanUpPointer(inPointer);
    },
    cleanUpPointer: function(inPointer) {
      pointermap$1.delete(inPointer.pointerId);
      this.removePrimaryPointer(inPointer);
    },

    // prevent synth mouse events from creating pointer events
    dedupSynthMouse: function(inEvent) {
      var lts = mouseEvents.lastTouches;
      var t = inEvent.changedTouches[0];

      // only the primary finger will synth mouse events
      if (this.isPrimaryTouch(t)) {

        // remember x/y of last touch
        var lt = { x: t.clientX, y: t.clientY };
        lts.push(lt);
        var fn = (function(lts, lt) {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }).bind(null, lts, lt);
        setTimeout(fn, DEDUP_TIMEOUT);
      }
    }
  };

  INSTALLER = new Installer(touchEvents.elementAdded, touchEvents.elementRemoved,
    touchEvents.elementChanged, touchEvents);

  var pointermap$2 = dispatcher.pointermap;
  var HAS_BITMAP_TYPE = window.MSPointerEvent &&
    typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';
  var msEvents = {
    events: [
      'MSPointerDown',
      'MSPointerMove',
      'MSPointerUp',
      'MSPointerOut',
      'MSPointerOver',
      'MSPointerCancel',
      'MSGotPointerCapture',
      'MSLostPointerCapture'
    ],
    register: function(target) {
      dispatcher.listen(target, this.events);
    },
    unregister: function(target) {
      dispatcher.unlisten(target, this.events);
    },
    POINTER_TYPES: [
      '',
      'unavailable',
      'touch',
      'pen',
      'mouse'
    ],
    prepareEvent: function(inEvent) {
      var e = inEvent;
      if (HAS_BITMAP_TYPE) {
        e = dispatcher.cloneEvent(inEvent);
        e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
      }
      return e;
    },
    cleanup: function(id) {
      pointermap$2.delete(id);
    },
    MSPointerDown: function(inEvent) {
      pointermap$2.set(inEvent.pointerId, inEvent);
      var e = this.prepareEvent(inEvent);
      dispatcher.down(e);
    },
    MSPointerMove: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.move(e);
    },
    MSPointerUp: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.up(e);
      this.cleanup(inEvent.pointerId);
    },
    MSPointerOut: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.leaveOut(e);
    },
    MSPointerOver: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.enterOver(e);
    },
    MSPointerCancel: function(inEvent) {
      var e = this.prepareEvent(inEvent);
      dispatcher.cancel(e);
      this.cleanup(inEvent.pointerId);
    },
    MSLostPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent('lostpointercapture', inEvent);
      dispatcher.dispatchEvent(e);
    },
    MSGotPointerCapture: function(inEvent) {
      var e = dispatcher.makeEvent('gotpointercapture', inEvent);
      dispatcher.dispatchEvent(e);
    }
  };

  function applyPolyfill() {

    // only activate if this platform does not have pointer events
    if (!window.PointerEvent) {
      window.PointerEvent = PointerEvent;

      if (window.navigator.msPointerEnabled) {
        var tp = window.navigator.msMaxTouchPoints;
        Object.defineProperty(window.navigator, 'maxTouchPoints', {
          value: tp,
          enumerable: true
        });
        dispatcher.registerSource('ms', msEvents);
      } else {
        dispatcher.registerSource('mouse', mouseEvents);
        if (window.ontouchstart !== undefined) {
          dispatcher.registerSource('touch', touchEvents);
        }
      }

      dispatcher.register(document);
    }
  }

  var n = window.navigator;
  var s;
  var r;
  function assertActive(id) {
    if (!dispatcher.pointermap.has(id)) {
      var error = new Error('InvalidPointerId');
      error.name = 'InvalidPointerId';
      throw error;
    }
  }
  function assertConnected(elem) {
    if (!elem.ownerDocument.contains(elem)) {
      var error = new Error('InvalidStateError');
      error.name = 'InvalidStateError';
      throw error;
    }
  }
  function inActiveButtonState(id) {
    var p = dispatcher.pointermap.get(id);
    return p.buttons !== 0;
  }
  if (n.msPointerEnabled) {
    s = function(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        this.msSetPointerCapture(pointerId);
      }
    };
    r = function(pointerId) {
      assertActive(pointerId);
      this.msReleasePointerCapture(pointerId);
    };
  } else {
    s = function setPointerCapture(pointerId) {
      assertActive(pointerId);
      assertConnected(this);
      if (inActiveButtonState(pointerId)) {
        dispatcher.setCapture(pointerId, this);
      }
    };
    r = function releasePointerCapture(pointerId) {
      assertActive(pointerId);
      dispatcher.releaseCapture(pointerId, this);
    };
  }

  function applyPolyfill$1() {
    if (window.Element && !Element.prototype.setPointerCapture) {
      Object.defineProperties(Element.prototype, {
        'setPointerCapture': {
          value: s
        },
        'releasePointerCapture': {
          value: r
        }
      });
    }
  }

  applyAttributeStyles();
  applyPolyfill();
  applyPolyfill$1();

  var pointerevents = {
    dispatcher: dispatcher,
    Installer: Installer,
    PointerEvent: PointerEvent,
    PointerMap: PointerMap,
    targetFinding: targeting
  };

  return pointerevents;

}));

/***/ }),

/***/ "./node_modules/process/browser.js":
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__("./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmeidate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/tslib/tslib.es6.js":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (immutable) */ __webpack_exports__["__rest"] = __rest;
/* harmony export (immutable) */ __webpack_exports__["__decorate"] = __decorate;
/* harmony export (immutable) */ __webpack_exports__["__param"] = __param;
/* harmony export (immutable) */ __webpack_exports__["__metadata"] = __metadata;
/* harmony export (immutable) */ __webpack_exports__["__awaiter"] = __awaiter;
/* harmony export (immutable) */ __webpack_exports__["__generator"] = __generator;
/* harmony export (immutable) */ __webpack_exports__["__exportStar"] = __exportStar;
/* harmony export (immutable) */ __webpack_exports__["__values"] = __values;
/* harmony export (immutable) */ __webpack_exports__["__read"] = __read;
/* harmony export (immutable) */ __webpack_exports__["__spread"] = __spread;
/* harmony export (immutable) */ __webpack_exports__["__await"] = __await;
/* harmony export (immutable) */ __webpack_exports__["__asyncGenerator"] = __asyncGenerator;
/* harmony export (immutable) */ __webpack_exports__["__asyncDelegator"] = __asyncDelegator;
/* harmony export (immutable) */ __webpack_exports__["__asyncValues"] = __asyncValues;
/* harmony export (immutable) */ __webpack_exports__["__makeTemplateObject"] = __makeTemplateObject;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator];
    return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};


/***/ }),

/***/ "./node_modules/web-animations-js/web-animations-next-lite.min.js":
/***/ (function(module, exports) {

// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
//     You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//     See the License for the specific language governing permissions and
// limitations under the License.

!function(a,b){var c={},d={},e={};!function(a,b){function c(a){if("number"==typeof a)return a;var b={};for(var c in a)b[c]=a[c];return b}function d(){this._delay=0,this._endDelay=0,this._fill="none",this._iterationStart=0,this._iterations=1,this._duration=0,this._playbackRate=1,this._direction="normal",this._easing="linear",this._easingFunction=x}function e(){return a.isDeprecated("Invalid timing inputs","2016-03-02","TypeError exceptions will be thrown instead.",!0)}function f(b,c,e){var f=new d;return c&&(f.fill="both",f.duration="auto"),"number"!=typeof b||isNaN(b)?void 0!==b&&Object.getOwnPropertyNames(b).forEach(function(c){if("auto"!=b[c]){if(("number"==typeof f[c]||"duration"==c)&&("number"!=typeof b[c]||isNaN(b[c])))return;if("fill"==c&&-1==v.indexOf(b[c]))return;if("direction"==c&&-1==w.indexOf(b[c]))return;if("playbackRate"==c&&1!==b[c]&&a.isDeprecated("AnimationEffectTiming.playbackRate","2014-11-28","Use Animation.playbackRate instead."))return;f[c]=b[c]}}):f.duration=b,f}function g(a){return"number"==typeof a&&(a=isNaN(a)?{duration:0}:{duration:a}),a}function h(b,c){return b=a.numericTimingToObject(b),f(b,c)}function i(a,b,c,d){return a<0||a>1||c<0||c>1?x:function(e){function f(a,b,c){return 3*a*(1-c)*(1-c)*c+3*b*(1-c)*c*c+c*c*c}if(e<=0){var g=0;return a>0?g=b/a:!b&&c>0&&(g=d/c),g*e}if(e>=1){var h=0;return c<1?h=(d-1)/(c-1):1==c&&a<1&&(h=(b-1)/(a-1)),1+h*(e-1)}for(var i=0,j=1;i<j;){var k=(i+j)/2,l=f(a,c,k);if(Math.abs(e-l)<1e-5)return f(b,d,k);l<e?i=k:j=k}return f(b,d,k)}}function j(a,b){return function(c){if(c>=1)return 1;var d=1/a;return(c+=b*d)-c%d}}function k(a){C||(C=document.createElement("div").style),C.animationTimingFunction="",C.animationTimingFunction=a;var b=C.animationTimingFunction;if(""==b&&e())throw new TypeError(a+" is not a valid value for easing");return b}function l(a){if("linear"==a)return x;var b=E.exec(a);if(b)return i.apply(this,b.slice(1).map(Number));var c=F.exec(a);return c?j(Number(c[1]),{start:y,middle:z,end:A}[c[2]]):B[a]||x}function m(a){return Math.abs(n(a)/a.playbackRate)}function n(a){return 0===a.duration||0===a.iterations?0:a.duration*a.iterations}function o(a,b,c){if(null==b)return G;var d=c.delay+a+c.endDelay;return b<Math.min(c.delay,d)?H:b>=Math.min(c.delay+a,d)?I:J}function p(a,b,c,d,e){switch(d){case H:return"backwards"==b||"both"==b?0:null;case J:return c-e;case I:return"forwards"==b||"both"==b?a:null;case G:return null}}function q(a,b,c,d,e){var f=e;return 0===a?b!==H&&(f+=c):f+=d/a,f}function r(a,b,c,d,e,f){var g=a===1/0?b%1:a%1;return 0!==g||c!==I||0===d||0===e&&0!==f||(g=1),g}function s(a,b,c,d){return a===I&&b===1/0?1/0:1===c?Math.floor(d)-1:Math.floor(d)}function t(a,b,c){var d=a;if("normal"!==a&&"reverse"!==a){var e=b;"alternate-reverse"===a&&(e+=1),d="normal",e!==1/0&&e%2!=0&&(d="reverse")}return"normal"===d?c:1-c}function u(a,b,c){var d=o(a,b,c),e=p(a,c.fill,b,d,c.delay);if(null===e)return null;var f=q(c.duration,d,c.iterations,e,c.iterationStart),g=r(f,c.iterationStart,d,c.iterations,e,c.duration),h=s(d,c.iterations,g,f),i=t(c.direction,h,g);return c._easingFunction(i)}var v="backwards|forwards|both|none".split("|"),w="reverse|alternate|alternate-reverse".split("|"),x=function(a){return a};d.prototype={_setMember:function(b,c){this["_"+b]=c,this._effect&&(this._effect._timingInput[b]=c,this._effect._timing=a.normalizeTimingInput(this._effect._timingInput),this._effect.activeDuration=a.calculateActiveDuration(this._effect._timing),this._effect._animation&&this._effect._animation._rebuildUnderlyingAnimation())},get playbackRate(){return this._playbackRate},set delay(a){this._setMember("delay",a)},get delay(){return this._delay},set endDelay(a){this._setMember("endDelay",a)},get endDelay(){return this._endDelay},set fill(a){this._setMember("fill",a)},get fill(){return this._fill},set iterationStart(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterationStart must be a non-negative number, received: "+timing.iterationStart);this._setMember("iterationStart",a)},get iterationStart(){return this._iterationStart},set duration(a){if("auto"!=a&&(isNaN(a)||a<0)&&e())throw new TypeError("duration must be non-negative or auto, received: "+a);this._setMember("duration",a)},get duration(){return this._duration},set direction(a){this._setMember("direction",a)},get direction(){return this._direction},set easing(a){this._easingFunction=l(k(a)),this._setMember("easing",a)},get easing(){return this._easing},set iterations(a){if((isNaN(a)||a<0)&&e())throw new TypeError("iterations must be non-negative, received: "+a);this._setMember("iterations",a)},get iterations(){return this._iterations}};var y=1,z=.5,A=0,B={ease:i(.25,.1,.25,1),"ease-in":i(.42,0,1,1),"ease-out":i(0,0,.58,1),"ease-in-out":i(.42,0,.58,1),"step-start":j(1,y),"step-middle":j(1,z),"step-end":j(1,A)},C=null,D="\\s*(-?\\d+\\.?\\d*|-?\\.\\d+)\\s*",E=new RegExp("cubic-bezier\\("+D+","+D+","+D+","+D+"\\)"),F=/steps\(\s*(\d+)\s*,\s*(start|middle|end)\s*\)/,G=0,H=1,I=2,J=3;a.cloneTimingInput=c,a.makeTiming=f,a.numericTimingToObject=g,a.normalizeTimingInput=h,a.calculateActiveDuration=m,a.calculateIterationProgress=u,a.calculatePhase=o,a.normalizeEasing=k,a.parseEasingFunction=l}(c),function(a,b){function c(a,b){return a in k?k[a][b]||b:b}function d(a){return"display"===a||0===a.lastIndexOf("animation",0)||0===a.lastIndexOf("transition",0)}function e(a,b,e){if(!d(a)){var f=h[a];if(f){i.style[a]=b;for(var g in f){var j=f[g],k=i.style[j];e[j]=c(j,k)}}else e[a]=c(a,b)}}function f(a){var b=[];for(var c in a)if(!(c in["easing","offset","composite"])){var d=a[c];Array.isArray(d)||(d=[d]);for(var e,f=d.length,g=0;g<f;g++)e={},e.offset="offset"in a?a.offset:1==f?1:g/(f-1),"easing"in a&&(e.easing=a.easing),"composite"in a&&(e.composite=a.composite),e[c]=d[g],b.push(e)}return b.sort(function(a,b){return a.offset-b.offset}),b}function g(b){function c(){var a=d.length;null==d[a-1].offset&&(d[a-1].offset=1),a>1&&null==d[0].offset&&(d[0].offset=0);for(var b=0,c=d[0].offset,e=1;e<a;e++){var f=d[e].offset;if(null!=f){for(var g=1;g<e-b;g++)d[b+g].offset=c+(f-c)*g/(e-b);b=e,c=f}}}if(null==b)return[];window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||(b=f(b));for(var d=b.map(function(b){var c={};for(var d in b){var f=b[d];if("offset"==d){if(null!=f){if(f=Number(f),!isFinite(f))throw new TypeError("Keyframe offsets must be numbers.");if(f<0||f>1)throw new TypeError("Keyframe offsets must be between 0 and 1.")}}else if("composite"==d){if("add"==f||"accumulate"==f)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"add compositing is not supported"};if("replace"!=f)throw new TypeError("Invalid composite mode "+f+".")}else f="easing"==d?a.normalizeEasing(f):""+f;e(d,f,c)}return void 0==c.offset&&(c.offset=null),void 0==c.easing&&(c.easing="linear"),c}),g=!0,h=-1/0,i=0;i<d.length;i++){var j=d[i].offset;if(null!=j){if(j<h)throw new TypeError("Keyframes are not loosely sorted by offset. Sort or specify offsets.");h=j}else g=!1}return d=d.filter(function(a){return a.offset>=0&&a.offset<=1}),g||c(),d}var h={background:["backgroundImage","backgroundPosition","backgroundSize","backgroundRepeat","backgroundAttachment","backgroundOrigin","backgroundClip","backgroundColor"],border:["borderTopColor","borderTopStyle","borderTopWidth","borderRightColor","borderRightStyle","borderRightWidth","borderBottomColor","borderBottomStyle","borderBottomWidth","borderLeftColor","borderLeftStyle","borderLeftWidth"],borderBottom:["borderBottomWidth","borderBottomStyle","borderBottomColor"],borderColor:["borderTopColor","borderRightColor","borderBottomColor","borderLeftColor"],borderLeft:["borderLeftWidth","borderLeftStyle","borderLeftColor"],borderRadius:["borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius"],borderRight:["borderRightWidth","borderRightStyle","borderRightColor"],borderTop:["borderTopWidth","borderTopStyle","borderTopColor"],borderWidth:["borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth"],flex:["flexGrow","flexShrink","flexBasis"],font:["fontFamily","fontSize","fontStyle","fontVariant","fontWeight","lineHeight"],margin:["marginTop","marginRight","marginBottom","marginLeft"],outline:["outlineColor","outlineStyle","outlineWidth"],padding:["paddingTop","paddingRight","paddingBottom","paddingLeft"]},i=document.createElementNS("http://www.w3.org/1999/xhtml","div"),j={thin:"1px",medium:"3px",thick:"5px"},k={borderBottomWidth:j,borderLeftWidth:j,borderRightWidth:j,borderTopWidth:j,fontSize:{"xx-small":"60%","x-small":"75%",small:"89%",medium:"100%",large:"120%","x-large":"150%","xx-large":"200%"},fontWeight:{normal:"400",bold:"700"},outlineWidth:j,textShadow:{none:"0px 0px 0px transparent"},boxShadow:{none:"0px 0px 0px 0px transparent"}};a.convertToArrayForm=f,a.normalizeKeyframes=g}(c),function(a){var b={};a.isDeprecated=function(a,c,d,e){var f=e?"are":"is",g=new Date,h=new Date(c);return h.setMonth(h.getMonth()+3),!(g<h&&(a in b||console.warn("Web Animations: "+a+" "+f+" deprecated and will stop working on "+h.toDateString()+". "+d),b[a]=!0,1))},a.deprecated=function(b,c,d,e){var f=e?"are":"is";if(a.isDeprecated(b,c,d,e))throw new Error(b+" "+f+" no longer supported. "+d)}}(c),function(){if(document.documentElement.animate){var a=document.documentElement.animate([],0),b=!0;if(a&&(b=!1,"play|currentTime|pause|reverse|playbackRate|cancel|finish|startTime|playState".split("|").forEach(function(c){void 0===a[c]&&(b=!0)})),!b)return}!function(a,b,c){function d(a){for(var b={},c=0;c<a.length;c++)for(var d in a[c])if("offset"!=d&&"easing"!=d&&"composite"!=d){var e={offset:a[c].offset,easing:a[c].easing,value:a[c][d]};b[d]=b[d]||[],b[d].push(e)}for(var f in b){var g=b[f];if(0!=g[0].offset||1!=g[g.length-1].offset)throw{type:DOMException.NOT_SUPPORTED_ERR,name:"NotSupportedError",message:"Partial keyframes are not supported"}}return b}function e(c){var d=[];for(var e in c)for(var f=c[e],g=0;g<f.length-1;g++){var h=g,i=g+1,j=f[h].offset,k=f[i].offset,l=j,m=k;0==g&&(l=-1/0,0==k&&(i=h)),g==f.length-2&&(m=1/0,1==j&&(h=i)),d.push({applyFrom:l,applyTo:m,startOffset:f[h].offset,endOffset:f[i].offset,easingFunction:a.parseEasingFunction(f[h].easing),property:e,interpolation:b.propertyInterpolation(e,f[h].value,f[i].value)})}return d.sort(function(a,b){return a.startOffset-b.startOffset}),d}b.convertEffectInput=function(c){var f=a.normalizeKeyframes(c),g=d(f),h=e(g);return function(a,c){if(null!=c)h.filter(function(a){return c>=a.applyFrom&&c<a.applyTo}).forEach(function(d){var e=c-d.startOffset,f=d.endOffset-d.startOffset,g=0==f?0:d.easingFunction(e/f);b.apply(a,d.property,d.interpolation(g))});else for(var d in g)"offset"!=d&&"easing"!=d&&"composite"!=d&&b.clear(a,d)}}}(c,d),function(a,b,c){function d(a){return a.replace(/-(.)/g,function(a,b){return b.toUpperCase()})}function e(a,b,c){h[c]=h[c]||[],h[c].push([a,b])}function f(a,b,c){for(var f=0;f<c.length;f++){e(a,b,d(c[f]))}}function g(c,e,f){var g=c;/-/.test(c)&&!a.isDeprecated("Hyphenated property names","2016-03-22","Use camelCase instead.",!0)&&(g=d(c)),"initial"!=e&&"initial"!=f||("initial"==e&&(e=i[g]),"initial"==f&&(f=i[g]));for(var j=e==f?[]:h[g],k=0;j&&k<j.length;k++){var l=j[k][0](e),m=j[k][0](f);if(void 0!==l&&void 0!==m){var n=j[k][1](l,m);if(n){var o=b.Interpolation.apply(null,n);return function(a){return 0==a?e:1==a?f:o(a)}}}}return b.Interpolation(!1,!0,function(a){return a?f:e})}var h={};b.addPropertiesHandler=f;var i={backgroundColor:"transparent",backgroundPosition:"0% 0%",borderBottomColor:"currentColor",borderBottomLeftRadius:"0px",borderBottomRightRadius:"0px",borderBottomWidth:"3px",borderLeftColor:"currentColor",borderLeftWidth:"3px",borderRightColor:"currentColor",borderRightWidth:"3px",borderSpacing:"2px",borderTopColor:"currentColor",borderTopLeftRadius:"0px",borderTopRightRadius:"0px",borderTopWidth:"3px",bottom:"auto",clip:"rect(0px, 0px, 0px, 0px)",color:"black",fontSize:"100%",fontWeight:"400",height:"auto",left:"auto",letterSpacing:"normal",lineHeight:"120%",marginBottom:"0px",marginLeft:"0px",marginRight:"0px",marginTop:"0px",maxHeight:"none",maxWidth:"none",minHeight:"0px",minWidth:"0px",opacity:"1.0",outlineColor:"invert",outlineOffset:"0px",outlineWidth:"3px",paddingBottom:"0px",paddingLeft:"0px",paddingRight:"0px",paddingTop:"0px",right:"auto",strokeDasharray:"none",strokeDashoffset:"0px",textIndent:"0px",textShadow:"0px 0px 0px transparent",top:"auto",transform:"",verticalAlign:"0px",visibility:"visible",width:"auto",wordSpacing:"normal",zIndex:"auto"};b.propertyInterpolation=g}(c,d),function(a,b,c){function d(b){var c=a.calculateActiveDuration(b),d=function(d){return a.calculateIterationProgress(c,d,b)};return d._totalDuration=b.delay+c+b.endDelay,d}b.KeyframeEffect=function(c,e,f,g){var h,i=d(a.normalizeTimingInput(f)),j=b.convertEffectInput(e),k=function(){j(c,h)};return k._update=function(a){return null!==(h=i(a))},k._clear=function(){j(c,null)},k._hasSameTarget=function(a){return c===a},k._target=c,k._totalDuration=i._totalDuration,k._id=g,k}}(c,d),function(a,b){a.apply=function(b,c,d){b.style[a.propertyName(c)]=d},a.clear=function(b,c){b.style[a.propertyName(c)]=""}}(d),function(a){window.Element.prototype.animate=function(b,c){var d="";return c&&c.id&&(d=c.id),a.timeline._play(a.KeyframeEffect(this,b,c,d))}}(d),function(a,b){function c(a,b,d){if("number"==typeof a&&"number"==typeof b)return a*(1-d)+b*d;if("boolean"==typeof a&&"boolean"==typeof b)return d<.5?a:b;if(a.length==b.length){for(var e=[],f=0;f<a.length;f++)e.push(c(a[f],b[f],d));return e}throw"Mismatched interpolation arguments "+a+":"+b}a.Interpolation=function(a,b,d){return function(e){return d(c(a,b,e))}}}(d),function(a,b,c){a.sequenceNumber=0;var d=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="finish",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()};b.Animation=function(b){this.id="",b&&b._id&&(this.id=b._id),this._sequenceNumber=a.sequenceNumber++,this._currentTime=0,this._startTime=null,this._paused=!1,this._playbackRate=1,this._inTimeline=!0,this._finishedFlag=!0,this.onfinish=null,this._finishHandlers=[],this._effect=b,this._inEffect=this._effect._update(0),this._idle=!0,this._currentTimePending=!1},b.Animation.prototype={_ensureAlive:function(){this.playbackRate<0&&0===this.currentTime?this._inEffect=this._effect._update(-1):this._inEffect=this._effect._update(this.currentTime),this._inTimeline||!this._inEffect&&this._finishedFlag||(this._inTimeline=!0,b.timeline._animations.push(this))},_tickCurrentTime:function(a,b){a!=this._currentTime&&(this._currentTime=a,this._isFinished&&!b&&(this._currentTime=this._playbackRate>0?this._totalDuration:0),this._ensureAlive())},get currentTime(){return this._idle||this._currentTimePending?null:this._currentTime},set currentTime(a){a=+a,isNaN(a)||(b.restart(),this._paused||null==this._startTime||(this._startTime=this._timeline.currentTime-a/this._playbackRate),this._currentTimePending=!1,this._currentTime!=a&&(this._idle&&(this._idle=!1,this._paused=!0),this._tickCurrentTime(a,!0),b.applyDirtiedAnimation(this)))},get startTime(){return this._startTime},set startTime(a){a=+a,isNaN(a)||this._paused||this._idle||(this._startTime=a,this._tickCurrentTime((this._timeline.currentTime-this._startTime)*this.playbackRate),b.applyDirtiedAnimation(this))},get playbackRate(){return this._playbackRate},set playbackRate(a){if(a!=this._playbackRate){var c=this.currentTime;this._playbackRate=a,this._startTime=null,"paused"!=this.playState&&"idle"!=this.playState&&(this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)),null!=c&&(this.currentTime=c)}},get _isFinished(){return!this._idle&&(this._playbackRate>0&&this._currentTime>=this._totalDuration||this._playbackRate<0&&this._currentTime<=0)},get _totalDuration(){return this._effect._totalDuration},get playState(){return this._idle?"idle":null==this._startTime&&!this._paused&&0!=this.playbackRate||this._currentTimePending?"pending":this._paused?"paused":this._isFinished?"finished":"running"},_rewind:function(){if(this._playbackRate>=0)this._currentTime=0;else{if(!(this._totalDuration<1/0))throw new DOMException("Unable to rewind negative playback rate animation with infinite duration","InvalidStateError");this._currentTime=this._totalDuration}},play:function(){this._paused=!1,(this._isFinished||this._idle)&&(this._rewind(),this._startTime=null),this._finishedFlag=!1,this._idle=!1,this._ensureAlive(),b.applyDirtiedAnimation(this)},pause:function(){this._isFinished||this._paused||this._idle?this._idle&&(this._rewind(),this._idle=!1):this._currentTimePending=!0,this._startTime=null,this._paused=!0},finish:function(){this._idle||(this.currentTime=this._playbackRate>0?this._totalDuration:0,this._startTime=this._totalDuration-this.currentTime,this._currentTimePending=!1,b.applyDirtiedAnimation(this))},cancel:function(){this._inEffect&&(this._inEffect=!1,this._idle=!0,this._paused=!1,this._isFinished=!0,this._finishedFlag=!0,this._currentTime=0,this._startTime=null,this._effect._update(null),b.applyDirtiedAnimation(this))},reverse:function(){this.playbackRate*=-1,this.play()},addEventListener:function(a,b){"function"==typeof b&&"finish"==a&&this._finishHandlers.push(b)},removeEventListener:function(a,b){if("finish"==a){var c=this._finishHandlers.indexOf(b);c>=0&&this._finishHandlers.splice(c,1)}},_fireEvents:function(a){if(this._isFinished){if(!this._finishedFlag){var b=new d(this,this._currentTime,a),c=this._finishHandlers.concat(this.onfinish?[this.onfinish]:[]);setTimeout(function(){c.forEach(function(a){a.call(b.target,b)})},0),this._finishedFlag=!0}}else this._finishedFlag=!1},_tick:function(a,b){this._idle||this._paused||(null==this._startTime?b&&(this.startTime=a-this._currentTime/this.playbackRate):this._isFinished||this._tickCurrentTime((a-this._startTime)*this.playbackRate)),b&&(this._currentTimePending=!1,this._fireEvents(a))},get _needsTick(){return this.playState in{pending:1,running:1}||!this._finishedFlag},_targetAnimations:function(){var a=this._effect._target;return a._activeAnimations||(a._activeAnimations=[]),a._activeAnimations},_markTarget:function(){var a=this._targetAnimations();-1===a.indexOf(this)&&a.push(this)},_unmarkTarget:function(){var a=this._targetAnimations(),b=a.indexOf(this);-1!==b&&a.splice(b,1)}}}(c,d),function(a,b,c){function d(a){var b=j;j=[],a<q.currentTime&&(a=q.currentTime),q._animations.sort(e),q._animations=h(a,!0,q._animations)[0],b.forEach(function(b){b[1](a)}),g(),l=void 0}function e(a,b){return a._sequenceNumber-b._sequenceNumber}function f(){this._animations=[],this.currentTime=window.performance&&performance.now?performance.now():0}function g(){o.forEach(function(a){a()}),o.length=0}function h(a,c,d){p=!0,n=!1,b.timeline.currentTime=a,m=!1;var e=[],f=[],g=[],h=[];return d.forEach(function(b){b._tick(a,c),b._inEffect?(f.push(b._effect),b._markTarget()):(e.push(b._effect),b._unmarkTarget()),b._needsTick&&(m=!0);var d=b._inEffect||b._needsTick;b._inTimeline=d,d?g.push(b):h.push(b)}),o.push.apply(o,e),o.push.apply(o,f),m&&requestAnimationFrame(function(){}),p=!1,[g,h]}var i=window.requestAnimationFrame,j=[],k=0;window.requestAnimationFrame=function(a){var b=k++;return 0==j.length&&i(d),j.push([b,a]),b},window.cancelAnimationFrame=function(a){j.forEach(function(b){b[0]==a&&(b[1]=function(){})})},f.prototype={_play:function(c){c._timing=a.normalizeTimingInput(c.timing);var d=new b.Animation(c);return d._idle=!1,d._timeline=this,this._animations.push(d),b.restart(),b.applyDirtiedAnimation(d),d}};var l=void 0,m=!1,n=!1;b.restart=function(){return m||(m=!0,requestAnimationFrame(function(){}),n=!0),n},b.applyDirtiedAnimation=function(a){if(!p){a._markTarget();var c=a._targetAnimations();c.sort(e),h(b.timeline.currentTime,!1,c.slice())[1].forEach(function(a){var b=q._animations.indexOf(a);-1!==b&&q._animations.splice(b,1)}),g()}};var o=[],p=!1,q=new f;b.timeline=q}(c,d),function(a){function b(a,b){var c=a.exec(b);if(c)return c=a.ignoreCase?c[0].toLowerCase():c[0],[c,b.substr(c.length)]}function c(a,b){b=b.replace(/^\s*/,"");var c=a(b);if(c)return[c[0],c[1].replace(/^\s*/,"")]}function d(a,d,e){a=c.bind(null,a);for(var f=[];;){var g=a(e);if(!g)return[f,e];if(f.push(g[0]),e=g[1],!(g=b(d,e))||""==g[1])return[f,e];e=g[1]}}function e(a,b){for(var c=0,d=0;d<b.length&&(!/\s|,/.test(b[d])||0!=c);d++)if("("==b[d])c++;else if(")"==b[d]&&(c--,0==c&&d++,c<=0))break;var e=a(b.substr(0,d));return void 0==e?void 0:[e,b.substr(d)]}function f(a,b){for(var c=a,d=b;c&&d;)c>d?c%=d:d%=c;return c=a*b/(c+d)}function g(a){return function(b){var c=a(b);return c&&(c[0]=void 0),c}}function h(a,b){return function(c){return a(c)||[b,c]}}function i(b,c){for(var d=[],e=0;e<b.length;e++){var f=a.consumeTrimmed(b[e],c);if(!f||""==f[0])return;void 0!==f[0]&&d.push(f[0]),c=f[1]}if(""==c)return d}function j(a,b,c,d,e){for(var g=[],h=[],i=[],j=f(d.length,e.length),k=0;k<j;k++){var l=b(d[k%d.length],e[k%e.length]);if(!l)return;g.push(l[0]),h.push(l[1]),i.push(l[2])}return[g,h,function(b){var d=b.map(function(a,b){return i[b](a)}).join(c);return a?a(d):d}]}function k(a,b,c){for(var d=[],e=[],f=[],g=0,h=0;h<c.length;h++)if("function"==typeof c[h]){var i=c[h](a[g],b[g++]);d.push(i[0]),e.push(i[1]),f.push(i[2])}else!function(a){d.push(!1),e.push(!1),f.push(function(){return c[a]})}(h);return[d,e,function(a){for(var b="",c=0;c<a.length;c++)b+=f[c](a[c]);return b}]}a.consumeToken=b,a.consumeTrimmed=c,a.consumeRepeated=d,a.consumeParenthesised=e,a.ignore=g,a.optional=h,a.consumeList=i,a.mergeNestedRepeated=j.bind(null,null),a.mergeWrappedNestedRepeated=j,a.mergeList=k}(d),function(a){function b(b){function c(b){var c=a.consumeToken(/^inset/i,b);if(c)return d.inset=!0,c;var c=a.consumeLengthOrPercent(b);if(c)return d.lengths.push(c[0]),c;var c=a.consumeColor(b);return c?(d.color=c[0],c):void 0}var d={inset:!1,lengths:[],color:null},e=a.consumeRepeated(c,/^/,b);if(e&&e[0].length)return[d,e[1]]}function c(c){var d=a.consumeRepeated(b,/^,/,c);if(d&&""==d[1])return d[0]}function d(b,c){for(;b.lengths.length<Math.max(b.lengths.length,c.lengths.length);)b.lengths.push({px:0});for(;c.lengths.length<Math.max(b.lengths.length,c.lengths.length);)c.lengths.push({px:0});if(b.inset==c.inset&&!!b.color==!!c.color){for(var d,e=[],f=[[],0],g=[[],0],h=0;h<b.lengths.length;h++){var i=a.mergeDimensions(b.lengths[h],c.lengths[h],2==h);f[0].push(i[0]),g[0].push(i[1]),e.push(i[2])}if(b.color&&c.color){var j=a.mergeColors(b.color,c.color);f[1]=j[0],g[1]=j[1],d=j[2]}return[f,g,function(a){for(var c=b.inset?"inset ":" ",f=0;f<e.length;f++)c+=e[f](a[0][f])+" ";return d&&(c+=d(a[1])),c}]}}function e(b,c,d,e){function f(a){return{inset:a,color:[0,0,0,0],lengths:[{px:0},{px:0},{px:0},{px:0}]}}for(var g=[],h=[],i=0;i<d.length||i<e.length;i++){var j=d[i]||f(e[i].inset),k=e[i]||f(d[i].inset);g.push(j),h.push(k)}return a.mergeNestedRepeated(b,c,g,h)}var f=e.bind(null,d,", ");a.addPropertiesHandler(c,f,["box-shadow","text-shadow"])}(d),function(a,b){function c(a){return a.toFixed(3).replace(/0+$/,"").replace(/\.$/,"")}function d(a,b,c){return Math.min(b,Math.max(a,c))}function e(a){if(/^\s*[-+]?(\d*\.)?\d+\s*$/.test(a))return Number(a)}function f(a,b){return[a,b,c]}function g(a,b){if(0!=a)return i(0,1/0)(a,b)}function h(a,b){return[a,b,function(a){return Math.round(d(1,1/0,a))}]}function i(a,b){return function(e,f){return[e,f,function(e){return c(d(a,b,e))}]}}function j(a){var b=a.trim().split(/\s*[\s,]\s*/);if(0!==b.length){for(var c=[],d=0;d<b.length;d++){var f=e(b[d]);if(void 0===f)return;c.push(f)}return c}}function k(a,b){if(a.length==b.length)return[a,b,function(a){return a.map(c).join(" ")}]}function l(a,b){return[a,b,Math.round]}a.clamp=d,a.addPropertiesHandler(j,k,["stroke-dasharray"]),a.addPropertiesHandler(e,i(0,1/0),["border-image-width","line-height"]),a.addPropertiesHandler(e,i(0,1),["opacity","shape-image-threshold"]),a.addPropertiesHandler(e,g,["flex-grow","flex-shrink"]),a.addPropertiesHandler(e,h,["orphans","widows"]),a.addPropertiesHandler(e,l,["z-index"]),a.parseNumber=e,a.parseNumberList=j,a.mergeNumbers=f,a.numberToString=c}(d),function(a,b){function c(a,b){if("visible"==a||"visible"==b)return[0,1,function(c){return c<=0?a:c>=1?b:"visible"}]}a.addPropertiesHandler(String,c,["visibility"])}(d),function(a,b){function c(a){a=a.trim(),f.fillStyle="#000",f.fillStyle=a;var b=f.fillStyle;if(f.fillStyle="#fff",f.fillStyle=a,b==f.fillStyle){f.fillRect(0,0,1,1);var c=f.getImageData(0,0,1,1).data;f.clearRect(0,0,1,1);var d=c[3]/255;return[c[0]*d,c[1]*d,c[2]*d,d]}}function d(b,c){return[b,c,function(b){function c(a){return Math.max(0,Math.min(255,a))}if(b[3])for(var d=0;d<3;d++)b[d]=Math.round(c(b[d]/b[3]));return b[3]=a.numberToString(a.clamp(0,1,b[3])),"rgba("+b.join(",")+")"}]}var e=document.createElementNS("http://www.w3.org/1999/xhtml","canvas");e.width=e.height=1;var f=e.getContext("2d");a.addPropertiesHandler(c,d,["background-color","border-bottom-color","border-left-color","border-right-color","border-top-color","color","fill","flood-color","lighting-color","outline-color","stop-color","stroke","text-decoration-color"]),a.consumeColor=a.consumeParenthesised.bind(null,c),a.mergeColors=d}(d),function(a,b){function c(a){function b(){var b=h.exec(a);g=b?b[0]:void 0}function c(){var a=Number(g);return b(),a}function d(){if("("!==g)return c();b();var a=f();return")"!==g?NaN:(b(),a)}function e(){for(var a=d();"*"===g||"/"===g;){var c=g;b();var e=d();"*"===c?a*=e:a/=e}return a}function f(){for(var a=e();"+"===g||"-"===g;){var c=g;b();var d=e();"+"===c?a+=d:a-=d}return a}var g,h=/([\+\-\w\.]+|[\(\)\*\/])/g;return b(),f()}function d(a,b){if("0"==(b=b.trim().toLowerCase())&&"px".search(a)>=0)return{px:0};if(/^[^(]*$|^calc/.test(b)){b=b.replace(/calc\(/g,"(");var d={};b=b.replace(a,function(a){return d[a]=null,"U"+a});for(var e="U("+a.source+")",f=b.replace(/[-+]?(\d*\.)?\d+([Ee][-+]?\d+)?/g,"N").replace(new RegExp("N"+e,"g"),"D").replace(/\s[+-]\s/g,"O").replace(/\s/g,""),g=[/N\*(D)/g,/(N|D)[*\/]N/g,/(N|D)O\1/g,/\((N|D)\)/g],h=0;h<g.length;)g[h].test(f)?(f=f.replace(g[h],"$1"),h=0):h++;if("D"==f){for(var i in d){var j=c(b.replace(new RegExp("U"+i,"g"),"").replace(new RegExp(e,"g"),"*0"));if(!isFinite(j))return;d[i]=j}return d}}}function e(a,b){return f(a,b,!0)}function f(b,c,d){var e,f=[];for(e in b)f.push(e);for(e in c)f.indexOf(e)<0&&f.push(e);return b=f.map(function(a){return b[a]||0}),c=f.map(function(a){return c[a]||0}),[b,c,function(b){var c=b.map(function(c,e){return 1==b.length&&d&&(c=Math.max(c,0)),a.numberToString(c)+f[e]}).join(" + ");return b.length>1?"calc("+c+")":c}]}var g="px|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc",h=d.bind(null,new RegExp(g,"g")),i=d.bind(null,new RegExp(g+"|%","g")),j=d.bind(null,/deg|rad|grad|turn/g);a.parseLength=h,a.parseLengthOrPercent=i,a.consumeLengthOrPercent=a.consumeParenthesised.bind(null,i),a.parseAngle=j,a.mergeDimensions=f;var k=a.consumeParenthesised.bind(null,h),l=a.consumeRepeated.bind(void 0,k,/^/),m=a.consumeRepeated.bind(void 0,l,/^,/);a.consumeSizePairList=m;var n=function(a){var b=m(a);if(b&&""==b[1])return b[0]},o=a.mergeNestedRepeated.bind(void 0,e," "),p=a.mergeNestedRepeated.bind(void 0,o,",");a.mergeNonNegativeSizePair=o,a.addPropertiesHandler(n,p,["background-size"]),a.addPropertiesHandler(i,e,["border-bottom-width","border-image-width","border-left-width","border-right-width","border-top-width","flex-basis","font-size","height","line-height","max-height","max-width","outline-width","width"]),a.addPropertiesHandler(i,f,["border-bottom-left-radius","border-bottom-right-radius","border-top-left-radius","border-top-right-radius","bottom","left","letter-spacing","margin-bottom","margin-left","margin-right","margin-top","min-height","min-width","outline-offset","padding-bottom","padding-left","padding-right","padding-top","perspective","right","shape-margin","stroke-dashoffset","text-indent","top","vertical-align","word-spacing"])}(d),function(a,b){function c(b){return a.consumeLengthOrPercent(b)||a.consumeToken(/^auto/,b)}function d(b){var d=a.consumeList([a.ignore(a.consumeToken.bind(null,/^rect/)),a.ignore(a.consumeToken.bind(null,/^\(/)),a.consumeRepeated.bind(null,c,/^,/),a.ignore(a.consumeToken.bind(null,/^\)/))],b);if(d&&4==d[0].length)return d[0]}function e(b,c){return"auto"==b||"auto"==c?[!0,!1,function(d){var e=d?b:c;if("auto"==e)return"auto";var f=a.mergeDimensions(e,e);return f[2](f[0])}]:a.mergeDimensions(b,c)}function f(a){return"rect("+a+")"}var g=a.mergeWrappedNestedRepeated.bind(null,f,e,", ");a.parseBox=d,a.mergeBoxes=g,a.addPropertiesHandler(d,g,["clip"])}(d),function(a,b){function c(a){return function(b){var c=0;return a.map(function(a){return a===k?b[c++]:a})}}function d(a){return a}function e(b){if("none"==(b=b.toLowerCase().trim()))return[];for(var c,d=/\s*(\w+)\(([^)]*)\)/g,e=[],f=0;c=d.exec(b);){if(c.index!=f)return;f=c.index+c[0].length;var g=c[1],h=n[g];if(!h)return;var i=c[2].split(","),j=h[0];if(j.length<i.length)return;for(var k=[],o=0;o<j.length;o++){var p,q=i[o],r=j[o];if(void 0===(p=q?{A:function(b){return"0"==b.trim()?m:a.parseAngle(b)},N:a.parseNumber,T:a.parseLengthOrPercent,L:a.parseLength}[r.toUpperCase()](q):{a:m,n:k[0],t:l}[r]))return;k.push(p)}if(e.push({t:g,d:k}),d.lastIndex==b.length)return e}}function f(a){return a.toFixed(6).replace(".000000","")}function g(b,c){if(b.decompositionPair!==c){b.decompositionPair=c;var d=a.makeMatrixDecomposition(b)}if(c.decompositionPair!==b){c.decompositionPair=b;var e=a.makeMatrixDecomposition(c)}return null==d[0]||null==e[0]?[[!1],[!0],function(a){return a?c[0].d:b[0].d}]:(d[0].push(0),e[0].push(1),[d,e,function(b){var c=a.quat(d[0][3],e[0][3],b[5]);return a.composeMatrix(b[0],b[1],b[2],c,b[4]).map(f).join(",")}])}function h(a){return a.replace(/[xy]/,"")}function i(a){return a.replace(/(x|y|z|3d)?$/,"3d")}function j(b,c){var d=a.makeMatrixDecomposition&&!0,e=!1;if(!b.length||!c.length){b.length||(e=!0,b=c,c=[]);for(var f=0;f<b.length;f++){var j=b[f].t,k=b[f].d,l="scale"==j.substr(0,5)?1:0;c.push({t:j,d:k.map(function(a){if("number"==typeof a)return l;var b={};for(var c in a)b[c]=l;return b})})}}var m=function(a,b){return"perspective"==a&&"perspective"==b||("matrix"==a||"matrix3d"==a)&&("matrix"==b||"matrix3d"==b)},o=[],p=[],q=[];if(b.length!=c.length){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]]}else for(var f=0;f<b.length;f++){var j,s=b[f].t,t=c[f].t,u=b[f].d,v=c[f].d,w=n[s],x=n[t];if(m(s,t)){if(!d)return;var r=g([b[f]],[c[f]]);o.push(r[0]),p.push(r[1]),q.push(["matrix",[r[2]]])}else{if(s==t)j=s;else if(w[2]&&x[2]&&h(s)==h(t))j=h(s),u=w[2](u),v=x[2](v);else{if(!w[1]||!x[1]||i(s)!=i(t)){if(!d)return;var r=g(b,c);o=[r[0]],p=[r[1]],q=[["matrix",[r[2]]]];break}j=i(s),u=w[1](u),v=x[1](v)}for(var y=[],z=[],A=[],B=0;B<u.length;B++){var C="number"==typeof u[B]?a.mergeNumbers:a.mergeDimensions,r=C(u[B],v[B]);y[B]=r[0],z[B]=r[1],A.push(r[2])}o.push(y),p.push(z),q.push([j,A])}}if(e){var D=o;o=p,p=D}return[o,p,function(a){return a.map(function(a,b){var c=a.map(function(a,c){return q[b][1][c](a)}).join(",");return"matrix"==q[b][0]&&16==c.split(",").length&&(q[b][0]="matrix3d"),q[b][0]+"("+c+")"}).join(" ")}]}var k=null,l={px:0},m={deg:0},n={matrix:["NNNNNN",[k,k,0,0,k,k,0,0,0,0,1,0,k,k,0,1],d],matrix3d:["NNNNNNNNNNNNNNNN",d],rotate:["A"],rotatex:["A"],rotatey:["A"],rotatez:["A"],rotate3d:["NNNA"],perspective:["L"],scale:["Nn",c([k,k,1]),d],scalex:["N",c([k,1,1]),c([k,1])],scaley:["N",c([1,k,1]),c([1,k])],scalez:["N",c([1,1,k])],scale3d:["NNN",d],skew:["Aa",null,d],skewx:["A",null,c([k,m])],skewy:["A",null,c([m,k])],translate:["Tt",c([k,k,l]),d],translatex:["T",c([k,l,l]),c([k,l])],translatey:["T",c([l,k,l]),c([l,k])],translatez:["L",c([l,l,k])],translate3d:["TTL",d]};a.addPropertiesHandler(e,j,["transform"]),a.transformToSvgMatrix=function(b){var c=a.transformListToMatrix(e(b));return"matrix("+f(c[0])+" "+f(c[1])+" "+f(c[4])+" "+f(c[5])+" "+f(c[12])+" "+f(c[13])+")"}}(d),function(a,b){function c(a,b){b.concat([a]).forEach(function(b){b in document.documentElement.style&&(d[a]=b),e[b]=a})}var d={},e={};c("transform",["webkitTransform","msTransform"]),c("transformOrigin",["webkitTransformOrigin"]),c("perspective",["webkitPerspective"]),c("perspectiveOrigin",["webkitPerspectiveOrigin"]),a.propertyName=function(a){return d[a]||a},a.unprefixedPropertyName=function(a){return e[a]||a}}(d)}(),function(){if(void 0===document.createElement("div").animate([]).oncancel){var a;if(window.performance&&performance.now)var a=function(){return performance.now()};else var a=function(){return Date.now()};var b=function(a,b,c){this.target=a,this.currentTime=b,this.timelineTime=c,this.type="cancel",this.bubbles=!1,this.cancelable=!1,this.currentTarget=a,this.defaultPrevented=!1,this.eventPhase=Event.AT_TARGET,this.timeStamp=Date.now()},c=window.Element.prototype.animate;window.Element.prototype.animate=function(d,e){var f=c.call(this,d,e);f._cancelHandlers=[],f.oncancel=null;var g=f.cancel;f.cancel=function(){g.call(this);var c=new b(this,null,a()),d=this._cancelHandlers.concat(this.oncancel?[this.oncancel]:[]);setTimeout(function(){d.forEach(function(a){a.call(c.target,c)})},0)};var h=f.addEventListener;f.addEventListener=function(a,b){"function"==typeof b&&"cancel"==a?this._cancelHandlers.push(b):h.call(this,a,b)};var i=f.removeEventListener;return f.removeEventListener=function(a,b){if("cancel"==a){var c=this._cancelHandlers.indexOf(b);c>=0&&this._cancelHandlers.splice(c,1)}else i.call(this,a,b)},f}}}(),function(a){var b=document.documentElement,c=null,d=!1;try{var e=getComputedStyle(b).getPropertyValue("opacity"),f="0"==e?"1":"0";c=b.animate({opacity:[f,f]},{duration:1}),c.currentTime=0,d=getComputedStyle(b).getPropertyValue("opacity")==f}catch(a){}finally{c&&c.cancel()}if(!d){var g=window.Element.prototype.animate;window.Element.prototype.animate=function(b,c){return window.Symbol&&Symbol.iterator&&Array.prototype.from&&b[Symbol.iterator]&&(b=Array.from(b)),Array.isArray(b)||null===b||(b=a.convertToArrayForm(b)),g.call(this,b,c)}}}(c),function(a,b,c){function d(a){var c=b.timeline;c.currentTime=a,c._discardAnimations(),0==c._animations.length?f=!1:requestAnimationFrame(d)}var e=window.requestAnimationFrame;window.requestAnimationFrame=function(a){return e(function(c){b.timeline._updateAnimationsPromises(),a(c),b.timeline._updateAnimationsPromises()})},b.AnimationTimeline=function(){this._animations=[],this.currentTime=void 0},b.AnimationTimeline.prototype={getAnimations:function(){return this._discardAnimations(),this._animations.slice()},_updateAnimationsPromises:function(){b.animationsWithPromises=b.animationsWithPromises.filter(function(a){return a._updatePromises()})},_discardAnimations:function(){this._updateAnimationsPromises(),this._animations=this._animations.filter(function(a){return"finished"!=a.playState&&"idle"!=a.playState})},_play:function(a){var c=new b.Animation(a,this);return this._animations.push(c),b.restartWebAnimationsNextTick(),c._updatePromises(),c._animation.play(),c._updatePromises(),c},play:function(a){return a&&a.remove(),this._play(a)}};var f=!1;b.restartWebAnimationsNextTick=function(){f||(f=!0,requestAnimationFrame(d))};var g=new b.AnimationTimeline;b.timeline=g;try{Object.defineProperty(window.document,"timeline",{configurable:!0,get:function(){return g}})}catch(a){}try{window.document.timeline=g}catch(a){}}(0,e),function(a,b,c){b.animationsWithPromises=[],b.Animation=function(b,c){if(this.id="",b&&b._id&&(this.id=b._id),this.effect=b,b&&(b._animation=this),!c)throw new Error("Animation with null timeline is not supported");this._timeline=c,this._sequenceNumber=a.sequenceNumber++,this._holdTime=0,this._paused=!1,this._isGroup=!1,this._animation=null,this._childAnimations=[],this._callback=null,this._oldPlayState="idle",this._rebuildUnderlyingAnimation(),this._animation.cancel(),this._updatePromises()},b.Animation.prototype={_updatePromises:function(){var a=this._oldPlayState,b=this.playState;return this._readyPromise&&b!==a&&("idle"==b?(this._rejectReadyPromise(),this._readyPromise=void 0):"pending"==a?this._resolveReadyPromise():"pending"==b&&(this._readyPromise=void 0)),this._finishedPromise&&b!==a&&("idle"==b?(this._rejectFinishedPromise(),this._finishedPromise=void 0):"finished"==b?this._resolveFinishedPromise():"finished"==a&&(this._finishedPromise=void 0)),this._oldPlayState=this.playState,this._readyPromise||this._finishedPromise},_rebuildUnderlyingAnimation:function(){this._updatePromises();var a,c,d,e,f=!!this._animation;f&&(a=this.playbackRate,c=this._paused,d=this.startTime,e=this.currentTime,this._animation.cancel(),this._animation._wrapper=null,this._animation=null),(!this.effect||this.effect instanceof window.KeyframeEffect)&&(this._animation=b.newUnderlyingAnimationForKeyframeEffect(this.effect),b.bindAnimationForKeyframeEffect(this)),(this.effect instanceof window.SequenceEffect||this.effect instanceof window.GroupEffect)&&(this._animation=b.newUnderlyingAnimationForGroup(this.effect),b.bindAnimationForGroup(this)),this.effect&&this.effect._onsample&&b.bindAnimationForCustomEffect(this),f&&(1!=a&&(this.playbackRate=a),null!==d?this.startTime=d:null!==e?this.currentTime=e:null!==this._holdTime&&(this.currentTime=this._holdTime),c&&this.pause()),this._updatePromises()},_updateChildren:function(){if(this.effect&&"idle"!=this.playState){var a=this.effect._timing.delay;this._childAnimations.forEach(function(c){this._arrangeChildren(c,a),this.effect instanceof window.SequenceEffect&&(a+=b.groupChildDuration(c.effect))}.bind(this))}},_setExternalAnimation:function(a){if(this.effect&&this._isGroup)for(var b=0;b<this.effect.children.length;b++)this.effect.children[b]._animation=a,this._childAnimations[b]._setExternalAnimation(a)},_constructChildAnimations:function(){if(this.effect&&this._isGroup){var a=this.effect._timing.delay;this._removeChildAnimations(),this.effect.children.forEach(function(c){var d=b.timeline._play(c);this._childAnimations.push(d),d.playbackRate=this.playbackRate,this._paused&&d.pause(),c._animation=this.effect._animation,this._arrangeChildren(d,a),this.effect instanceof window.SequenceEffect&&(a+=b.groupChildDuration(c))}.bind(this))}},_arrangeChildren:function(a,b){null===this.startTime?a.currentTime=this.currentTime-b/this.playbackRate:a.startTime!==this.startTime+b/this.playbackRate&&(a.startTime=this.startTime+b/this.playbackRate)},get timeline(){return this._timeline},get playState(){return this._animation?this._animation.playState:"idle"},get finished(){return window.Promise?(this._finishedPromise||(-1==b.animationsWithPromises.indexOf(this)&&b.animationsWithPromises.push(this),this._finishedPromise=new Promise(function(a,b){this._resolveFinishedPromise=function(){a(this)},this._rejectFinishedPromise=function(){b({type:DOMException.ABORT_ERR,name:"AbortError"})}}.bind(this)),"finished"==this.playState&&this._resolveFinishedPromise()),this._finishedPromise):(console.warn("Animation Promises require JavaScript Promise constructor"),null)},get ready(){return window.Promise?(this._readyPromise||(-1==b.animationsWithPromises.indexOf(this)&&b.animationsWithPromises.push(this),this._readyPromise=new Promise(function(a,b){this._resolveReadyPromise=function(){a(this)},this._rejectReadyPromise=function(){b({type:DOMException.ABORT_ERR,name:"AbortError"})}}.bind(this)),"pending"!==this.playState&&this._resolveReadyPromise()),this._readyPromise):(console.warn("Animation Promises require JavaScript Promise constructor"),null)},get onfinish(){return this._animation.onfinish},set onfinish(a){this._animation.onfinish="function"==typeof a?function(b){b.target=this,a.call(this,b)}.bind(this):a},get oncancel(){return this._animation.oncancel},set oncancel(a){this._animation.oncancel="function"==typeof a?function(b){b.target=this,a.call(this,b)}.bind(this):a},get currentTime(){this._updatePromises();var a=this._animation.currentTime;return this._updatePromises(),a},set currentTime(a){this._updatePromises(),this._animation.currentTime=isFinite(a)?a:Math.sign(a)*Number.MAX_VALUE,this._register(),this._forEachChild(function(b,c){b.currentTime=a-c}),this._updatePromises()},get startTime(){return this._animation.startTime},set startTime(a){this._updatePromises(),this._animation.startTime=isFinite(a)?a:Math.sign(a)*Number.MAX_VALUE,this._register(),this._forEachChild(function(b,c){b.startTime=a+c}),this._updatePromises()},get playbackRate(){return this._animation.playbackRate},set playbackRate(a){this._updatePromises();var b=this.currentTime;this._animation.playbackRate=a,this._forEachChild(function(b){b.playbackRate=a}),null!==b&&(this.currentTime=b),this._updatePromises()},play:function(){this._updatePromises(),this._paused=!1,this._animation.play(),-1==this._timeline._animations.indexOf(this)&&this._timeline._animations.push(this),this._register(),b.awaitStartTime(this),this._forEachChild(function(a){var b=a.currentTime;a.play(),a.currentTime=b}),this._updatePromises()},pause:function(){this._updatePromises(),this.currentTime&&(this._holdTime=this.currentTime),this._animation.pause(),this._register(),this._forEachChild(function(a){a.pause()}),this._paused=!0,this._updatePromises()},finish:function(){this._updatePromises(),this._animation.finish(),this._register(),this._updatePromises()},cancel:function(){this._updatePromises(),this._animation.cancel(),this._register(),this._removeChildAnimations(),this._updatePromises()},reverse:function(){this._updatePromises();var a=this.currentTime;this._animation.reverse(),this._forEachChild(function(a){a.reverse()}),null!==a&&(this.currentTime=a),this._updatePromises()},addEventListener:function(a,b){var c=b;"function"==typeof b&&(c=function(a){a.target=this,b.call(this,a)}.bind(this),b._wrapper=c),this._animation.addEventListener(a,c)},removeEventListener:function(a,b){this._animation.removeEventListener(a,b&&b._wrapper||b)},_removeChildAnimations:function(){for(;this._childAnimations.length;)this._childAnimations.pop().cancel()},_forEachChild:function(b){var c=0;if(this.effect.children&&this._childAnimations.length<this.effect.children.length&&this._constructChildAnimations(),this._childAnimations.forEach(function(a){b.call(this,a,c),this.effect instanceof window.SequenceEffect&&(c+=a.effect.activeDuration)}.bind(this)),"pending"!=this.playState){var d=this.effect._timing,e=this.currentTime;null!==e&&(e=a.calculateIterationProgress(a.calculateActiveDuration(d),e,d)),(null==e||isNaN(e))&&this._removeChildAnimations()}}},window.Animation=b.Animation}(c,e),function(a,b,c){function d(b){this._frames=a.normalizeKeyframes(b)}function e(){for(var a=!1;i.length;)i.shift()._updateChildren(),a=!0;return a}var f=function(a){if(a._animation=void 0,a instanceof window.SequenceEffect||a instanceof window.GroupEffect)for(var b=0;b<a.children.length;b++)f(a.children[b])};b.removeMulti=function(a){for(var b=[],c=0;c<a.length;c++){var d=a[c];d._parent?(-1==b.indexOf(d._parent)&&b.push(d._parent),d._parent.children.splice(d._parent.children.indexOf(d),1),d._parent=null,f(d)):d._animation&&d._animation.effect==d&&(d._animation.cancel(),d._animation.effect=new KeyframeEffect(null,[]),d._animation._callback&&(d._animation._callback._animation=null),d._animation._rebuildUnderlyingAnimation(),f(d))}for(c=0;c<b.length;c++)b[c]._rebuild()},b.KeyframeEffect=function(b,c,e,f){return this.target=b,this._parent=null,e=a.numericTimingToObject(e),this._timingInput=a.cloneTimingInput(e),this._timing=a.normalizeTimingInput(e),this.timing=a.makeTiming(e,!1,this),this.timing._effect=this,"function"==typeof c?(a.deprecated("Custom KeyframeEffect","2015-06-22","Use KeyframeEffect.onsample instead."),this._normalizedKeyframes=c):this._normalizedKeyframes=new d(c),this._keyframes=c,this.activeDuration=a.calculateActiveDuration(this._timing),this._id=f,this},b.KeyframeEffect.prototype={getFrames:function(){return"function"==typeof this._normalizedKeyframes?this._normalizedKeyframes:this._normalizedKeyframes._frames},set onsample(a){if("function"==typeof this.getFrames())throw new Error("Setting onsample on custom effect KeyframeEffect is not supported.");this._onsample=a,this._animation&&this._animation._rebuildUnderlyingAnimation()},get parent(){return this._parent},clone:function(){if("function"==typeof this.getFrames())throw new Error("Cloning custom effects is not supported.");var b=new KeyframeEffect(this.target,[],a.cloneTimingInput(this._timingInput),this._id);return b._normalizedKeyframes=this._normalizedKeyframes,b._keyframes=this._keyframes,b},remove:function(){b.removeMulti([this])}};var g=Element.prototype.animate;Element.prototype.animate=function(a,c){var d="";return c&&c.id&&(d=c.id),b.timeline._play(new b.KeyframeEffect(this,a,c,d))};var h=document.createElementNS("http://www.w3.org/1999/xhtml","div");b.newUnderlyingAnimationForKeyframeEffect=function(a){if(a){var b=a.target||h,c=a._keyframes;"function"==typeof c&&(c=[]);var d=a._timingInput;d.id=a._id}else var b=h,c=[],d=0;return g.apply(b,[c,d])},b.bindAnimationForKeyframeEffect=function(a){a.effect&&"function"==typeof a.effect._normalizedKeyframes&&b.bindAnimationForCustomEffect(a)};var i=[];b.awaitStartTime=function(a){null===a.startTime&&a._isGroup&&(0==i.length&&requestAnimationFrame(e),i.push(a))};var j=window.getComputedStyle;Object.defineProperty(window,"getComputedStyle",{configurable:!0,enumerable:!0,value:function(){b.timeline._updateAnimationsPromises();var a=j.apply(this,arguments);return e()&&(a=j.apply(this,arguments)),b.timeline._updateAnimationsPromises(),a}}),window.KeyframeEffect=b.KeyframeEffect,window.Element.prototype.getAnimations=function(){return document.timeline.getAnimations().filter(function(a){return null!==a.effect&&a.effect.target==this}.bind(this))}}(c,e),function(a,b,c){function d(a){a._registered||(a._registered=!0,g.push(a),h||(h=!0,requestAnimationFrame(e)))}function e(a){var b=g;g=[],b.sort(function(a,b){return a._sequenceNumber-b._sequenceNumber}),b=b.filter(function(a){a();var b=a._animation?a._animation.playState:"idle";return"running"!=b&&"pending"!=b&&(a._registered=!1),a._registered}),g.push.apply(g,b),g.length?(h=!0,requestAnimationFrame(e)):h=!1}var f=(document.createElementNS("http://www.w3.org/1999/xhtml","div"),0);b.bindAnimationForCustomEffect=function(b){var c,e=b.effect.target,g="function"==typeof b.effect.getFrames();c=g?b.effect.getFrames():b.effect._onsample;var h=b.effect.timing,i=null;h=a.normalizeTimingInput(h);var j=function(){var d=j._animation?j._animation.currentTime:null;null!==d&&(d=a.calculateIterationProgress(a.calculateActiveDuration(h),d,h),isNaN(d)&&(d=null)),d!==i&&(g?c(d,e,b.effect):c(d,b.effect,b.effect._animation)),i=d};j._animation=b,j._registered=!1,j._sequenceNumber=f++,b._callback=j,d(j)};var g=[],h=!1;b.Animation.prototype._register=function(){this._callback&&d(this._callback)}}(c,e),function(a,b,c){function d(a){return a._timing.delay+a.activeDuration+a._timing.endDelay}function e(b,c,d){this._id=d,this._parent=null,this.children=b||[],this._reparent(this.children),c=a.numericTimingToObject(c),this._timingInput=a.cloneTimingInput(c),this._timing=a.normalizeTimingInput(c,!0),this.timing=a.makeTiming(c,!0,this),this.timing._effect=this,"auto"===this._timing.duration&&(this._timing.duration=this.activeDuration)}window.SequenceEffect=function(){e.apply(this,arguments)},window.GroupEffect=function(){e.apply(this,arguments)},e.prototype={_isAncestor:function(a){for(var b=this;null!==b;){if(b==a)return!0;b=b._parent}return!1},_rebuild:function(){for(var a=this;a;)"auto"===a.timing.duration&&(a._timing.duration=a.activeDuration),a=a._parent;this._animation&&this._animation._rebuildUnderlyingAnimation()},_reparent:function(a){b.removeMulti(a);for(var c=0;c<a.length;c++)a[c]._parent=this},_putChild:function(a,b){for(var c=b?"Cannot append an ancestor or self":"Cannot prepend an ancestor or self",d=0;d<a.length;d++)if(this._isAncestor(a[d]))throw{type:DOMException.HIERARCHY_REQUEST_ERR,name:"HierarchyRequestError",message:c};for(var d=0;d<a.length;d++)b?this.children.push(a[d]):this.children.unshift(a[d]);this._reparent(a),this._rebuild()},append:function(){this._putChild(arguments,!0)},prepend:function(){this._putChild(arguments,!1)},get parent(){return this._parent},get firstChild(){return this.children.length?this.children[0]:null},get lastChild(){return this.children.length?this.children[this.children.length-1]:null},clone:function(){for(var b=a.cloneTimingInput(this._timingInput),c=[],d=0;d<this.children.length;d++)c.push(this.children[d].clone());return this instanceof GroupEffect?new GroupEffect(c,b):new SequenceEffect(c,b)},remove:function(){b.removeMulti([this])}},window.SequenceEffect.prototype=Object.create(e.prototype),Object.defineProperty(window.SequenceEffect.prototype,"activeDuration",{get:function(){var a=0;return this.children.forEach(function(b){a+=d(b)}),Math.max(a,0)}}),window.GroupEffect.prototype=Object.create(e.prototype),Object.defineProperty(window.GroupEffect.prototype,"activeDuration",{get:function(){var a=0;return this.children.forEach(function(b){a=Math.max(a,d(b))}),a}}),b.newUnderlyingAnimationForGroup=function(c){var d,e=null,f=function(b){var c=d._wrapper;if(c&&"pending"!=c.playState&&c.effect)return null==b?void c._removeChildAnimations():0==b&&c.playbackRate<0&&(e||(e=a.normalizeTimingInput(c.effect.timing)),b=a.calculateIterationProgress(a.calculateActiveDuration(e),-1,e),isNaN(b)||null==b)?(c._forEachChild(function(a){a.currentTime=-1}),void c._removeChildAnimations()):void 0},g=new KeyframeEffect(null,[],c._timing,c._id);return g.onsample=f,d=b.timeline._play(g)},b.bindAnimationForGroup=function(a){a._animation._wrapper=a,a._isGroup=!0,b.awaitStartTime(a),a._constructChildAnimations(),a._setExternalAnimation(a)},b.groupChildDuration=d}(c,e),b.true=a}({},function(){return this}());
//# sourceMappingURL=web-animations-next-lite.min.js.map

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/App.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __syncRequire = typeof module === "object" && typeof module.exports === "object";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var css = __webpack_require__("./src/app.m.css");
var App = function () {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var Foo;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, __syncRequire ? Promise.resolve().then(function () { return __webpack_require__("./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,src/Foo!./src/Foo.ts")(); }) : false];
                case 1:
                    Foo = _a.sent();
                    return [2 /*return*/, Foo.default];
            }
        });
    });
};
var Bar = function () {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var Bar;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, __syncRequire ? Promise.resolve().then(function () { return __webpack_require__("./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Bar.ts")(); }) : false];
                case 1:
                    Bar = _a.sent();
                    return [2 /*return*/, Bar.default];
            }
        });
    });
};
var Baz = function () {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var Baz;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, __syncRequire ? Promise.resolve().then(function () { return __webpack_require__("./node_modules/@dojo/webpack-contrib/promise-loader/index.js?global,widgets!./src/Baz.ts")(); }) : false];
                case 1:
                    Baz = _a.sent();
                    return [2 /*return*/, Baz.default];
            }
        });
    });
};
function default_1() {
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var bar, baz;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    console.log(css);
                    return [4 /*yield*/, Bar()];
                case 1:
                    bar = _a.sent();
                    return [4 /*yield*/, Baz()];
                case 2:
                    baz = _a.sent();
                    bar();
                    baz();
                    return [2 /*return*/, App()];
            }
        });
    });
}
exports.default = default_1;


/***/ }),

/***/ "./src/app.m.css":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin
module.exports = {" _key":"test-app/app","root":"app-m__root__YxttP theme-m__root__2d86p"};

/***/ }),

/***/ "./src/main.css":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ "./src/main.ts":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
__webpack_require__("./node_modules/@dojo/webpack-contrib/i18n-plugin/templates/setLocaleData.js");

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__("./node_modules/tslib/tslib.es6.js");
var App_1 = __webpack_require__("./src/App.ts");
var css = __webpack_require__("./src/app.m.css");
var has_1 = __webpack_require__("./node_modules/@dojo/has/has.js");
// !has('bar')
// elided: import './Bar'
if (true) {
    console.log('foo');
}
App_1.default().then(function (result) {
    console.log(result());
    var div = document.createElement('div');
    div.innerHTML = 'hello, world';
    (_a = div.classList).add.apply(_a, tslib_1.__spread(css.root.split(' ')));
    document.body.appendChild(div);
    var _a;
});


/***/ }),

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./node_modules/@dojo/shim/browser.js");
__webpack_require__("./src/main.css");
module.exports = __webpack_require__("./src/main.ts");


/***/ })

},[0]);
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay91bml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZG9qby9jb3JlL0Rlc3Ryb3lhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZG9qby9jb3JlL0V2ZW50ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bkb2pvL2NvcmUvaGFzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZG9qby9jb3JlL2xhbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bkb2pvL2NvcmUvbG9hZC91dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZG9qby9jb3JlL3V1aWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bkb2pvL2hhcy9oYXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bkb2pvL2kxOG4vY2xkci9sb2FkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZG9qby9pMThuL2NsZHIvbG9jYWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGRvam8vaTE4bi9pMThuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZG9qby9pMThuL3V0aWwvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9NYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vUHJvbWlzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9TeW1ib2wuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vb2JqZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL3N0cmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9zdXBwb3J0L2hhcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9zdXBwb3J0L3F1ZXVlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL3N1cHBvcnQvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL2kxOG4tcGx1Z2luL3RlbXBsYXRlcy9zZXRMb2NhbGVEYXRhLmpzIiwid2VicGFjazovLy8uL3NyYy9Gb28udHM/N2RjZSIsIndlYnBhY2s6Ly8vLi9zcmMvQmFyLnRzPzg4NzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL0Jhei50cz9iZmRjIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL2V2ZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL3N1cHBsZW1lbnRhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci91bnJlc29sdmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9ub2RlX21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2N1cnJlbmN5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvZGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL21lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9wbHVyYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9yZWxhdGl2ZS10aW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvdW5pdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3Qvbm9kZS1tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIvaW50ZXJzZWN0aW9uLW9ic2VydmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wZXBqcy9kaXN0L3BlcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dlYi1hbmltYXRpb25zLWpzL3dlYi1hbmltYXRpb25zLW5leHQtbGl0ZS5taW4uanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvQXBwLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAubS5jc3M/MTU2ZCIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi5jc3M/ODQ4NSIsIndlYnBhY2s6Ly8vLi9zcmMvbWFpbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxPOzs7Ozs7QUNWQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDhCOzs7Ozs7OztBQzVEQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwyQ0FBMkMsRUFBRTtBQUMzRztBQUNBO0FBQ0EseURBQXlELHlCQUF5QixFQUFFO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBCOzs7Ozs7OztBQ2pGQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdEQUFnRCxtQ0FBbUMsU0FBUyxpQkFBaUIsMEJBQTBCLEtBQUssWUFBWSwyQkFBMkIsS0FBSyxHQUFHLEVBQUUsT0FBTztBQUNuTyxnQkFBZ0IsaUNBQWlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLFM7Ozs7Ozs7O0FDOUNEO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0Q7Ozs7Ozs7O0FDek9BO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLG1CQUFtQjtBQUM5RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixRQUFRLGdCQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDOzs7Ozs7OztBQ3ZDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUI7Ozs7Ozs7O3VEQ2JBO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRTs7Ozs7Ozs7O0FDNU1EO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0I7Ozs7Ozs7O0FDOU5BO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEI7Ozs7Ozs7OytDQ3pnQkE7QUFDQSw4Q0FBOEMsY0FBYztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGNBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCwwQkFBMEIsRUFBRTtBQUNwRiw4Q0FBOEMsa0NBQWtDLEVBQUU7QUFDbEYsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQjtBQUMvQyxvRUFBb0UsdUNBQXVDLEVBQUU7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsK0JBQStCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSTs7Ozs7Ozs7O0FDMUxEO0FBQ0EsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BELDhCQUE4QixpQkFBaUI7QUFDL0Msa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVCQUF1QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0M7Ozs7Ozs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Qzs7Ozs7Ozs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFO0FBQ0YsQzs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFO0FBQ0YsQzs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFO0FBQ0YsQzs7Ozs7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUIsY0FBYyxVQUFVO0FBQ3hCLHlCQUF5QixVQUFVO0FBQ25DLDJCQUEyQixJQUFJLElBQUk7QUFDbkM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsK0NBQStDO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsSUFBSSxrQkFBa0IsSUFBSTtBQUN4RSwyQ0FBMkMsSUFBSSxlQUFlLEVBQUUsWUFBWSxFQUFFLE9BQU8sRUFBRSxvQkFBb0IsSUFBSSxrQkFBa0IsRUFBRTtBQUNuSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLE9BQU87QUFDbEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSyxhQUFhLEVBQUUsR0FBRyxLQUFLLGFBQWEsRUFBRTtBQUN2RCxRQUFRLEtBQUssbUJBQW1CO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscURBQXFELElBQUksR0FBRyxJQUFJO0FBQ2hFLGNBQWMsa0JBQWtCOztBQUVoQyxtREFBbUQsSUFBSSxHQUFHLElBQUk7QUFDOUQ7O0FBRUEsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGLElBQUksU0FBUyxFQUFFLFNBQVMsSUFBSTs7QUFFNUc7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSw0QkFBNEIsT0FBTztBQUNuQzs7QUFFQTs7Ozs7QUFLQSxDQUFDOzs7Ozs7OztBQ3pxQkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZLFNBQVM7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsc0JBQXNCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksU0FBUztBQUNyQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLFNBQVM7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLFNBQVM7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLFdBQVc7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsWUFBWSxXQUFXO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVkscUJBQXFCO0FBQ2pDLFlBQVksV0FBVztBQUN2QixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxNQUFNO0FBQ2xCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksS0FBSztBQUNqQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxFQUFFO0FBQ2QsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBLENBQUM7Ozs7Ozs7O0FDeGtCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTs7OztBQUlBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELFVBQVU7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBOztBQUVBOztBQUVBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQSxDQUFDOzs7Ozs7OztBQ3BHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGlCQUFpQjtBQUNoRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLENBQUM7OztBQUdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBLENBQUM7Ozs7Ozs7O0FDbktEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUNyQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxLQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsRUFBRSxrQkFBa0I7QUFDMUM7QUFDQSxzQkFBc0IsRUFBRSxFQUFFLEVBQUUsZ0JBQWdCO0FBQzVDO0FBQ0Esc0JBQXNCLEtBQUssR0FBRyxNQUFNO0FBQ3BDO0FBQ0E7QUFDQSxNQUFNLEVBQUU7QUFDUjtBQUNBOztBQUVBLGFBQWEsVUFBVTtBQUN2Qiw4QkFBOEIsaUJBQWlCO0FBQy9DLDBCQUEwQixJQUFJLElBQUk7QUFDbEM7QUFDQSxFQUFFOztBQUVGO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7Ozs7O0FBS0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLDhEQUE4RCxLQUFLO0FBQ25FO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7Ozs7O0FBS0E7QUFDQSxnRUFBZ0UsS0FBSztBQUNyRSx3QkFBd0IsYUFBYTtBQUNyQzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLLGNBQWMsTUFBTSxpQkFBaUIsUUFBUSxHQUFHLFFBQVE7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsS0FBSyxjQUFjLE1BQU0sSUFBSSxTQUFTO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0Qzs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7OztBQUtBLENBQUM7Ozs7Ozs7OztBQ3ZhRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxFQUFFOzs7OztBQUsxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKLEdBQUcsVUFBVTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0EsMkRBQTJELEVBQUU7QUFDN0QsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7QUFLQSxDQUFDOzs7Ozs7Ozs7QUN6YkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQSx1REFBdUQsS0FBSyxVQUFVLE1BQU07QUFDNUU7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixZQUFZO0FBQzVCLGFBQWEsV0FBVyxFQUFFLGNBQWMsT0FBTyxXQUFXLEVBQUUsY0FBYztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUIsYUFBYSxXQUFXLEVBQUUsS0FBSyxPQUFPLFdBQVcsRUFBRSxLQUFLO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksVUFBVSxJQUFJLFVBQVUsU0FBUyxjQUFjO0FBQzNELGVBQWUsV0FBVyxXQUFXLE9BQU8sY0FBYztBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDtBQUNsRCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLHVEQUF1RDtBQUN2RCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELElBQUk7QUFDakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQsSUFBSTtBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RCxF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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLFdBQVc7O0FBRTlDOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0EsQ0FBQzs7Ozs7Ozs7O0FDM2lHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMERBQTBEOztBQUUxRCx1QkFBdUI7O0FBRXZCLGtDQUFrQyx3QkFBd0I7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkIsa0JBQWtCLDJCQUEyQixvQkFBb0IsS0FBSztBQUN0RTtBQUNBO0FBQ0Esa0JBQWtCLG9EQUFvRDtBQUN0RSxtQkFBbUI7QUFDbkIsa0JBQWtCLDJCQUEyQixvQkFBb0IsS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUIsOERBQThEO0FBQ2pGO0FBQ0Esc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYjtBQUNBLG1CQUFtQiw0RUFBNEU7QUFDL0Y7QUFDQSxtQkFBbUIsOERBQThEO0FBQ2pGO0FBQ0Esc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QixhQUFhO0FBQ2I7QUFDQSxtQkFBbUIsOERBQThEO0FBQ2pGO0FBQ0EsbUJBQW1CLG9EQUFvRDtBQUN2RSwrQkFBK0IsVUFBVSxFQUFFO0FBQzNDO0FBQ0Esc0JBQXNCO0FBQ3RCLGFBQWE7QUFDYiwrQkFBK0IsVUFBVSxFQUFFO0FBQzNDO0FBQ0EsbUJBQW1CLG9EQUFvRDtBQUN2RSxnQ0FBZ0MsU0FBUyxnREFBZ0QsRUFBRTtBQUMzRiwrQkFBK0IsVUFBVSxFQUFFO0FBQzNDO0FBQ0EsbUJBQW1CLG9EQUFvRDtBQUN2RSw4QkFBOEIsU0FBUyxvQkFBb0IsRUFBRTtBQUM3RCwrQkFBK0IsU0FBUyxtQ0FBbUMsRUFBRTtBQUM3RSxtQkFBbUIsMkNBQTJDO0FBQzlEO0FBQ0EsbUJBQW1CLHNFQUFzRTtBQUN6RixtQ0FBbUM7QUFDbkMsbUJBQW1CLDBDQUEwQyxvQ0FBb0MsSUFBSTtBQUNyRywrQkFBK0IsVUFBVSxFQUFFO0FBQzNDLG1DQUFtQyx1QkFBdUIsRUFBRTtBQUM1RCx3QkFBd0I7QUFDeEIsbUJBQW1CLDRCQUE0QiwrQ0FBK0MsNkJBQTZCO0FBQzNILCtCQUErQixVQUFVLEVBQUU7QUFDM0M7QUFDQSxtQkFBbUIsOERBQThEO0FBQ2pGLDhCQUE4QixhQUFhLEVBQUU7QUFDN0M7QUFDQSxtQkFBbUIsMERBQTBEO0FBQzdFLDhCQUE4QixZQUFZLEVBQUU7QUFDNUMsc0JBQXNCO0FBQ3RCLG1CQUFtQiw2QkFBNkIsd0JBQXdCLEtBQUs7QUFDN0UsOEJBQThCLGlCQUFpQixFQUFFO0FBQ2pELHNCQUFzQjtBQUN0QixtQkFBbUIsNkJBQTZCLHdCQUF3QixLQUFLO0FBQzdFLDhCQUE4QixpQkFBaUIsRUFBRTtBQUNqRDtBQUNBLG1CQUFtQiwwREFBMEQ7QUFDN0U7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQixzREFBc0Q7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxtQkFBbUIsa0VBQWtFO0FBQ3JGLG1CQUFtQiwyQ0FBMkM7QUFDOUQsK0JBQStCLG1CQUFtQixFQUFFO0FBQ3BEO0FBQ0EsbUJBQW1CLG9FQUFvRTs7QUFFdkY7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9DQUFvQztBQUNwRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwQ0FBMEM7QUFDcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QyxRQUFROztBQUVqRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEIsb0RBQW9EOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHlCQUF5QixFQUFFO0FBQzFGLCtEQUErRCx5QkFBeUIsRUFBRTtBQUMxRiwrREFBK0QseUJBQXlCLEVBQUU7QUFDMUYsK0RBQStELHlCQUF5QixFQUFFO0FBQzFGOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLHFCQUFxQjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsOENBQThDLGtCQUFrQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSw4Q0FBOEMsa0JBQWtCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMENBQTBDLGtCQUFrQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHNDQUFzQyxrQkFBa0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0MsbUJBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLHdDQUF3QyxtQkFBbUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esc0NBQXNDLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0Esd0NBQXdDLG1CQUFtQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMENBQTBDLG1CQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsOENBQThDLG1CQUFtQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSx3Q0FBd0MsbUJBQW1CO0FBQzNEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLG9DQUFvQyxtQkFBbUI7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksV0FBVztBQUN2QjtBQUNBLHFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQkFBK0I7QUFDcEM7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrREFBa0Q7QUFDbEYsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsU0FBUztBQUN4QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDZCQUE2QjtBQUMzRTtBQUNBLDRDQUE0QyxrQkFBa0I7QUFDOUQsYUFBYSxNQUFNO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0IsS0FBSyxNQUFNO0FBQzdEOzs7O0FBSUE7QUFDQSw0REFBNEQ7QUFDNUQsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsNkJBQTZCLDZCQUE2QjtBQUMxRDtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMsU0FBUztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyx1QkFBdUI7QUFDckMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakIsOENBQThDLGlCQUFpQjtBQUMvRDtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsd0JBQXdCO0FBQ3hCLGVBQWUsaURBQWlEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVMsWUFBWTtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLDJCQUEyQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxpREFBaUQsb0JBQW9CLEVBQUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsNEJBQTRCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHFFQUFxRTtBQUNuSDtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7O0FBRXRDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0NBQXdDO0FBQ3BFLFlBQVkseUNBQXlDO0FBQ3JELFlBQVkseUNBQXlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVksT0FBTyxRQUFRO0FBQzNCLFlBQVksT0FBTztBQUNuQjtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEMsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQSxrQkFBa0Isb0NBQW9DLEVBQUU7QUFDeEQ7QUFDQTtBQUNBLG1CQUFtQixRQUFRLEtBQUs7QUFDaEMsa0NBQWtDLG1CQUFtQixXQUFXLE9BQU8sV0FBVyxJQUFJO0FBQ3RGO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0NBQW9DLEVBQUU7QUFDM0QscUJBQXFCLDBEQUEwRCxrQkFBa0Isc0JBQXNCLHFCQUFxQixvQ0FBb0MsRUFBRSxRQUFRO0FBQzFMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsTUFBTSxRQUFRLEtBQUs7QUFDeEMsNkNBQTZDLDBCQUEwQixJQUFJLEtBQUssSUFBSSxLQUFLLElBQUksT0FBTyxLQUFLLFlBQVk7QUFDckgsMkJBQTJCLE1BQU0sS0FBSztBQUN0Qyx5Q0FBeUMsNEJBQTRCLElBQUksY0FBYyxFQUFFO0FBQ3pGLDRCQUE0QixxQkFBcUI7QUFDakQsMENBQTBDLDBDQUEwQztBQUNwRjtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFdBQVc7QUFDbEM7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0NBQXdDO0FBQ25ELGlCQUFpQiwyREFBMkQsU0FBUztBQUNyRixLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWEsa0RBQWtEO0FBQy9ELG1CQUFtQiw0RUFBNEUsU0FBUztBQUN4RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLE9BQU87QUFDOUMsMkRBQTJELE9BQU87QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0Esb0VBQW9FLEtBQUs7QUFDekUsd0JBQXdCLGFBQWE7QUFDckM7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSyxJQUFJLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILHlDQUF5QztBQUN6QztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOzs7OztBQUtBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRDQUE0QyxPQUFPO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7O0FBRUE7Ozs7O0FBS0EsQ0FBQzs7Ozs7Ozs7O0FDOWhFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQSxFQUFFO0FBQ0Y7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0gsNEJBQTRCLG1DQUFtQztBQUMvRDs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix1QkFBdUI7QUFDL0M7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCx3QkFBd0IscUJBQXFCLEtBQUs7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0Qjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsSUFBSSxLQUFLLEVBQUU7QUFDM0Q7QUFDQSxnREFBZ0QsSUFBSSxNQUFNLEVBQUUsT0FBTyxFQUFFOztBQUVyRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQsaUJBQWlCLDhCQUE4QjtBQUMvQyxpQkFBaUIsNEJBQTRCO0FBQzdDLEdBQUc7QUFDSCxzQkFBc0IsOEJBQThCO0FBQ3BELGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7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QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0EsQ0FBQzs7Ozs7Ozs7O0FDdlhEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0EsQ0FBQzs7Ozs7Ozs7O0FDM01EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksVUFBVSxFQUFFO0FBQ2hCLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLE1BQU0sVUFBVSxFQUFFO0FBQ2xCLGtCQUFrQixFQUFFLFFBQVE7QUFDNUIsTUFBTSxVQUFVLEVBQUU7QUFDbEIsa0JBQWtCLEVBQUUsV0FBVztBQUMvQjtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlDQUFpQyxFQUFFO0FBQ25DLG1DQUFtQyxFQUFFO0FBQ3JDLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxVQUFVLEVBQUU7QUFDbEIsa0JBQWtCLEVBQUUsUUFBUTtBQUM1QixNQUFNLFVBQVUsRUFBRTtBQUNsQixrQkFBa0IsRUFBRSxXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7O0FBS0EsQ0FBQzs7Ozs7Ozs7O0FDOVNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsNkJBQTZCO0FBQzlEO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSx5QkFBeUIsMkNBQTJDOztBQUVwRTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlCQUF5QiwyQ0FBMkM7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxNQUFNO0FBQ3JCLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCLHlCQUF5QixFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWE7QUFDdkQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUJBQXVCOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3Q0FBd0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsd0NBQXdDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3Q0FBd0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUNBQXlDLHdCQUF3QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxHOzs7Ozs7O0FDMzVDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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LHdMQUFvQjs7b0JBQTFCLElBQUcsRUFBRyxTQUFxQjtvQkFDakMsc0JBQU8sR0FBRyxDQUFDLE9BQU87Ozs7Q0FDbEI7QUFFRDs7Ozs7O29CQUNDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDO29CQUNKLHFCQUFNLEdBQUcsRUFBRTs7b0JBQWpCLElBQUcsRUFBRyxTQUFXO29CQUNYLHFCQUFNLEdBQUcsRUFBRTs7b0JBQWpCLElBQUcsRUFBRyxTQUFXO29CQUN2QixHQUFHLEVBQUU7b0JBQ0wsR0FBRyxFQUFFO29CQUNMLHNCQUFPLEdBQUcsRUFBRTs7Ozs7QUFOYjs7Ozs7Ozs7QUNqQkE7QUFDQSxrQkFBa0IseUU7Ozs7Ozs7QUNEbEIseUM7Ozs7Ozs7Ozs7OztBQ0FBO0FBQ0E7QUFDQTs7O1VBSWdCO0lBQ2YsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUM7QUFDbkI7QUFFQSxhQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsZ0JBQU07SUFDaEIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUNyQixJQUFNLElBQUcsRUFBRyxRQUFRLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQztJQUN6QyxHQUFHLENBQUMsVUFBUyxFQUFHLGNBQWM7SUFDOUIsU0FBRyxDQUFDLFNBQVMsRUFBQyxHQUFHLDRCQUFJLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUN4QyxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUM7O0FBQy9CLENBQUMsQ0FBQyIsImZpbGUiOiJtYWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoXCJtYWluXCIsIFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIm1haW5cIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wibWFpblwiXSA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIFxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL3VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIGxhbmdfMSA9IHJlcXVpcmUoXCIuL2xhbmdcIik7XHJcbnZhciBQcm9taXNlXzEgPSByZXF1aXJlKFwiQGRvam8vc2hpbS9Qcm9taXNlXCIpO1xyXG4vKipcclxuICogTm8gb3BlcmF0aW9uIGZ1bmN0aW9uIHRvIHJlcGxhY2Ugb3duIG9uY2UgaW5zdGFuY2UgaXMgZGVzdG9yeWVkXHJcbiAqL1xyXG5mdW5jdGlvbiBub29wKCkge1xyXG4gICAgcmV0dXJuIFByb21pc2VfMS5kZWZhdWx0LnJlc29sdmUoZmFsc2UpO1xyXG59XHJcbi8qKlxyXG4gKiBObyBvcCBmdW5jdGlvbiB1c2VkIHRvIHJlcGxhY2Ugb3duLCBvbmNlIGluc3RhbmNlIGhhcyBiZWVuIGRlc3RvcnllZFxyXG4gKi9cclxuZnVuY3Rpb24gZGVzdHJveWVkKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsIG1hZGUgdG8gZGVzdHJveWVkIG1ldGhvZCcpO1xyXG59XHJcbnZhciBEZXN0cm95YWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGNvbnN0cnVjdG9yXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIERlc3Ryb3lhYmxlKCkge1xyXG4gICAgICAgIHRoaXMuaGFuZGxlcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBoYW5kbGVzIGZvciB0aGUgaW5zdGFuY2UgdGhhdCB3aWxsIGJlIGRlc3Ryb3llZCB3aGVuIGB0aGlzLmRlc3Ryb3lgIGlzIGNhbGxlZFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SGFuZGxlfSBoYW5kbGUgVGhlIGhhbmRsZSB0byBhZGQgZm9yIHRoZSBpbnN0YW5jZVxyXG4gICAgICogQHJldHVybnMge0hhbmRsZX0gYSBoYW5kbGUgZm9yIHRoZSBoYW5kbGUsIHJlbW92ZXMgdGhlIGhhbmRsZSBmb3IgdGhlIGluc3RhbmNlIGFuZCBjYWxscyBkZXN0cm95XHJcbiAgICAgKi9cclxuICAgIERlc3Ryb3lhYmxlLnByb3RvdHlwZS5vd24gPSBmdW5jdGlvbiAoaGFuZGxlcykge1xyXG4gICAgICAgIHZhciBoYW5kbGUgPSBBcnJheS5pc0FycmF5KGhhbmRsZXMpID8gbGFuZ18xLmNyZWF0ZUNvbXBvc2l0ZUhhbmRsZS5hcHBseSh2b2lkIDAsIHRzbGliXzEuX19zcHJlYWQoaGFuZGxlcykpIDogaGFuZGxlcztcclxuICAgICAgICB2YXIgX2hhbmRsZXMgPSB0aGlzLmhhbmRsZXM7XHJcbiAgICAgICAgX2hhbmRsZXMucHVzaChoYW5kbGUpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIF9oYW5kbGVzLnNwbGljZShfaGFuZGxlcy5pbmRleE9mKGhhbmRsZSkpO1xyXG4gICAgICAgICAgICAgICAgaGFuZGxlLmRlc3Ryb3koKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXN0cnB5cyBhbGwgaGFuZGVycyByZWdpc3RlcmVkIGZvciB0aGUgaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxhbnl9IGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgYWxsIGhhbmRsZXMgaGF2ZSBiZWVuIGRlc3Ryb3llZFxyXG4gICAgICovXHJcbiAgICBEZXN0cm95YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZV8xLmRlZmF1bHQoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgX3RoaXMuaGFuZGxlcy5mb3JFYWNoKGZ1bmN0aW9uIChoYW5kbGUpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZSAmJiBoYW5kbGUuZGVzdHJveSAmJiBoYW5kbGUuZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgX3RoaXMuZGVzdHJveSA9IG5vb3A7XHJcbiAgICAgICAgICAgIF90aGlzLm93biA9IGRlc3Ryb3llZDtcclxuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gRGVzdHJveWFibGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuRGVzdHJveWFibGUgPSBEZXN0cm95YWJsZTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gRGVzdHJveWFibGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vY29yZS9EZXN0cm95YWJsZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGRvam8vY29yZS9EZXN0cm95YWJsZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIE1hcF8xID0gcmVxdWlyZShcIkBkb2pvL3NoaW0vTWFwXCIpO1xyXG52YXIgRGVzdHJveWFibGVfMSA9IHJlcXVpcmUoXCIuL0Rlc3Ryb3lhYmxlXCIpO1xyXG4vKipcclxuICogTWFwIG9mIGNvbXB1dGVkIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGtleWVkIGJ5IHN0cmluZ1xyXG4gKi9cclxudmFyIHJlZ2V4TWFwID0gbmV3IE1hcF8xLmRlZmF1bHQoKTtcclxuLyoqXHJcbiAqIERldGVybWluZXMgaXMgdGhlIGV2ZW50IHR5cGUgZ2xvYiBoYXMgYmVlbiBtYXRjaGVkXHJcbiAqXHJcbiAqIEByZXR1cm5zIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgdGhlIGdsb2IgaXMgbWF0Y2hlZFxyXG4gKi9cclxuZnVuY3Rpb24gaXNHbG9iTWF0Y2goZ2xvYlN0cmluZywgdGFyZ2V0U3RyaW5nKSB7XHJcbiAgICBpZiAodHlwZW9mIHRhcmdldFN0cmluZyA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGdsb2JTdHJpbmcgPT09ICdzdHJpbmcnICYmIGdsb2JTdHJpbmcuaW5kZXhPZignKicpICE9PSAtMSkge1xyXG4gICAgICAgIHZhciByZWdleCA9IHZvaWQgMDtcclxuICAgICAgICBpZiAocmVnZXhNYXAuaGFzKGdsb2JTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHJlZ2V4ID0gcmVnZXhNYXAuZ2V0KGdsb2JTdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKFwiXlwiICsgZ2xvYlN0cmluZy5yZXBsYWNlKC9cXCovZywgJy4qJykgKyBcIiRcIik7XHJcbiAgICAgICAgICAgIHJlZ2V4TWFwLnNldChnbG9iU3RyaW5nLCByZWdleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZWdleC50ZXN0KHRhcmdldFN0cmluZyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gZ2xvYlN0cmluZyA9PT0gdGFyZ2V0U3RyaW5nO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuaXNHbG9iTWF0Y2ggPSBpc0dsb2JNYXRjaDtcclxuLyoqXHJcbiAqIEV2ZW50IENsYXNzXHJcbiAqL1xyXG52YXIgRXZlbnRlZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEV2ZW50ZWQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBFdmVudGVkKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIG1hcCBvZiBsaXN0ZW5lcnMga2V5ZWQgYnkgZXZlbnQgdHlwZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLmxpc3RlbmVyc01hcCA9IG5ldyBNYXBfMS5kZWZhdWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRXZlbnRlZC5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5saXN0ZW5lcnNNYXAuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kcywgdHlwZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNHbG9iTWF0Y2godHlwZSwgZXZlbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIG1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kLmNhbGwoX3RoaXMsIGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRlZC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGxpc3RlbmVyKSkge1xyXG4gICAgICAgICAgICB2YXIgaGFuZGxlc18xID0gbGlzdGVuZXIubWFwKGZ1bmN0aW9uIChsaXN0ZW5lcikgeyByZXR1cm4gX3RoaXMuX2FkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTsgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlc18xLmZvckVhY2goZnVuY3Rpb24gKGhhbmRsZSkgeyByZXR1cm4gaGFuZGxlLmRlc3Ryb3koKTsgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XHJcbiAgICB9O1xyXG4gICAgRXZlbnRlZC5wcm90b3R5cGUuX2FkZExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnNNYXAuZ2V0KHR5cGUpIHx8IFtdO1xyXG4gICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuICAgICAgICB0aGlzLmxpc3RlbmVyc01hcC5zZXQodHlwZSwgbGlzdGVuZXJzKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gX3RoaXMubGlzdGVuZXJzTWFwLmdldCh0eXBlKSB8fCBbXTtcclxuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UobGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEV2ZW50ZWQ7XHJcbn0oRGVzdHJveWFibGVfMS5EZXN0cm95YWJsZSkpO1xyXG5leHBvcnRzLkV2ZW50ZWQgPSBFdmVudGVkO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudGVkO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2NvcmUvRXZlbnRlZC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGRvam8vY29yZS9FdmVudGVkLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG52YXIgZ2xvYmFsXzEgPSByZXF1aXJlKFwiQGRvam8vc2hpbS9nbG9iYWxcIik7XHJcbnZhciBoYXNfMSA9IHJlcXVpcmUoXCJAZG9qby9zaGltL3N1cHBvcnQvaGFzXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiQGRvam8vc2hpbS9zdXBwb3J0L2hhc1wiKSwgZXhwb3J0cyk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGhhc18xLmRlZmF1bHQ7XHJcbmhhc18xLmFkZCgnb2JqZWN0LWFzc2lnbicsIHR5cGVvZiBnbG9iYWxfMS5kZWZhdWx0Lk9iamVjdC5hc3NpZ24gPT09ICdmdW5jdGlvbicsIHRydWUpO1xyXG5oYXNfMS5hZGQoJ2FycmF5YnVmZmVyJywgdHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQuQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnLCB0cnVlKTtcclxuaGFzXzEuYWRkKCdmb3JtZGF0YScsIHR5cGVvZiBnbG9iYWxfMS5kZWZhdWx0LkZvcm1EYXRhICE9PSAndW5kZWZpbmVkJywgdHJ1ZSk7XHJcbmhhc18xLmFkZCgnZmlsZXJlYWRlcicsIHR5cGVvZiBnbG9iYWxfMS5kZWZhdWx0LkZpbGVSZWFkZXIgIT09ICd1bmRlZmluZWQnLCB0cnVlKTtcclxuaGFzXzEuYWRkKCd4aHInLCB0eXBlb2YgZ2xvYmFsXzEuZGVmYXVsdC5YTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcsIHRydWUpO1xyXG5oYXNfMS5hZGQoJ3hocjInLCBoYXNfMS5kZWZhdWx0KCd4aHInKSAmJiAncmVzcG9uc2VUeXBlJyBpbiBnbG9iYWxfMS5kZWZhdWx0LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZSwgdHJ1ZSk7XHJcbmhhc18xLmFkZCgnYmxvYicsIGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghaGFzXzEuZGVmYXVsdCgneGhyMicpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgZ2xvYmFsXzEuZGVmYXVsdC5YTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgcmVxdWVzdC5vcGVuKCdHRVQnLCAnaHR0cDovL3d3dy5nb29nbGUuY29tJywgdHJ1ZSk7XHJcbiAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9ICdibG9iJztcclxuICAgIHJlcXVlc3QuYWJvcnQoKTtcclxuICAgIHJldHVybiByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9PT0gJ2Jsb2InO1xyXG59LCB0cnVlKTtcclxuaGFzXzEuYWRkKCdub2RlLWJ1ZmZlcicsICdCdWZmZXInIGluIGdsb2JhbF8xLmRlZmF1bHQgJiYgdHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQuQnVmZmVyID09PSAnZnVuY3Rpb24nLCB0cnVlKTtcclxuaGFzXzEuYWRkKCdmZXRjaCcsICdmZXRjaCcgaW4gZ2xvYmFsXzEuZGVmYXVsdCAmJiB0eXBlb2YgZ2xvYmFsXzEuZGVmYXVsdC5mZXRjaCA9PT0gJ2Z1bmN0aW9uJywgdHJ1ZSk7XHJcbmhhc18xLmFkZCgnd2ViLXdvcmtlci14aHItdXBsb2FkJywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgaWYgKGdsb2JhbF8xLmRlZmF1bHQuV29ya2VyICE9PSB1bmRlZmluZWQgJiYgZ2xvYmFsXzEuZGVmYXVsdC5VUkwgJiYgZ2xvYmFsXzEuZGVmYXVsdC5VUkwuY3JlYXRlT2JqZWN0VVJMKSB7XHJcbiAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW1xyXG4gICAgICAgICAgICAgICAgXCIoZnVuY3Rpb24gKCkge1xcbnNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uICgpIHtcXG5cXHR2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XFxuXFx0dHJ5IHtcXG5cXHRcXHR4aHIudXBsb2FkO1xcblxcdFxcdHBvc3RNZXNzYWdlKCd0cnVlJyk7XFxuXFx0fSBjYXRjaCAoZSkge1xcblxcdFxcdHBvc3RNZXNzYWdlKCdmYWxzZScpO1xcblxcdH1cXG59KTtcXG5cXHRcXHR9KSgpXCJcclxuICAgICAgICAgICAgXSwgeyB0eXBlOiAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcgfSk7XHJcbiAgICAgICAgICAgIHZhciB3b3JrZXIgPSBuZXcgV29ya2VyKFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYikpO1xyXG4gICAgICAgICAgICB3b3JrZXIuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IF9hLmRhdGE7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCA9PT0gJ3RydWUnKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7fSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8vIElFMTEgb24gV2lub2R3cyA4LjEgZW5jb3VudGVycyBhIHNlY3VyaXR5IGVycm9yLlxyXG4gICAgICAgIHJlc29sdmUoZmFsc2UpO1xyXG4gICAgfVxyXG59KSwgdHJ1ZSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vY29yZS9oYXMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2NvcmUvaGFzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG52YXIgb2JqZWN0XzEgPSByZXF1aXJlKFwiQGRvam8vc2hpbS9vYmplY3RcIik7XHJcbnZhciBvYmplY3RfMiA9IHJlcXVpcmUoXCJAZG9qby9zaGltL29iamVjdFwiKTtcclxuZXhwb3J0cy5hc3NpZ24gPSBvYmplY3RfMi5hc3NpZ247XHJcbnZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcclxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcclxuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgdGhhdCBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGNhbiBiZSBjb2VyY2VkIHRvIE9iamVjdFxyXG4gKiB0byB3ZWVkIG91dCBob3N0IG9iamVjdHMgdGhhdCBkbyBub3QgZGVyaXZlIGZyb20gT2JqZWN0LlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gY2hlY2sgaWYgd2Ugd2FudCB0byBkZWVwIGNvcHkgYW4gb2JqZWN0IG9yIG5vdC5cclxuICogTm90ZTogSW4gRVM2IGl0IGlzIHBvc3NpYmxlIHRvIG1vZGlmeSBhbiBvYmplY3QncyBTeW1ib2wudG9TdHJpbmdUYWcgcHJvcGVydHksIHdoaWNoIHdpbGxcclxuICogY2hhbmdlIHRoZSB2YWx1ZSByZXR1cm5lZCBieSBgdG9TdHJpbmdgLiBUaGlzIGlzIGEgcmFyZSBlZGdlIGNhc2UgdGhhdCBpcyBkaWZmaWN1bHQgdG8gaGFuZGxlLFxyXG4gKiBzbyBpdCBpcyBub3QgaGFuZGxlZCBoZXJlLlxyXG4gKiBAcGFyYW0gIHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVja1xyXG4gKiBAcmV0dXJuICAgICAgIElmIHRoZSB2YWx1ZSBpcyBjb2VyY2libGUgaW50byBhbiBPYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIHNob3VsZERlZXBDb3B5T2JqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XHJcbn1cclxuZnVuY3Rpb24gY29weUFycmF5KGFycmF5LCBpbmhlcml0ZWQpIHtcclxuICAgIHJldHVybiBhcnJheS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29weUFycmF5KGl0ZW0sIGluaGVyaXRlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAhc2hvdWxkRGVlcENvcHlPYmplY3QoaXRlbSlcclxuICAgICAgICAgICAgPyBpdGVtXHJcbiAgICAgICAgICAgIDogX21peGluKHtcclxuICAgICAgICAgICAgICAgIGRlZXA6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpbmhlcml0ZWQ6IGluaGVyaXRlZCxcclxuICAgICAgICAgICAgICAgIHNvdXJjZXM6IFtpdGVtXSxcclxuICAgICAgICAgICAgICAgIHRhcmdldDoge31cclxuICAgICAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBfbWl4aW4oa3dBcmdzKSB7XHJcbiAgICB2YXIgZGVlcCA9IGt3QXJncy5kZWVwO1xyXG4gICAgdmFyIGluaGVyaXRlZCA9IGt3QXJncy5pbmhlcml0ZWQ7XHJcbiAgICB2YXIgdGFyZ2V0ID0ga3dBcmdzLnRhcmdldDtcclxuICAgIHZhciBjb3BpZWQgPSBrd0FyZ3MuY29waWVkIHx8IFtdO1xyXG4gICAgdmFyIGNvcGllZENsb25lID0gdHNsaWJfMS5fX3NwcmVhZChjb3BpZWQpO1xyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrd0FyZ3Muc291cmNlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHZhciBzb3VyY2UgPSBrd0FyZ3Muc291cmNlc1tpXTtcclxuICAgICAgICBpZiAoc291cmNlID09PSBudWxsIHx8IHNvdXJjZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvcGllZENsb25lLmluZGV4T2YodmFsdWUpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRlZXApIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBjb3B5QXJyYXkodmFsdWUsIGluaGVyaXRlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNob3VsZERlZXBDb3B5T2JqZWN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XSB8fCB7fTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29waWVkLnB1c2goc291cmNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfbWl4aW4oe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVlcDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaGVyaXRlZDogaW5oZXJpdGVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlczogW3ZhbHVlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0VmFsdWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3BpZWQ6IGNvcGllZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxyXG5mdW5jdGlvbiBjcmVhdGUocHJvdG90eXBlKSB7XHJcbiAgICB2YXIgbWl4aW5zID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIG1peGluc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIGlmICghbWl4aW5zLmxlbmd0aCkge1xyXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdsYW5nLmNyZWF0ZSByZXF1aXJlcyBhdCBsZWFzdCBvbmUgbWl4aW4gb2JqZWN0LicpO1xyXG4gICAgfVxyXG4gICAgdmFyIGFyZ3MgPSBtaXhpbnMuc2xpY2UoKTtcclxuICAgIGFyZ3MudW5zaGlmdChPYmplY3QuY3JlYXRlKHByb3RvdHlwZSkpO1xyXG4gICAgcmV0dXJuIG9iamVjdF8xLmFzc2lnbi5hcHBseShudWxsLCBhcmdzKTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZSA9IGNyZWF0ZTtcclxuZnVuY3Rpb24gZGVlcEFzc2lnbih0YXJnZXQpIHtcclxuICAgIHZhciBzb3VyY2VzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX21peGluKHtcclxuICAgICAgICBkZWVwOiB0cnVlLFxyXG4gICAgICAgIGluaGVyaXRlZDogZmFsc2UsXHJcbiAgICAgICAgc291cmNlczogc291cmNlcyxcclxuICAgICAgICB0YXJnZXQ6IHRhcmdldFxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kZWVwQXNzaWduID0gZGVlcEFzc2lnbjtcclxuZnVuY3Rpb24gZGVlcE1peGluKHRhcmdldCkge1xyXG4gICAgdmFyIHNvdXJjZXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBfbWl4aW4oe1xyXG4gICAgICAgIGRlZXA6IHRydWUsXHJcbiAgICAgICAgaW5oZXJpdGVkOiB0cnVlLFxyXG4gICAgICAgIHNvdXJjZXM6IHNvdXJjZXMsXHJcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuZGVlcE1peGluID0gZGVlcE1peGluO1xyXG4vKipcclxuICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdXNpbmcgdGhlIHByb3ZpZGVkIHNvdXJjZSdzIHByb3RvdHlwZSBhcyB0aGUgcHJvdG90eXBlIGZvciB0aGUgbmV3IG9iamVjdCwgYW5kIHRoZW5cclxuICogZGVlcCBjb3BpZXMgdGhlIHByb3ZpZGVkIHNvdXJjZSdzIHZhbHVlcyBpbnRvIHRoZSBuZXcgdGFyZ2V0LlxyXG4gKlxyXG4gKiBAcGFyYW0gc291cmNlIFRoZSBvYmplY3QgdG8gZHVwbGljYXRlXHJcbiAqIEByZXR1cm4gVGhlIG5ldyBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIGR1cGxpY2F0ZShzb3VyY2UpIHtcclxuICAgIHZhciB0YXJnZXQgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzb3VyY2UpKTtcclxuICAgIHJldHVybiBkZWVwTWl4aW4odGFyZ2V0LCBzb3VyY2UpO1xyXG59XHJcbmV4cG9ydHMuZHVwbGljYXRlID0gZHVwbGljYXRlO1xyXG4vKipcclxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHR3byB2YWx1ZXMgYXJlIHRoZSBzYW1lIHZhbHVlLlxyXG4gKlxyXG4gKiBAcGFyYW0gYSBGaXJzdCB2YWx1ZSB0byBjb21wYXJlXHJcbiAqIEBwYXJhbSBiIFNlY29uZCB2YWx1ZSB0byBjb21wYXJlXHJcbiAqIEByZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWVzIGFyZSB0aGUgc2FtZTsgZmFsc2Ugb3RoZXJ3aXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0lkZW50aWNhbChhLCBiKSB7XHJcbiAgICByZXR1cm4gKGEgPT09IGIgfHxcclxuICAgICAgICAvKiBib3RoIHZhbHVlcyBhcmUgTmFOICovXHJcbiAgICAgICAgKGEgIT09IGEgJiYgYiAhPT0gYikpO1xyXG59XHJcbmV4cG9ydHMuaXNJZGVudGljYWwgPSBpc0lkZW50aWNhbDtcclxuLyoqXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGJpbmRzIGEgbWV0aG9kIHRvIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGF0IHJ1bnRpbWUuIFRoaXMgaXMgc2ltaWxhciB0b1xyXG4gKiBgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmRgLCBidXQgaW5zdGVhZCBvZiBhIGZ1bmN0aW9uIGl0IHRha2VzIHRoZSBuYW1lIG9mIGEgbWV0aG9kIG9uIGFuIG9iamVjdC5cclxuICogQXMgYSByZXN1bHQsIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBieSBgbGF0ZUJpbmRgIHdpbGwgYWx3YXlzIGNhbGwgdGhlIGZ1bmN0aW9uIGN1cnJlbnRseSBhc3NpZ25lZCB0b1xyXG4gKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IG9uIHRoZSBvYmplY3QgYXMgb2YgdGhlIG1vbWVudCB0aGUgZnVuY3Rpb24gaXQgcmV0dXJucyBpcyBjYWxsZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBpbnN0YW5jZSBUaGUgY29udGV4dCBvYmplY3RcclxuICogQHBhcmFtIG1ldGhvZCBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIG9uIHRoZSBjb250ZXh0IG9iamVjdCB0byBiaW5kIHRvIGl0c2VsZlxyXG4gKiBAcGFyYW0gc3VwcGxpZWRBcmdzIEFuIG9wdGlvbmFsIGFycmF5IG9mIHZhbHVlcyB0byBwcmVwZW5kIHRvIHRoZSBgaW5zdGFuY2VbbWV0aG9kXWAgYXJndW1lbnRzIGxpc3RcclxuICogQHJldHVybiBUaGUgYm91bmQgZnVuY3Rpb25cclxuICovXHJcbmZ1bmN0aW9uIGxhdGVCaW5kKGluc3RhbmNlLCBtZXRob2QpIHtcclxuICAgIHZhciBzdXBwbGllZEFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgc3VwcGxpZWRBcmdzW19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1cHBsaWVkQXJncy5sZW5ndGhcclxuICAgICAgICA/IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID8gc3VwcGxpZWRBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpIDogc3VwcGxpZWRBcmdzO1xyXG4gICAgICAgICAgICAvLyBUUzcwMTdcclxuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlW21ldGhvZF0uYXBwbHkoaW5zdGFuY2UsIGFyZ3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgLy8gVFM3MDE3XHJcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZVttZXRob2RdLmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xyXG4gICAgICAgIH07XHJcbn1cclxuZXhwb3J0cy5sYXRlQmluZCA9IGxhdGVCaW5kO1xyXG5mdW5jdGlvbiBtaXhpbih0YXJnZXQpIHtcclxuICAgIHZhciBzb3VyY2VzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHNvdXJjZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX21peGluKHtcclxuICAgICAgICBkZWVwOiBmYWxzZSxcclxuICAgICAgICBpbmhlcml0ZWQ6IHRydWUsXHJcbiAgICAgICAgc291cmNlczogc291cmNlcyxcclxuICAgICAgICB0YXJnZXQ6IHRhcmdldFxyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5taXhpbiA9IG1peGluO1xyXG4vKipcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHdoaWNoIGludm9rZXMgdGhlIGdpdmVuIGZ1bmN0aW9uIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cyBwcmVwZW5kZWQgdG8gaXRzIGFyZ3VtZW50IGxpc3QuXHJcbiAqIExpa2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kYCwgYnV0IGRvZXMgbm90IGFsdGVyIGV4ZWN1dGlvbiBjb250ZXh0LlxyXG4gKlxyXG4gKiBAcGFyYW0gdGFyZ2V0RnVuY3Rpb24gVGhlIGZ1bmN0aW9uIHRoYXQgbmVlZHMgdG8gYmUgYm91bmRcclxuICogQHBhcmFtIHN1cHBsaWVkQXJncyBBbiBvcHRpb25hbCBhcnJheSBvZiBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aGUgYHRhcmdldEZ1bmN0aW9uYCBhcmd1bWVudHMgbGlzdFxyXG4gKiBAcmV0dXJuIFRoZSBib3VuZCBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gcGFydGlhbCh0YXJnZXRGdW5jdGlvbikge1xyXG4gICAgdmFyIHN1cHBsaWVkQXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBzdXBwbGllZEFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA/IHN1cHBsaWVkQXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSA6IHN1cHBsaWVkQXJncztcclxuICAgICAgICByZXR1cm4gdGFyZ2V0RnVuY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMucGFydGlhbCA9IHBhcnRpYWw7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB3aXRoIGEgZGVzdHJveSBtZXRob2QgdGhhdCwgd2hlbiBjYWxsZWQsIGNhbGxzIHRoZSBwYXNzZWQtaW4gZGVzdHJ1Y3Rvci5cclxuICogVGhpcyBpcyBpbnRlbmRlZCB0byBwcm92aWRlIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGNyZWF0aW5nIFwicmVtb3ZlXCIgLyBcImRlc3Ryb3lcIiBoYW5kbGVycyBmb3JcclxuICogZXZlbnQgbGlzdGVuZXJzLCB0aW1lcnMsIGV0Yy5cclxuICpcclxuICogQHBhcmFtIGRlc3RydWN0b3IgQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGhhbmRsZSdzIGBkZXN0cm95YCBtZXRob2QgaXMgaW52b2tlZFxyXG4gKiBAcmV0dXJuIFRoZSBoYW5kbGUgb2JqZWN0XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVIYW5kbGUoZGVzdHJ1Y3Rvcikge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHsgfTtcclxuICAgICAgICAgICAgZGVzdHJ1Y3Rvci5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVIYW5kbGUgPSBjcmVhdGVIYW5kbGU7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgc2luZ2xlIGhhbmRsZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGRlc3Ryb3kgbXVsdGlwbGUgaGFuZGxlcyBzaW11bHRhbmVvdXNseS5cclxuICpcclxuICogQHBhcmFtIGhhbmRsZXMgQW4gYXJyYXkgb2YgaGFuZGxlcyB3aXRoIGBkZXN0cm95YCBtZXRob2RzXHJcbiAqIEByZXR1cm4gVGhlIGhhbmRsZSBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvc2l0ZUhhbmRsZSgpIHtcclxuICAgIHZhciBoYW5kbGVzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGhhbmRsZXNbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVIYW5kbGUoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFuZGxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBoYW5kbGVzW2ldLmRlc3Ryb3koKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZUNvbXBvc2l0ZUhhbmRsZSA9IGNyZWF0ZUNvbXBvc2l0ZUhhbmRsZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby9jb3JlL2xhbmcuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2NvcmUvbGFuZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIGl0ZXJhdG9yXzEgPSByZXF1aXJlKFwiQGRvam8vc2hpbS9pdGVyYXRvclwiKTtcclxuZnVuY3Rpb24gaXNQbHVnaW4odmFsdWUpIHtcclxuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUubG9hZCA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG5leHBvcnRzLmlzUGx1Z2luID0gaXNQbHVnaW47XHJcbmZ1bmN0aW9uIHVzZURlZmF1bHQobW9kdWxlcykge1xyXG4gICAgaWYgKGl0ZXJhdG9yXzEuaXNBcnJheUxpa2UobW9kdWxlcykpIHtcclxuICAgICAgICB2YXIgcHJvY2Vzc2VkTW9kdWxlcyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgbW9kdWxlXzEgPSBtb2R1bGVzW2ldO1xyXG4gICAgICAgICAgICBwcm9jZXNzZWRNb2R1bGVzLnB1c2gobW9kdWxlXzEuX19lc01vZHVsZSAmJiBtb2R1bGVfMS5kZWZhdWx0ID8gbW9kdWxlXzEuZGVmYXVsdCA6IG1vZHVsZV8xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZE1vZHVsZXM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpdGVyYXRvcl8xLmlzSXRlcmFibGUobW9kdWxlcykpIHtcclxuICAgICAgICB2YXIgcHJvY2Vzc2VkTW9kdWxlcyA9IFtdO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIG1vZHVsZXNfMSA9IHRzbGliXzEuX192YWx1ZXMobW9kdWxlcyksIG1vZHVsZXNfMV8xID0gbW9kdWxlc18xLm5leHQoKTsgIW1vZHVsZXNfMV8xLmRvbmU7IG1vZHVsZXNfMV8xID0gbW9kdWxlc18xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZV8yID0gbW9kdWxlc18xXzEudmFsdWU7XHJcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRNb2R1bGVzLnB1c2gobW9kdWxlXzIuX19lc01vZHVsZSAmJiBtb2R1bGVfMi5kZWZhdWx0ID8gbW9kdWxlXzIuZGVmYXVsdCA6IG1vZHVsZV8yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxyXG4gICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vZHVsZXNfMV8xICYmICFtb2R1bGVzXzFfMS5kb25lICYmIChfYSA9IG1vZHVsZXNfMS5yZXR1cm4pKSBfYS5jYWxsKG1vZHVsZXNfMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkTW9kdWxlcztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBtb2R1bGVzLl9fZXNNb2R1bGUgJiYgbW9kdWxlcy5kZWZhdWx0ID8gbW9kdWxlcy5kZWZhdWx0IDogbW9kdWxlcztcclxuICAgIH1cclxuICAgIHZhciBlXzEsIF9hO1xyXG59XHJcbmV4cG9ydHMudXNlRGVmYXVsdCA9IHVzZURlZmF1bHQ7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vY29yZS9sb2FkL3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2NvcmUvbG9hZC91dGlsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgdjQgY29tcGxpYW50IFVVSUQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xyXG5mdW5jdGlvbiB1dWlkKCkge1xyXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICB2YXIgciA9IChNYXRoLnJhbmRvbSgpICogMTYpIHwgMCwgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XHJcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbn1cclxuZXhwb3J0cy5kZWZhdWx0ID0gdXVpZDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby9jb3JlL3V1aWQuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2NvcmUvdXVpZC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5mdW5jdGlvbiBpc0ZlYXR1cmVUZXN0VGhlbmFibGUodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50aGVuO1xyXG59XHJcbi8qKlxyXG4gKiBBIGNhY2hlIG9mIHJlc3VsdHMgb2YgZmVhdHVyZSB0ZXN0c1xyXG4gKi9cclxuZXhwb3J0cy50ZXN0Q2FjaGUgPSB7fTtcclxuLyoqXHJcbiAqIEEgY2FjaGUgb2YgdGhlIHVuLXJlc29sdmVkIGZlYXR1cmUgdGVzdHNcclxuICovXHJcbmV4cG9ydHMudGVzdEZ1bmN0aW9ucyA9IHt9O1xyXG4vKipcclxuICogQSBjYWNoZSBvZiB1bnJlc29sdmVkIHRoZW5hYmxlcyAocHJvYmFibHkgcHJvbWlzZXMpXHJcbiAqIEB0eXBlIHt7fX1cclxuICovXHJcbnZhciB0ZXN0VGhlbmFibGVzID0ge307XHJcbi8qKlxyXG4gKiBBIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIHNjb3BlIChgd2luZG93YCBpbiBhIGJyb3dzZXIsIGBnbG9iYWxgIGluIE5vZGVKUylcclxuICovXHJcbnZhciBnbG9iYWxTY29wZSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgLy8gQnJvd3NlcnNcclxuICAgICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvLyBOb2RlXHJcbiAgICAgICAgcmV0dXJuIGdsb2JhbDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIFdlYiB3b3JrZXJzXHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgcmV0dXJuIHt9O1xyXG59KSgpO1xyXG4vKiBHcmFiIHRoZSBzdGF0aWNGZWF0dXJlcyBpZiB0aGVyZSBhcmUgYXZhaWxhYmxlICovXHJcbnZhciBzdGF0aWNGZWF0dXJlcyA9IChnbG9iYWxTY29wZS5Eb2pvSGFzRW52aXJvbm1lbnQgfHwge30pLnN0YXRpY0ZlYXR1cmVzO1xyXG4vKiBDbGVhbmluZyB1cCB0aGUgRG9qb0hhc0Vudmlvcm5tZW50ICovXHJcbmlmICgnRG9qb0hhc0Vudmlyb25tZW50JyBpbiBnbG9iYWxTY29wZSkge1xyXG4gICAgZGVsZXRlIGdsb2JhbFNjb3BlLkRvam9IYXNFbnZpcm9ubWVudDtcclxufVxyXG4vKipcclxuICogQ3VzdG9tIHR5cGUgZ3VhcmQgdG8gbmFycm93IHRoZSBgc3RhdGljRmVhdHVyZXNgIHRvIGVpdGhlciBhIG1hcCBvciBhIGZ1bmN0aW9uIHRoYXRcclxuICogcmV0dXJucyBhIG1hcC5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0byBndWFyZCBmb3JcclxuICovXHJcbmZ1bmN0aW9uIGlzU3RhdGljRmVhdHVyZUZ1bmN0aW9uKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgY2FjaGUgb2YgYXNzZXJ0ZWQgZmVhdHVyZXMgdGhhdCB3ZXJlIGF2YWlsYWJsZSBpbiB0aGUgZ2xvYmFsIHNjb3BlIHdoZW4gdGhlXHJcbiAqIG1vZHVsZSBsb2FkZWRcclxuICovXHJcbnZhciBzdGF0aWNDYWNoZSA9IHN0YXRpY0ZlYXR1cmVzXHJcbiAgICA/IGlzU3RhdGljRmVhdHVyZUZ1bmN0aW9uKHN0YXRpY0ZlYXR1cmVzKVxyXG4gICAgICAgID8gc3RhdGljRmVhdHVyZXMuYXBwbHkoZ2xvYmFsU2NvcGUpXHJcbiAgICAgICAgOiBzdGF0aWNGZWF0dXJlc1xyXG4gICAgOiB7fTsvKiBQcm92aWRpbmcgYW4gZW1wdHkgY2FjaGUsIGlmIG5vbmUgd2FzIGluIHRoZSBlbnZpcm9ubWVudFxyXG5cclxuLyoqXHJcbiogQU1EIHBsdWdpbiBmdW5jdGlvbi5cclxuKlxyXG4qIENvbmRpdGlvbmFsIGxvYWRzIG1vZHVsZXMgYmFzZWQgb24gYSBoYXMgZmVhdHVyZSB0ZXN0IHZhbHVlLlxyXG4qXHJcbiogQHBhcmFtIHJlc291cmNlSWQgR2l2ZXMgdGhlIHJlc29sdmVkIG1vZHVsZSBpZCB0byBsb2FkLlxyXG4qIEBwYXJhbSByZXF1aXJlIFRoZSBsb2FkZXIgcmVxdWlyZSBmdW5jdGlvbiB3aXRoIHJlc3BlY3QgdG8gdGhlIG1vZHVsZSB0aGF0IGNvbnRhaW5lZCB0aGUgcGx1Z2luIHJlc291cmNlIGluIGl0c1xyXG4qICAgICAgICAgICAgICAgIGRlcGVuZGVuY3kgbGlzdC5cclxuKiBAcGFyYW0gbG9hZCBDYWxsYmFjayB0byBsb2FkZXIgdGhhdCBjb25zdW1lcyByZXN1bHQgb2YgcGx1Z2luIGRlbWFuZC5cclxuKi9cclxuZnVuY3Rpb24gbG9hZChyZXNvdXJjZUlkLCByZXF1aXJlLCBsb2FkLCBjb25maWcpIHtcclxuICAgIHJlc291cmNlSWQgPyByZXF1aXJlKFtyZXNvdXJjZUlkXSwgbG9hZCkgOiBsb2FkKCk7XHJcbn1cclxuZXhwb3J0cy5sb2FkID0gbG9hZDtcclxuLyoqXHJcbiAqIEFNRCBwbHVnaW4gZnVuY3Rpb24uXHJcbiAqXHJcbiAqIFJlc29sdmVzIHJlc291cmNlSWQgaW50byBhIG1vZHVsZSBpZCBiYXNlZCBvbiBwb3NzaWJseS1uZXN0ZWQgdGVuYXJ5IGV4cHJlc3Npb24gdGhhdCBicmFuY2hlcyBvbiBoYXMgZmVhdHVyZSB0ZXN0XHJcbiAqIHZhbHVlKHMpLlxyXG4gKlxyXG4gKiBAcGFyYW0gcmVzb3VyY2VJZCBUaGUgaWQgb2YgdGhlIG1vZHVsZVxyXG4gKiBAcGFyYW0gbm9ybWFsaXplIFJlc29sdmVzIGEgcmVsYXRpdmUgbW9kdWxlIGlkIGludG8gYW4gYWJzb2x1dGUgbW9kdWxlIGlkXHJcbiAqL1xyXG5mdW5jdGlvbiBub3JtYWxpemUocmVzb3VyY2VJZCwgbm9ybWFsaXplKSB7XHJcbiAgICB2YXIgdG9rZW5zID0gcmVzb3VyY2VJZC5tYXRjaCgvW1xcPzpdfFteOlxcP10qL2cpIHx8IFtdO1xyXG4gICAgdmFyIGkgPSAwO1xyXG4gICAgZnVuY3Rpb24gZ2V0KHNraXApIHtcclxuICAgICAgICB2YXIgdGVybSA9IHRva2Vuc1tpKytdO1xyXG4gICAgICAgIGlmICh0ZXJtID09PSAnOicpIHtcclxuICAgICAgICAgICAgLy8gZW1wdHkgc3RyaW5nIG1vZHVsZSBuYW1lLCByZXNvbHZlcyB0byBudWxsXHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gcG9zdGZpeGVkIHdpdGggYSA/IG1lYW5zIGl0IGlzIGEgZmVhdHVyZSB0byBicmFuY2ggb24sIHRoZSB0ZXJtIGlzIHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlXHJcbiAgICAgICAgICAgIGlmICh0b2tlbnNbaSsrXSA9PT0gJz8nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXNraXAgJiYgaGFzKHRlcm0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gbWF0Y2hlZCB0aGUgZmVhdHVyZSwgZ2V0IHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlkIG5vdCBtYXRjaCwgZ2V0IHRoZSBzZWNvbmQgdmFsdWUsIHBhc3Npbmcgb3ZlciB0aGUgZmlyc3RcclxuICAgICAgICAgICAgICAgICAgICBnZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldChza2lwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBhIG1vZHVsZVxyXG4gICAgICAgICAgICByZXR1cm4gdGVybTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgaWQgPSBnZXQoKTtcclxuICAgIHJldHVybiBpZCAmJiBub3JtYWxpemUoaWQpO1xyXG59XHJcbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplO1xyXG4vKipcclxuICogQ2hlY2sgaWYgYSBmZWF0dXJlIGhhcyBhbHJlYWR5IGJlZW4gcmVnaXN0ZXJlZFxyXG4gKlxyXG4gKiBAcGFyYW0gZmVhdHVyZSB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZVxyXG4gKi9cclxuZnVuY3Rpb24gZXhpc3RzKGZlYXR1cmUpIHtcclxuICAgIHZhciBub3JtYWxpemVkRmVhdHVyZSA9IGZlYXR1cmUudG9Mb3dlckNhc2UoKTtcclxuICAgIHJldHVybiBCb29sZWFuKG5vcm1hbGl6ZWRGZWF0dXJlIGluIHN0YXRpY0NhY2hlIHx8IG5vcm1hbGl6ZWRGZWF0dXJlIGluIGV4cG9ydHMudGVzdENhY2hlIHx8IGV4cG9ydHMudGVzdEZ1bmN0aW9uc1tub3JtYWxpemVkRmVhdHVyZV0pO1xyXG59XHJcbmV4cG9ydHMuZXhpc3RzID0gZXhpc3RzO1xyXG4vKipcclxuICogUmVnaXN0ZXIgYSBuZXcgdGVzdCBmb3IgYSBuYW1lZCBmZWF0dXJlLlxyXG4gKlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBoYXMuYWRkKCdkb20tYWRkZXZlbnRsaXN0ZW5lcicsICEhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcik7XHJcbiAqXHJcbiAqIEBleGFtcGxlXHJcbiAqIGhhcy5hZGQoJ3RvdWNoLWV2ZW50cycsIGZ1bmN0aW9uICgpIHtcclxuICogICAgcmV0dXJuICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50XHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBAcGFyYW0gZmVhdHVyZSB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZVxyXG4gKiBAcGFyYW0gdmFsdWUgdGhlIHZhbHVlIHJlcG9ydGVkIG9mIHRoZSBmZWF0dXJlLCBvciBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBleGVjdXRlZCBvbmNlIG9uIGZpcnN0IHRlc3RcclxuICogQHBhcmFtIG92ZXJ3cml0ZSBpZiBhbiBleGlzdGluZyB2YWx1ZSBzaG91bGQgYmUgb3ZlcndyaXR0ZW4uIERlZmF1bHRzIHRvIGZhbHNlLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRkKGZlYXR1cmUsIHZhbHVlLCBvdmVyd3JpdGUpIHtcclxuICAgIGlmIChvdmVyd3JpdGUgPT09IHZvaWQgMCkgeyBvdmVyd3JpdGUgPSBmYWxzZTsgfVxyXG4gICAgdmFyIG5vcm1hbGl6ZWRGZWF0dXJlID0gZmVhdHVyZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKGV4aXN0cyhub3JtYWxpemVkRmVhdHVyZSkgJiYgIW92ZXJ3cml0ZSAmJiAhKG5vcm1hbGl6ZWRGZWF0dXJlIGluIHN0YXRpY0NhY2hlKSkge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGZWF0dXJlIFxcXCJcIiArIGZlYXR1cmUgKyBcIlxcXCIgZXhpc3RzIGFuZCBvdmVyd3JpdGUgbm90IHRydWUuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGV4cG9ydHMudGVzdEZ1bmN0aW9uc1tub3JtYWxpemVkRmVhdHVyZV0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzRmVhdHVyZVRlc3RUaGVuYWJsZSh2YWx1ZSkpIHtcclxuICAgICAgICB0ZXN0VGhlbmFibGVzW2ZlYXR1cmVdID0gdmFsdWUudGhlbihmdW5jdGlvbiAocmVzb2x2ZWRWYWx1ZSkge1xyXG4gICAgICAgICAgICBleHBvcnRzLnRlc3RDYWNoZVtmZWF0dXJlXSA9IHJlc29sdmVkVmFsdWU7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0ZXN0VGhlbmFibGVzW2ZlYXR1cmVdO1xyXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRlc3RUaGVuYWJsZXNbZmVhdHVyZV07XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBleHBvcnRzLnRlc3RDYWNoZVtub3JtYWxpemVkRmVhdHVyZV0gPSB2YWx1ZTtcclxuICAgICAgICBkZWxldGUgZXhwb3J0cy50ZXN0RnVuY3Rpb25zW25vcm1hbGl6ZWRGZWF0dXJlXTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmFkZCA9IGFkZDtcclxuLyoqXHJcbiAqIFJldHVybiB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIG5hbWVkIGZlYXR1cmUuXHJcbiAqXHJcbiAqIEBwYXJhbSBmZWF0dXJlIFRoZSBuYW1lIChpZiBhIHN0cmluZykgb3IgaWRlbnRpZmllciAoaWYgYW4gaW50ZWdlcikgb2YgdGhlIGZlYXR1cmUgdG8gdGVzdC5cclxuICovXHJcbmZ1bmN0aW9uIGhhcyhmZWF0dXJlKSB7XHJcbiAgICB2YXIgcmVzdWx0O1xyXG4gICAgdmFyIG5vcm1hbGl6ZWRGZWF0dXJlID0gZmVhdHVyZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgaWYgKG5vcm1hbGl6ZWRGZWF0dXJlIGluIHN0YXRpY0NhY2hlKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gc3RhdGljQ2FjaGVbbm9ybWFsaXplZEZlYXR1cmVdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZXhwb3J0cy50ZXN0RnVuY3Rpb25zW25vcm1hbGl6ZWRGZWF0dXJlXSkge1xyXG4gICAgICAgIHJlc3VsdCA9IGV4cG9ydHMudGVzdENhY2hlW25vcm1hbGl6ZWRGZWF0dXJlXSA9IGV4cG9ydHMudGVzdEZ1bmN0aW9uc1tub3JtYWxpemVkRmVhdHVyZV0uY2FsbChudWxsKTtcclxuICAgICAgICBkZWxldGUgZXhwb3J0cy50ZXN0RnVuY3Rpb25zW25vcm1hbGl6ZWRGZWF0dXJlXTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKG5vcm1hbGl6ZWRGZWF0dXJlIGluIGV4cG9ydHMudGVzdENhY2hlKSB7XHJcbiAgICAgICAgcmVzdWx0ID0gZXhwb3J0cy50ZXN0Q2FjaGVbbm9ybWFsaXplZEZlYXR1cmVdO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoZmVhdHVyZSBpbiB0ZXN0VGhlbmFibGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkF0dGVtcHQgdG8gZGV0ZWN0IHVucmVnaXN0ZXJlZCBoYXMgZmVhdHVyZSBcXFwiXCIgKyBmZWF0dXJlICsgXCJcXFwiXCIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBoYXM7XHJcbi8qXHJcbiAqIE91dCBvZiB0aGUgYm94IGZlYXR1cmUgdGVzdHNcclxuICovXHJcbi8qIEVudmlyb25tZW50cyAqL1xyXG4vKiBVc2VkIGFzIGEgdmFsdWUgdG8gcHJvdmlkZSBhIGRlYnVnIG9ubHkgY29kZSBwYXRoICovXHJcbmFkZCgnZGVidWcnLCB0cnVlKTtcclxuLyogRGV0ZWN0cyBpZiB0aGUgZW52aXJvbm1lbnQgaXMgXCJicm93c2VyIGxpa2VcIiAqL1xyXG5hZGQoJ2hvc3QtYnJvd3NlcicsIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyk7XHJcbi8qIERldGVjdHMgaWYgdGhlIGVudmlyb25tZW50IGFwcGVhcnMgdG8gYmUgTm9kZUpTICovXHJcbmFkZCgnaG9zdC1ub2RlJywgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiBwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMubm9kZSkge1xyXG4gICAgICAgIHJldHVybiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XHJcbiAgICB9XHJcbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2hhcy9oYXMuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2hhcy9oYXMuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gcmVxdWlyZWQgZm9yIEdsb2JhbGl6ZS9DbGRyIHRvIHByb3Blcmx5IHJlc29sdmUgbG9jYWxlcyBpbiB0aGUgYnJvd3Nlci5cclxucmVxdWlyZShcImNsZHJqcy9kaXN0L2NsZHIvdW5yZXNvbHZlZFwiKTtcclxudmFyIEdsb2JhbGl6ZSA9IHJlcXVpcmUoXCJnbG9iYWxpemVcIik7XHJcbnZhciBsb2NhbGVzXzEgPSByZXF1aXJlKFwiLi9sb2NhbGVzXCIpO1xyXG52YXIgbWFpbl8xID0gcmVxdWlyZShcIi4uL3V0aWwvbWFpblwiKTtcclxuLyoqXHJcbiAqIEEgbGlzdCBvZiBhbGwgcmVxdWlyZWQgQ0xEUiBwYWNrYWdlcyBmb3IgYW4gaW5kaXZpZHVhbCBsb2NhbGUuXHJcbiAqL1xyXG5leHBvcnRzLm1haW5QYWNrYWdlcyA9IE9iamVjdC5mcmVlemUoW1xyXG4gICAgJ2RhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4nLFxyXG4gICAgJ2RhdGVzL2ZpZWxkcycsXHJcbiAgICAnZGF0ZXMvdGltZVpvbmVOYW1lcycsXHJcbiAgICAnbnVtYmVycycsXHJcbiAgICAnbnVtYmVycy9jdXJyZW5jaWVzJyxcclxuICAgICd1bml0cydcclxuXSk7XHJcbi8qKlxyXG4gKiBBIGxpc3Qgb2YgYWxsIHJlcXVpcmVkIENMRFIgc3VwcGxlbWVudCBwYWNrYWdlcy5cclxuICovXHJcbmV4cG9ydHMuc3VwcGxlbWVudGFsUGFja2FnZXMgPSBPYmplY3QuZnJlZXplKFtcclxuICAgICdjdXJyZW5jeURhdGEnLFxyXG4gICAgJ2xpa2VseVN1YnRhZ3MnLFxyXG4gICAgJ251bWJlcmluZ1N5c3RlbXMnLFxyXG4gICAgJ3BsdXJhbHMtdHlwZS1jYXJkaW5hbCcsXHJcbiAgICAncGx1cmFscy10eXBlLW9yZGluYWwnLFxyXG4gICAgJ3RpbWVEYXRhJyxcclxuICAgICd3ZWVrRGF0YSdcclxuXSk7XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBBIHNpbXBsZSBtYXAgY29udGFpbmluZyBib29sZWFuIGZsYWdzIGluZGljYXRpbmcgd2hldGhlciBhIHBhcnRpY3VsYXIgQ0xEUiBwYWNrYWdlIGhhcyBiZWVuIGxvYWRlZC5cclxuICovXHJcbnZhciBsb2FkQ2FjaGUgPSB7XHJcbiAgICBtYWluOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgc3VwcGxlbWVudGFsOiBnZW5lcmF0ZVN1cHBsZW1lbnRhbENhY2hlKClcclxufTtcclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEdlbmVyYXRlIHRoZSBsb2NhbGUtc3BlY2lmaWMgZGF0YSBjYWNoZSBmcm9tIGEgbGlzdCBvZiBrZXlzLiBOZXN0ZWQgb2JqZWN0cyB3aWxsIGJlIGdlbmVyYXRlZCBmcm9tXHJcbiAqIHNsYXNoLXNlcGFyYXRlZCBzdHJpbmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0gY2FjaGVcclxuICogQW4gZW1wdHkgbG9jYWxlIGNhY2hlIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtIGtleXNcclxuICogVGhlIGxpc3Qgb2Yga2V5cy5cclxuICovXHJcbmZ1bmN0aW9uIGdlbmVyYXRlTG9jYWxlQ2FjaGUoY2FjaGUsIGtleXMpIHtcclxuICAgIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAodHJlZSwga2V5KSB7XHJcbiAgICAgICAgdmFyIHBhcnRzID0ga2V5LnNwbGl0KCcvJyk7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICB0cmVlW2tleV0gPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIHRyZWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBhcnRzLnJlZHVjZShmdW5jdGlvbiAodHJlZSwga2V5LCBpKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHJlZVtrZXldICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICAgICAgdHJlZVtrZXldID0gaSA9PT0gcGFydHMubGVuZ3RoIC0gMSA/IGZhbHNlIDogT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJlZVtrZXldO1xyXG4gICAgICAgIH0sIHRyZWUpO1xyXG4gICAgICAgIHJldHVybiB0cmVlO1xyXG4gICAgfSwgY2FjaGUpO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBHZW5lcmF0ZSB0aGUgc3VwcGxlbWVudGFsIGRhdGEgY2FjaGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZVN1cHBsZW1lbnRhbENhY2hlKCkge1xyXG4gICAgcmV0dXJuIGV4cG9ydHMuc3VwcGxlbWVudGFsUGFja2FnZXMucmVkdWNlKGZ1bmN0aW9uIChtYXAsIGtleSkge1xyXG4gICAgICAgIG1hcFtrZXldID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIG1hcDtcclxuICAgIH0sIE9iamVjdC5jcmVhdGUobnVsbCkpO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBSZWN1cnNpdmVseSBkZXRlcm1pbmUgd2hldGhlciBhIGxpc3Qgb2YgcGFja2FnZXMgaGF2ZSBiZWVuIGxvYWRlZCBmb3IgdGhlIHNwZWNpZmllZCBDTERSIGdyb3VwLlxyXG4gKlxyXG4gKiBAcGFyYW0gZ3JvdXBcclxuICogVGhlIENMRFIgZ3JvdXAgb2JqZWN0IChlLmcuLCB0aGUgc3VwcGxlbWVudGFsIGRhdGEsIG9yIGEgc3BlY2lmaWMgbG9jYWxlIGdyb3VwKVxyXG4gKlxyXG4gKiBAcGFyYW0gYXJnc1xyXG4gKiBBIGxpc3Qgb2Yga2V5cyB0byByZWN1cnNpdmVseSBjaGVjayBmcm9tIGxlZnQgdG8gcmlnaHQuIEZvciBleGFtcGxlLCBpZiBbIFwiZW5cIiwgXCJudW1iZXJzXCIgXSxcclxuICogdGhlbiBgZ3JvdXAuZW4ubnVtYmVyc2AgbXVzdCBleGlzdCBmb3IgdGhlIHRlc3QgdG8gcGFzcy5cclxuICpcclxuICogQHJldHVyblxyXG4gKiBgdHJ1ZWAgaWYgdGhlIGRlZXBlc3QgdmFsdWUgZXhpc3RzOyBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzTG9hZGVkRm9yR3JvdXAoZ3JvdXAsIGFyZ3MpIHtcclxuICAgIHJldHVybiBhcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHtcclxuICAgICAgICB2YXIgbmV4dCA9IGdyb3VwW2FyZ107XHJcbiAgICAgICAgZ3JvdXAgPSBuZXh0O1xyXG4gICAgICAgIHJldHVybiBCb29sZWFuKG5leHQpO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFJlY3Vyc2l2ZWx5IGZsYWcgYXMgbG9hZGVkIGFsbCByZWNvZ25pemVkIGtleXMgb24gdGhlIHByb3ZpZGVkIENMRFIgZGF0YSBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBjYWNoZVxyXG4gKiBUaGUgbG9hZCBjYWNoZSAoZWl0aGVyIHRoZSBlbnRpcmUgb2JqZWN0LCBvciBhIG5lc3RlZCBzZWdtZW50IG9mIGl0KS5cclxuICpcclxuICogQHBhcmFtIGxvY2FsZURhdGFcclxuICogVGhlIENMRFIgZGF0YSBvYmplY3QgYmVpbmcgbG9hZGVkIChlaXRoZXIgdGhlIGVudGlyZSBvYmplY3QsIG9yIGEgbmVzdGVkIHNlZ21lbnQgb2YgaXQpLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJMb2NhbGVEYXRhKGNhY2hlLCBsb2NhbGVEYXRhKSB7XHJcbiAgICBPYmplY3Qua2V5cyhsb2NhbGVEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICBpZiAoa2V5IGluIGNhY2hlKSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGNhY2hlW2tleV07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICAgICAgY2FjaGVba2V5XSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZWdpc3RlckxvY2FsZURhdGEodmFsdWUsIGxvY2FsZURhdGFba2V5XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogRmxhZyBhbGwgc3VwcGxpZWQgQ0xEUiBwYWNrYWdlcyBmb3IgYSBzcGVjaWZpYyBsb2NhbGUgYXMgbG9hZGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gZGF0YVxyXG4gKiBUaGUgYG1haW5gIGxvY2FsZSBkYXRhLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJNYWluKGRhdGEpIHtcclxuICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgIGlmIChsb2NhbGVzXzEuZGVmYXVsdC5pbmRleE9mKGxvY2FsZSkgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxvYWRlZERhdGEgPSBsb2FkQ2FjaGUubWFpbltsb2NhbGVdO1xyXG4gICAgICAgIGlmICghbG9hZGVkRGF0YSkge1xyXG4gICAgICAgICAgICBsb2FkZWREYXRhID0gbG9hZENhY2hlLm1haW5bbG9jYWxlXSA9IGdlbmVyYXRlTG9jYWxlQ2FjaGUoT2JqZWN0LmNyZWF0ZShudWxsKSwgZXhwb3J0cy5tYWluUGFja2FnZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZWdpc3RlckxvY2FsZURhdGEobG9hZGVkRGF0YSwgZGF0YVtsb2NhbGVdKTtcclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBGbGFnIGFsbCBzdXBwbGllZCBDTERSIHN1cHBsZW1lbnRhbCBwYWNrYWdlcyBhcyBsb2FkZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBkYXRhXHJcbiAqIFRoZSBzdXBwbGVtZW50YWwgZGF0YS5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVyU3VwcGxlbWVudGFsKGRhdGEpIHtcclxuICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIHZhciBzdXBwbGVtZW50YWwgPSBsb2FkQ2FjaGUuc3VwcGxlbWVudGFsO1xyXG4gICAgT2JqZWN0LmtleXMoZGF0YSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgaWYgKGtleSBpbiBzdXBwbGVtZW50YWwpIHtcclxuICAgICAgICAgICAgc3VwcGxlbWVudGFsW2tleV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmUgd2hldGhlciBhIHBhcnRpY3VsYXIgQ0xEUiBwYWNrYWdlIGhhcyBiZWVuIGxvYWRlZC5cclxuICpcclxuICogRXhhbXBsZTogdG8gY2hlY2sgdGhhdCBgc3VwcGxlbWVudGFsLmxpa2VseVN1YnRhZ3NgIGhhcyBiZWVuIGxvYWRlZCwgYGlzTG9hZGVkYCB3b3VsZCBiZSBjYWxsZWQgYXNcclxuICogYGlzTG9hZGVkKCdzdXBwbGVtZW50YWwnLCAnbGlrZWx5U3VidGFncycpYC5cclxuICpcclxuICogQHBhcmFtIGdyb3VwTmFtZVxyXG4gKiBUaGUgZ3JvdXAgdG8gY2hlY2s7IGVpdGhlciBcIm1haW5cIiBvciBcInN1cHBsZW1lbnRhbFwiLlxyXG4gKlxyXG4gKiBAcGFyYW0gLi4uYXJnc1xyXG4gKiBBbnkgcmVtYWluaW5nIGtleXMgaW4gdGhlIHBhdGggdG8gdGhlIGRlc2lyZWQgcGFja2FnZS5cclxuICpcclxuICogQHJldHVyblxyXG4gKiBgdHJ1ZWAgaWYgdGhlIGRlZXBlc3QgdmFsdWUgZXhpc3RzOyBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGlzTG9hZGVkKGdyb3VwTmFtZSkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBncm91cCA9IGxvYWRDYWNoZVtncm91cE5hbWVdO1xyXG4gICAgaWYgKGdyb3VwTmFtZSA9PT0gJ21haW4nICYmIGFyZ3MubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIHZhciBsb2NhbGUgPSBhcmdzWzBdO1xyXG4gICAgICAgIGlmICghbWFpbl8xLnZhbGlkYXRlTG9jYWxlKGxvY2FsZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhcmdzID0gYXJncy5zbGljZSgxKTtcclxuICAgICAgICByZXR1cm4gbWFpbl8xLmdlbmVyYXRlTG9jYWxlcyhsb2NhbGUpLnNvbWUoZnVuY3Rpb24gKGxvY2FsZSkge1xyXG4gICAgICAgICAgICB2YXIgbmV4dCA9IGdyb3VwW2xvY2FsZV07XHJcbiAgICAgICAgICAgIHJldHVybiBuZXh0ID8gaXNMb2FkZWRGb3JHcm91cChuZXh0LCBhcmdzKSA6IGZhbHNlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzTG9hZGVkRm9yR3JvdXAoZ3JvdXAsIGFyZ3MpO1xyXG59XHJcbmV4cG9ydHMuaXNMb2FkZWQgPSBpc0xvYWRlZDtcclxuLyoqXHJcbiAqIExvYWQgdGhlIHNwZWNpZmllZCBDTERSIGRhdGEgd2l0aCB0aGUgaTE4biBlY29zeXN0ZW0uXHJcbiAqXHJcbiAqIEBwYXJhbSBkYXRhXHJcbiAqIEEgZGF0YSBvYmplY3QgY29udGFpbmluZyBgbWFpbmAgYW5kL29yIGBzdXBwbGVtZW50YWxgIG9iamVjdHMgd2l0aCBDTERSIGRhdGEuXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkQ2xkckRhdGEoZGF0YSkge1xyXG4gICAgcmVnaXN0ZXJNYWluKGRhdGEubWFpbik7XHJcbiAgICByZWdpc3RlclN1cHBsZW1lbnRhbChkYXRhLnN1cHBsZW1lbnRhbCk7XHJcbiAgICBHbG9iYWxpemUubG9hZChkYXRhKTtcclxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBsb2FkQ2xkckRhdGE7XHJcbi8qKlxyXG4gKiBDbGVhciB0aGUgbG9hZCBjYWNoZSwgZWl0aGVyIHRoZSBlbnRpcmUgY2FjaGUgZm9yIHRoZSBzcGVjaWZpZWQgZ3JvdXAuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXHJcbiAqIGBpc0xvYWRlZGAgd2lsbCByZXR1cm4gZmFsc2UgZm9yIGtleXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgZ3JvdXAocykuXHJcbiAqXHJcbiAqIEBwYXJhbSBncm91cFxyXG4gKiBBbiBvcHRpb25hbCBncm91cCBuYW1lLiBJZiBub3QgcHJvdmlkZWQsIHRoZW4gYm90aCB0aGUgXCJtYWluXCIgYW5kIFwic3VwcGxlbWVudGFsXCIgY2FjaGVzIHdpbGwgYmUgY2xlYXJlZC5cclxuICovXHJcbmZ1bmN0aW9uIHJlc2V0KGdyb3VwKSB7XHJcbiAgICBpZiAoZ3JvdXAgIT09ICdzdXBwbGVtZW50YWwnKSB7XHJcbiAgICAgICAgbG9hZENhY2hlLm1haW4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG4gICAgfVxyXG4gICAgaWYgKGdyb3VwICE9PSAnbWFpbicpIHtcclxuICAgICAgICBsb2FkQ2FjaGUuc3VwcGxlbWVudGFsID0gZ2VuZXJhdGVTdXBwbGVtZW50YWxDYWNoZSgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucmVzZXQgPSByZXNldDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby9pMThuL2NsZHIvbG9hZC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGRvam8vaTE4bi9jbGRyL2xvYWQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEEgbGlzdCBvZiBgY2xkci1kYXRhL21haW5gIGRpcmVjdG9yaWVzIHVzZWQgdG8gbG9hZCB0aGUgY29ycmVjdCBDTERSIGRhdGEgZm9yIGEgZ2l2ZW4gbG9jYWxlLlxyXG4gKi9cclxudmFyIGxvY2FsZXNMaXN0ID0gW1xyXG4gICAgJ2FmLU5BJyxcclxuICAgICdhZicsXHJcbiAgICAnYWdxJyxcclxuICAgICdhaycsXHJcbiAgICAnYW0nLFxyXG4gICAgJ2FyLUFFJyxcclxuICAgICdhci1CSCcsXHJcbiAgICAnYXItREonLFxyXG4gICAgJ2FyLURaJyxcclxuICAgICdhci1FRycsXHJcbiAgICAnYXItRUgnLFxyXG4gICAgJ2FyLUVSJyxcclxuICAgICdhci1JTCcsXHJcbiAgICAnYXItSVEnLFxyXG4gICAgJ2FyLUpPJyxcclxuICAgICdhci1LTScsXHJcbiAgICAnYXItS1cnLFxyXG4gICAgJ2FyLUxCJyxcclxuICAgICdhci1MWScsXHJcbiAgICAnYXItTUEnLFxyXG4gICAgJ2FyLU1SJyxcclxuICAgICdhci1PTScsXHJcbiAgICAnYXItUFMnLFxyXG4gICAgJ2FyLVFBJyxcclxuICAgICdhci1TQScsXHJcbiAgICAnYXItU0QnLFxyXG4gICAgJ2FyLVNPJyxcclxuICAgICdhci1TUycsXHJcbiAgICAnYXItU1knLFxyXG4gICAgJ2FyLVREJyxcclxuICAgICdhci1UTicsXHJcbiAgICAnYXItWUUnLFxyXG4gICAgJ2FyJyxcclxuICAgICdhcycsXHJcbiAgICAnYXNhJyxcclxuICAgICdhc3QnLFxyXG4gICAgJ2F6LUN5cmwnLFxyXG4gICAgJ2F6LUxhdG4nLFxyXG4gICAgJ2F6JyxcclxuICAgICdiYXMnLFxyXG4gICAgJ2JlJyxcclxuICAgICdiZW0nLFxyXG4gICAgJ2JleicsXHJcbiAgICAnYmcnLFxyXG4gICAgJ2JtJyxcclxuICAgICdibi1JTicsXHJcbiAgICAnYm4nLFxyXG4gICAgJ2JvLUlOJyxcclxuICAgICdibycsXHJcbiAgICAnYnInLFxyXG4gICAgJ2JyeCcsXHJcbiAgICAnYnMtQ3lybCcsXHJcbiAgICAnYnMtTGF0bicsXHJcbiAgICAnYnMnLFxyXG4gICAgJ2NhLUFEJyxcclxuICAgICdjYS1FUy1WQUxFTkNJQScsXHJcbiAgICAnY2EtRlInLFxyXG4gICAgJ2NhLUlUJyxcclxuICAgICdjYScsXHJcbiAgICAnY2UnLFxyXG4gICAgJ2NnZycsXHJcbiAgICAnY2hyJyxcclxuICAgICdja2ItSVInLFxyXG4gICAgJ2NrYicsXHJcbiAgICAnY3MnLFxyXG4gICAgJ2N1JyxcclxuICAgICdjeScsXHJcbiAgICAnZGEtR0wnLFxyXG4gICAgJ2RhJyxcclxuICAgICdkYXYnLFxyXG4gICAgJ2RlLUFUJyxcclxuICAgICdkZS1CRScsXHJcbiAgICAnZGUtQ0gnLFxyXG4gICAgJ2RlLUlUJyxcclxuICAgICdkZS1MSScsXHJcbiAgICAnZGUtTFUnLFxyXG4gICAgJ2RlJyxcclxuICAgICdkamUnLFxyXG4gICAgJ2RzYicsXHJcbiAgICAnZHVhJyxcclxuICAgICdkeW8nLFxyXG4gICAgJ2R6JyxcclxuICAgICdlYnUnLFxyXG4gICAgJ2VlLVRHJyxcclxuICAgICdlZScsXHJcbiAgICAnZWwtQ1knLFxyXG4gICAgJ2VsJyxcclxuICAgICdlbi0wMDEnLFxyXG4gICAgJ2VuLTE1MCcsXHJcbiAgICAnZW4tQUcnLFxyXG4gICAgJ2VuLUFJJyxcclxuICAgICdlbi1BUycsXHJcbiAgICAnZW4tQVQnLFxyXG4gICAgJ2VuLUFVJyxcclxuICAgICdlbi1CQicsXHJcbiAgICAnZW4tQkUnLFxyXG4gICAgJ2VuLUJJJyxcclxuICAgICdlbi1CTScsXHJcbiAgICAnZW4tQlMnLFxyXG4gICAgJ2VuLUJXJyxcclxuICAgICdlbi1CWicsXHJcbiAgICAnZW4tQ0EnLFxyXG4gICAgJ2VuLUNDJyxcclxuICAgICdlbi1DSCcsXHJcbiAgICAnZW4tQ0snLFxyXG4gICAgJ2VuLUNNJyxcclxuICAgICdlbi1DWCcsXHJcbiAgICAnZW4tQ1knLFxyXG4gICAgJ2VuLURFJyxcclxuICAgICdlbi1ERycsXHJcbiAgICAnZW4tREsnLFxyXG4gICAgJ2VuLURNJyxcclxuICAgICdlbi1FUicsXHJcbiAgICAnZW4tRkknLFxyXG4gICAgJ2VuLUZKJyxcclxuICAgICdlbi1GSycsXHJcbiAgICAnZW4tRk0nLFxyXG4gICAgJ2VuLUdCJyxcclxuICAgICdlbi1HRCcsXHJcbiAgICAnZW4tR0cnLFxyXG4gICAgJ2VuLUdIJyxcclxuICAgICdlbi1HSScsXHJcbiAgICAnZW4tR00nLFxyXG4gICAgJ2VuLUdVJyxcclxuICAgICdlbi1HWScsXHJcbiAgICAnZW4tSEsnLFxyXG4gICAgJ2VuLUlFJyxcclxuICAgICdlbi1JTCcsXHJcbiAgICAnZW4tSU0nLFxyXG4gICAgJ2VuLUlOJyxcclxuICAgICdlbi1JTycsXHJcbiAgICAnZW4tSkUnLFxyXG4gICAgJ2VuLUpNJyxcclxuICAgICdlbi1LRScsXHJcbiAgICAnZW4tS0knLFxyXG4gICAgJ2VuLUtOJyxcclxuICAgICdlbi1LWScsXHJcbiAgICAnZW4tTEMnLFxyXG4gICAgJ2VuLUxSJyxcclxuICAgICdlbi1MUycsXHJcbiAgICAnZW4tTUcnLFxyXG4gICAgJ2VuLU1IJyxcclxuICAgICdlbi1NTycsXHJcbiAgICAnZW4tTVAnLFxyXG4gICAgJ2VuLU1TJyxcclxuICAgICdlbi1NVCcsXHJcbiAgICAnZW4tTVUnLFxyXG4gICAgJ2VuLU1XJyxcclxuICAgICdlbi1NWScsXHJcbiAgICAnZW4tTkEnLFxyXG4gICAgJ2VuLU5GJyxcclxuICAgICdlbi1ORycsXHJcbiAgICAnZW4tTkwnLFxyXG4gICAgJ2VuLU5SJyxcclxuICAgICdlbi1OVScsXHJcbiAgICAnZW4tTlonLFxyXG4gICAgJ2VuLVBHJyxcclxuICAgICdlbi1QSCcsXHJcbiAgICAnZW4tUEsnLFxyXG4gICAgJ2VuLVBOJyxcclxuICAgICdlbi1QUicsXHJcbiAgICAnZW4tUFcnLFxyXG4gICAgJ2VuLVJXJyxcclxuICAgICdlbi1TQicsXHJcbiAgICAnZW4tU0MnLFxyXG4gICAgJ2VuLVNEJyxcclxuICAgICdlbi1TRScsXHJcbiAgICAnZW4tU0cnLFxyXG4gICAgJ2VuLVNIJyxcclxuICAgICdlbi1TSScsXHJcbiAgICAnZW4tU0wnLFxyXG4gICAgJ2VuLVNTJyxcclxuICAgICdlbi1TWCcsXHJcbiAgICAnZW4tU1onLFxyXG4gICAgJ2VuLVRDJyxcclxuICAgICdlbi1USycsXHJcbiAgICAnZW4tVE8nLFxyXG4gICAgJ2VuLVRUJyxcclxuICAgICdlbi1UVicsXHJcbiAgICAnZW4tVFonLFxyXG4gICAgJ2VuLVVHJyxcclxuICAgICdlbi1VTScsXHJcbiAgICAnZW4tVVMtUE9TSVgnLFxyXG4gICAgJ2VuLVZDJyxcclxuICAgICdlbi1WRycsXHJcbiAgICAnZW4tVkknLFxyXG4gICAgJ2VuLVZVJyxcclxuICAgICdlbi1XUycsXHJcbiAgICAnZW4tWkEnLFxyXG4gICAgJ2VuLVpNJyxcclxuICAgICdlbi1aVycsXHJcbiAgICAnZW4nLFxyXG4gICAgJ2VvJyxcclxuICAgICdlcy00MTknLFxyXG4gICAgJ2VzLUFSJyxcclxuICAgICdlcy1CTycsXHJcbiAgICAnZXMtQlInLFxyXG4gICAgJ2VzLUNMJyxcclxuICAgICdlcy1DTycsXHJcbiAgICAnZXMtQ1InLFxyXG4gICAgJ2VzLUNVJyxcclxuICAgICdlcy1ETycsXHJcbiAgICAnZXMtRUEnLFxyXG4gICAgJ2VzLUVDJyxcclxuICAgICdlcy1HUScsXHJcbiAgICAnZXMtR1QnLFxyXG4gICAgJ2VzLUhOJyxcclxuICAgICdlcy1JQycsXHJcbiAgICAnZXMtTVgnLFxyXG4gICAgJ2VzLU5JJyxcclxuICAgICdlcy1QQScsXHJcbiAgICAnZXMtUEUnLFxyXG4gICAgJ2VzLVBIJyxcclxuICAgICdlcy1QUicsXHJcbiAgICAnZXMtUFknLFxyXG4gICAgJ2VzLVNWJyxcclxuICAgICdlcy1VUycsXHJcbiAgICAnZXMtVVknLFxyXG4gICAgJ2VzLVZFJyxcclxuICAgICdlcycsXHJcbiAgICAnZXQnLFxyXG4gICAgJ2V1JyxcclxuICAgICdld28nLFxyXG4gICAgJ2ZhLUFGJyxcclxuICAgICdmYScsXHJcbiAgICAnZmYtQ00nLFxyXG4gICAgJ2ZmLUdOJyxcclxuICAgICdmZi1NUicsXHJcbiAgICAnZmYnLFxyXG4gICAgJ2ZpJyxcclxuICAgICdmaWwnLFxyXG4gICAgJ2ZvLURLJyxcclxuICAgICdmbycsXHJcbiAgICAnZnItQkUnLFxyXG4gICAgJ2ZyLUJGJyxcclxuICAgICdmci1CSScsXHJcbiAgICAnZnItQkonLFxyXG4gICAgJ2ZyLUJMJyxcclxuICAgICdmci1DQScsXHJcbiAgICAnZnItQ0QnLFxyXG4gICAgJ2ZyLUNGJyxcclxuICAgICdmci1DRycsXHJcbiAgICAnZnItQ0gnLFxyXG4gICAgJ2ZyLUNJJyxcclxuICAgICdmci1DTScsXHJcbiAgICAnZnItREonLFxyXG4gICAgJ2ZyLURaJyxcclxuICAgICdmci1HQScsXHJcbiAgICAnZnItR0YnLFxyXG4gICAgJ2ZyLUdOJyxcclxuICAgICdmci1HUCcsXHJcbiAgICAnZnItR1EnLFxyXG4gICAgJ2ZyLUhUJyxcclxuICAgICdmci1LTScsXHJcbiAgICAnZnItTFUnLFxyXG4gICAgJ2ZyLU1BJyxcclxuICAgICdmci1NQycsXHJcbiAgICAnZnItTUYnLFxyXG4gICAgJ2ZyLU1HJyxcclxuICAgICdmci1NTCcsXHJcbiAgICAnZnItTVEnLFxyXG4gICAgJ2ZyLU1SJyxcclxuICAgICdmci1NVScsXHJcbiAgICAnZnItTkMnLFxyXG4gICAgJ2ZyLU5FJyxcclxuICAgICdmci1QRicsXHJcbiAgICAnZnItUE0nLFxyXG4gICAgJ2ZyLVJFJyxcclxuICAgICdmci1SVycsXHJcbiAgICAnZnItU0MnLFxyXG4gICAgJ2ZyLVNOJyxcclxuICAgICdmci1TWScsXHJcbiAgICAnZnItVEQnLFxyXG4gICAgJ2ZyLVRHJyxcclxuICAgICdmci1UTicsXHJcbiAgICAnZnItVlUnLFxyXG4gICAgJ2ZyLVdGJyxcclxuICAgICdmci1ZVCcsXHJcbiAgICAnZnInLFxyXG4gICAgJ2Z1cicsXHJcbiAgICAnZnknLFxyXG4gICAgJ2dhJyxcclxuICAgICdnZCcsXHJcbiAgICAnZ2wnLFxyXG4gICAgJ2dzdy1GUicsXHJcbiAgICAnZ3N3LUxJJyxcclxuICAgICdnc3cnLFxyXG4gICAgJ2d1JyxcclxuICAgICdndXonLFxyXG4gICAgJ2d2JyxcclxuICAgICdoYS1HSCcsXHJcbiAgICAnaGEtTkUnLFxyXG4gICAgJ2hhJyxcclxuICAgICdoYXcnLFxyXG4gICAgJ2hlJyxcclxuICAgICdoaScsXHJcbiAgICAnaHItQkEnLFxyXG4gICAgJ2hyJyxcclxuICAgICdoc2InLFxyXG4gICAgJ2h1JyxcclxuICAgICdoeScsXHJcbiAgICAnaWQnLFxyXG4gICAgJ2lnJyxcclxuICAgICdpaScsXHJcbiAgICAnaXMnLFxyXG4gICAgJ2l0LUNIJyxcclxuICAgICdpdC1TTScsXHJcbiAgICAnaXQnLFxyXG4gICAgJ2phJyxcclxuICAgICdqZ28nLFxyXG4gICAgJ2ptYycsXHJcbiAgICAna2EnLFxyXG4gICAgJ2thYicsXHJcbiAgICAna2FtJyxcclxuICAgICdrZGUnLFxyXG4gICAgJ2tlYScsXHJcbiAgICAna2hxJyxcclxuICAgICdraScsXHJcbiAgICAna2snLFxyXG4gICAgJ2traicsXHJcbiAgICAna2wnLFxyXG4gICAgJ2tsbicsXHJcbiAgICAna20nLFxyXG4gICAgJ2tuJyxcclxuICAgICdrby1LUCcsXHJcbiAgICAna28nLFxyXG4gICAgJ2tvaycsXHJcbiAgICAna3MnLFxyXG4gICAgJ2tzYicsXHJcbiAgICAna3NmJyxcclxuICAgICdrc2gnLFxyXG4gICAgJ2t3JyxcclxuICAgICdreScsXHJcbiAgICAnbGFnJyxcclxuICAgICdsYicsXHJcbiAgICAnbGcnLFxyXG4gICAgJ2xrdCcsXHJcbiAgICAnbG4tQU8nLFxyXG4gICAgJ2xuLUNGJyxcclxuICAgICdsbi1DRycsXHJcbiAgICAnbG4nLFxyXG4gICAgJ2xvJyxcclxuICAgICdscmMtSVEnLFxyXG4gICAgJ2xyYycsXHJcbiAgICAnbHQnLFxyXG4gICAgJ2x1JyxcclxuICAgICdsdW8nLFxyXG4gICAgJ2x1eScsXHJcbiAgICAnbHYnLFxyXG4gICAgJ21hcy1UWicsXHJcbiAgICAnbWFzJyxcclxuICAgICdtZXInLFxyXG4gICAgJ21mZScsXHJcbiAgICAnbWcnLFxyXG4gICAgJ21naCcsXHJcbiAgICAnbWdvJyxcclxuICAgICdtaycsXHJcbiAgICAnbWwnLFxyXG4gICAgJ21uJyxcclxuICAgICdtcicsXHJcbiAgICAnbXMtQk4nLFxyXG4gICAgJ21zLVNHJyxcclxuICAgICdtcycsXHJcbiAgICAnbXQnLFxyXG4gICAgJ211YScsXHJcbiAgICAnbXknLFxyXG4gICAgJ216bicsXHJcbiAgICAnbmFxJyxcclxuICAgICduYi1TSicsXHJcbiAgICAnbmInLFxyXG4gICAgJ25kJyxcclxuICAgICduZHMtTkwnLFxyXG4gICAgJ25kcycsXHJcbiAgICAnbmUtSU4nLFxyXG4gICAgJ25lJyxcclxuICAgICdubC1BVycsXHJcbiAgICAnbmwtQkUnLFxyXG4gICAgJ25sLUJRJyxcclxuICAgICdubC1DVycsXHJcbiAgICAnbmwtU1InLFxyXG4gICAgJ25sLVNYJyxcclxuICAgICdubCcsXHJcbiAgICAnbm1nJyxcclxuICAgICdubicsXHJcbiAgICAnbm5oJyxcclxuICAgICdudXMnLFxyXG4gICAgJ255bicsXHJcbiAgICAnb20tS0UnLFxyXG4gICAgJ29tJyxcclxuICAgICdvcicsXHJcbiAgICAnb3MtUlUnLFxyXG4gICAgJ29zJyxcclxuICAgICdwYS1BcmFiJyxcclxuICAgICdwYS1HdXJ1JyxcclxuICAgICdwYScsXHJcbiAgICAncGwnLFxyXG4gICAgJ3ByZycsXHJcbiAgICAncHMnLFxyXG4gICAgJ3B0LUFPJyxcclxuICAgICdwdC1DSCcsXHJcbiAgICAncHQtQ1YnLFxyXG4gICAgJ3B0LUdRJyxcclxuICAgICdwdC1HVycsXHJcbiAgICAncHQtTFUnLFxyXG4gICAgJ3B0LU1PJyxcclxuICAgICdwdC1NWicsXHJcbiAgICAncHQtUFQnLFxyXG4gICAgJ3B0LVNUJyxcclxuICAgICdwdC1UTCcsXHJcbiAgICAncHQnLFxyXG4gICAgJ3F1LUJPJyxcclxuICAgICdxdS1FQycsXHJcbiAgICAncXUnLFxyXG4gICAgJ3JtJyxcclxuICAgICdybicsXHJcbiAgICAncm8tTUQnLFxyXG4gICAgJ3JvJyxcclxuICAgICdyb2YnLFxyXG4gICAgJ3Jvb3QnLFxyXG4gICAgJ3J1LUJZJyxcclxuICAgICdydS1LRycsXHJcbiAgICAncnUtS1onLFxyXG4gICAgJ3J1LU1EJyxcclxuICAgICdydS1VQScsXHJcbiAgICAncnUnLFxyXG4gICAgJ3J3JyxcclxuICAgICdyd2snLFxyXG4gICAgJ3NhaCcsXHJcbiAgICAnc2FxJyxcclxuICAgICdzYnAnLFxyXG4gICAgJ3NlLUZJJyxcclxuICAgICdzZS1TRScsXHJcbiAgICAnc2UnLFxyXG4gICAgJ3NlaCcsXHJcbiAgICAnc2VzJyxcclxuICAgICdzZycsXHJcbiAgICAnc2hpLUxhdG4nLFxyXG4gICAgJ3NoaS1UZm5nJyxcclxuICAgICdzaGknLFxyXG4gICAgJ3NpJyxcclxuICAgICdzaycsXHJcbiAgICAnc2wnLFxyXG4gICAgJ3NtbicsXHJcbiAgICAnc24nLFxyXG4gICAgJ3NvLURKJyxcclxuICAgICdzby1FVCcsXHJcbiAgICAnc28tS0UnLFxyXG4gICAgJ3NvJyxcclxuICAgICdzcS1NSycsXHJcbiAgICAnc3EtWEsnLFxyXG4gICAgJ3NxJyxcclxuICAgICdzci1DeXJsLUJBJyxcclxuICAgICdzci1DeXJsLU1FJyxcclxuICAgICdzci1DeXJsLVhLJyxcclxuICAgICdzci1DeXJsJyxcclxuICAgICdzci1MYXRuLUJBJyxcclxuICAgICdzci1MYXRuLU1FJyxcclxuICAgICdzci1MYXRuLVhLJyxcclxuICAgICdzci1MYXRuJyxcclxuICAgICdzcicsXHJcbiAgICAnc3YtQVgnLFxyXG4gICAgJ3N2LUZJJyxcclxuICAgICdzdicsXHJcbiAgICAnc3ctQ0QnLFxyXG4gICAgJ3N3LUtFJyxcclxuICAgICdzdy1VRycsXHJcbiAgICAnc3cnLFxyXG4gICAgJ3RhLUxLJyxcclxuICAgICd0YS1NWScsXHJcbiAgICAndGEtU0cnLFxyXG4gICAgJ3RhJyxcclxuICAgICd0ZScsXHJcbiAgICAndGVvLUtFJyxcclxuICAgICd0ZW8nLFxyXG4gICAgJ3RoJyxcclxuICAgICd0aS1FUicsXHJcbiAgICAndGknLFxyXG4gICAgJ3RrJyxcclxuICAgICd0bycsXHJcbiAgICAndHItQ1knLFxyXG4gICAgJ3RyJyxcclxuICAgICd0d3EnLFxyXG4gICAgJ3R6bScsXHJcbiAgICAndWcnLFxyXG4gICAgJ3VrJyxcclxuICAgICd1ci1JTicsXHJcbiAgICAndXInLFxyXG4gICAgJ3V6LUFyYWInLFxyXG4gICAgJ3V6LUN5cmwnLFxyXG4gICAgJ3V6LUxhdG4nLFxyXG4gICAgJ3V6JyxcclxuICAgICd2YWktTGF0bicsXHJcbiAgICAndmFpLVZhaWknLFxyXG4gICAgJ3ZhaScsXHJcbiAgICAndmknLFxyXG4gICAgJ3ZvJyxcclxuICAgICd2dW4nLFxyXG4gICAgJ3dhZScsXHJcbiAgICAneG9nJyxcclxuICAgICd5YXYnLFxyXG4gICAgJ3lpJyxcclxuICAgICd5by1CSicsXHJcbiAgICAneW8nLFxyXG4gICAgJ3l1ZScsXHJcbiAgICAnemdoJyxcclxuICAgICd6aC1IYW5zLUhLJyxcclxuICAgICd6aC1IYW5zLU1PJyxcclxuICAgICd6aC1IYW5zLVNHJyxcclxuICAgICd6aC1IYW5zJyxcclxuICAgICd6aC1IYW50LUhLJyxcclxuICAgICd6aC1IYW50LU1PJyxcclxuICAgICd6aC1IYW50JyxcclxuICAgICd6aCcsXHJcbiAgICAnenUnXHJcbl07XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGxvY2FsZXNMaXN0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2kxOG4vY2xkci9sb2NhbGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9AZG9qby9pMThuL2NsZHIvbG9jYWxlcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxuLyogdHNsaW50OmRpc2FibGU6aW50ZXJmYWNlLW5hbWUgKi9cclxudmFyIGdsb2JhbF8xID0gcmVxdWlyZShcIkBkb2pvL3NoaW0vZ2xvYmFsXCIpO1xyXG52YXIgTWFwXzEgPSByZXF1aXJlKFwiQGRvam8vc2hpbS9NYXBcIik7XHJcbnZhciBFdmVudGVkXzEgPSByZXF1aXJlKFwiQGRvam8vY29yZS9FdmVudGVkXCIpO1xyXG52YXIgaGFzXzEgPSByZXF1aXJlKFwiQGRvam8vY29yZS9oYXNcIik7XHJcbnZhciB1dWlkXzEgPSByZXF1aXJlKFwiQGRvam8vY29yZS91dWlkXCIpO1xyXG52YXIgdXRpbF8xID0gcmVxdWlyZShcIkBkb2pvL2NvcmUvbG9hZC91dGlsXCIpO1xyXG52YXIgR2xvYmFsaXplID0gcmVxdWlyZShcImdsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9tZXNzYWdlXCIpO1xyXG52YXIgbG9hZF8xID0gcmVxdWlyZShcIi4vY2xkci9sb2FkXCIpO1xyXG52YXIgbWFpbl8xID0gcmVxdWlyZShcIi4vdXRpbC9tYWluXCIpO1xyXG52YXIgVE9LRU5fUEFUVEVSTiA9IC9cXHsoW2EtejAtOV9dKylcXH0vZ2k7XHJcbnZhciBidW5kbGVNYXAgPSBuZXcgTWFwXzEuZGVmYXVsdCgpO1xyXG52YXIgZm9ybWF0dGVyTWFwID0gbmV3IE1hcF8xLmRlZmF1bHQoKTtcclxudmFyIGxvY2FsZVByb2R1Y2VyID0gbmV3IEV2ZW50ZWRfMS5kZWZhdWx0KCk7XHJcbnZhciByb290TG9jYWxlO1xyXG4vKipcclxuICogUmV0dXJuIHRoZSBidW5kbGUncyB1bmlxdWUgaWRlbnRpZmllciwgY3JlYXRpbmcgb25lIGlmIGl0IGRvZXMgbm90IGFscmVhZHkgZXhpc3QuXHJcbiAqXHJcbiAqIEBwYXJhbSBidW5kbGUgQSBtZXNzYWdlIGJ1bmRsZVxyXG4gKiBAcmV0dXJuIFRoZSBidW5kbGUncyB1bmlxdWUgaWRlbnRpZmllclxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0QnVuZGxlSWQoYnVuZGxlKSB7XHJcbiAgICBpZiAoYnVuZGxlLmlkKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ1bmRsZS5pZDtcclxuICAgIH1cclxuICAgIHZhciBpZCA9IHV1aWRfMS5kZWZhdWx0KCk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYnVuZGxlLCAnaWQnLCB7XHJcbiAgICAgICAgdmFsdWU6IGlkXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBpZDtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGFuIElDVS1zdHlsZSBtZXNzYWdlLCBhbmQgdGFrZXMgYW4gb3B0aW9uYWwgdmFsdWUgZm9yIHRva2VuIHJlcGxhY2VtZW50LlxyXG4gKlxyXG4gKiBVc2FnZTpcclxuICogY29uc3QgZm9ybWF0dGVyID0gZ2V0TWVzc2FnZUZvcm1hdHRlcihidW5kbGUsICdndWVzdEluZm8nLCAnZnInKTtcclxuICogY29uc3QgbWVzc2FnZSA9IGZvcm1hdHRlcih7XHJcbiAqICAgaG9zdDogJ01pbGVzJyxcclxuICogICBnZW5kZXI6ICdtYWxlJyxcclxuICogICBndWVzdDogJ09zY2FyJyxcclxuICogICBndWVzdENvdW50OiAnMTUnXHJcbiAqIH0pO1xyXG4gKlxyXG4gKiBAcGFyYW0gaWRcclxuICogVGhlIG1lc3NhZ2UncyBidW5kbGUgaWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBrZXlcclxuICogVGhlIG1lc3NhZ2UncyBrZXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBsb2NhbGVcclxuICogQW4gb3B0aW9uYWwgbG9jYWxlIGZvciB0aGUgZm9ybWF0dGVyLiBJZiBubyBsb2NhbGUgaXMgc3VwcGxpZWQsIG9yIGlmIHRoZSBsb2NhbGUgaXMgbm90IHN1cHBvcnRlZCwgdGhlXHJcbiAqIGRlZmF1bHQgbG9jYWxlIGlzIHVzZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5cclxuICogVGhlIG1lc3NhZ2UgZm9ybWF0dGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0SWN1TWVzc2FnZUZvcm1hdHRlcihpZCwga2V5LCBsb2NhbGUpIHtcclxuICAgIGxvY2FsZSA9IG1haW5fMS5ub3JtYWxpemVMb2NhbGUobG9jYWxlIHx8IGdldFJvb3RMb2NhbGUoKSk7XHJcbiAgICB2YXIgZm9ybWF0dGVyS2V5ID0gbG9jYWxlICsgXCI6XCIgKyBpZCArIFwiOlwiICsga2V5O1xyXG4gICAgdmFyIGZvcm1hdHRlciA9IGZvcm1hdHRlck1hcC5nZXQoZm9ybWF0dGVyS2V5KTtcclxuICAgIGlmIChmb3JtYXR0ZXIpIHtcclxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyO1xyXG4gICAgfVxyXG4gICAgdmFyIGdsb2JhbGl6ZSA9IGxvY2FsZSAhPT0gZ2V0Um9vdExvY2FsZSgpID8gbmV3IEdsb2JhbGl6ZShtYWluXzEubm9ybWFsaXplTG9jYWxlKGxvY2FsZSkpIDogR2xvYmFsaXplO1xyXG4gICAgZm9ybWF0dGVyID0gZ2xvYmFsaXplLm1lc3NhZ2VGb3JtYXR0ZXIoaWQgKyBcIi9cIiArIGtleSk7XHJcbiAgICB2YXIgY2FjaGVkID0gYnVuZGxlTWFwLmdldChpZCk7XHJcbiAgICBpZiAoY2FjaGVkICYmIGNhY2hlZC5nZXQobG9jYWxlKSkge1xyXG4gICAgICAgIGZvcm1hdHRlck1hcC5zZXQoZm9ybWF0dGVyS2V5LCBmb3JtYXR0ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdHRlcjtcclxufVxyXG4vKipcclxuICogQHByaXZhdGVcclxuICogTG9hZCB0aGUgc3BlY2lmaWVkIGxvY2FsZS1zcGVjaWZpYyBidW5kbGVzLCBtYXBwaW5nIHRoZSBkZWZhdWx0IGV4cG9ydHMgdG8gc2ltcGxlIGBNZXNzYWdlc2Agb2JqZWN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGxvYWRMb2NhbGVCdW5kbGVzKGxvY2FsZXMsIHN1cHBvcnRlZCkge1xyXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHN1cHBvcnRlZC5tYXAoZnVuY3Rpb24gKGxvY2FsZSkgeyByZXR1cm4gbG9jYWxlc1tsb2NhbGVdKCk7IH0pKS50aGVuKGZ1bmN0aW9uIChidW5kbGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIGJ1bmRsZXMubWFwKGZ1bmN0aW9uIChidW5kbGUpIHsgcmV0dXJuIHV0aWxfMS51c2VEZWZhdWx0KGJ1bmRsZSk7IH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIFJldHVybiB0aGUgcm9vdCBsb2NhbGUuIERlZmF1bHRzIHRvIHRoZSBzeXN0ZW0gbG9jYWxlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Um9vdExvY2FsZSgpIHtcclxuICAgIHJldHVybiByb290TG9jYWxlIHx8IGV4cG9ydHMuc3lzdGVtTG9jYWxlO1xyXG59XHJcbi8qKlxyXG4gKiBAcHJpdmF0ZVxyXG4gKiBSZXRyaWV2ZSBhIGxpc3Qgb2Ygc3VwcG9ydGVkIGxvY2FsZXMgdGhhdCBjYW4gcHJvdmlkZSBtZXNzYWdlcyBmb3IgdGhlIHNwZWNpZmllZCBsb2NhbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBsb2NhbGVcclxuICogVGhlIHRhcmdldCBsb2NhbGUuXHJcbiAqXHJcbiAqIEBwYXJhbSBzdXBwb3J0ZWRcclxuICogVGhlIGxvY2FsZXMgdGhhdCBhcmUgc3VwcG9ydGVkIGJ5IHRoZSBidW5kbGUuXHJcbiAqXHJcbiAqIEByZXR1cm5cclxuICogQSBsaXN0IG9mIHN1cHBvcnRlZCBsb2NhbGVzIHRoYXQgbWF0Y2ggdGhlIHRhcmdldCBsb2NhbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRMb2NhbGVzKGxvY2FsZSwgc3VwcG9ydGVkKSB7XHJcbiAgICBpZiAoc3VwcG9ydGVkID09PSB2b2lkIDApIHsgc3VwcG9ydGVkID0gW107IH1cclxuICAgIHJldHVybiBtYWluXzEuZ2VuZXJhdGVMb2NhbGVzKGxvY2FsZSkuZmlsdGVyKGZ1bmN0aW9uIChsb2NhbGUpIHsgcmV0dXJuIHN1cHBvcnRlZC5pbmRleE9mKGxvY2FsZSkgPiAtMTsgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwcml2YXRlXHJcbiAqIEluamVjdCBtZXNzYWdlcyBmb3IgdGhlIHNwZWNpZmllZCBsb2NhbGUgaW50byB0aGUgaTE4biBzeXN0ZW0uXHJcbiAqXHJcbiAqIEBwYXJhbSBpZFxyXG4gKiBUaGUgYnVuZGxlJ3MgdW5pcXVlIGlkZW50aWZpZXJcclxuICpcclxuICogQHBhcmFtIG1lc3NhZ2VzXHJcbiAqIFRoZSBtZXNzYWdlcyB0byBpbmplY3RcclxuICpcclxuICogQHBhcmFtIGxvY2FsZVxyXG4gKiBBbiBvcHRpb25hbCBsb2NhbGUuIElmIG5vdCBzcGVjaWZpZWQsIHRoZW4gaXQgaXMgYXNzdW1lZCB0aGF0IHRoZSBtZXNzYWdlcyBhcmUgdGhlIGRlZmF1bHRzIGZvciB0aGUgZ2l2ZW5cclxuICogYnVuZGxlIHBhdGguXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2FkTWVzc2FnZXMoaWQsIG1lc3NhZ2VzLCBsb2NhbGUpIHtcclxuICAgIGlmIChsb2NhbGUgPT09IHZvaWQgMCkgeyBsb2NhbGUgPSAncm9vdCc7IH1cclxuICAgIHZhciBjYWNoZWQgPSBidW5kbGVNYXAuZ2V0KGlkKTtcclxuICAgIGlmICghY2FjaGVkKSB7XHJcbiAgICAgICAgY2FjaGVkID0gbmV3IE1hcF8xLmRlZmF1bHQoKTtcclxuICAgICAgICBidW5kbGVNYXAuc2V0KGlkLCBjYWNoZWQpO1xyXG4gICAgfVxyXG4gICAgY2FjaGVkLnNldChsb2NhbGUsIG1lc3NhZ2VzKTtcclxuICAgIEdsb2JhbGl6ZS5sb2FkTWVzc2FnZXMoKF9hID0ge30sXHJcbiAgICAgICAgX2FbbG9jYWxlXSA9IChfYiA9IHt9LFxyXG4gICAgICAgICAgICBfYltpZF0gPSBtZXNzYWdlcyxcclxuICAgICAgICAgICAgX2IpLFxyXG4gICAgICAgIF9hKSk7XHJcbiAgICB2YXIgX2EsIF9iO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBmb3JtYXR0ZWQgbWVzc2FnZS5cclxuICpcclxuICogSWYgYm90aCB0aGUgXCJzdXBwbGVtZW50YWwvbGlrZWx5U3VidGFnc1wiIGFuZCBcInN1cHBsZW1lbnRhbC9wbHVyYWxzLXR5cGUtY2FyZGluYWxcIiBDTERSIGRhdGEgaGF2ZSBiZWVuIGxvYWRlZCwgdGhlblxyXG4gKiB0aGUgSUNVIG1lc3NhZ2UgZm9ybWF0IGlzIHN1cHBvcnRlZC4gT3RoZXJ3aXNlLCBhIHNpbXBsZSB0b2tlbi1yZXBsYWNlbWVudCBtZWNoYW5pc20gaXMgdXNlZC5cclxuICpcclxuICogVXNhZ2U6XHJcbiAqIGZvcm1hdE1lc3NhZ2UoYnVuZGxlLCAnZ3Vlc3RJbmZvJywge1xyXG4gKiAgIGhvc3Q6ICdCaWxsJyxcclxuICogICBndWVzdDogJ0pvaG4nXHJcbiAqIH0sICdmcicpO1xyXG4gKlxyXG4gKiBAcGFyYW0gYnVuZGxlXHJcbiAqIFRoZSBidW5kbGUgY29udGFpbmluZyB0aGUgdGFyZ2V0IG1lc3NhZ2UuXHJcbiAqXHJcbiAqIEBwYXJhbSBrZXlcclxuICogVGhlIG1lc3NhZ2UncyBrZXkuXHJcbiAqXHJcbiAqIEBwYXJhbSBvcHRpb25zXHJcbiAqIEFuIG9wdGlvbmFsIHZhbHVlIHVzZWQgYnkgdGhlIGZvcm1hdHRlciB0byByZXBsYWNlIHRva2VucyB3aXRoIHZhbHVlcy5cclxuICpcclxuICogQHBhcmFtIGxvY2FsZVxyXG4gKiBBbiBvcHRpb25hbCBsb2NhbGUgZm9yIHRoZSBmb3JtYXR0ZXIuIElmIG5vIGxvY2FsZSBpcyBzdXBwbGllZCwgb3IgaWYgdGhlIGxvY2FsZSBpcyBub3Qgc3VwcG9ydGVkLCB0aGVcclxuICogZGVmYXVsdCBsb2NhbGUgaXMgdXNlZC5cclxuICpcclxuICogQHJldHVyblxyXG4gKiBUaGUgZm9ybWF0dGVkIG1lc3NhZ2UuXHJcbiAqL1xyXG5mdW5jdGlvbiBmb3JtYXRNZXNzYWdlKGJ1bmRsZSwga2V5LCBvcHRpb25zLCBsb2NhbGUpIHtcclxuICAgIHJldHVybiBnZXRNZXNzYWdlRm9ybWF0dGVyKGJ1bmRsZSwga2V5LCBsb2NhbGUpKG9wdGlvbnMpO1xyXG59XHJcbmV4cG9ydHMuZm9ybWF0TWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2U7XHJcbi8qKlxyXG4gKiBSZXR1cm4gdGhlIGNhY2hlZCBtZXNzYWdlcyBmb3IgdGhlIHNwZWNpZmllZCBidW5kbGUgYW5kIGxvY2FsZS4gSWYgbWVzc2FnZXMgaGF2ZSBub3QgYmVlbiBwcmV2aW91c2x5IGxvYWRlZCBmb3IgdGhlXHJcbiAqIHNwZWNpZmllZCBsb2NhbGUsIG5vIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBidW5kbGVcclxuICogVGhlIGRlZmF1bHQgYnVuZGxlIHRoYXQgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hlcmUgdGhlIGxvY2FsZS1zcGVjaWZpYyBidW5kbGVzIGFyZSBsb2NhdGVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gbG9jYWxlXHJcbiAqIFRoZSBsb2NhbGUgb2YgdGhlIGRlc2lyZWQgbWVzc2FnZXMuXHJcbiAqXHJcbiAqIEByZXR1cm4gVGhlIGNhY2hlZCBtZXNzYWdlcyBvYmplY3QsIGlmIGl0IGV4aXN0cy5cclxuICovXHJcbmZ1bmN0aW9uIGdldENhY2hlZE1lc3NhZ2VzKGJ1bmRsZSwgbG9jYWxlKSB7XHJcbiAgICB2YXIgX2EgPSBidW5kbGUuaWQsIGlkID0gX2EgPT09IHZvaWQgMCA/IGdldEJ1bmRsZUlkKGJ1bmRsZSkgOiBfYSwgbG9jYWxlcyA9IGJ1bmRsZS5sb2NhbGVzLCBtZXNzYWdlcyA9IGJ1bmRsZS5tZXNzYWdlcztcclxuICAgIHZhciBjYWNoZWQgPSBidW5kbGVNYXAuZ2V0KGlkKTtcclxuICAgIGlmICghY2FjaGVkKSB7XHJcbiAgICAgICAgbG9hZE1lc3NhZ2VzKGlkLCBtZXNzYWdlcyk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgbG9jYWxlTWVzc2FnZXMgPSBjYWNoZWQuZ2V0KGxvY2FsZSk7XHJcbiAgICAgICAgaWYgKGxvY2FsZU1lc3NhZ2VzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGVNZXNzYWdlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB2YXIgc3VwcG9ydGVkTG9jYWxlcyA9IGdldFN1cHBvcnRlZExvY2FsZXMobG9jYWxlLCBsb2NhbGVzICYmIE9iamVjdC5rZXlzKGxvY2FsZXMpKTtcclxuICAgIGlmICghc3VwcG9ydGVkTG9jYWxlcy5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XHJcbiAgICB9XHJcbiAgICBpZiAoY2FjaGVkKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZC5nZXQoc3VwcG9ydGVkTG9jYWxlc1tzdXBwb3J0ZWRMb2NhbGVzLmxlbmd0aCAtIDFdKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldENhY2hlZE1lc3NhZ2VzID0gZ2V0Q2FjaGVkTWVzc2FnZXM7XHJcbi8qKlxyXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYSBzcGVjaWZpYyBtZXNzYWdlLCBhbmQgdGFrZXMgYW4gb3B0aW9uYWwgdmFsdWUgZm9yIHRva2VuIHJlcGxhY2VtZW50LlxyXG4gKlxyXG4gKiBJZiBib3RoIHRoZSBcInN1cHBsZW1lbnRhbC9saWtlbHlTdWJ0YWdzXCIgYW5kIFwic3VwcGxlbWVudGFsL3BsdXJhbHMtdHlwZS1jYXJkaW5hbFwiIENMRFIgZGF0YSBoYXZlIGJlZW4gbG9hZGVkLCB0aGVuXHJcbiAqIHRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsIGhhdmUgSUNVIG1lc3NhZ2UgZm9ybWF0IHN1cHBvcnQuIE90aGVyd2lzZSwgdGhlIHJldHVybmVkIGZ1bmN0aW9uIHdpbGwgcGVyZm9ybSBhIHNpbXBsZVxyXG4gKiB0b2tlbiByZXBsYWNlbWVudCBvbiB0aGUgbWVzc2FnZSBzdHJpbmcuXHJcbiAqXHJcbiAqIFVzYWdlOlxyXG4gKiBjb25zdCBmb3JtYXR0ZXIgPSBnZXRNZXNzYWdlRm9ybWF0dGVyKGJ1bmRsZSwgJ2d1ZXN0SW5mbycsICdmcicpO1xyXG4gKiBjb25zdCBtZXNzYWdlID0gZm9ybWF0dGVyKHtcclxuICogICBob3N0OiAnTWlsZXMnLFxyXG4gKiAgIGdlbmRlcjogJ21hbGUnLFxyXG4gKiAgIGd1ZXN0OiAnT3NjYXInLFxyXG4gKiAgIGd1ZXN0Q291bnQ6ICcxNSdcclxuICogfSk7XHJcbiAqXHJcbiAqIEBwYXJhbSBidW5kbGVcclxuICogVGhlIGJ1bmRsZSBjb250YWluaW5nIHRoZSB0YXJnZXQgbWVzc2FnZS5cclxuICpcclxuICogQHBhcmFtIGtleVxyXG4gKiBUaGUgbWVzc2FnZSdzIGtleS5cclxuICpcclxuICogQHBhcmFtIGxvY2FsZVxyXG4gKiBBbiBvcHRpb25hbCBsb2NhbGUgZm9yIHRoZSBmb3JtYXR0ZXIuIElmIG5vIGxvY2FsZSBpcyBzdXBwbGllZCwgb3IgaWYgdGhlIGxvY2FsZSBpcyBub3Qgc3VwcG9ydGVkLCB0aGVcclxuICogZGVmYXVsdCBsb2NhbGUgaXMgdXNlZC5cclxuICpcclxuICogQHJldHVyblxyXG4gKiBUaGUgbWVzc2FnZSBmb3JtYXR0ZXIuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNZXNzYWdlRm9ybWF0dGVyKGJ1bmRsZSwga2V5LCBsb2NhbGUpIHtcclxuICAgIHZhciBfYSA9IGJ1bmRsZS5pZCwgaWQgPSBfYSA9PT0gdm9pZCAwID8gZ2V0QnVuZGxlSWQoYnVuZGxlKSA6IF9hO1xyXG4gICAgaWYgKGxvYWRfMS5pc0xvYWRlZCgnc3VwcGxlbWVudGFsJywgJ2xpa2VseVN1YnRhZ3MnKSAmJiBsb2FkXzEuaXNMb2FkZWQoJ3N1cHBsZW1lbnRhbCcsICdwbHVyYWxzLXR5cGUtY2FyZGluYWwnKSkge1xyXG4gICAgICAgIHJldHVybiBnZXRJY3VNZXNzYWdlRm9ybWF0dGVyKGlkLCBrZXksIGxvY2FsZSk7XHJcbiAgICB9XHJcbiAgICB2YXIgY2FjaGVkID0gYnVuZGxlTWFwLmdldChpZCk7XHJcbiAgICB2YXIgbWVzc2FnZXMgPSBjYWNoZWQgPyBjYWNoZWQuZ2V0KGxvY2FsZSB8fCBnZXRSb290TG9jYWxlKCkpIHx8IGNhY2hlZC5nZXQoJ3Jvb3QnKSA6IG51bGw7XHJcbiAgICBpZiAoIW1lc3NhZ2VzKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIGJ1bmRsZSBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZC5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyB9XHJcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzW2tleV0ucmVwbGFjZShUT0tFTl9QQVRURVJOLCBmdW5jdGlvbiAodG9rZW4sIHByb3BlcnR5KSB7XHJcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbcHJvcGVydHldO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBwcm9wZXJ0eSBcIiArIHByb3BlcnR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0TWVzc2FnZUZvcm1hdHRlciA9IGdldE1lc3NhZ2VGb3JtYXR0ZXI7XHJcbi8qKlxyXG4gKiBMb2FkIGxvY2FsZS1zcGVjaWZpYyBtZXNzYWdlcyBmb3IgdGhlIHNwZWNpZmllZCBidW5kbGUgYW5kIGxvY2FsZS5cclxuICpcclxuICogQHBhcmFtIGJ1bmRsZVxyXG4gKiBUaGUgZGVmYXVsdCBidW5kbGUgdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGVyZSB0aGUgbG9jYWxlLXNwZWNpZmljIGJ1bmRsZXMgYXJlIGxvY2F0ZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSBsb2NhbGVcclxuICogQW4gb3B0aW9uYWwgbG9jYWxlLiBJZiBubyBsb2NhbGUgaXMgcHJvdmlkZWQsIHRoZW4gdGhlIGN1cnJlbnQgbG9jYWxlIGlzIGFzc3VtZWQuXHJcbiAqXHJcbiAqIEByZXR1cm4gQSBwcm9taXNlIHRvIHRoZSBsb2NhbGUtc3BlY2lmaWMgbWVzc2FnZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBpMThuKGJ1bmRsZSwgbG9jYWxlKSB7XHJcbiAgICByZXR1cm4gdHNsaWJfMS5fX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY3VycmVudExvY2FsZSwgY2FjaGVkTWVzc2FnZXMsIGxvY2FsZXMsIHN1cHBvcnRlZExvY2FsZXMsIGJ1bmRsZXM7XHJcbiAgICAgICAgcmV0dXJuIHRzbGliXzEuX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50TG9jYWxlID0gbG9jYWxlID8gbWFpbl8xLm5vcm1hbGl6ZUxvY2FsZShsb2NhbGUpIDogZ2V0Um9vdExvY2FsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlZE1lc3NhZ2VzID0gZ2V0Q2FjaGVkTWVzc2FnZXMoYnVuZGxlLCBjdXJyZW50TG9jYWxlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGVkTWVzc2FnZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNhY2hlZE1lc3NhZ2VzXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlcyA9IGJ1bmRsZS5sb2NhbGVzO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1cHBvcnRlZExvY2FsZXMgPSBnZXRTdXBwb3J0ZWRMb2NhbGVzKGN1cnJlbnRMb2NhbGUsIE9iamVjdC5rZXlzKGxvY2FsZXMpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBsb2FkTG9jYWxlQnVuZGxlcyhsb2NhbGVzLCBzdXBwb3J0ZWRMb2NhbGVzKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlcyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgYnVuZGxlcy5yZWR1Y2UoZnVuY3Rpb24gKHByZXZpb3VzLCBwYXJ0aWFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbG9jYWxlTWVzc2FnZXMgPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBwcmV2aW91cywgcGFydGlhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkTWVzc2FnZXMoZ2V0QnVuZGxlSWQoYnVuZGxlKSwgT2JqZWN0LmZyZWV6ZShsb2NhbGVNZXNzYWdlcyksIGN1cnJlbnRMb2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZU1lc3NhZ2VzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBidW5kbGUubWVzc2FnZXMpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGkxOG4sICdsb2NhbGUnLCB7XHJcbiAgICBnZXQ6IGdldFJvb3RMb2NhbGVcclxufSk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGkxOG47XHJcbi8qKlxyXG4gKiBJbnZhbGlkYXRlIHRoZSBjYWNoZSBmb3IgYSBwYXJ0aWN1bGFyIGJ1bmRsZSwgb3IgaW52YWxpZGF0ZSB0aGUgZW50aXJlIGNhY2hlLiBOb3RlIHRoYXQgY2FjaGVkIG1lc3NhZ2VzIGZvciBhbGxcclxuICogbG9jYWxlcyBmb3IgYSBnaXZlbiBidW5kbGUgd2lsbCBiZSBjbGVhcmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gYnVuZGxlXHJcbiAqIEFuIG9wdGlvbmFsIGJ1bmRsZSB0byBpbnZhbGlkYXRlLiBJZiBubyBidW5kbGUgaXMgcHJvdmlkZWQsIHRoZW4gdGhlIGNhY2hlIGlzIGNsZWFyZWQgZm9yIGFsbCBidW5kbGVzLlxyXG4gKi9cclxuZnVuY3Rpb24gaW52YWxpZGF0ZShidW5kbGUpIHtcclxuICAgIGlmIChidW5kbGUpIHtcclxuICAgICAgICBidW5kbGUuaWQgJiYgYnVuZGxlTWFwLmRlbGV0ZShidW5kbGUuaWQpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYnVuZGxlTWFwLmNsZWFyKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5pbnZhbGlkYXRlID0gaW52YWxpZGF0ZTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVyIGFuIG9ic2VydmVyIHRvIGJlIG5vdGlmaWVkIHdoZW4gdGhlIHJvb3QgbG9jYWxlIGNoYW5nZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBvYnNlcnZlclxyXG4gKiBUaGUgb2JzZXJ2ZXIgd2hvc2UgYG5leHRgIG1ldGhvZCB3aWxsIHJlY2VpdmUgdGhlIGxvY2FsZSBzdHJpbmcgb24gdXBkYXRlcywgYW5kIHdob3NlIGBlcnJvcmAgbWV0aG9kIHdpbGwgcmVjZWl2ZVxyXG4gKiBhbiBFcnJvciBvYmplY3QgaWYgdGhlIGxvY2FsZSBzd2l0Y2ggZmFpbHMuXHJcbiAqXHJcbiAqIEByZXR1cm5cclxuICogQSBzdWJzY3JpcHRpb24gb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gdW5zdWJzY3JpYmUgZnJvbSB1cGRhdGVzLlxyXG4gKi9cclxuZXhwb3J0cy5vYnNlcnZlTG9jYWxlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gbG9jYWxlUHJvZHVjZXIub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIGNhbGxiYWNrKGV2ZW50LnRhcmdldCk7XHJcbiAgICB9KTtcclxufTtcclxuLyoqXHJcbiAqIFByZS1sb2FkIGxvY2FsZS1zcGVjaWZpYyBtZXNzYWdlcyBpbnRvIHRoZSBpMThuIHN5c3RlbS5cclxuICpcclxuICogQHBhcmFtIGJ1bmRsZVxyXG4gKiBUaGUgZGVmYXVsdCBidW5kbGUgdGhhdCBpcyB1c2VkIHRvIG1lcmdlIGxvY2FsZS1zcGVjaWZpYyBtZXNzYWdlcyB3aXRoIHRoZSBkZWZhdWx0IG1lc3NhZ2VzLlxyXG4gKlxyXG4gKiBAcGFyYW0gbWVzc2FnZXNcclxuICogVGhlIG1lc3NhZ2VzIHRvIGNhY2hlLlxyXG4gKlxyXG4gKiBAcGFyYW0gbG9jYWxlXHJcbiAqIFRoZSBsb2NhbGUgZm9yIHRoZSBtZXNzYWdlc1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0TG9jYWxlTWVzc2FnZXMoYnVuZGxlLCBsb2NhbGVNZXNzYWdlcywgbG9jYWxlKSB7XHJcbiAgICB2YXIgbWVzc2FnZXMgPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBidW5kbGUubWVzc2FnZXMsIGxvY2FsZU1lc3NhZ2VzKTtcclxuICAgIGxvYWRNZXNzYWdlcyhnZXRCdW5kbGVJZChidW5kbGUpLCBPYmplY3QuZnJlZXplKG1lc3NhZ2VzKSwgbG9jYWxlKTtcclxufVxyXG5leHBvcnRzLnNldExvY2FsZU1lc3NhZ2VzID0gc2V0TG9jYWxlTWVzc2FnZXM7XHJcbi8qKlxyXG4gKiBDaGFuZ2UgdGhlIHJvb3QgbG9jYWxlLCBhbmQgbm90aWZ5IGFueSByZWdpc3RlcmVkIG9ic2VydmVycy5cclxuICpcclxuICogQHBhcmFtIGxvY2FsZVxyXG4gKiBUaGUgbmV3IGxvY2FsZS5cclxuICovXHJcbmZ1bmN0aW9uIHN3aXRjaExvY2FsZShsb2NhbGUpIHtcclxuICAgIHZhciBwcmV2aW91cyA9IHJvb3RMb2NhbGU7XHJcbiAgICByb290TG9jYWxlID0gbG9jYWxlID8gbWFpbl8xLm5vcm1hbGl6ZUxvY2FsZShsb2NhbGUpIDogJyc7XHJcbiAgICBpZiAocHJldmlvdXMgIT09IHJvb3RMb2NhbGUpIHtcclxuICAgICAgICBpZiAobG9hZF8xLmlzTG9hZGVkKCdzdXBwbGVtZW50YWwnLCAnbGlrZWx5U3VidGFncycpKSB7XHJcbiAgICAgICAgICAgIEdsb2JhbGl6ZS5sb2FkKHtcclxuICAgICAgICAgICAgICAgIG1haW46IChfYSA9IHt9LFxyXG4gICAgICAgICAgICAgICAgICAgIF9hW3Jvb3RMb2NhbGVdID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgX2EpXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBHbG9iYWxpemUubG9jYWxlKHJvb3RMb2NhbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2NhbGVQcm9kdWNlci5lbWl0KHsgdHlwZTogJ2NoYW5nZScsIHRhcmdldDogcm9vdExvY2FsZSB9KTtcclxuICAgIH1cclxuICAgIHZhciBfYTtcclxufVxyXG5leHBvcnRzLnN3aXRjaExvY2FsZSA9IHN3aXRjaExvY2FsZTtcclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGVudmlyb25tZW50IGxvY2FsZS5cclxuICpcclxuICogSXQgc2hvdWxkIGJlIG5vdGVkIHRoYXQgd2hpbGUgdGhlIHN5c3RlbSBsb2NhbGUgd2lsbCBiZSBub3JtYWxpemVkIHRvIGEgc2luZ2xlXHJcbiAqIGZvcm1hdCB3aGVuIGxvYWRpbmcgbWVzc2FnZSBidW5kbGVzLCB0aGlzIHZhbHVlIHJlcHJlc2VudHMgdGhlIHVuYWx0ZXJlZFxyXG4gKiBsb2NhbGUgcmV0dXJuZWQgZGlyZWN0bHkgYnkgdGhlIGVudmlyb25tZW50LlxyXG4gKi9cclxuZXhwb3J0cy5zeXN0ZW1Mb2NhbGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHN5c3RlbUxvY2FsZSA9ICdlbic7XHJcbiAgICBpZiAoaGFzXzEuZGVmYXVsdCgnaG9zdC1icm93c2VyJykpIHtcclxuICAgICAgICB2YXIgbmF2aWdhdG9yXzEgPSBnbG9iYWxfMS5kZWZhdWx0Lm5hdmlnYXRvcjtcclxuICAgICAgICBzeXN0ZW1Mb2NhbGUgPSBuYXZpZ2F0b3JfMS5sYW5ndWFnZSB8fCBuYXZpZ2F0b3JfMS51c2VyTGFuZ3VhZ2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChoYXNfMS5kZWZhdWx0KCdob3N0LW5vZGUnKSkge1xyXG4gICAgICAgIHN5c3RlbUxvY2FsZSA9IHByb2Nlc3MuZW52LkxBTkcgfHwgc3lzdGVtTG9jYWxlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG1haW5fMS5ub3JtYWxpemVMb2NhbGUoc3lzdGVtTG9jYWxlKTtcclxufSkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby9pMThuL2kxOG4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2kxOG4vaTE4bi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBNYXRjaGVzIGFuIElTTyA2MzkuMS82MzkuMiBjb21wYXRpYmxlIGxhbmd1YWdlLCBmb2xsb3dlZCBieSBvcHRpb25hbCBzdWJ0YWdzLlxyXG52YXIgVkFMSURfTE9DQUxFX1BBVFRFUk4gPSAvXlthLXpdezIsM30oLVthLXowLTlcXC1cXF9dKyk/JC9pO1xyXG4vKipcclxuICogUmV0cmlldmUgYSBsaXN0IG9mIGxvY2FsZXMgdGhhdCBjYW4gcHJvdmlkZSBzdWJzdGl0dXRlIGZvciB0aGUgc3BlY2lmaWVkIGxvY2FsZVxyXG4gKiAoaW5jbHVkaW5nIGl0c2VsZikuXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCBpZiAnZnItQ0EnIGlzIHNwZWNpZmllZCwgdGhlbiBgWyAnZnInLCAnZnItQ0EnIF1gIGlzIHJldHVybmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0gbG9jYWxlXHJcbiAqIFRoZSB0YXJnZXQgbG9jYWxlLlxyXG4gKlxyXG4gKiBAcmV0dXJuXHJcbiAqIEEgbGlzdCBvZiBsb2NhbGVzIHRoYXQgbWF0Y2ggdGhlIHRhcmdldCBsb2NhbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZW5lcmF0ZUxvY2FsZXMobG9jYWxlKSB7XHJcbiAgICB2YXIgbm9ybWFsaXplZCA9IGV4cG9ydHMubm9ybWFsaXplTG9jYWxlKGxvY2FsZSk7XHJcbiAgICB2YXIgcGFydHMgPSBub3JtYWxpemVkLnNwbGl0KCctJyk7XHJcbiAgICB2YXIgY3VycmVudCA9IHBhcnRzWzBdO1xyXG4gICAgdmFyIHJlc3VsdCA9IFtjdXJyZW50XTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XHJcbiAgICAgICAgY3VycmVudCArPSAnLScgKyBwYXJ0c1tpICsgMV07XHJcbiAgICAgICAgcmVzdWx0LnB1c2goY3VycmVudCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuZ2VuZXJhdGVMb2NhbGVzID0gZ2VuZXJhdGVMb2NhbGVzO1xyXG4vKipcclxuICogTm9ybWFsaXplIGEgbG9jYWxlIHNvIHRoYXQgaXQgY2FuIGJlIGNvbnZlcnRlZCB0byBhIGJ1bmRsZSBwYXRoLlxyXG4gKlxyXG4gKiBAcGFyYW0gbG9jYWxlXHJcbiAqIFRoZSB0YXJnZXQgbG9jYWxlLlxyXG4gKlxyXG4gKiBAcmV0dXJuIFRoZSBub3JtYWxpemVkIGxvY2FsZS5cclxuICovXHJcbmV4cG9ydHMubm9ybWFsaXplTG9jYWxlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yKHZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoLyhcXC18XykkLywgJycpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKGxvY2FsZSkge1xyXG4gICAgICAgIGlmIChsb2NhbGUuaW5kZXhPZignLicpID09PSAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3ZlVHJhaWxpbmdTZXBhcmF0b3IobG9jYWxlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGxvY2FsZVxyXG4gICAgICAgICAgICAuc3BsaXQoJy4nKVxyXG4gICAgICAgICAgICAuc2xpY2UoMCwgLTEpXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbW92ZVRyYWlsaW5nU2VwYXJhdG9yKHBhcnQpLnJlcGxhY2UoL18vZywgJy0nKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuam9pbignLScpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChsb2NhbGUpIHtcclxuICAgICAgICB2YXIgbm9ybWFsaXplZCA9IG5vcm1hbGl6ZShsb2NhbGUpO1xyXG4gICAgICAgIGlmICghdmFsaWRhdGVMb2NhbGUobm9ybWFsaXplZCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG5vcm1hbGl6ZWQgKyBcIiBpcyBub3QgYSB2YWxpZCBsb2NhbGUuXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZDtcclxuICAgIH07XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBWYWxpZGF0ZXMgdGhhdCB0aGUgcHJvdmlkZWQgbG9jYWxlIGF0IGxlYXN0IGJlZ2lucyB3aXRoIGEgSVNPIDYzOS4xLzYzOS4yIGNvbXB0YWJpbGUgbGFuZ3VhZ2Ugc3VidGFnLFxyXG4gKiBhbmQgdGhhdCBhbnkgYWRkaXRpb25hbCBzdWJ0YWdzIGNvbnRhaW4gb25seSB2YWxpZCBjaGFyYWN0ZXJzLlxyXG4gKlxyXG4gKiBXaGlsZSBsb2NhbGVzIHNob3VsZCBhZGhlcmUgdG8gdGhlIGd1aWRlbGluZXMgc2V0IGZvcnRoIGJ5IFJGQyA1NjQ2IChodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNTY0NiksXHJcbiAqIG9ubHkgdGhlIGxhbmd1YWdlIHN1YnRhZyBpcyBzdHJpY3RseSBlbmZvcmNlZC5cclxuICpcclxuICogQHBhcmFtIGxvY2FsZVxyXG4gKiBUaGUgbG9jYWxlIHRvIHZhbGlkYXRlLlxyXG4gKlxyXG4gKiBAcmV0dXJuXHJcbiAqIGB0cnVlYCBpZiB0aGUgbG9jYWxlIGlzIHZhbGlkOyBgZmFsc2VgIG90aGVyd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlTG9jYWxlKGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIFZBTElEX0xPQ0FMRV9QQVRURVJOLnRlc3QobG9jYWxlKTtcclxufVxyXG5leHBvcnRzLnZhbGlkYXRlTG9jYWxlID0gdmFsaWRhdGVMb2NhbGU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vaTE4bi91dGlsL21haW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL2kxOG4vdXRpbC9tYWluLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG52YXIgaXRlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2l0ZXJhdG9yXCIpO1xyXG52YXIgZ2xvYmFsXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxcIik7XHJcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcclxudmFyIGhhc18xID0gcmVxdWlyZShcIi4vc3VwcG9ydC9oYXNcIik7XHJcbnJlcXVpcmUoXCIuL1N5bWJvbFwiKTtcclxuZXhwb3J0cy5NYXAgPSBnbG9iYWxfMS5kZWZhdWx0Lk1hcDtcclxuaWYgKCFoYXNfMS5kZWZhdWx0KCdlczYtbWFwJykpIHtcclxuICAgIGV4cG9ydHMuTWFwID0gKF9hID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBNYXAoaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgdGhpc1tTeW1ib2wudG9TdHJpbmdUYWddID0gJ01hcCc7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmFibGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0b3JfMS5pc0FycmF5TGlrZShpdGVyYWJsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlcmFibGVbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaXRlcmFibGVfMSA9IHRzbGliXzEuX192YWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8xXzEgPSBpdGVyYWJsZV8xLm5leHQoKTsgIWl0ZXJhYmxlXzFfMS5kb25lOyBpdGVyYWJsZV8xXzEgPSBpdGVyYWJsZV8xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGl0ZXJhYmxlXzFfMS52YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh2YWx1ZVswXSwgdmFsdWVbMV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmFibGVfMV8xICYmICFpdGVyYWJsZV8xXzEuZG9uZSAmJiAoX2EgPSBpdGVyYWJsZV8xLnJldHVybikpIF9hLmNhbGwoaXRlcmFibGVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB2YXIgZV8xLCBfYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQW4gYWx0ZXJuYXRpdmUgdG8gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgdXNpbmcgT2JqZWN0LmlzXHJcbiAgICAgICAgICAgICAqIHRvIGNoZWNrIGZvciBlcXVhbGl0eS4gU2VlIGh0dHA6Ly9temwubGEvMXp1S08yVlxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5faW5kZXhPZktleSA9IGZ1bmN0aW9uIChrZXlzLCBrZXkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGhfMSA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmplY3RfMS5pcyhrZXlzW2ldLCBrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE1hcC5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMubGVuZ3RoID0gdGhpcy5fdmFsdWVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZGVsZXRlID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXhPZktleSh0aGlzLl9rZXlzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZW50cmllcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy5fa2V5cy5tYXAoZnVuY3Rpb24gKGtleSwgaSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBba2V5LCBfdGhpcy5fdmFsdWVzW2ldXTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBpdGVyYXRvcl8xLlNoaW1JdGVyYXRvcih2YWx1ZXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXlzID0gdGhpcy5fa2V5cztcclxuICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSB0aGlzLl92YWx1ZXM7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoXzIgPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aF8yOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKGNvbnRleHQsIHZhbHVlc1tpXSwga2V5c1tpXSwgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5faW5kZXhPZktleSh0aGlzLl9rZXlzLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IHRoaXMuX3ZhbHVlc1tpbmRleF07XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIE1hcC5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luZGV4T2ZLZXkodGhpcy5fa2V5cywga2V5KSA+IC0xO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGl0ZXJhdG9yXzEuU2hpbUl0ZXJhdG9yKHRoaXMuX2tleXMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9pbmRleE9mS2V5KHRoaXMuX2tleXMsIGtleSk7XHJcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IHRoaXMuX2tleXMubGVuZ3RoIDogaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzW2luZGV4XSA9IGtleTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBNYXAucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaXRlcmF0b3JfMS5TaGltSXRlcmF0b3IodGhpcy5fdmFsdWVzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgTWFwLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgICAgIH0oKSksXHJcbiAgICAgICAgX2FbU3ltYm9sLnNwZWNpZXNdID0gX2EsXHJcbiAgICAgICAgX2EpO1xyXG59XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGV4cG9ydHMuTWFwO1xyXG52YXIgX2E7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9NYXAuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vTWFwLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG52YXIgZ2xvYmFsXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxcIik7XHJcbnZhciBxdWV1ZV8xID0gcmVxdWlyZShcIi4vc3VwcG9ydC9xdWV1ZVwiKTtcclxucmVxdWlyZShcIi4vU3ltYm9sXCIpO1xyXG52YXIgaGFzXzEgPSByZXF1aXJlKFwiLi9zdXBwb3J0L2hhc1wiKTtcclxuZXhwb3J0cy5TaGltUHJvbWlzZSA9IGdsb2JhbF8xLmRlZmF1bHQuUHJvbWlzZTtcclxuZXhwb3J0cy5pc1RoZW5hYmxlID0gZnVuY3Rpb24gaXNUaGVuYWJsZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xyXG59O1xyXG5pZiAoIWhhc18xLmRlZmF1bHQoJ2VzNi1wcm9taXNlJykpIHtcclxuICAgIGdsb2JhbF8xLmRlZmF1bHQuUHJvbWlzZSA9IGV4cG9ydHMuU2hpbVByb21pc2UgPSAoX2EgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IFByb21pc2UuXHJcbiAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAqIEBjb25zdHJ1Y3RvclxyXG4gICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgKiBAcGFyYW0gZXhlY3V0b3JcclxuICAgICAgICAgICAgICogVGhlIGV4ZWN1dG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBpbW1lZGlhdGVseSB3aGVuIHRoZSBQcm9taXNlIGlzIGluc3RhbnRpYXRlZC4gSXQgaXMgcmVzcG9uc2libGUgZm9yXHJcbiAgICAgICAgICAgICAqIHN0YXJ0aW5nIHRoZSBhc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoZW4gaXQgaXMgaW52b2tlZC5cclxuICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICogVGhlIGV4ZWN1dG9yIG11c3QgY2FsbCBlaXRoZXIgdGhlIHBhc3NlZCBgcmVzb2x2ZWAgZnVuY3Rpb24gd2hlbiB0aGUgYXN5bmNocm9ub3VzIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkXHJcbiAgICAgICAgICAgICAqIHN1Y2Nlc3NmdWxseSwgb3IgdGhlIGByZWplY3RgIGZ1bmN0aW9uIHdoZW4gdGhlIG9wZXJhdGlvbiBmYWlscy5cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIFByb21pc2UoZXhlY3V0b3IpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IDEgLyogUGVuZGluZyAqLztcclxuICAgICAgICAgICAgICAgIHRoaXNbU3ltYm9sLnRvU3RyaW5nVGFnXSA9ICdQcm9taXNlJztcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogSWYgdHJ1ZSwgdGhlIHJlc29sdXRpb24gb2YgdGhpcyBwcm9taXNlIGlzIGNoYWluZWQgKFwibG9ja2VkIGluXCIpIHRvIGFub3RoZXIgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzQ2hhaW5lZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGlzIHByb21pc2UgaXMgaW4gYSByZXNvbHZlZCBzdGF0ZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIGlzUmVzb2x2ZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0YXRlICE9PSAxIC8qIFBlbmRpbmcgKi8gfHwgaXNDaGFpbmVkO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogQ2FsbGJhY2tzIHRoYXQgc2hvdWxkIGJlIGludm9rZWQgb25jZSB0aGUgYXN5bmNocm9ub3VzIG9wZXJhdGlvbiBoYXMgY29tcGxldGVkLlxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEluaXRpYWxseSBwdXNoZXMgY2FsbGJhY2tzIG9udG8gYSBxdWV1ZSBmb3IgZXhlY3V0aW9uIG9uY2UgdGhpcyBwcm9taXNlIHNldHRsZXMuIEFmdGVyIHRoZSBwcm9taXNlIHNldHRsZXMsXHJcbiAgICAgICAgICAgICAgICAgKiBlbnF1ZXVlcyBjYWxsYmFja3MgZm9yIGV4ZWN1dGlvbiBvbiB0aGUgbmV4dCBldmVudCBsb29wIHR1cm4uXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciB3aGVuRmluaXNoZWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBTZXR0bGVzIHRoaXMgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbmV3U3RhdGUgVGhlIHJlc29sdmVkIHN0YXRlIGZvciB0aGlzIHByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0ge1R8YW55fSB2YWx1ZSBUaGUgcmVzb2x2ZWQgdmFsdWUgZm9yIHRoaXMgcHJvbWlzZS5cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgdmFyIHNldHRsZSA9IGZ1bmN0aW9uIChuZXdTdGF0ZSwgdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBIHByb21pc2UgY2FuIG9ubHkgYmUgc2V0dGxlZCBvbmNlLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSAhPT0gMSAvKiBQZW5kaW5nICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBuZXdTdGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXNvbHZlZFZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgd2hlbkZpbmlzaGVkID0gcXVldWVfMS5xdWV1ZU1pY3JvVGFzaztcclxuICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGVucXVldWUgYSBjYWxsYmFjayBydW5uZXIgaWYgdGhlcmUgYXJlIGNhbGxiYWNrcyBzbyB0aGF0IGluaXRpYWxseSBmdWxmaWxsZWQgUHJvbWlzZXMgZG9uJ3QgaGF2ZSB0b1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhaXQgYW4gZXh0cmEgdHVybi5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2tzICYmIGNhbGxiYWNrcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlXzEucXVldWVNaWNyb1Rhc2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb3VudCA9IGNhbGxiYWNrcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBSZXNvbHZlcyB0aGlzIHByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIG5ld1N0YXRlIFRoZSByZXNvbHZlZCBzdGF0ZSBmb3IgdGhpcyBwcm9taXNlLlxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIHtUfGFueX0gdmFsdWUgVGhlIHJlc29sdmVkIHZhbHVlIGZvciB0aGlzIHByb21pc2UuXHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIHZhciByZXNvbHZlID0gZnVuY3Rpb24gKG5ld1N0YXRlLCB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Jlc29sdmVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXhwb3J0cy5pc1RoZW5hYmxlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS50aGVuKHNldHRsZS5iaW5kKG51bGwsIDAgLyogRnVsZmlsbGVkICovKSwgc2V0dGxlLmJpbmQobnVsbCwgMiAvKiBSZWplY3RlZCAqLykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0NoYWluZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0dGxlKG5ld1N0YXRlLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMudGhlbiA9IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW5GaW5pc2hlZCBpbml0aWFsbHkgcXVldWVzIHVwIGNhbGxiYWNrcyBmb3IgZXhlY3V0aW9uIGFmdGVyIHRoZSBwcm9taXNlIGhhcyBzZXR0bGVkLiBPbmNlIHRoZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9taXNlIGhhcyBzZXR0bGVkLCB3aGVuRmluaXNoZWQgd2lsbCBzY2hlZHVsZSBjYWxsYmFja3MgZm9yIGV4ZWN1dGlvbiBvbiB0aGUgbmV4dCB0dXJuIHRocm91Z2ggdGhlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50IGxvb3AuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoZW5GaW5pc2hlZChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfdGhpcy5zdGF0ZSA9PT0gMiAvKiBSZWplY3RlZCAqLyA/IG9uUmVqZWN0ZWQgOiBvbkZ1bGZpbGxlZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNhbGxiYWNrKF90aGlzLnJlc29sdmVkVmFsdWUpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMuc3RhdGUgPT09IDIgLyogUmVqZWN0ZWQgKi8pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoX3RoaXMucmVzb2x2ZWRWYWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLnJlc29sdmVkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dG9yKHJlc29sdmUuYmluZChudWxsLCAwIC8qIEZ1bGZpbGxlZCAqLyksIHJlc29sdmUuYmluZChudWxsLCAyIC8qIFJlamVjdGVkICovKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXR0bGUoMiAvKiBSZWplY3RlZCAqLywgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIFByb21pc2UuYWxsID0gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY29tcGxldGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvcHVsYXRpbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKytjb21wbGV0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmlzaCgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBvcHVsYXRpbmcgfHwgY29tcGxldGUgPCB0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWVzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0l0ZW0oaW5kZXgsIGl0ZW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgKyt0b3RhbDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cG9ydHMuaXNUaGVuYWJsZShpdGVtKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gaXRlbSBQcm9taXNlIHJlamVjdHMsIHRoaXMgUHJvbWlzZSBpcyBpbW1lZGlhdGVseSByZWplY3RlZCB3aXRoIHRoZSBpdGVtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9taXNlJ3MgcmVqZWN0aW9uIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS50aGVuKGZ1bGZpbGwuYmluZChudWxsLCBpbmRleCksIHJlamVjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoaXRlbSkudGhlbihmdWxmaWxsLmJpbmQobnVsbCwgaW5kZXgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaXRlcmFibGVfMSA9IHRzbGliXzEuX192YWx1ZXMoaXRlcmFibGUpLCBpdGVyYWJsZV8xXzEgPSBpdGVyYWJsZV8xLm5leHQoKTsgIWl0ZXJhYmxlXzFfMS5kb25lOyBpdGVyYWJsZV8xXzEgPSBpdGVyYWJsZV8xLm5leHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gaXRlcmFibGVfMV8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0l0ZW0oaSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmFibGVfMV8xICYmICFpdGVyYWJsZV8xXzEuZG9uZSAmJiAoX2EgPSBpdGVyYWJsZV8xLnJldHVybikpIF9hLmNhbGwoaXRlcmFibGVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBwb3B1bGF0aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluaXNoKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVfMSwgX2E7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgUHJvbWlzZS5yYWNlID0gZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHRoaXMoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGl0ZXJhYmxlXzIgPSB0c2xpYl8xLl9fdmFsdWVzKGl0ZXJhYmxlKSwgaXRlcmFibGVfMl8xID0gaXRlcmFibGVfMi5uZXh0KCk7ICFpdGVyYWJsZV8yXzEuZG9uZTsgaXRlcmFibGVfMl8xID0gaXRlcmFibGVfMi5uZXh0KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpdGVtID0gaXRlcmFibGVfMl8xLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYSBQcm9taXNlIGl0ZW0gcmVqZWN0cywgdGhpcyBQcm9taXNlIGlzIGltbWVkaWF0ZWx5IHJlamVjdGVkIHdpdGggdGhlIGl0ZW1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBQcm9taXNlJ3MgcmVqZWN0aW9uIGVycm9yLlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0udGhlbihyZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKGl0ZW0pLnRoZW4ocmVzb2x2ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYWJsZV8yXzEgJiYgIWl0ZXJhYmxlXzJfMS5kb25lICYmIChfYSA9IGl0ZXJhYmxlXzIucmV0dXJuKSkgX2EuY2FsbChpdGVyYWJsZV8yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBlXzIsIF9hO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFByb21pc2UucmVqZWN0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyB0aGlzKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3QocmVhc29uKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgdGhpcyhmdW5jdGlvbiAocmVzb2x2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFByb21pc2UucHJvdG90eXBlLmNhdGNoID0gZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2U7XHJcbiAgICAgICAgfSgpKSxcclxuICAgICAgICBfYVtTeW1ib2wuc3BlY2llc10gPSBleHBvcnRzLlNoaW1Qcm9taXNlLFxyXG4gICAgICAgIF9hKTtcclxufVxyXG5leHBvcnRzLmRlZmF1bHQgPSBleHBvcnRzLlNoaW1Qcm9taXNlO1xyXG52YXIgX2E7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9Qcm9taXNlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL1Byb21pc2UuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGhhc18xID0gcmVxdWlyZShcIi4vc3VwcG9ydC9oYXNcIik7XHJcbnZhciBnbG9iYWxfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbFwiKTtcclxudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3N1cHBvcnQvdXRpbFwiKTtcclxuZXhwb3J0cy5TeW1ib2wgPSBnbG9iYWxfMS5kZWZhdWx0LlN5bWJvbDtcclxuaWYgKCFoYXNfMS5kZWZhdWx0KCdlczYtc3ltYm9sJykpIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhyb3dzIGlmIHRoZSB2YWx1ZSBpcyBub3QgYSBzeW1ib2wsIHVzZWQgaW50ZXJuYWxseSB3aXRoaW4gdGhlIFNoaW1cclxuICAgICAqIEBwYXJhbSAge2FueX0gICAgdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrXHJcbiAgICAgKiBAcmV0dXJuIHtzeW1ib2x9ICAgICAgIFJldHVybnMgdGhlIHN5bWJvbCBvciB0aHJvd3NcclxuICAgICAqL1xyXG4gICAgdmFyIHZhbGlkYXRlU3ltYm9sXzEgPSBmdW5jdGlvbiB2YWxpZGF0ZVN5bWJvbCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICghaXNTeW1ib2wodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IodmFsdWUgKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9O1xyXG4gICAgdmFyIGRlZmluZVByb3BlcnRpZXNfMSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xyXG4gICAgdmFyIGRlZmluZVByb3BlcnR5XzEgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XHJcbiAgICB2YXIgY3JlYXRlXzEgPSBPYmplY3QuY3JlYXRlO1xyXG4gICAgdmFyIG9ialByb3RvdHlwZV8xID0gT2JqZWN0LnByb3RvdHlwZTtcclxuICAgIHZhciBnbG9iYWxTeW1ib2xzXzEgPSB7fTtcclxuICAgIHZhciBnZXRTeW1ib2xOYW1lXzEgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlXzEobnVsbCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkZXNjKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3N0Zml4ID0gMDtcclxuICAgICAgICAgICAgdmFyIG5hbWU7XHJcbiAgICAgICAgICAgIHdoaWxlIChjcmVhdGVkW1N0cmluZyhkZXNjKSArIChwb3N0Zml4IHx8ICcnKV0pIHtcclxuICAgICAgICAgICAgICAgICsrcG9zdGZpeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZXNjICs9IFN0cmluZyhwb3N0Zml4IHx8ICcnKTtcclxuICAgICAgICAgICAgY3JlYXRlZFtkZXNjXSA9IHRydWU7XHJcbiAgICAgICAgICAgIG5hbWUgPSAnQEAnICsgZGVzYztcclxuICAgICAgICAgICAgLy8gRklYTUU6IFRlbXBvcmFyeSBndWFyZCB1bnRpbCB0aGUgZHVwbGljYXRlIGV4ZWN1dGlvbiB3aGVuIHRlc3RpbmcgY2FuIGJlXHJcbiAgICAgICAgICAgIC8vIHBpbm5lZCBkb3duLlxyXG4gICAgICAgICAgICBpZiAoIU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqUHJvdG90eXBlXzEsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eV8xKG9ialByb3RvdHlwZV8xLCBuYW1lLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUHJvcGVydHlfMSh0aGlzLCBuYW1lLCB1dGlsXzEuZ2V0VmFsdWVEZXNjcmlwdG9yKHZhbHVlKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XHJcbiAgICAgICAgfTtcclxuICAgIH0pKCk7XHJcbiAgICB2YXIgSW50ZXJuYWxTeW1ib2xfMSA9IGZ1bmN0aW9uIFN5bWJvbChkZXNjcmlwdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgSW50ZXJuYWxTeW1ib2xfMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUeXBlRXJyb3I6IFN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU3ltYm9sKGRlc2NyaXB0aW9uKTtcclxuICAgIH07XHJcbiAgICBleHBvcnRzLlN5bWJvbCA9IGdsb2JhbF8xLmRlZmF1bHQuU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKGRlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBTeW1ib2wpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVHlwZUVycm9yOiBTeW1ib2wgaXMgbm90IGEgY29uc3RydWN0b3InKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN5bSA9IE9iamVjdC5jcmVhdGUoSW50ZXJuYWxTeW1ib2xfMS5wcm90b3R5cGUpO1xyXG4gICAgICAgIGRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKGRlc2NyaXB0aW9uKTtcclxuICAgICAgICByZXR1cm4gZGVmaW5lUHJvcGVydGllc18xKHN5bSwge1xyXG4gICAgICAgICAgICBfX2Rlc2NyaXB0aW9uX186IHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZGVzY3JpcHRpb24pLFxyXG4gICAgICAgICAgICBfX25hbWVfXzogdXRpbF8xLmdldFZhbHVlRGVzY3JpcHRvcihnZXRTeW1ib2xOYW1lXzEoZGVzY3JpcHRpb24pKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qIERlY29yYXRlIHRoZSBTeW1ib2wgZnVuY3Rpb24gd2l0aCB0aGUgYXBwcm9wcmlhdGUgcHJvcGVydGllcyAqL1xyXG4gICAgZGVmaW5lUHJvcGVydHlfMShleHBvcnRzLlN5bWJvbCwgJ2ZvcicsIHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIGlmIChnbG9iYWxTeW1ib2xzXzFba2V5XSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3ltYm9sc18xW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoZ2xvYmFsU3ltYm9sc18xW2tleV0gPSBleHBvcnRzLlN5bWJvbChTdHJpbmcoa2V5KSkpO1xyXG4gICAgfSkpO1xyXG4gICAgZGVmaW5lUHJvcGVydGllc18xKGV4cG9ydHMuU3ltYm9sLCB7XHJcbiAgICAgICAga2V5Rm9yOiB1dGlsXzEuZ2V0VmFsdWVEZXNjcmlwdG9yKGZ1bmN0aW9uIChzeW0pIHtcclxuICAgICAgICAgICAgdmFyIGtleTtcclxuICAgICAgICAgICAgdmFsaWRhdGVTeW1ib2xfMShzeW0pO1xyXG4gICAgICAgICAgICBmb3IgKGtleSBpbiBnbG9iYWxTeW1ib2xzXzEpIHtcclxuICAgICAgICAgICAgICAgIGlmIChnbG9iYWxTeW1ib2xzXzFba2V5XSA9PT0gc3ltKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtleTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIGhhc0luc3RhbmNlOiB1dGlsXzEuZ2V0VmFsdWVEZXNjcmlwdG9yKGV4cG9ydHMuU3ltYm9sLmZvcignaGFzSW5zdGFuY2UnKSwgZmFsc2UsIGZhbHNlKSxcclxuICAgICAgICBpc0NvbmNhdFNwcmVhZGFibGU6IHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZXhwb3J0cy5TeW1ib2wuZm9yKCdpc0NvbmNhdFNwcmVhZGFibGUnKSwgZmFsc2UsIGZhbHNlKSxcclxuICAgICAgICBpdGVyYXRvcjogdXRpbF8xLmdldFZhbHVlRGVzY3JpcHRvcihleHBvcnRzLlN5bWJvbC5mb3IoJ2l0ZXJhdG9yJyksIGZhbHNlLCBmYWxzZSksXHJcbiAgICAgICAgbWF0Y2g6IHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZXhwb3J0cy5TeW1ib2wuZm9yKCdtYXRjaCcpLCBmYWxzZSwgZmFsc2UpLFxyXG4gICAgICAgIG9ic2VydmFibGU6IHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZXhwb3J0cy5TeW1ib2wuZm9yKCdvYnNlcnZhYmxlJyksIGZhbHNlLCBmYWxzZSksXHJcbiAgICAgICAgcmVwbGFjZTogdXRpbF8xLmdldFZhbHVlRGVzY3JpcHRvcihleHBvcnRzLlN5bWJvbC5mb3IoJ3JlcGxhY2UnKSwgZmFsc2UsIGZhbHNlKSxcclxuICAgICAgICBzZWFyY2g6IHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZXhwb3J0cy5TeW1ib2wuZm9yKCdzZWFyY2gnKSwgZmFsc2UsIGZhbHNlKSxcclxuICAgICAgICBzcGVjaWVzOiB1dGlsXzEuZ2V0VmFsdWVEZXNjcmlwdG9yKGV4cG9ydHMuU3ltYm9sLmZvcignc3BlY2llcycpLCBmYWxzZSwgZmFsc2UpLFxyXG4gICAgICAgIHNwbGl0OiB1dGlsXzEuZ2V0VmFsdWVEZXNjcmlwdG9yKGV4cG9ydHMuU3ltYm9sLmZvcignc3BsaXQnKSwgZmFsc2UsIGZhbHNlKSxcclxuICAgICAgICB0b1ByaW1pdGl2ZTogdXRpbF8xLmdldFZhbHVlRGVzY3JpcHRvcihleHBvcnRzLlN5bWJvbC5mb3IoJ3RvUHJpbWl0aXZlJyksIGZhbHNlLCBmYWxzZSksXHJcbiAgICAgICAgdG9TdHJpbmdUYWc6IHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZXhwb3J0cy5TeW1ib2wuZm9yKCd0b1N0cmluZ1RhZycpLCBmYWxzZSwgZmFsc2UpLFxyXG4gICAgICAgIHVuc2NvcGFibGVzOiB1dGlsXzEuZ2V0VmFsdWVEZXNjcmlwdG9yKGV4cG9ydHMuU3ltYm9sLmZvcigndW5zY29wYWJsZXMnKSwgZmFsc2UsIGZhbHNlKVxyXG4gICAgfSk7XHJcbiAgICAvKiBEZWNvcmF0ZSB0aGUgSW50ZXJuYWxTeW1ib2wgb2JqZWN0ICovXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzXzEoSW50ZXJuYWxTeW1ib2xfMS5wcm90b3R5cGUsIHtcclxuICAgICAgICBjb25zdHJ1Y3RvcjogdXRpbF8xLmdldFZhbHVlRGVzY3JpcHRvcihleHBvcnRzLlN5bWJvbCksXHJcbiAgICAgICAgdG9TdHJpbmc6IHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX25hbWVfXztcclxuICAgICAgICB9LCBmYWxzZSwgZmFsc2UpXHJcbiAgICB9KTtcclxuICAgIC8qIERlY29yYXRlIHRoZSBTeW1ib2wucHJvdG90eXBlICovXHJcbiAgICBkZWZpbmVQcm9wZXJ0aWVzXzEoZXhwb3J0cy5TeW1ib2wucHJvdG90eXBlLCB7XHJcbiAgICAgICAgdG9TdHJpbmc6IHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ1N5bWJvbCAoJyArIHZhbGlkYXRlU3ltYm9sXzEodGhpcykuX19kZXNjcmlwdGlvbl9fICsgJyknO1xyXG4gICAgICAgIH0pLFxyXG4gICAgICAgIHZhbHVlT2Y6IHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsaWRhdGVTeW1ib2xfMSh0aGlzKTtcclxuICAgICAgICB9KVxyXG4gICAgfSk7XHJcbiAgICBkZWZpbmVQcm9wZXJ0eV8xKGV4cG9ydHMuU3ltYm9sLnByb3RvdHlwZSwgZXhwb3J0cy5TeW1ib2wudG9QcmltaXRpdmUsIHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVN5bWJvbF8xKHRoaXMpO1xyXG4gICAgfSkpO1xyXG4gICAgZGVmaW5lUHJvcGVydHlfMShleHBvcnRzLlN5bWJvbC5wcm90b3R5cGUsIGV4cG9ydHMuU3ltYm9sLnRvU3RyaW5nVGFnLCB1dGlsXzEuZ2V0VmFsdWVEZXNjcmlwdG9yKCdTeW1ib2wnLCBmYWxzZSwgZmFsc2UsIHRydWUpKTtcclxuICAgIGRlZmluZVByb3BlcnR5XzEoSW50ZXJuYWxTeW1ib2xfMS5wcm90b3R5cGUsIGV4cG9ydHMuU3ltYm9sLnRvUHJpbWl0aXZlLCB1dGlsXzEuZ2V0VmFsdWVEZXNjcmlwdG9yKGV4cG9ydHMuU3ltYm9sLnByb3RvdHlwZVtleHBvcnRzLlN5bWJvbC50b1ByaW1pdGl2ZV0sIGZhbHNlLCBmYWxzZSwgdHJ1ZSkpO1xyXG4gICAgZGVmaW5lUHJvcGVydHlfMShJbnRlcm5hbFN5bWJvbF8xLnByb3RvdHlwZSwgZXhwb3J0cy5TeW1ib2wudG9TdHJpbmdUYWcsIHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZXhwb3J0cy5TeW1ib2wucHJvdG90eXBlW2V4cG9ydHMuU3ltYm9sLnRvU3RyaW5nVGFnXSwgZmFsc2UsIGZhbHNlLCB0cnVlKSk7XHJcbn1cclxuLyoqXHJcbiAqIEEgY3VzdG9tIGd1YXJkIGZ1bmN0aW9uIHRoYXQgZGV0ZXJtaW5lcyBpZiBhbiBvYmplY3QgaXMgYSBzeW1ib2wgb3Igbm90XHJcbiAqIEBwYXJhbSAge2FueX0gICAgICAgdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrIHRvIHNlZSBpZiBpdCBpcyBhIHN5bWJvbCBvciBub3RcclxuICogQHJldHVybiB7aXMgc3ltYm9sfSAgICAgICBSZXR1cm5zIHRydWUgaWYgYSBzeW1ib2wgb3Igbm90IChhbmQgbmFycm93cyB0aGUgdHlwZSBndWFyZClcclxuICovXHJcbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gKHZhbHVlICYmICh0eXBlb2YgdmFsdWUgPT09ICdzeW1ib2wnIHx8IHZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSkgfHwgZmFsc2U7XHJcbn1cclxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xyXG4vKipcclxuICogRmlsbCBhbnkgbWlzc2luZyB3ZWxsIGtub3duIHN5bWJvbHMgaWYgdGhlIG5hdGl2ZSBTeW1ib2wgaXMgbWlzc2luZyB0aGVtXHJcbiAqL1xyXG5bXHJcbiAgICAnaGFzSW5zdGFuY2UnLFxyXG4gICAgJ2lzQ29uY2F0U3ByZWFkYWJsZScsXHJcbiAgICAnaXRlcmF0b3InLFxyXG4gICAgJ3NwZWNpZXMnLFxyXG4gICAgJ3JlcGxhY2UnLFxyXG4gICAgJ3NlYXJjaCcsXHJcbiAgICAnc3BsaXQnLFxyXG4gICAgJ21hdGNoJyxcclxuICAgICd0b1ByaW1pdGl2ZScsXHJcbiAgICAndG9TdHJpbmdUYWcnLFxyXG4gICAgJ3Vuc2NvcGFibGVzJyxcclxuICAgICdvYnNlcnZhYmxlJ1xyXG5dLmZvckVhY2goZnVuY3Rpb24gKHdlbGxLbm93bikge1xyXG4gICAgaWYgKCFleHBvcnRzLlN5bWJvbFt3ZWxsS25vd25dKSB7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuU3ltYm9sLCB3ZWxsS25vd24sIHV0aWxfMS5nZXRWYWx1ZURlc2NyaXB0b3IoZXhwb3J0cy5TeW1ib2wuZm9yKHdlbGxLbm93biksIGZhbHNlLCBmYWxzZSkpO1xyXG4gICAgfVxyXG59KTtcclxuZXhwb3J0cy5kZWZhdWx0ID0gZXhwb3J0cy5TeW1ib2w7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9TeW1ib2wuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vU3ltYm9sLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlwidXNlIHN0cmljdFwiO1xyXG4vLyAhaGFzKCdkb20tcG9pbnRlci1ldmVudHMnKVxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnJlcXVpcmUoXCJwZXBqc1wiKTtcclxuLy8gIWhhcygnZG9tLWludGVyc2VjdGlvbi1vYnNlcnZlcicpXHJcbnJlcXVpcmUoXCJpbnRlcnNlY3Rpb24tb2JzZXJ2ZXJcIik7XHJcbi8vICFoYXMoJ2RvbS13ZWJhbmltYXRpb24nKVxyXG5yZXF1aXJlKFwid2ViLWFuaW1hdGlvbnMtanMvd2ViLWFuaW1hdGlvbnMtbmV4dC1saXRlLm1pblwiKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL2Jyb3dzZXIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZ2xvYmFsT2JqZWN0ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIGdsb2JhbCBzcGVjIGRlZmluZXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QgY2FsbGVkICdnbG9iYWwnXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZ2xvYmFsXHJcbiAgICAgICAgLy8gYGdsb2JhbGAgaXMgYWxzbyBkZWZpbmVkIGluIE5vZGVKU1xyXG4gICAgICAgIHJldHVybiBnbG9iYWw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIHdpbmRvdyBpcyBkZWZpbmVkIGluIGJyb3dzZXJzXHJcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIHNlbGYgaXMgZGVmaW5lZCBpbiBXZWJXb3JrZXJzXHJcbiAgICAgICAgcmV0dXJuIHNlbGY7XHJcbiAgICB9XHJcbn0pKCk7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGdsb2JhbE9iamVjdDtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9nbG9iYWwuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxucmVxdWlyZShcIi4vU3ltYm9sXCIpO1xyXG52YXIgc3RyaW5nXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdcIik7XHJcbnZhciBzdGF0aWNEb25lID0geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH07XHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgX3NoaW1zXyBhbiBpdGVyYXRvciBpbnRlcmZhY2Ugb24gYXJyYXkgbGlrZSBvYmplY3RzLlxyXG4gKi9cclxudmFyIFNoaW1JdGVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFNoaW1JdGVyYXRvcihsaXN0KSB7XHJcbiAgICAgICAgdGhpcy5fbmV4dEluZGV4ID0gLTE7XHJcbiAgICAgICAgaWYgKGlzSXRlcmFibGUobGlzdCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fbmF0aXZlSXRlcmF0b3IgPSBsaXN0W1N5bWJvbC5pdGVyYXRvcl0oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3QgPSBsaXN0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBuZXh0IGl0ZXJhdGlvbiByZXN1bHQgZm9yIHRoZSBJdGVyYXRvclxyXG4gICAgICovXHJcbiAgICBTaGltSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX25hdGl2ZUl0ZXJhdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYXRpdmVJdGVyYXRvci5uZXh0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fbGlzdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3RhdGljRG9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCsrdGhpcy5fbmV4dEluZGV4IDwgdGhpcy5fbGlzdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRoaXMuX2xpc3RbdGhpcy5fbmV4dEluZGV4XVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RhdGljRG9uZTtcclxuICAgIH07XHJcbiAgICBTaGltSXRlcmF0b3IucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFNoaW1JdGVyYXRvcjtcclxufSgpKTtcclxuZXhwb3J0cy5TaGltSXRlcmF0b3IgPSBTaGltSXRlcmF0b3I7XHJcbi8qKlxyXG4gKiBBIHR5cGUgZ3VhcmQgZm9yIGNoZWNraW5nIGlmIHNvbWV0aGluZyBoYXMgYW4gSXRlcmFibGUgaW50ZXJmYWNlXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdG8gdHlwZSBndWFyZCBhZ2FpbnN0XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XHJcbn1cclxuZXhwb3J0cy5pc0l0ZXJhYmxlID0gaXNJdGVyYWJsZTtcclxuLyoqXHJcbiAqIEEgdHlwZSBndWFyZCBmb3IgY2hlY2tpbmcgaWYgc29tZXRoaW5nIGlzIEFycmF5TGlrZVxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHR5cGUgZ3VhcmQgYWdhaW5zdFxyXG4gKi9cclxuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcclxuICAgIHJldHVybiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUubGVuZ3RoID09PSAnbnVtYmVyJztcclxufVxyXG5leHBvcnRzLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBmb3IgYW4gb2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSBpdGVyYWJsZSBUaGUgaXRlcmFibGUgb2JqZWN0IHRvIHJldHVybiB0aGUgaXRlcmF0b3IgZm9yXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXQoaXRlcmFibGUpIHtcclxuICAgIGlmIChpc0l0ZXJhYmxlKGl0ZXJhYmxlKSkge1xyXG4gICAgICAgIHJldHVybiBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc0FycmF5TGlrZShpdGVyYWJsZSkpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNoaW1JdGVyYXRvcihpdGVyYWJsZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5nZXQgPSBnZXQ7XHJcbi8qKlxyXG4gKiBTaGltcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBgZm9yIC4uLiBvZmAgYmxvY2tzXHJcbiAqXHJcbiAqIEBwYXJhbSBpdGVyYWJsZSBUaGUgb2JqZWN0IHRoZSBwcm92aWRlcyBhbiBpbnRlcmF0b3IgaW50ZXJmYWNlXHJcbiAqIEBwYXJhbSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgd2hpY2ggd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2ggaXRlbSBvZiB0aGUgaXRlcmFibGVcclxuICogQHBhcmFtIHRoaXNBcmcgT3B0aW9uYWwgc2NvcGUgdG8gcGFzcyB0aGUgY2FsbGJhY2tcclxuICovXHJcbmZ1bmN0aW9uIGZvck9mKGl0ZXJhYmxlLCBjYWxsYmFjaywgdGhpc0FyZykge1xyXG4gICAgdmFyIGJyb2tlbiA9IGZhbHNlO1xyXG4gICAgZnVuY3Rpb24gZG9CcmVhaygpIHtcclxuICAgICAgICBicm9rZW4gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyogV2UgbmVlZCB0byBoYW5kbGUgaXRlcmF0aW9uIG9mIGRvdWJsZSBieXRlIHN0cmluZ3MgcHJvcGVybHkgKi9cclxuICAgIGlmIChpc0FycmF5TGlrZShpdGVyYWJsZSkgJiYgdHlwZW9mIGl0ZXJhYmxlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZhciBsID0gaXRlcmFibGUubGVuZ3RoO1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgKytpKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGFyID0gaXRlcmFibGVbaV07XHJcbiAgICAgICAgICAgIGlmIChpICsgMSA8IGwpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjb2RlID0gY2hhci5jaGFyQ29kZUF0KDApO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvZGUgPj0gc3RyaW5nXzEuSElHSF9TVVJST0dBVEVfTUlOICYmIGNvZGUgPD0gc3RyaW5nXzEuSElHSF9TVVJST0dBVEVfTUFYKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hhciArPSBpdGVyYWJsZVsrK2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgY2hhciwgaXRlcmFibGUsIGRvQnJlYWspO1xyXG4gICAgICAgICAgICBpZiAoYnJva2VuKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgaXRlcmF0b3IgPSBnZXQoaXRlcmFibGUpO1xyXG4gICAgICAgIGlmIChpdGVyYXRvcikge1xyXG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gaXRlcmF0b3IubmV4dCgpO1xyXG4gICAgICAgICAgICB3aGlsZSAoIXJlc3VsdC5kb25lKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHJlc3VsdC52YWx1ZSwgaXRlcmFibGUsIGRvQnJlYWspO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJyb2tlbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmZvck9mID0gZm9yT2Y7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9pdGVyYXRvci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgZ2xvYmFsXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxcIik7XHJcbnZhciBoYXNfMSA9IHJlcXVpcmUoXCIuL3N1cHBvcnQvaGFzXCIpO1xyXG52YXIgU3ltYm9sXzEgPSByZXF1aXJlKFwiLi9TeW1ib2xcIik7XHJcbmlmIChoYXNfMS5kZWZhdWx0KCdlczYtb2JqZWN0JykpIHtcclxuICAgIHZhciBnbG9iYWxPYmplY3QgPSBnbG9iYWxfMS5kZWZhdWx0Lk9iamVjdDtcclxuICAgIGV4cG9ydHMuYXNzaWduID0gZ2xvYmFsT2JqZWN0LmFzc2lnbjtcclxuICAgIGV4cG9ydHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2xvYmFsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcclxuICAgIGV4cG9ydHMuZ2V0T3duUHJvcGVydHlOYW1lcyA9IGdsb2JhbE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xyXG4gICAgZXhwb3J0cy5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnbG9iYWxPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xyXG4gICAgZXhwb3J0cy5pcyA9IGdsb2JhbE9iamVjdC5pcztcclxuICAgIGV4cG9ydHMua2V5cyA9IGdsb2JhbE9iamVjdC5rZXlzO1xyXG59XHJcbmVsc2Uge1xyXG4gICAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gc3ltYm9sQXdhcmVLZXlzKG8pIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFCb29sZWFuKGtleS5tYXRjaCgvXkBALisvKSk7IH0pO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBzb3VyY2VzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgc291cmNlc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFR5cGVFcnJvciBpZiB1bmRlZmluZWQgb3IgbnVsbFxyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XHJcbiAgICAgICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChuZXh0U291cmNlKSB7XHJcbiAgICAgICAgICAgIGlmIChuZXh0U291cmNlKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBTa2lwIG92ZXIgaWYgdW5kZWZpbmVkIG9yIG51bGxcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMua2V5cyhuZXh0U291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChuZXh0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdG87XHJcbiAgICB9O1xyXG4gICAgZXhwb3J0cy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobywgcHJvcCkge1xyXG4gICAgICAgIGlmIChTeW1ib2xfMS5pc1N5bWJvbChwcm9wKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCBwcm9wKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG8sIHByb3ApO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBleHBvcnRzLmdldE93blByb3BlcnR5TmFtZXMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKG8pIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobykuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICFCb29sZWFuKGtleS5tYXRjaCgvXkBALisvKSk7IH0pO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMuZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG8pIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobylcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBCb29sZWFuKGtleS5tYXRjaCgvXkBALisvKSk7IH0pXHJcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gU3ltYm9sLmZvcihrZXkuc3Vic3RyaW5nKDIpKTsgfSk7XHJcbiAgICB9O1xyXG4gICAgZXhwb3J0cy5pcyA9IGZ1bmN0aW9uIGlzKHZhbHVlMSwgdmFsdWUyKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlMSA9PT0gdmFsdWUyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTEgIT09IDAgfHwgMSAvIHZhbHVlMSA9PT0gMSAvIHZhbHVlMjsgLy8gLTBcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlMSAhPT0gdmFsdWUxICYmIHZhbHVlMiAhPT0gdmFsdWUyOyAvLyBOYU5cclxuICAgIH07XHJcbn1cclxuaWYgKGhhc18xLmRlZmF1bHQoJ2VzMjAxNy1vYmplY3QnKSkge1xyXG4gICAgdmFyIGdsb2JhbE9iamVjdCA9IGdsb2JhbF8xLmRlZmF1bHQuT2JqZWN0O1xyXG4gICAgZXhwb3J0cy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gZ2xvYmFsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM7XHJcbiAgICBleHBvcnRzLmVudHJpZXMgPSBnbG9iYWxPYmplY3QuZW50cmllcztcclxuICAgIGV4cG9ydHMudmFsdWVzID0gZ2xvYmFsT2JqZWN0LnZhbHVlcztcclxufVxyXG5lbHNlIHtcclxuICAgIGV4cG9ydHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMobykge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLmdldE93blByb3BlcnR5TmFtZXMobykucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91cywga2V5KSB7XHJcbiAgICAgICAgICAgIHByZXZpb3VzW2tleV0gPSBleHBvcnRzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvLCBrZXkpO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXM7XHJcbiAgICAgICAgfSwge30pO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMuZW50cmllcyA9IGZ1bmN0aW9uIGVudHJpZXMobykge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLmtleXMobykubWFwKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIFtrZXksIG9ba2V5XV07IH0pO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzKG8pIHtcclxuICAgICAgICByZXR1cm4gZXhwb3J0cy5rZXlzKG8pLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBvW2tleV07IH0pO1xyXG4gICAgfTtcclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vb2JqZWN0LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL29iamVjdC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIGdsb2JhbF8xID0gcmVxdWlyZShcIi4vZ2xvYmFsXCIpO1xyXG52YXIgaGFzXzEgPSByZXF1aXJlKFwiLi9zdXBwb3J0L2hhc1wiKTtcclxudmFyIHV0aWxfMSA9IHJlcXVpcmUoXCIuL3N1cHBvcnQvdXRpbFwiKTtcclxuLyoqXHJcbiAqIFRoZSBtaW5pbXVtIGxvY2F0aW9uIG9mIGhpZ2ggc3Vycm9nYXRlc1xyXG4gKi9cclxuZXhwb3J0cy5ISUdIX1NVUlJPR0FURV9NSU4gPSAweGQ4MDA7XHJcbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBsb2NhdGlvbiBvZiBoaWdoIHN1cnJvZ2F0ZXNcclxuICovXHJcbmV4cG9ydHMuSElHSF9TVVJST0dBVEVfTUFYID0gMHhkYmZmO1xyXG4vKipcclxuICogVGhlIG1pbmltdW0gbG9jYXRpb24gb2YgbG93IHN1cnJvZ2F0ZXNcclxuICovXHJcbmV4cG9ydHMuTE9XX1NVUlJPR0FURV9NSU4gPSAweGRjMDA7XHJcbi8qKlxyXG4gKiBUaGUgbWF4aW11bSBsb2NhdGlvbiBvZiBsb3cgc3Vycm9nYXRlc1xyXG4gKi9cclxuZXhwb3J0cy5MT1dfU1VSUk9HQVRFX01BWCA9IDB4ZGZmZjtcclxuaWYgKGhhc18xLmRlZmF1bHQoJ2VzNi1zdHJpbmcnKSAmJiBoYXNfMS5kZWZhdWx0KCdlczYtc3RyaW5nLXJhdycpKSB7XHJcbiAgICBleHBvcnRzLmZyb21Db2RlUG9pbnQgPSBnbG9iYWxfMS5kZWZhdWx0LlN0cmluZy5mcm9tQ29kZVBvaW50O1xyXG4gICAgZXhwb3J0cy5yYXcgPSBnbG9iYWxfMS5kZWZhdWx0LlN0cmluZy5yYXc7XHJcbiAgICBleHBvcnRzLmNvZGVQb2ludEF0ID0gdXRpbF8xLndyYXBOYXRpdmUoZ2xvYmFsXzEuZGVmYXVsdC5TdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0KTtcclxuICAgIGV4cG9ydHMuZW5kc1dpdGggPSB1dGlsXzEud3JhcE5hdGl2ZShnbG9iYWxfMS5kZWZhdWx0LlN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpO1xyXG4gICAgZXhwb3J0cy5pbmNsdWRlcyA9IHV0aWxfMS53cmFwTmF0aXZlKGdsb2JhbF8xLmRlZmF1bHQuU3RyaW5nLnByb3RvdHlwZS5pbmNsdWRlcyk7XHJcbiAgICBleHBvcnRzLm5vcm1hbGl6ZSA9IHV0aWxfMS53cmFwTmF0aXZlKGdsb2JhbF8xLmRlZmF1bHQuU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemUpO1xyXG4gICAgZXhwb3J0cy5yZXBlYXQgPSB1dGlsXzEud3JhcE5hdGl2ZShnbG9iYWxfMS5kZWZhdWx0LlN0cmluZy5wcm90b3R5cGUucmVwZWF0KTtcclxuICAgIGV4cG9ydHMuc3RhcnRzV2l0aCA9IHV0aWxfMS53cmFwTmF0aXZlKGdsb2JhbF8xLmRlZmF1bHQuU3RyaW5nLnByb3RvdHlwZS5zdGFydHNXaXRoKTtcclxufVxyXG5lbHNlIHtcclxuICAgIC8qKlxyXG4gICAgICogVmFsaWRhdGVzIHRoYXQgdGV4dCBpcyBkZWZpbmVkLCBhbmQgbm9ybWFsaXplcyBwb3NpdGlvbiAoYmFzZWQgb24gdGhlIGdpdmVuIGRlZmF1bHQgaWYgdGhlIGlucHV0IGlzIE5hTikuXHJcbiAgICAgKiBVc2VkIGJ5IHN0YXJ0c1dpdGgsIGluY2x1ZGVzLCBhbmQgZW5kc1dpdGguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybiBOb3JtYWxpemVkIHBvc2l0aW9uLlxyXG4gICAgICovXHJcbiAgICB2YXIgbm9ybWFsaXplU3Vic3RyaW5nQXJnc18xID0gZnVuY3Rpb24gKG5hbWUsIHRleHQsIHNlYXJjaCwgcG9zaXRpb24sIGlzRW5kKSB7XHJcbiAgICAgICAgaWYgKGlzRW5kID09PSB2b2lkIDApIHsgaXNFbmQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmICh0ZXh0ID09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nLicgKyBuYW1lICsgJyByZXF1aXJlcyBhIHZhbGlkIHN0cmluZyB0byBzZWFyY2ggYWdhaW5zdC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGxlbmd0aCA9IHRleHQubGVuZ3RoO1xyXG4gICAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gIT09IHBvc2l0aW9uID8gKGlzRW5kID8gbGVuZ3RoIDogMCkgOiBwb3NpdGlvbjtcclxuICAgICAgICByZXR1cm4gW3RleHQsIFN0cmluZyhzZWFyY2gpLCBNYXRoLm1pbihNYXRoLm1heChwb3NpdGlvbiwgMCksIGxlbmd0aCldO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMuZnJvbUNvZGVQb2ludCA9IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoKSB7XHJcbiAgICAgICAgdmFyIGNvZGVQb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBjb2RlUG9pbnRzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcuZnJvbUNvZGVQb2ludFxyXG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xyXG4gICAgICAgIGlmICghbGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAnJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XHJcbiAgICAgICAgdmFyIE1BWF9TSVpFID0gMHg0MDAwO1xyXG4gICAgICAgIHZhciBjb2RlVW5pdHMgPSBbXTtcclxuICAgICAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IE51bWJlcihhcmd1bWVudHNbaW5kZXhdKTtcclxuICAgICAgICAgICAgLy8gQ29kZSBwb2ludHMgbXVzdCBiZSBmaW5pdGUgaW50ZWdlcnMgd2l0aGluIHRoZSB2YWxpZCByYW5nZVxyXG4gICAgICAgICAgICB2YXIgaXNWYWxpZCA9IGlzRmluaXRlKGNvZGVQb2ludCkgJiYgTWF0aC5mbG9vcihjb2RlUG9pbnQpID09PSBjb2RlUG9pbnQgJiYgY29kZVBvaW50ID49IDAgJiYgY29kZVBvaW50IDw9IDB4MTBmZmZmO1xyXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IFJhbmdlRXJyb3IoJ3N0cmluZy5mcm9tQ29kZVBvaW50OiBJbnZhbGlkIGNvZGUgcG9pbnQgJyArIGNvZGVQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA8PSAweGZmZmYpIHtcclxuICAgICAgICAgICAgICAgIC8vIEJNUCBjb2RlIHBvaW50XHJcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMucHVzaChjb2RlUG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gQXN0cmFsIGNvZGUgcG9pbnQ7IHNwbGl0IGluIHN1cnJvZ2F0ZSBoYWx2ZXNcclxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nI3N1cnJvZ2F0ZS1mb3JtdWxhZVxyXG4gICAgICAgICAgICAgICAgY29kZVBvaW50IC09IDB4MTAwMDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgaGlnaFN1cnJvZ2F0ZSA9IChjb2RlUG9pbnQgPj4gMTApICsgZXhwb3J0cy5ISUdIX1NVUlJPR0FURV9NSU47XHJcbiAgICAgICAgICAgICAgICB2YXIgbG93U3Vycm9nYXRlID0gY29kZVBvaW50ICUgMHg0MDAgKyBleHBvcnRzLkxPV19TVVJST0dBVEVfTUlOO1xyXG4gICAgICAgICAgICAgICAgY29kZVVuaXRzLnB1c2goaGlnaFN1cnJvZ2F0ZSwgbG93U3Vycm9nYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaW5kZXggKyAxID09PSBsZW5ndGggfHwgY29kZVVuaXRzLmxlbmd0aCA+IE1BWF9TSVpFKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNvZGVVbml0cyk7XHJcbiAgICAgICAgICAgICAgICBjb2RlVW5pdHMubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMucmF3ID0gZnVuY3Rpb24gcmF3KGNhbGxTaXRlKSB7XHJcbiAgICAgICAgdmFyIHN1YnN0aXR1dGlvbnMgPSBbXTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICBzdWJzdGl0dXRpb25zW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmF3U3RyaW5ncyA9IGNhbGxTaXRlLnJhdztcclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgdmFyIG51bVN1YnN0aXR1dGlvbnMgPSBzdWJzdGl0dXRpb25zLmxlbmd0aDtcclxuICAgICAgICBpZiAoY2FsbFNpdGUgPT0gbnVsbCB8fCBjYWxsU2l0ZS5yYXcgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcucmF3IHJlcXVpcmVzIGEgdmFsaWQgY2FsbFNpdGUgb2JqZWN0IHdpdGggYSByYXcgdmFsdWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aF8xID0gcmF3U3RyaW5ncy5sZW5ndGg7IGkgPCBsZW5ndGhfMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSByYXdTdHJpbmdzW2ldICsgKGkgPCBudW1TdWJzdGl0dXRpb25zICYmIGkgPCBsZW5ndGhfMSAtIDEgPyBzdWJzdGl0dXRpb25zW2ldIDogJycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMuY29kZVBvaW50QXQgPSBmdW5jdGlvbiBjb2RlUG9pbnRBdCh0ZXh0LCBwb3NpdGlvbikge1xyXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7IHBvc2l0aW9uID0gMDsgfVxyXG4gICAgICAgIC8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWF0aGlhc2J5bmVucy9TdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0XHJcbiAgICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcuY29kZVBvaW50QXQgcmVxdXJpZXMgYSB2YWxpZCBzdHJpbmcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcclxuICAgICAgICBpZiAocG9zaXRpb24gIT09IHBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBsZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR2V0IHRoZSBmaXJzdCBjb2RlIHVuaXRcclxuICAgICAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQocG9zaXRpb24pO1xyXG4gICAgICAgIGlmIChmaXJzdCA+PSBleHBvcnRzLkhJR0hfU1VSUk9HQVRFX01JTiAmJiBmaXJzdCA8PSBleHBvcnRzLkhJR0hfU1VSUk9HQVRFX01BWCAmJiBsZW5ndGggPiBwb3NpdGlvbiArIDEpIHtcclxuICAgICAgICAgICAgLy8gU3RhcnQgb2YgYSBzdXJyb2dhdGUgcGFpciAoaGlnaCBzdXJyb2dhdGUgYW5kIHRoZXJlIGlzIGEgbmV4dCBjb2RlIHVuaXQpOyBjaGVjayBmb3IgbG93IHN1cnJvZ2F0ZVxyXG4gICAgICAgICAgICAvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcclxuICAgICAgICAgICAgdmFyIHNlY29uZCA9IHRleHQuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpO1xyXG4gICAgICAgICAgICBpZiAoc2Vjb25kID49IGV4cG9ydHMuTE9XX1NVUlJPR0FURV9NSU4gJiYgc2Vjb25kIDw9IGV4cG9ydHMuTE9XX1NVUlJPR0FURV9NQVgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoZmlyc3QgLSBleHBvcnRzLkhJR0hfU1VSUk9HQVRFX01JTikgKiAweDQwMCArIHNlY29uZCAtIGV4cG9ydHMuTE9XX1NVUlJPR0FURV9NSU4gKyAweDEwMDAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaXJzdDtcclxuICAgIH07XHJcbiAgICBleHBvcnRzLmVuZHNXaXRoID0gZnVuY3Rpb24gZW5kc1dpdGgodGV4dCwgc2VhcmNoLCBlbmRQb3NpdGlvbikge1xyXG4gICAgICAgIGlmIChlbmRQb3NpdGlvbiA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGVuZFBvc2l0aW9uID0gdGV4dC5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9hID0gdHNsaWJfMS5fX3JlYWQobm9ybWFsaXplU3Vic3RyaW5nQXJnc18xKCdlbmRzV2l0aCcsIHRleHQsIHNlYXJjaCwgZW5kUG9zaXRpb24sIHRydWUpLCAzKSwgdGV4dCA9IF9hWzBdLCBzZWFyY2ggPSBfYVsxXSwgZW5kUG9zaXRpb24gPSBfYVsyXTtcclxuICAgICAgICB2YXIgc3RhcnQgPSBlbmRQb3NpdGlvbiAtIHNlYXJjaC5sZW5ndGg7XHJcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHN0YXJ0LCBlbmRQb3NpdGlvbikgPT09IHNlYXJjaDtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICB9O1xyXG4gICAgZXhwb3J0cy5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzKHRleHQsIHNlYXJjaCwgcG9zaXRpb24pIHtcclxuICAgICAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkgeyBwb3NpdGlvbiA9IDA7IH1cclxuICAgICAgICBfYSA9IHRzbGliXzEuX19yZWFkKG5vcm1hbGl6ZVN1YnN0cmluZ0FyZ3NfMSgnaW5jbHVkZXMnLCB0ZXh0LCBzZWFyY2gsIHBvc2l0aW9uKSwgMyksIHRleHQgPSBfYVswXSwgc2VhcmNoID0gX2FbMV0sIHBvc2l0aW9uID0gX2FbMl07XHJcbiAgICAgICAgcmV0dXJuIHRleHQuaW5kZXhPZihzZWFyY2gsIHBvc2l0aW9uKSAhPT0gLTE7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgfTtcclxuICAgIGV4cG9ydHMucmVwZWF0ID0gZnVuY3Rpb24gcmVwZWF0KHRleHQsIGNvdW50KSB7XHJcbiAgICAgICAgaWYgKGNvdW50ID09PSB2b2lkIDApIHsgY291bnQgPSAwOyB9XHJcbiAgICAgICAgLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL1N0cmluZy5wcm90b3R5cGUucmVwZWF0XHJcbiAgICAgICAgaWYgKHRleHQgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdHJpbmcucmVwZWF0IHJlcXVpcmVzIGEgdmFsaWQgc3RyaW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY291bnQgIT09IGNvdW50KSB7XHJcbiAgICAgICAgICAgIGNvdW50ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvdW50IDwgMCB8fCBjb3VudCA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0cmluZy5yZXBlYXQgcmVxdWlyZXMgYSBub24tbmVnYXRpdmUgZmluaXRlIGNvdW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgcmVzdWx0ID0gJyc7XHJcbiAgICAgICAgd2hpbGUgKGNvdW50KSB7XHJcbiAgICAgICAgICAgIGlmIChjb3VudCAlIDIpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB0ZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb3VudCA+IDEpIHtcclxuICAgICAgICAgICAgICAgIHRleHQgKz0gdGV4dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb3VudCA+Pj0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH07XHJcbiAgICBleHBvcnRzLnN0YXJ0c1dpdGggPSBmdW5jdGlvbiBzdGFydHNXaXRoKHRleHQsIHNlYXJjaCwgcG9zaXRpb24pIHtcclxuICAgICAgICBpZiAocG9zaXRpb24gPT09IHZvaWQgMCkgeyBwb3NpdGlvbiA9IDA7IH1cclxuICAgICAgICBzZWFyY2ggPSBTdHJpbmcoc2VhcmNoKTtcclxuICAgICAgICBfYSA9IHRzbGliXzEuX19yZWFkKG5vcm1hbGl6ZVN1YnN0cmluZ0FyZ3NfMSgnc3RhcnRzV2l0aCcsIHRleHQsIHNlYXJjaCwgcG9zaXRpb24pLCAzKSwgdGV4dCA9IF9hWzBdLCBzZWFyY2ggPSBfYVsxXSwgcG9zaXRpb24gPSBfYVsyXTtcclxuICAgICAgICB2YXIgZW5kID0gcG9zaXRpb24gKyBzZWFyY2gubGVuZ3RoO1xyXG4gICAgICAgIGlmIChlbmQgPiB0ZXh0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZXh0LnNsaWNlKHBvc2l0aW9uLCBlbmQpID09PSBzZWFyY2g7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgfTtcclxufVxyXG5pZiAoaGFzXzEuZGVmYXVsdCgnZXMyMDE3LXN0cmluZycpKSB7XHJcbiAgICBleHBvcnRzLnBhZEVuZCA9IHV0aWxfMS53cmFwTmF0aXZlKGdsb2JhbF8xLmRlZmF1bHQuU3RyaW5nLnByb3RvdHlwZS5wYWRFbmQpO1xyXG4gICAgZXhwb3J0cy5wYWRTdGFydCA9IHV0aWxfMS53cmFwTmF0aXZlKGdsb2JhbF8xLmRlZmF1bHQuU3RyaW5nLnByb3RvdHlwZS5wYWRTdGFydCk7XHJcbn1cclxuZWxzZSB7XHJcbiAgICBleHBvcnRzLnBhZEVuZCA9IGZ1bmN0aW9uIHBhZEVuZCh0ZXh0LCBtYXhMZW5ndGgsIGZpbGxTdHJpbmcpIHtcclxuICAgICAgICBpZiAoZmlsbFN0cmluZyA9PT0gdm9pZCAwKSB7IGZpbGxTdHJpbmcgPSAnICc7IH1cclxuICAgICAgICBpZiAodGV4dCA9PT0gbnVsbCB8fCB0ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyaW5nLnJlcGVhdCByZXF1aXJlcyBhIHZhbGlkIHN0cmluZy4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG1heExlbmd0aCA9PT0gSW5maW5pdHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3N0cmluZy5wYWRFbmQgcmVxdWlyZXMgYSBub24tbmVnYXRpdmUgZmluaXRlIGNvdW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4TGVuZ3RoID09PSBudWxsIHx8IG1heExlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IG1heExlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgbWF4TGVuZ3RoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0clRleHQgPSBTdHJpbmcodGV4dCk7XHJcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBtYXhMZW5ndGggLSBzdHJUZXh0Lmxlbmd0aDtcclxuICAgICAgICBpZiAocGFkZGluZyA+IDApIHtcclxuICAgICAgICAgICAgc3RyVGV4dCArPVxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5yZXBlYXQoZmlsbFN0cmluZywgTWF0aC5mbG9vcihwYWRkaW5nIC8gZmlsbFN0cmluZy5sZW5ndGgpKSArXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsbFN0cmluZy5zbGljZSgwLCBwYWRkaW5nICUgZmlsbFN0cmluZy5sZW5ndGgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3RyVGV4dDtcclxuICAgIH07XHJcbiAgICBleHBvcnRzLnBhZFN0YXJ0ID0gZnVuY3Rpb24gcGFkU3RhcnQodGV4dCwgbWF4TGVuZ3RoLCBmaWxsU3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKGZpbGxTdHJpbmcgPT09IHZvaWQgMCkgeyBmaWxsU3RyaW5nID0gJyAnOyB9XHJcbiAgICAgICAgaWYgKHRleHQgPT09IG51bGwgfHwgdGV4dCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3N0cmluZy5yZXBlYXQgcmVxdWlyZXMgYSB2YWxpZCBzdHJpbmcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtYXhMZW5ndGggPT09IEluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzdHJpbmcucGFkU3RhcnQgcmVxdWlyZXMgYSBub24tbmVnYXRpdmUgZmluaXRlIGNvdW50LicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWF4TGVuZ3RoID09PSBudWxsIHx8IG1heExlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IG1heExlbmd0aCA8IDApIHtcclxuICAgICAgICAgICAgbWF4TGVuZ3RoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0clRleHQgPSBTdHJpbmcodGV4dCk7XHJcbiAgICAgICAgdmFyIHBhZGRpbmcgPSBtYXhMZW5ndGggLSBzdHJUZXh0Lmxlbmd0aDtcclxuICAgICAgICBpZiAocGFkZGluZyA+IDApIHtcclxuICAgICAgICAgICAgc3RyVGV4dCA9XHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLnJlcGVhdChmaWxsU3RyaW5nLCBNYXRoLmZsb29yKHBhZGRpbmcgLyBmaWxsU3RyaW5nLmxlbmd0aCkpICtcclxuICAgICAgICAgICAgICAgICAgICBmaWxsU3RyaW5nLnNsaWNlKDAsIHBhZGRpbmcgJSBmaWxsU3RyaW5nLmxlbmd0aCkgK1xyXG4gICAgICAgICAgICAgICAgICAgIHN0clRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdHJUZXh0O1xyXG4gICAgfTtcclxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vc3RyaW5nLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL3N0cmluZy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIGhhc18xID0gcmVxdWlyZShcIkBkb2pvL2hhcy9oYXNcIik7XHJcbnZhciBnbG9iYWxfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxcIik7XHJcbmV4cG9ydHMuZGVmYXVsdCA9IGhhc18xLmRlZmF1bHQ7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCJAZG9qby9oYXMvaGFzXCIpLCBleHBvcnRzKTtcclxuLyogRUNNQVNjcmlwdCA2IGFuZCA3IEZlYXR1cmVzICovXHJcbi8qIEFycmF5ICovXHJcbmhhc18xLmFkZCgnZXM2LWFycmF5JywgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIChbJ2Zyb20nLCAnb2YnXS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgaW4gZ2xvYmFsXzEuZGVmYXVsdC5BcnJheTsgfSkgJiZcclxuICAgICAgICBbJ2ZpbmRJbmRleCcsICdmaW5kJywgJ2NvcHlXaXRoaW4nXS5ldmVyeShmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBrZXkgaW4gZ2xvYmFsXzEuZGVmYXVsdC5BcnJheS5wcm90b3R5cGU7IH0pKTtcclxufSwgdHJ1ZSk7XHJcbmhhc18xLmFkZCgnZXM2LWFycmF5LWZpbGwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoJ2ZpbGwnIGluIGdsb2JhbF8xLmRlZmF1bHQuQXJyYXkucHJvdG90eXBlKSB7XHJcbiAgICAgICAgLyogU29tZSB2ZXJzaW9ucyBvZiBTYWZhcmkgZG8gbm90IHByb3Blcmx5IGltcGxlbWVudCB0aGlzICovXHJcbiAgICAgICAgcmV0dXJuIFsxXS5maWxsKDksIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSlbMF0gPT09IDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn0sIHRydWUpO1xyXG5oYXNfMS5hZGQoJ2VzNy1hcnJheScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuICdpbmNsdWRlcycgaW4gZ2xvYmFsXzEuZGVmYXVsdC5BcnJheS5wcm90b3R5cGU7IH0sIHRydWUpO1xyXG4vKiBNYXAgKi9cclxuaGFzXzEuYWRkKCdlczYtbWFwJywgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxfMS5kZWZhdWx0Lk1hcCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8qXHJcbiAgICBJRTExIGFuZCBvbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgYXJlIG1pc3NpbmcgY3JpdGljYWwgRVM2IE1hcCBmdW5jdGlvbmFsaXR5XHJcbiAgICBXZSB3cmFwIHRoaXMgaW4gYSB0cnkvY2F0Y2ggYmVjYXVzZSBzb21ldGltZXMgdGhlIE1hcCBjb25zdHJ1Y3RvciBleGlzdHMsIGJ1dCBkb2VzIG5vdFxyXG4gICAgdGFrZSBhcmd1bWVudHMgKGlPUyA4LjQpXHJcbiAgICAgKi9cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB2YXIgbWFwID0gbmV3IGdsb2JhbF8xLmRlZmF1bHQuTWFwKFtbMCwgMV1dKTtcclxuICAgICAgICAgICAgcmV0dXJuIChtYXAuaGFzKDApICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgbWFwLmtleXMgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIGhhc18xLmRlZmF1bHQoJ2VzNi1zeW1ib2wnKSAmJlxyXG4gICAgICAgICAgICAgICAgdHlwZW9mIG1hcC52YWx1ZXMgPT09ICdmdW5jdGlvbicgJiZcclxuICAgICAgICAgICAgICAgIHR5cGVvZiBtYXAuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBub3QgdGVzdGluZyBvbiBpT1MgYXQgdGhlIG1vbWVudCAqL1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59LCB0cnVlKTtcclxuLyogTWF0aCAqL1xyXG5oYXNfMS5hZGQoJ2VzNi1tYXRoJywgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFtcclxuICAgICAgICAnY2x6MzInLFxyXG4gICAgICAgICdzaWduJyxcclxuICAgICAgICAnbG9nMTAnLFxyXG4gICAgICAgICdsb2cyJyxcclxuICAgICAgICAnbG9nMXAnLFxyXG4gICAgICAgICdleHBtMScsXHJcbiAgICAgICAgJ2Nvc2gnLFxyXG4gICAgICAgICdzaW5oJyxcclxuICAgICAgICAndGFuaCcsXHJcbiAgICAgICAgJ2Fjb3NoJyxcclxuICAgICAgICAnYXNpbmgnLFxyXG4gICAgICAgICdhdGFuaCcsXHJcbiAgICAgICAgJ3RydW5jJyxcclxuICAgICAgICAnZnJvdW5kJyxcclxuICAgICAgICAnY2JydCcsXHJcbiAgICAgICAgJ2h5cG90J1xyXG4gICAgXS5ldmVyeShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQuTWF0aFtuYW1lXSA9PT0gJ2Z1bmN0aW9uJzsgfSk7XHJcbn0sIHRydWUpO1xyXG5oYXNfMS5hZGQoJ2VzNi1tYXRoLWltdWwnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoJ2ltdWwnIGluIGdsb2JhbF8xLmRlZmF1bHQuTWF0aCkge1xyXG4gICAgICAgIC8qIFNvbWUgdmVyc2lvbnMgb2YgU2FmYXJpIG9uIGlvcyBkbyBub3QgcHJvcGVybHkgaW1wbGVtZW50IHRoaXMgKi9cclxuICAgICAgICByZXR1cm4gTWF0aC5pbXVsKDB4ZmZmZmZmZmYsIDUpID09PSAtNTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufSwgdHJ1ZSk7XHJcbi8qIE9iamVjdCAqL1xyXG5oYXNfMS5hZGQoJ2VzNi1vYmplY3QnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gKGhhc18xLmRlZmF1bHQoJ2VzNi1zeW1ib2wnKSAmJlxyXG4gICAgICAgIFsnYXNzaWduJywgJ2lzJywgJ2dldE93blByb3BlcnR5U3ltYm9scycsICdzZXRQcm90b3R5cGVPZiddLmV2ZXJ5KGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0eXBlb2YgZ2xvYmFsXzEuZGVmYXVsdC5PYmplY3RbbmFtZV0gPT09ICdmdW5jdGlvbic7IH0pKTtcclxufSwgdHJ1ZSk7XHJcbmhhc18xLmFkZCgnZXMyMDE3LW9iamVjdCcsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBbJ3ZhbHVlcycsICdlbnRyaWVzJywgJ2dldE93blByb3BlcnR5RGVzY3JpcHRvcnMnXS5ldmVyeShmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQuT2JqZWN0W25hbWVdID09PSAnZnVuY3Rpb24nOyB9KTtcclxufSwgdHJ1ZSk7XHJcbi8qIE9ic2VydmFibGUgKi9cclxuaGFzXzEuYWRkKCdlcy1vYnNlcnZhYmxlJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQuT2JzZXJ2YWJsZSAhPT0gJ3VuZGVmaW5lZCc7IH0sIHRydWUpO1xyXG4vKiBQcm9taXNlICovXHJcbmhhc18xLmFkZCgnZXM2LXByb21pc2UnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlb2YgZ2xvYmFsXzEuZGVmYXVsdC5Qcm9taXNlICE9PSAndW5kZWZpbmVkJyAmJiBoYXNfMS5kZWZhdWx0KCdlczYtc3ltYm9sJyk7IH0sIHRydWUpO1xyXG4vKiBTZXQgKi9cclxuaGFzXzEuYWRkKCdlczYtc2V0JywgZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxfMS5kZWZhdWx0LlNldCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8qIElFMTEgYW5kIG9sZGVyIHZlcnNpb25zIG9mIFNhZmFyaSBhcmUgbWlzc2luZyBjcml0aWNhbCBFUzYgU2V0IGZ1bmN0aW9uYWxpdHkgKi9cclxuICAgICAgICB2YXIgc2V0ID0gbmV3IGdsb2JhbF8xLmRlZmF1bHQuU2V0KFsxXSk7XHJcbiAgICAgICAgcmV0dXJuIHNldC5oYXMoMSkgJiYgJ2tleXMnIGluIHNldCAmJiB0eXBlb2Ygc2V0LmtleXMgPT09ICdmdW5jdGlvbicgJiYgaGFzXzEuZGVmYXVsdCgnZXM2LXN5bWJvbCcpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59LCB0cnVlKTtcclxuLyogU3RyaW5nICovXHJcbmhhc18xLmFkZCgnZXM2LXN0cmluZycsIGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAoW1xyXG4gICAgICAgIC8qIHN0YXRpYyBtZXRob2RzICovXHJcbiAgICAgICAgJ2Zyb21Db2RlUG9pbnQnXHJcbiAgICBdLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHR5cGVvZiBnbG9iYWxfMS5kZWZhdWx0LlN0cmluZ1trZXldID09PSAnZnVuY3Rpb24nOyB9KSAmJlxyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgLyogaW5zdGFuY2UgbWV0aG9kcyAqL1xyXG4gICAgICAgICAgICAnY29kZVBvaW50QXQnLFxyXG4gICAgICAgICAgICAnbm9ybWFsaXplJyxcclxuICAgICAgICAgICAgJ3JlcGVhdCcsXHJcbiAgICAgICAgICAgICdzdGFydHNXaXRoJyxcclxuICAgICAgICAgICAgJ2VuZHNXaXRoJyxcclxuICAgICAgICAgICAgJ2luY2x1ZGVzJ1xyXG4gICAgICAgIF0uZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQuU3RyaW5nLnByb3RvdHlwZVtrZXldID09PSAnZnVuY3Rpb24nOyB9KSk7XHJcbn0sIHRydWUpO1xyXG5oYXNfMS5hZGQoJ2VzNi1zdHJpbmctcmF3JywgZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gZ2V0Q2FsbFNpdGUoY2FsbFNpdGUpIHtcclxuICAgICAgICB2YXIgc3Vic3RpdHV0aW9ucyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHN1YnN0aXR1dGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZXN1bHQgPSB0c2xpYl8xLl9fc3ByZWFkKGNhbGxTaXRlKTtcclxuICAgICAgICByZXN1bHQucmF3ID0gY2FsbFNpdGUucmF3O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBpZiAoJ3JhdycgaW4gZ2xvYmFsXzEuZGVmYXVsdC5TdHJpbmcpIHtcclxuICAgICAgICB2YXIgYiA9IDE7XHJcbiAgICAgICAgdmFyIGNhbGxTaXRlID0gZ2V0Q2FsbFNpdGUodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IHRzbGliXzEuX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiYVxcblwiLCBcIlwiXSwgW1wiYVxcXFxuXCIsIFwiXCJdKSksIGIpO1xyXG4gICAgICAgIGNhbGxTaXRlLnJhdyA9IFsnYVxcXFxuJ107XHJcbiAgICAgICAgdmFyIHN1cHBvcnRzVHJ1bmMgPSBnbG9iYWxfMS5kZWZhdWx0LlN0cmluZy5yYXcoY2FsbFNpdGUsIDQyKSA9PT0gJ2E6XFxcXG4nO1xyXG4gICAgICAgIHJldHVybiBzdXBwb3J0c1RydW5jO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59LCB0cnVlKTtcclxuaGFzXzEuYWRkKCdlczIwMTctc3RyaW5nJywgZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIFsncGFkU3RhcnQnLCAncGFkRW5kJ10uZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gdHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQuU3RyaW5nLnByb3RvdHlwZVtrZXldID09PSAnZnVuY3Rpb24nOyB9KTtcclxufSwgdHJ1ZSk7XHJcbi8qIFN5bWJvbCAqL1xyXG5oYXNfMS5hZGQoJ2VzNi1zeW1ib2wnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlb2YgZ2xvYmFsXzEuZGVmYXVsdC5TeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTeW1ib2woKSA9PT0gJ3N5bWJvbCc7IH0sIHRydWUpO1xyXG4vKiBXZWFrTWFwICovXHJcbmhhc18xLmFkZCgnZXM2LXdlYWttYXAnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQuV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAvKiBJRTExIGFuZCBvbGRlciB2ZXJzaW9ucyBvZiBTYWZhcmkgYXJlIG1pc3NpbmcgY3JpdGljYWwgRVM2IE1hcCBmdW5jdGlvbmFsaXR5ICovXHJcbiAgICAgICAgdmFyIGtleTEgPSB7fTtcclxuICAgICAgICB2YXIga2V5MiA9IHt9O1xyXG4gICAgICAgIHZhciBtYXAgPSBuZXcgZ2xvYmFsXzEuZGVmYXVsdC5XZWFrTWFwKFtba2V5MSwgMV1dKTtcclxuICAgICAgICBPYmplY3QuZnJlZXplKGtleTEpO1xyXG4gICAgICAgIHJldHVybiBtYXAuZ2V0KGtleTEpID09PSAxICYmIG1hcC5zZXQoa2V5MiwgMikgPT09IG1hcCAmJiBoYXNfMS5kZWZhdWx0KCdlczYtc3ltYm9sJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn0sIHRydWUpO1xyXG4vKiBNaXNjZWxsYW5lb3VzIGZlYXR1cmVzICovXHJcbmhhc18xLmFkZCgnbWljcm90YXNrcycsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGhhc18xLmRlZmF1bHQoJ2VzNi1wcm9taXNlJykgfHwgaGFzXzEuZGVmYXVsdCgnaG9zdC1ub2RlJykgfHwgaGFzXzEuZGVmYXVsdCgnZG9tLW11dGF0aW9ub2JzZXJ2ZXInKTsgfSwgdHJ1ZSk7XHJcbmhhc18xLmFkZCgncG9zdG1lc3NhZ2UnLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAvLyBJZiB3aW5kb3cgaXMgdW5kZWZpbmVkLCBhbmQgd2UgaGF2ZSBwb3N0TWVzc2FnZSwgaXQgcHJvYmFibHkgbWVhbnMgd2UncmUgaW4gYSB3ZWIgd29ya2VyLiBXZWIgd29ya2VycyBoYXZlXHJcbiAgICAvLyBwb3N0IG1lc3NhZ2UgYnV0IGl0IGRvZXNuJ3Qgd29yayBob3cgd2UgZXhwZWN0IGl0IHRvLCBzbyBpdCdzIGJlc3QganVzdCB0byBwcmV0ZW5kIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAgICByZXR1cm4gdHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQud2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZ2xvYmFsXzEuZGVmYXVsdC5wb3N0TWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJztcclxufSwgdHJ1ZSk7XHJcbmhhc18xLmFkZCgncmFmJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdHlwZW9mIGdsb2JhbF8xLmRlZmF1bHQucmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nOyB9LCB0cnVlKTtcclxuaGFzXzEuYWRkKCdzZXRpbW1lZGlhdGUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0eXBlb2YgZ2xvYmFsXzEuZGVmYXVsdC5zZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnOyB9LCB0cnVlKTtcclxuLyogRE9NIEZlYXR1cmVzICovXHJcbmhhc18xLmFkZCgnZG9tLW11dGF0aW9ub2JzZXJ2ZXInLCBmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoaGFzXzEuZGVmYXVsdCgnaG9zdC1icm93c2VyJykgJiYgQm9vbGVhbihnbG9iYWxfMS5kZWZhdWx0Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsXzEuZGVmYXVsdC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyKSkge1xyXG4gICAgICAgIC8vIElFMTEgaGFzIGFuIHVucmVsaWFibGUgTXV0YXRpb25PYnNlcnZlciBpbXBsZW1lbnRhdGlvbiB3aGVyZSBzZXRQcm9wZXJ0eSgpIGRvZXMgbm90XHJcbiAgICAgICAgLy8gZ2VuZXJhdGUgYSBtdXRhdGlvbiBldmVudCwgb2JzZXJ2ZXJzIGNhbiBjcmFzaCwgYW5kIHRoZSBxdWV1ZSBkb2VzIG5vdCBkcmFpblxyXG4gICAgICAgIC8vIHJlbGlhYmx5LiBUaGUgZm9sbG93aW5nIGZlYXR1cmUgdGVzdCB3YXMgYWRhcHRlZCBmcm9tXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vdDEwa28vNGFjZWI4YzcxNjgxZmRiMjc1ZTMzZWZlNWU1NzZiMTRcclxuICAgICAgICB2YXIgZXhhbXBsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIC8qIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp2YXJpYWJsZS1uYW1lICovXHJcbiAgICAgICAgdmFyIEhvc3RNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsXzEuZGVmYXVsdC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbF8xLmRlZmF1bHQuV2ViS2l0TXV0YXRpb25PYnNlcnZlcjtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgSG9zdE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkgeyB9KTtcclxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGV4YW1wbGUsIHsgYXR0cmlidXRlczogdHJ1ZSB9KTtcclxuICAgICAgICBleGFtcGxlLnN0eWxlLnNldFByb3BlcnR5KCdkaXNwbGF5JywgJ2Jsb2NrJyk7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JzZXJ2ZXIudGFrZVJlY29yZHMoKS5sZW5ndGgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG59LCB0cnVlKTtcclxuaGFzXzEuYWRkKCdkb20td2ViYW5pbWF0aW9uJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gaGFzXzEuZGVmYXVsdCgnaG9zdC1icm93c2VyJykgJiYgZ2xvYmFsXzEuZGVmYXVsdC5BbmltYXRpb24gIT09IHVuZGVmaW5lZCAmJiBnbG9iYWxfMS5kZWZhdWx0LktleWZyYW1lRWZmZWN0ICE9PSB1bmRlZmluZWQ7IH0sIHRydWUpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL3N1cHBvcnQvaGFzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL3N1cHBvcnQvaGFzLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBnbG9iYWxfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxcIik7XHJcbnZhciBoYXNfMSA9IHJlcXVpcmUoXCIuL2hhc1wiKTtcclxuZnVuY3Rpb24gZXhlY3V0ZVRhc2soaXRlbSkge1xyXG4gICAgaWYgKGl0ZW0gJiYgaXRlbS5pc0FjdGl2ZSAmJiBpdGVtLmNhbGxiYWNrKSB7XHJcbiAgICAgICAgaXRlbS5jYWxsYmFjaygpO1xyXG4gICAgfVxyXG59XHJcbmZ1bmN0aW9uIGdldFF1ZXVlSGFuZGxlKGl0ZW0sIGRlc3RydWN0b3IpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICAgICAgICAgIGl0ZW0uaXNBY3RpdmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgaXRlbS5jYWxsYmFjayA9IG51bGw7XHJcbiAgICAgICAgICAgIGlmIChkZXN0cnVjdG9yKSB7XHJcbiAgICAgICAgICAgICAgICBkZXN0cnVjdG9yKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbnZhciBjaGVja01pY3JvVGFza1F1ZXVlO1xyXG52YXIgbWljcm9UYXNrcztcclxuLyoqXHJcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHRoZSBtYWNyb3Rhc2sgcXVldWUuXHJcbiAqXHJcbiAqIEBwYXJhbSBjYWxsYmFjayB0aGUgZnVuY3Rpb24gdG8gYmUgcXVldWVkIGFuZCBsYXRlciBleGVjdXRlZC5cclxuICogQHJldHVybnMgQW4gb2JqZWN0IHdpdGggYSBgZGVzdHJveWAgbWV0aG9kIHRoYXQsIHdoZW4gY2FsbGVkLCBwcmV2ZW50cyB0aGUgcmVnaXN0ZXJlZCBjYWxsYmFjayBmcm9tIGV4ZWN1dGluZy5cclxuICovXHJcbmV4cG9ydHMucXVldWVUYXNrID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBkZXN0cnVjdG9yO1xyXG4gICAgdmFyIGVucXVldWU7XHJcbiAgICAvLyBTaW5jZSB0aGUgSUUgaW1wbGVtZW50YXRpb24gb2YgYHNldEltbWVkaWF0ZWAgaXMgbm90IGZsYXdsZXNzLCB3ZSB3aWxsIHRlc3QgZm9yIGBwb3N0TWVzc2FnZWAgZmlyc3QuXHJcbiAgICBpZiAoaGFzXzEuZGVmYXVsdCgncG9zdG1lc3NhZ2UnKSkge1xyXG4gICAgICAgIHZhciBxdWV1ZV8xID0gW107XHJcbiAgICAgICAgZ2xvYmFsXzEuZGVmYXVsdC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIENvbmZpcm0gdGhhdCB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZCBieSB0aGUgY3VycmVudCB3aW5kb3cgYW5kIGJ5IHRoaXMgcGFydGljdWxhciBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsXzEuZGVmYXVsdCAmJiBldmVudC5kYXRhID09PSAnZG9qby1xdWV1ZS1tZXNzYWdlJykge1xyXG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocXVldWVfMS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRlVGFzayhxdWV1ZV8xLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZW5xdWV1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlXzEucHVzaChpdGVtKTtcclxuICAgICAgICAgICAgZ2xvYmFsXzEuZGVmYXVsdC5wb3N0TWVzc2FnZSgnZG9qby1xdWV1ZS1tZXNzYWdlJywgJyonKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaGFzXzEuZGVmYXVsdCgnc2V0aW1tZWRpYXRlJykpIHtcclxuICAgICAgICBkZXN0cnVjdG9yID0gZ2xvYmFsXzEuZGVmYXVsdC5jbGVhckltbWVkaWF0ZTtcclxuICAgICAgICBlbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShleGVjdXRlVGFzay5iaW5kKG51bGwsIGl0ZW0pKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZGVzdHJ1Y3RvciA9IGdsb2JhbF8xLmRlZmF1bHQuY2xlYXJUaW1lb3V0O1xyXG4gICAgICAgIGVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChleGVjdXRlVGFzay5iaW5kKG51bGwsIGl0ZW0pLCAwKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcXVldWVUYXNrKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBpZCA9IGVucXVldWUoaXRlbSk7XHJcbiAgICAgICAgcmV0dXJuIGdldFF1ZXVlSGFuZGxlKGl0ZW0sIGRlc3RydWN0b3IgJiZcclxuICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgZGVzdHJ1Y3RvcihpZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogVXNlIGFzcGVjdC5iZWZvcmUgd2hlbiBpdCBpcyBhdmFpbGFibGUuXHJcbiAgICByZXR1cm4gaGFzXzEuZGVmYXVsdCgnbWljcm90YXNrcycpXHJcbiAgICAgICAgPyBxdWV1ZVRhc2tcclxuICAgICAgICA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjaGVja01pY3JvVGFza1F1ZXVlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZVRhc2soY2FsbGJhY2spO1xyXG4gICAgICAgIH07XHJcbn0pKCk7XHJcbi8vIFdoZW4gbm8gbWVjaGFuaXNtIGZvciByZWdpc3RlcmluZyBtaWNyb3Rhc2tzIGlzIGV4cG9zZWQgYnkgdGhlIGVudmlyb25tZW50LCBtaWNyb3Rhc2tzIHdpbGxcclxuLy8gYmUgcXVldWVkIGFuZCB0aGVuIGV4ZWN1dGVkIGluIGEgc2luZ2xlIG1hY3JvdGFzayBiZWZvcmUgdGhlIG90aGVyIG1hY3JvdGFza3MgYXJlIGV4ZWN1dGVkLlxyXG5pZiAoIWhhc18xLmRlZmF1bHQoJ21pY3JvdGFza3MnKSkge1xyXG4gICAgdmFyIGlzTWljcm9UYXNrUXVldWVkXzEgPSBmYWxzZTtcclxuICAgIG1pY3JvVGFza3MgPSBbXTtcclxuICAgIGNoZWNrTWljcm9UYXNrUXVldWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFpc01pY3JvVGFza1F1ZXVlZF8xKSB7XHJcbiAgICAgICAgICAgIGlzTWljcm9UYXNrUXVldWVkXzEgPSB0cnVlO1xyXG4gICAgICAgICAgICBleHBvcnRzLnF1ZXVlVGFzayhmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpc01pY3JvVGFza1F1ZXVlZF8xID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBpZiAobWljcm9UYXNrcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IHZvaWQgMDtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGl0ZW0gPSBtaWNyb1Rhc2tzLnNoaWZ0KCkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVUYXNrKGl0ZW0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogU2NoZWR1bGVzIGFuIGFuaW1hdGlvbiB0YXNrIHdpdGggYHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGlmIGl0IGV4aXN0cywgb3Igd2l0aCBgcXVldWVUYXNrYCBvdGhlcndpc2UuXHJcbiAqXHJcbiAqIFNpbmNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSdzIGJlaGF2aW9yIGRvZXMgbm90IG1hdGNoIHRoYXQgZXhwZWN0ZWQgZnJvbSBgcXVldWVUYXNrYCwgaXQgaXMgbm90IHVzZWQgdGhlcmUuXHJcbiAqIEhvd2V2ZXIsIGF0IHRpbWVzIGl0IG1ha2VzIG1vcmUgc2Vuc2UgdG8gZGVsZWdhdGUgdG8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lOyBoZW5jZSB0aGUgZm9sbG93aW5nIG1ldGhvZC5cclxuICpcclxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBiZSBxdWV1ZWQgYW5kIGxhdGVyIGV4ZWN1dGVkLlxyXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhIGBkZXN0cm95YCBtZXRob2QgdGhhdCwgd2hlbiBjYWxsZWQsIHByZXZlbnRzIHRoZSByZWdpc3RlcmVkIGNhbGxiYWNrIGZyb20gZXhlY3V0aW5nLlxyXG4gKi9cclxuZXhwb3J0cy5xdWV1ZUFuaW1hdGlvblRhc2sgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCFoYXNfMS5kZWZhdWx0KCdyYWYnKSkge1xyXG4gICAgICAgIHJldHVybiBleHBvcnRzLnF1ZXVlVGFzaztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHF1ZXVlQW5pbWF0aW9uVGFzayhjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBpdGVtID0ge1xyXG4gICAgICAgICAgICBpc0FjdGl2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgcmFmSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZXhlY3V0ZVRhc2suYmluZChudWxsLCBpdGVtKSk7XHJcbiAgICAgICAgcmV0dXJuIGdldFF1ZXVlSGFuZGxlKGl0ZW0sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLy8gVE9ETzogVXNlIGFzcGVjdC5iZWZvcmUgd2hlbiBpdCBpcyBhdmFpbGFibGUuXHJcbiAgICByZXR1cm4gaGFzXzEuZGVmYXVsdCgnbWljcm90YXNrcycpXHJcbiAgICAgICAgPyBxdWV1ZUFuaW1hdGlvblRhc2tcclxuICAgICAgICA6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjaGVja01pY3JvVGFza1F1ZXVlKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBxdWV1ZUFuaW1hdGlvblRhc2soY2FsbGJhY2spO1xyXG4gICAgICAgIH07XHJcbn0pKCk7XHJcbi8qKlxyXG4gKiBTY2hlZHVsZXMgYSBjYWxsYmFjayB0byB0aGUgbWljcm90YXNrIHF1ZXVlLlxyXG4gKlxyXG4gKiBBbnkgY2FsbGJhY2tzIHJlZ2lzdGVyZWQgd2l0aCBgcXVldWVNaWNyb1Rhc2tgIHdpbGwgYmUgZXhlY3V0ZWQgYmVmb3JlIHRoZSBuZXh0IG1hY3JvdGFzay4gSWYgbm8gbmF0aXZlXHJcbiAqIG1lY2hhbmlzbSBmb3Igc2NoZWR1bGluZyBtYWNyb3Rhc2tzIGlzIGV4cG9zZWQsIHRoZW4gYW55IGNhbGxiYWNrcyB3aWxsIGJlIGZpcmVkIGJlZm9yZSBhbnkgbWFjcm90YXNrXHJcbiAqIHJlZ2lzdGVyZWQgd2l0aCBgcXVldWVUYXNrYCBvciBgcXVldWVBbmltYXRpb25UYXNrYC5cclxuICpcclxuICogQHBhcmFtIGNhbGxiYWNrIHRoZSBmdW5jdGlvbiB0byBiZSBxdWV1ZWQgYW5kIGxhdGVyIGV4ZWN1dGVkLlxyXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhIGBkZXN0cm95YCBtZXRob2QgdGhhdCwgd2hlbiBjYWxsZWQsIHByZXZlbnRzIHRoZSByZWdpc3RlcmVkIGNhbGxiYWNrIGZyb20gZXhlY3V0aW5nLlxyXG4gKi9cclxuZXhwb3J0cy5xdWV1ZU1pY3JvVGFzayA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgZW5xdWV1ZTtcclxuICAgIGlmIChoYXNfMS5kZWZhdWx0KCdob3N0LW5vZGUnKSkge1xyXG4gICAgICAgIGVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBnbG9iYWxfMS5kZWZhdWx0LnByb2Nlc3MubmV4dFRpY2soZXhlY3V0ZVRhc2suYmluZChudWxsLCBpdGVtKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhc18xLmRlZmF1bHQoJ2VzNi1wcm9taXNlJykpIHtcclxuICAgICAgICBlbnF1ZXVlID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICAgICAgZ2xvYmFsXzEuZGVmYXVsdC5Qcm9taXNlLnJlc29sdmUoaXRlbSkudGhlbihleGVjdXRlVGFzayk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGhhc18xLmRlZmF1bHQoJ2RvbS1tdXRhdGlvbm9ic2VydmVyJykpIHtcclxuICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6dmFyaWFibGUtbmFtZSAqL1xyXG4gICAgICAgIHZhciBIb3N0TXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbF8xLmRlZmF1bHQuTXV0YXRpb25PYnNlcnZlciB8fCBnbG9iYWxfMS5kZWZhdWx0LldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgICAgICAgdmFyIG5vZGVfMSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgIHZhciBxdWV1ZV8yID0gW107XHJcbiAgICAgICAgdmFyIG9ic2VydmVyID0gbmV3IEhvc3RNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgd2hpbGUgKHF1ZXVlXzIubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZV8yLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLmlzQWN0aXZlICYmIGl0ZW0uY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpdGVtLmNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGVfMSwgeyBhdHRyaWJ1dGVzOiB0cnVlIH0pO1xyXG4gICAgICAgIGVucXVldWUgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICBxdWV1ZV8yLnB1c2goaXRlbSk7XHJcbiAgICAgICAgICAgIG5vZGVfMS5zZXRBdHRyaWJ1dGUoJ3F1ZXVlU3RhdHVzJywgJzEnKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZW5xdWV1ZSA9IGZ1bmN0aW9uIChpdGVtKSB7XHJcbiAgICAgICAgICAgIGNoZWNrTWljcm9UYXNrUXVldWUoKTtcclxuICAgICAgICAgICAgbWljcm9UYXNrcy5wdXNoKGl0ZW0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB7XHJcbiAgICAgICAgICAgIGlzQWN0aXZlOiB0cnVlLFxyXG4gICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2tcclxuICAgICAgICB9O1xyXG4gICAgICAgIGVucXVldWUoaXRlbSk7XHJcbiAgICAgICAgcmV0dXJuIGdldFF1ZXVlSGFuZGxlKGl0ZW0pO1xyXG4gICAgfTtcclxufSkoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby9zaGltL3N1cHBvcnQvcXVldWUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vc3VwcG9ydC9xdWV1ZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGEgdmFsdWUgcHJvcGVydHkgZGVzY3JpcHRvclxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgICAgICAgIFRoZSB2YWx1ZSB0aGUgcHJvcGVydHkgZGVzY3JpcHRvciBzaG91bGQgYmUgc2V0IHRvXHJcbiAqIEBwYXJhbSBlbnVtZXJhYmxlICAgSWYgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBlbnVtYmVyYWJsZSwgZGVmYXVsdHMgdG8gZmFsc2VcclxuICogQHBhcmFtIHdyaXRhYmxlICAgICBJZiB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHdyaXRhYmxlLCBkZWZhdWx0cyB0byB0cnVlXHJcbiAqIEBwYXJhbSBjb25maWd1cmFibGUgSWYgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25maWd1cmFibGUsIGRlZmF1bHRzIHRvIHRydWVcclxuICogQHJldHVybiAgICAgICAgICAgICBUaGUgcHJvcGVydHkgZGVzY3JpcHRvciBvYmplY3RcclxuICovXHJcbmZ1bmN0aW9uIGdldFZhbHVlRGVzY3JpcHRvcih2YWx1ZSwgZW51bWVyYWJsZSwgd3JpdGFibGUsIGNvbmZpZ3VyYWJsZSkge1xyXG4gICAgaWYgKGVudW1lcmFibGUgPT09IHZvaWQgMCkgeyBlbnVtZXJhYmxlID0gZmFsc2U7IH1cclxuICAgIGlmICh3cml0YWJsZSA9PT0gdm9pZCAwKSB7IHdyaXRhYmxlID0gdHJ1ZTsgfVxyXG4gICAgaWYgKGNvbmZpZ3VyYWJsZSA9PT0gdm9pZCAwKSB7IGNvbmZpZ3VyYWJsZSA9IHRydWU7IH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgIGVudW1lcmFibGU6IGVudW1lcmFibGUsXHJcbiAgICAgICAgd3JpdGFibGU6IHdyaXRhYmxlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogY29uZmlndXJhYmxlXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZ2V0VmFsdWVEZXNjcmlwdG9yID0gZ2V0VmFsdWVEZXNjcmlwdG9yO1xyXG5mdW5jdGlvbiB3cmFwTmF0aXZlKG5hdGl2ZUZ1bmN0aW9uKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIHZhciBhcmdzID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUZ1bmN0aW9uLmFwcGx5KHRhcmdldCwgYXJncyk7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMud3JhcE5hdGl2ZSA9IHdyYXBOYXRpdmU7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vc2hpbS9zdXBwb3J0L3V0aWwuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3NoaW0vc3VwcG9ydC91dGlsLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgaTE4biA9IHJlcXVpcmUoJ0Bkb2pvL2kxOG4vaTE4bicpO1xuY29uc3QgbG9hZENsZHJEYXRhID0gcmVxdWlyZSgnQGRvam8vaTE4bi9jbGRyL2xvYWQnKS5kZWZhdWx0O1xuY29uc3Qgc3lzdGVtTG9jYWxlID0gaTE4bi5zeXN0ZW1Mb2NhbGU7XG5jb25zdCB1c2VyTG9jYWxlID0gc3lzdGVtTG9jYWxlLnJlcGxhY2UoL14oW2Etel17Mn0pLiovaSwgJyQxJyk7XG5jb25zdCBpc1VzZXJMb2NhbGVTdXBwb3J0ZWQgPSB1c2VyTG9jYWxlID09PSBfX2RlZmF1bHRMb2NhbGVfXyB8fFxuICAgIF9fc3VwcG9ydGVkTG9jYWxlc19fLnNvbWUoZnVuY3Rpb24gKGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlID09PSBzeXN0ZW1Mb2NhbGUgfHwgbG9jYWxlID09PSB1c2VyTG9jYWxlO1xuICAgIH0pO1xubG9hZENsZHJEYXRhKF9fY2xkckRhdGFfXyk7XG5pMThuLnN3aXRjaExvY2FsZShpc1VzZXJMb2NhbGVTdXBwb3J0ZWQgPyBzeXN0ZW1Mb2NhbGUgOiBfX2RlZmF1bHRMb2NhbGVfXyk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXRMb2NhbGVEYXRhLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9pMThuLXBsdWdpbi90ZW1wbGF0ZXMvc2V0TG9jYWxlRGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL2kxOG4tcGx1Z2luL3RlbXBsYXRlcy9zZXRMb2NhbGVEYXRhLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG5cdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuXHRyZXF1aXJlLmVuc3VyZShbXSwgZnVuY3Rpb24gKHJlcXVpcmUpIHtcblx0XHRyZXNvbHZlKHJlcXVpcmUoXCIhIS4uL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvc3RhdGljLWJ1aWxkLWxvYWRlci9pbmRleC5qcz8/cmVmLS0zLTAhLi4vbm9kZV9tb2R1bGVzL3VtZC1jb21wYXQtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTMtMSEuLi9ub2RlX21vZHVsZXMvdHMtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTMtMiEuLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL2Nzcy1tb2R1bGUtZHRzLWxvYWRlci9pbmRleC5qcz90eXBlPXRzJmluc3RhbmNlTmFtZT0wX2Rvam8hLi9Gb28udHNcIikpO1xuXHR9LCBcInNyYy9Gb29cIik7XG5cdH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9wcm9taXNlLWxvYWRlcj9nbG9iYWwsc3JjL0ZvbyEuL3NyYy9Gb28udHNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9wcm9taXNlLWxvYWRlci9pbmRleC5qcz9nbG9iYWwsc3JjL0ZvbyEuL3NyYy9Gb28udHNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcblx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG5cdHJlcXVpcmUuZW5zdXJlKFtdLCBmdW5jdGlvbiAocmVxdWlyZSkge1xuXHRcdHJlc29sdmUocmVxdWlyZShcIiEhLi4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9zdGF0aWMtYnVpbGQtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTMtMCEuLi9ub2RlX21vZHVsZXMvdW1kLWNvbXBhdC1sb2FkZXIvaW5kZXguanM/P3JlZi0tMy0xIS4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P3JlZi0tMy0yIS4uL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvY3NzLW1vZHVsZS1kdHMtbG9hZGVyL2luZGV4LmpzP3R5cGU9dHMmaW5zdGFuY2VOYW1lPTBfZG9qbyEuL0Jhci50c1wiKSk7XG5cdH0sIFwid2lkZ2V0c1wiKTtcblx0fSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL3Byb21pc2UtbG9hZGVyP2dsb2JhbCx3aWRnZXRzIS4vc3JjL0Jhci50c1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL3Byb21pc2UtbG9hZGVyL2luZGV4LmpzP2dsb2JhbCx3aWRnZXRzIS4vc3JjL0Jhci50c1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcblx0cmVxdWlyZS5lbnN1cmUoW10sIGZ1bmN0aW9uIChyZXF1aXJlKSB7XG5cdFx0cmVzb2x2ZShyZXF1aXJlKFwiISEuLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL3N0YXRpYy1idWlsZC1sb2FkZXIvaW5kZXguanM/P3JlZi0tMy0wIS4uL25vZGVfbW9kdWxlcy91bWQtY29tcGF0LWxvYWRlci9pbmRleC5qcz8/cmVmLS0zLTEhLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/cmVmLS0zLTIhLi4vbm9kZV9tb2R1bGVzL0Bkb2pvL3dlYnBhY2stY29udHJpYi9jc3MtbW9kdWxlLWR0cy1sb2FkZXIvaW5kZXguanM/dHlwZT10cyZpbnN0YW5jZU5hbWU9MF9kb2pvIS4vQmF6LnRzXCIpKTtcblx0fSwgXCJ3aWRnZXRzXCIpO1xuXHR9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvcHJvbWlzZS1sb2FkZXI/Z2xvYmFsLHdpZGdldHMhLi9zcmMvQmF6LnRzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvcHJvbWlzZS1sb2FkZXIvaW5kZXguanM/Z2xvYmFsLHdpZGdldHMhLi9zcmMvQmF6LnRzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKlxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44XG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgMjAxMyBSYWZhZWwgWGF2aWVyIGRlIFNvdXphXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE2LTExLTI2VDE1OjAzWlxuICovXG4vKiFcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOCAyMDE2LTExLTI2VDE1OjAzWiBNSVQgbGljZW5zZSDCqSBSYWZhZWwgWGF2aWVyXG4gKiBodHRwOi8vZ2l0LmlvL2g0bG1WZ1xuICovXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHQvLyBBTUQuXG5cdFx0ZGVmaW5lKCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIE5vZGUuIENvbW1vbkpTLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEdsb2JhbFxuXHRcdHJvb3QuQ2xkciA9IGZhY3RvcnkoKTtcblx0fVxuXG59KCB0aGlzLCBmdW5jdGlvbigpIHtcblxuXG5cdHZhciBhcnJheUlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggb2JqICkgPT09IFwiW29iamVjdCBBcnJheV1cIjtcblx0fTtcblxuXG5cblxuXHR2YXIgcGF0aE5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCBwYXRoLCBhdHRyaWJ1dGVzICkge1xuXHRcdGlmICggYXJyYXlJc0FycmF5KCBwYXRoICkgKSB7XG5cdFx0XHRwYXRoID0gcGF0aC5qb2luKCBcIi9cIiApO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiBwYXRoICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImludmFsaWQgcGF0aCBcXFwiXCIgKyBwYXRoICsgXCJcXFwiXCIgKTtcblx0XHR9XG5cdFx0Ly8gMTogSWdub3JlIGxlYWRpbmcgc2xhc2ggYC9gXG5cdFx0Ly8gMjogSWdub3JlIGxlYWRpbmcgYGNsZHIvYFxuXHRcdHBhdGggPSBwYXRoXG5cdFx0XHQucmVwbGFjZSggL15cXC8vICwgXCJcIiApIC8qIDEgKi9cblx0XHRcdC5yZXBsYWNlKCAvXmNsZHJcXC8vICwgXCJcIiApOyAvKiAyICovXG5cblx0XHQvLyBSZXBsYWNlIHthdHRyaWJ1dGV9J3Ncblx0XHRwYXRoID0gcGF0aC5yZXBsYWNlKCAve1thLXpBLVpdK30vZywgZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKCAvXnsoW159XSopfSQvLCBcIiQxXCIgKTtcblx0XHRcdHJldHVybiBhdHRyaWJ1dGVzWyBuYW1lIF07XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcGF0aC5zcGxpdCggXCIvXCIgKTtcblx0fTtcblxuXG5cblxuXHR2YXIgYXJyYXlTb21lID0gZnVuY3Rpb24oIGFycmF5LCBjYWxsYmFjayApIHtcblx0XHR2YXIgaSwgbGVuZ3RoO1xuXHRcdGlmICggYXJyYXkuc29tZSApIHtcblx0XHRcdHJldHVybiBhcnJheS5zb21lKCBjYWxsYmFjayApO1xuXHRcdH1cblx0XHRmb3IgKCBpID0gMCwgbGVuZ3RoID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRpZiAoIGNhbGxiYWNrKCBhcnJheVsgaSBdLCBpLCBhcnJheSApICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cblxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gdGhlIG1heGltaXplZCBsYW5ndWFnZSBpZCBhcyBkZWZpbmVkIGluXG5cdCAqIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNMaWtlbHlfU3VidGFnc1xuXHQgKiAxLiBDYW5vbmljYWxpemUuXG5cdCAqIDEuMSBNYWtlIHN1cmUgdGhlIGlucHV0IGxvY2FsZSBpcyBpbiBjYW5vbmljYWwgZm9ybTogdXNlcyB0aGUgcmlnaHRcblx0ICogc2VwYXJhdG9yLCBhbmQgaGFzIHRoZSByaWdodCBjYXNpbmcuXG5cdCAqIFRPRE8gUmlnaHQgY2FzaW5nPyBXaGF0IGRmPyBJdCBzZWVtcyBsYW5ndWFnZXMgYXJlIGxvd2VyY2FzZSwgc2NyaXB0cyBhcmVcblx0ICogQ2FwaXRhbGl6ZWQsIHRlcnJpdG9yeSBpcyB1cHBlcmNhc2UuIEkgYW0gbGVhdmluZyB0aGlzIGFzIGFuIGV4ZXJjaXNlIHRvXG5cdCAqIHRoZSB1c2VyLlxuXHQgKlxuXHQgKiAxLjIgUmVwbGFjZSBhbnkgZGVwcmVjYXRlZCBzdWJ0YWdzIHdpdGggdGhlaXIgY2Fub25pY2FsIHZhbHVlcyB1c2luZyB0aGVcblx0ICogPGFsaWFzPiBkYXRhIGluIHN1cHBsZW1lbnRhbCBtZXRhZGF0YS4gVXNlIHRoZSBmaXJzdCB2YWx1ZSBpbiB0aGVcblx0ICogcmVwbGFjZW1lbnQgbGlzdCwgaWYgaXQgZXhpc3RzLiBMYW5ndWFnZSB0YWcgcmVwbGFjZW1lbnRzIG1heSBoYXZlIG11bHRpcGxlXG5cdCAqIHBhcnRzLCBzdWNoIGFzIFwic2hcIiDinp4gXCJzcl9MYXRuXCIgb3IgbW9cIiDinp4gXCJyb19NRFwiLiBJbiBzdWNoIGEgY2FzZSwgdGhlXG5cdCAqIG9yaWdpbmFsIHNjcmlwdCBhbmQvb3IgcmVnaW9uIGFyZSByZXRhaW5lZCBpZiB0aGVyZSBpcyBvbmUuIFRodXNcblx0ICogXCJzaF9BcmFiX0FRXCIg4p6eIFwic3JfQXJhYl9BUVwiLCBub3QgXCJzcl9MYXRuX0FRXCIuXG5cdCAqIFRPRE8gV2hhdCA8YWxpYXM+IGRhdGE/XG5cdCAqXG5cdCAqIDEuMyBJZiB0aGUgdGFnIGlzIGdyYW5kZmF0aGVyZWQgKHNlZSA8dmFyaWFibGUgaWQ9XCIkZ3JhbmRmYXRoZXJlZFwiXG5cdCAqIHR5cGU9XCJjaG9pY2VcIj4gaW4gdGhlIHN1cHBsZW1lbnRhbCBkYXRhKSwgdGhlbiByZXR1cm4gaXQuXG5cdCAqIFRPRE8gZ3JhbmRmYXRoZXJlZD9cblx0ICpcblx0ICogMS40IFJlbW92ZSB0aGUgc2NyaXB0IGNvZGUgJ1p6enonIGFuZCB0aGUgcmVnaW9uIGNvZGUgJ1paJyBpZiB0aGV5IG9jY3VyLlxuXHQgKiAxLjUgR2V0IHRoZSBjb21wb25lbnRzIG9mIHRoZSBjbGVhbmVkLXVwIHNvdXJjZSB0YWcgKGxhbmd1YWdlcywgc2NyaXB0cyxcblx0ICogYW5kIHJlZ2lvbnMpLCBwbHVzIGFueSB2YXJpYW50cyBhbmQgZXh0ZW5zaW9ucy5cblx0ICogMi4gTG9va3VwLiBMb29rdXAgZWFjaCBvZiB0aGUgZm9sbG93aW5nIGluIG9yZGVyLCBhbmQgc3RvcCBvbiB0aGUgZmlyc3Rcblx0ICogbWF0Y2g6XG5cdCAqIDIuMSBsYW5ndWFnZXNfc2NyaXB0c19yZWdpb25zXG5cdCAqIDIuMiBsYW5ndWFnZXNfcmVnaW9uc1xuXHQgKiAyLjMgbGFuZ3VhZ2VzX3NjcmlwdHNcblx0ICogMi40IGxhbmd1YWdlc1xuXHQgKiAyLjUgdW5kX3NjcmlwdHNcblx0ICogMy4gUmV0dXJuXG5cdCAqIDMuMSBJZiB0aGVyZSBpcyBubyBtYXRjaCwgZWl0aGVyIHJldHVybiBhbiBlcnJvciB2YWx1ZSwgb3IgdGhlIG1hdGNoIGZvclxuXHQgKiBcInVuZFwiIChpbiBBUElzIHdoZXJlIGEgdmFsaWQgbGFuZ3VhZ2UgdGFnIGlzIHJlcXVpcmVkKS5cblx0ICogMy4yIE90aGVyd2lzZSB0aGVyZSBpcyBhIG1hdGNoID0gbGFuZ3VhZ2VtX3NjcmlwdG1fcmVnaW9ubVxuXHQgKiAzLjMgTGV0IHhyID0geHMgaWYgeHMgaXMgbm90IGVtcHR5LCBhbmQgeG0gb3RoZXJ3aXNlLlxuXHQgKiAzLjQgUmV0dXJuIHRoZSBsYW5ndWFnZSB0YWcgY29tcG9zZWQgb2YgbGFuZ3VhZ2VyIF8gc2NyaXB0ciBfIHJlZ2lvbnIgK1xuXHQgKiB2YXJpYW50cyArIGV4dGVuc2lvbnMuXG5cdCAqXG5cdCAqIEBzdWJ0YWdzIFtBcnJheV0gbm9ybWFsaXplZCBsYW5ndWFnZSBpZCBzdWJ0YWdzIHR1cGxlIChzZWUgaW5pdC5qcykuXG5cdCAqL1xuXHR2YXIgY29yZUxpa2VseVN1YnRhZ3MgPSBmdW5jdGlvbiggQ2xkciwgY2xkciwgc3VidGFncywgb3B0aW9ucyApIHtcblx0XHR2YXIgbWF0Y2gsIG1hdGNoRm91bmQsXG5cdFx0XHRsYW5ndWFnZSA9IHN1YnRhZ3NbIDAgXSxcblx0XHRcdHNjcmlwdCA9IHN1YnRhZ3NbIDEgXSxcblx0XHRcdHNlcCA9IENsZHIubG9jYWxlU2VwLFxuXHRcdFx0dGVycml0b3J5ID0gc3VidGFnc1sgMiBdLFxuXHRcdFx0dmFyaWFudHMgPSBzdWJ0YWdzLnNsaWNlKCAzLCA0ICk7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBTa2lwIGlmIChsYW5ndWFnZSwgc2NyaXB0LCB0ZXJyaXRvcnkpIGlzIG5vdCBlbXB0eSBbMy4zXVxuXHRcdGlmICggbGFuZ3VhZ2UgIT09IFwidW5kXCIgJiYgc2NyaXB0ICE9PSBcIlp6enpcIiAmJiB0ZXJyaXRvcnkgIT09IFwiWlpcIiApIHtcblx0XHRcdHJldHVybiBbIGxhbmd1YWdlLCBzY3JpcHQsIHRlcnJpdG9yeSBdLmNvbmNhdCggdmFyaWFudHMgKTtcblx0XHR9XG5cblx0XHQvLyBTa2lwIGlmIG5vIHN1cHBsZW1lbnRhbCBsaWtlbHlTdWJ0YWdzIGRhdGEgaXMgcHJlc2VudFxuXHRcdGlmICggdHlwZW9mIGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC9saWtlbHlTdWJ0YWdzXCIgKSA9PT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBbMl1cblx0XHRtYXRjaEZvdW5kID0gYXJyYXlTb21lKFtcblx0XHRcdFsgbGFuZ3VhZ2UsIHNjcmlwdCwgdGVycml0b3J5IF0sXG5cdFx0XHRbIGxhbmd1YWdlLCB0ZXJyaXRvcnkgXSxcblx0XHRcdFsgbGFuZ3VhZ2UsIHNjcmlwdCBdLFxuXHRcdFx0WyBsYW5ndWFnZSBdLFxuXHRcdFx0WyBcInVuZFwiLCBzY3JpcHQgXVxuXHRcdF0sIGZ1bmN0aW9uKCB0ZXN0ICkge1xuXHRcdFx0cmV0dXJuIG1hdGNoID0gISgvXFxiKFp6enp8WlopXFxiLykudGVzdCggdGVzdC5qb2luKCBzZXAgKSApIC8qIFsxLjRdICovICYmIGNsZHIuZ2V0KCBbIFwic3VwcGxlbWVudGFsL2xpa2VseVN1YnRhZ3NcIiwgdGVzdC5qb2luKCBzZXAgKSBdICk7XG5cdFx0fSk7XG5cblx0XHQvLyBbM11cblx0XHRpZiAoIG1hdGNoRm91bmQgKSB7XG5cdFx0XHQvLyBbMy4yIC4uIDMuNF1cblx0XHRcdG1hdGNoID0gbWF0Y2guc3BsaXQoIHNlcCApO1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bGFuZ3VhZ2UgIT09IFwidW5kXCIgPyBsYW5ndWFnZSA6IG1hdGNoWyAwIF0sXG5cdFx0XHRcdHNjcmlwdCAhPT0gXCJaenp6XCIgPyBzY3JpcHQgOiBtYXRjaFsgMSBdLFxuXHRcdFx0XHR0ZXJyaXRvcnkgIT09IFwiWlpcIiA/IHRlcnJpdG9yeSA6IG1hdGNoWyAyIF1cblx0XHRcdF0uY29uY2F0KCB2YXJpYW50cyApO1xuXHRcdH0gZWxzZSBpZiAoIG9wdGlvbnMuZm9yY2UgKSB7XG5cdFx0XHQvLyBbMy4xLjJdXG5cdFx0XHRyZXR1cm4gY2xkci5nZXQoIFwic3VwcGxlbWVudGFsL2xpa2VseVN1YnRhZ3MvdW5kXCIgKS5zcGxpdCggc2VwICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIFszLjEuMV1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cdH07XG5cblxuXG5cdC8qKlxuXHQgKiBHaXZlbiBhIGxvY2FsZSwgcmVtb3ZlIGFueSBmaWVsZHMgdGhhdCBBZGQgTGlrZWx5IFN1YnRhZ3Mgd291bGQgYWRkLlxuXHQgKiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jTGlrZWx5X1N1YnRhZ3Ncblx0ICogMS4gRmlyc3QgZ2V0IG1heCA9IEFkZExpa2VseVN1YnRhZ3MoaW5wdXRMb2NhbGUpLiBJZiBhbiBlcnJvciBpcyBzaWduYWxlZCxcblx0ICogcmV0dXJuIGl0LlxuXHQgKiAyLiBSZW1vdmUgdGhlIHZhcmlhbnRzIGZyb20gbWF4LlxuXHQgKiAzLiBUaGVuIGZvciB0cmlhbCBpbiB7bGFuZ3VhZ2UsIGxhbmd1YWdlIF8gcmVnaW9uLCBsYW5ndWFnZSBfIHNjcmlwdH0uIElmXG5cdCAqIEFkZExpa2VseVN1YnRhZ3ModHJpYWwpID0gbWF4LCB0aGVuIHJldHVybiB0cmlhbCArIHZhcmlhbnRzLlxuXHQgKiA0LiBJZiB5b3UgZG8gbm90IGdldCBhIG1hdGNoLCByZXR1cm4gbWF4ICsgdmFyaWFudHMuXG5cdCAqIFxuXHQgKiBAbWF4TGFuZ3VhZ2VJZCBbQXJyYXldIG1heExhbmd1YWdlSWQgdHVwbGUgKHNlZSBpbml0LmpzKS5cblx0ICovXG5cdHZhciBjb3JlUmVtb3ZlTGlrZWx5U3VidGFncyA9IGZ1bmN0aW9uKCBDbGRyLCBjbGRyLCBtYXhMYW5ndWFnZUlkICkge1xuXHRcdHZhciBtYXRjaCwgbWF0Y2hGb3VuZCxcblx0XHRcdGxhbmd1YWdlID0gbWF4TGFuZ3VhZ2VJZFsgMCBdLFxuXHRcdFx0c2NyaXB0ID0gbWF4TGFuZ3VhZ2VJZFsgMSBdLFxuXHRcdFx0dGVycml0b3J5ID0gbWF4TGFuZ3VhZ2VJZFsgMiBdLFxuXHRcdFx0dmFyaWFudHMgPSBtYXhMYW5ndWFnZUlkWyAzIF07XG5cblx0XHQvLyBbM11cblx0XHRtYXRjaEZvdW5kID0gYXJyYXlTb21lKFtcblx0XHRcdFsgWyBsYW5ndWFnZSwgXCJaenp6XCIsIFwiWlpcIiBdLCBbIGxhbmd1YWdlIF0gXSxcblx0XHRcdFsgWyBsYW5ndWFnZSwgXCJaenp6XCIsIHRlcnJpdG9yeSBdLCBbIGxhbmd1YWdlLCB0ZXJyaXRvcnkgXSBdLFxuXHRcdFx0WyBbIGxhbmd1YWdlLCBzY3JpcHQsIFwiWlpcIiBdLCBbIGxhbmd1YWdlLCBzY3JpcHQgXSBdXG5cdFx0XSwgZnVuY3Rpb24oIHRlc3QgKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gY29yZUxpa2VseVN1YnRhZ3MoIENsZHIsIGNsZHIsIHRlc3RbIDAgXSApO1xuXHRcdFx0bWF0Y2ggPSB0ZXN0WyAxIF07XG5cdFx0XHRyZXR1cm4gcmVzdWx0ICYmIHJlc3VsdFsgMCBdID09PSBtYXhMYW5ndWFnZUlkWyAwIF0gJiZcblx0XHRcdFx0cmVzdWx0WyAxIF0gPT09IG1heExhbmd1YWdlSWRbIDEgXSAmJlxuXHRcdFx0XHRyZXN1bHRbIDIgXSA9PT0gbWF4TGFuZ3VhZ2VJZFsgMiBdO1xuXHRcdH0pO1xuXG5cdFx0aWYgKCBtYXRjaEZvdW5kICkge1xuXHRcdFx0aWYgKCB2YXJpYW50cyApIHtcblx0XHRcdFx0bWF0Y2gucHVzaCggdmFyaWFudHMgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9XG5cblx0XHQvLyBbNF1cblx0XHRyZXR1cm4gbWF4TGFuZ3VhZ2VJZDtcblx0fTtcblxuXG5cblxuXHQvKipcblx0ICogc3VidGFncyggbG9jYWxlIClcblx0ICpcblx0ICogQGxvY2FsZSBbU3RyaW5nXVxuXHQgKi9cblx0dmFyIGNvcmVTdWJ0YWdzID0gZnVuY3Rpb24oIGxvY2FsZSApIHtcblx0XHR2YXIgYXV4LCB1bmljb2RlTGFuZ3VhZ2VJZCxcblx0XHRcdHN1YnRhZ3MgPSBbXTtcblxuXHRcdGxvY2FsZSA9IGxvY2FsZS5yZXBsYWNlKCAvXy8sIFwiLVwiICk7XG5cblx0XHQvLyBVbmljb2RlIGxvY2FsZSBleHRlbnNpb25zLlxuXHRcdGF1eCA9IGxvY2FsZS5zcGxpdCggXCItdS1cIiApO1xuXHRcdGlmICggYXV4WyAxIF0gKSB7XG5cdFx0XHRhdXhbIDEgXSA9IGF1eFsgMSBdLnNwbGl0KCBcIi10LVwiICk7XG5cdFx0XHRsb2NhbGUgPSBhdXhbIDAgXSArICggYXV4WyAxIF1bIDEgXSA/IFwiLXQtXCIgKyBhdXhbIDEgXVsgMSBdIDogXCJcIik7XG5cdFx0XHRzdWJ0YWdzWyA0IC8qIHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zICovIF0gPSBhdXhbIDEgXVsgMCBdO1xuXHRcdH1cblxuXHRcdC8vIFRPRE8gbm9ybWFsaXplIHRyYW5zZm9ybWVkIGV4dGVuc2lvbnMuIEN1cnJlbnRseSwgc2tpcHBlZC5cblx0XHQvLyBzdWJ0YWdzWyB4IF0gPSBsb2NhbGUuc3BsaXQoIFwiLXQtXCIgKVsgMSBdO1xuXHRcdHVuaWNvZGVMYW5ndWFnZUlkID0gbG9jYWxlLnNwbGl0KCBcIi10LVwiIClbIDAgXTtcblxuXHRcdC8vIHVuaWNvZGVfbGFuZ3VhZ2VfaWQgPSBcInJvb3RcIlxuXHRcdC8vICAgfCB1bmljb2RlX2xhbmd1YWdlX3N1YnRhZyAgICAgICAgIFxuXHRcdC8vICAgICAoc2VwIHVuaWNvZGVfc2NyaXB0X3N1YnRhZyk/IFxuXHRcdC8vICAgICAoc2VwIHVuaWNvZGVfcmVnaW9uX3N1YnRhZyk/XG5cdFx0Ly8gICAgIChzZXAgdW5pY29kZV92YXJpYW50X3N1YnRhZykqIDtcblx0XHQvL1xuXHRcdC8vIEFsdGhvdWdoIHVuaWNvZGVfbGFuZ3VhZ2Vfc3VidGFnID0gYWxwaGF7Miw4fSwgSSdtIHVzaW5nIGFscGhhezIsM30uIEJlY2F1c2UsIHRoZXJlJ3Mgbm8gbGFuZ3VhZ2Ugb24gQ0xEUiBsZW5ndGhpZXIgdGhhbiAzLlxuXHRcdGF1eCA9IHVuaWNvZGVMYW5ndWFnZUlkLm1hdGNoKCAvXigoW2Etel17MiwzfSkoLShbQS1aXVthLXpdezN9KSk/KC0oW0EtWl17Mn18WzAtOV17M30pKT8pKCgtKFthLXpBLVowLTldezUsOH18WzAtOV1bYS16QS1aMC05XXszfSkpKikkfF4ocm9vdCkkLyApO1xuXHRcdGlmICggYXV4ID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIFsgXCJ1bmRcIiwgXCJaenp6XCIsIFwiWlpcIiBdO1xuXHRcdH1cblx0XHRzdWJ0YWdzWyAwIC8qIGxhbmd1YWdlICovIF0gPSBhdXhbIDEwIF0gLyogcm9vdCAqLyB8fCBhdXhbIDIgXSB8fCBcInVuZFwiO1xuXHRcdHN1YnRhZ3NbIDEgLyogc2NyaXB0ICovIF0gPSBhdXhbIDQgXSB8fCBcIlp6enpcIjtcblx0XHRzdWJ0YWdzWyAyIC8qIHRlcnJpdG9yeSAqLyBdID0gYXV4WyA2IF0gfHwgXCJaWlwiO1xuXHRcdGlmICggYXV4WyA3IF0gJiYgYXV4WyA3IF0ubGVuZ3RoICkge1xuXHRcdFx0c3VidGFnc1sgMyAvKiB2YXJpYW50ICovIF0gPSBhdXhbIDcgXS5zbGljZSggMSApIC8qIHJlbW92ZSBsZWFkaW5nIFwiLVwiICovO1xuXHRcdH1cblxuXHRcdC8vIDA6IGxhbmd1YWdlXG5cdFx0Ly8gMTogc2NyaXB0XG5cdFx0Ly8gMjogdGVycml0b3J5IChha2EgcmVnaW9uKVxuXHRcdC8vIDM6IHZhcmlhbnRcblx0XHQvLyA0OiB1bmljb2RlTG9jYWxlRXh0ZW5zaW9uc1xuXHRcdHJldHVybiBzdWJ0YWdzO1xuXHR9O1xuXG5cblxuXG5cdHZhciBhcnJheUZvckVhY2ggPSBmdW5jdGlvbiggYXJyYXksIGNhbGxiYWNrICkge1xuXHRcdHZhciBpLCBsZW5ndGg7XG5cdFx0aWYgKCBhcnJheS5mb3JFYWNoICkge1xuXHRcdFx0cmV0dXJuIGFycmF5LmZvckVhY2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHRcdGZvciAoIGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdGNhbGxiYWNrKCBhcnJheVsgaSBdLCBpLCBhcnJheSApO1xuXHRcdH1cblx0fTtcblxuXG5cblxuXHQvKipcblx0ICogYnVuZGxlTG9va3VwKCBtaW5MYW5ndWFnZUlkIClcblx0ICpcblx0ICogQENsZHIgW0NsZHIgY2xhc3NdXG5cdCAqXG5cdCAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXVxuXHQgKlxuXHQgKiBAbWluTGFuZ3VhZ2VJZCBbU3RyaW5nXSByZXF1ZXN0ZWQgbGFuZ3VhZ2VJZCBhZnRlciBhcHBsaWVkIHJlbW92ZSBsaWtlbHkgc3VidGFncy5cblx0ICovXG5cdHZhciBidW5kbGVMb29rdXAgPSBmdW5jdGlvbiggQ2xkciwgY2xkciwgbWluTGFuZ3VhZ2VJZCApIHtcblx0XHR2YXIgYXZhaWxhYmxlQnVuZGxlTWFwID0gQ2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwLFxuXHRcdFx0YXZhaWxhYmxlQnVuZGxlTWFwUXVldWUgPSBDbGRyLl9hdmFpbGFibGVCdW5kbGVNYXBRdWV1ZTtcblxuXHRcdGlmICggYXZhaWxhYmxlQnVuZGxlTWFwUXVldWUubGVuZ3RoICkge1xuXHRcdFx0YXJyYXlGb3JFYWNoKCBhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZSwgZnVuY3Rpb24oIGJ1bmRsZSApIHtcblx0XHRcdFx0dmFyIGV4aXN0aW5nLCBtYXhCdW5kbGUsIG1pbkJ1bmRsZSwgc3VidGFncztcblx0XHRcdFx0c3VidGFncyA9IGNvcmVTdWJ0YWdzKCBidW5kbGUgKTtcblx0XHRcdFx0bWF4QnVuZGxlID0gY29yZUxpa2VseVN1YnRhZ3MoIENsZHIsIGNsZHIsIHN1YnRhZ3MgKTtcblx0XHRcdFx0bWluQnVuZGxlID0gY29yZVJlbW92ZUxpa2VseVN1YnRhZ3MoIENsZHIsIGNsZHIsIG1heEJ1bmRsZSApO1xuXHRcdFx0XHRtaW5CdW5kbGUgPSBtaW5CdW5kbGUuam9pbiggQ2xkci5sb2NhbGVTZXAgKTtcblx0XHRcdFx0ZXhpc3RpbmcgPSBhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZVsgbWluQnVuZGxlIF07XG5cdFx0XHRcdGlmICggZXhpc3RpbmcgJiYgZXhpc3RpbmcubGVuZ3RoIDwgYnVuZGxlLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0YXZhaWxhYmxlQnVuZGxlTWFwWyBtaW5CdW5kbGUgXSA9IGJ1bmRsZTtcblx0XHRcdH0pO1xuXHRcdFx0Q2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwUXVldWUgPSBbXTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYXZhaWxhYmxlQnVuZGxlTWFwWyBtaW5MYW5ndWFnZUlkIF0gfHwgbnVsbDtcblx0fTtcblxuXG5cblxuXHR2YXIgb2JqZWN0S2V5cyA9IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRyZXN1bHQgPSBbXTtcblxuXHRcdGlmICggT2JqZWN0LmtleXMgKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0LmtleXMoIG9iamVjdCApO1xuXHRcdH1cblxuXHRcdGZvciAoIGkgaW4gb2JqZWN0ICkge1xuXHRcdFx0cmVzdWx0LnB1c2goIGkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cblxuXG5cdHZhciBjcmVhdGVFcnJvciA9IGZ1bmN0aW9uKCBjb2RlLCBhdHRyaWJ1dGVzICkge1xuXHRcdHZhciBlcnJvciwgbWVzc2FnZTtcblxuXHRcdG1lc3NhZ2UgPSBjb2RlICsgKCBhdHRyaWJ1dGVzICYmIEpTT04gPyBcIjogXCIgKyBKU09OLnN0cmluZ2lmeSggYXR0cmlidXRlcyApIDogXCJcIiApO1xuXHRcdGVycm9yID0gbmV3IEVycm9yKCBtZXNzYWdlICk7XG5cdFx0ZXJyb3IuY29kZSA9IGNvZGU7XG5cblx0XHQvLyBleHRlbmQoIGVycm9yLCBhdHRyaWJ1dGVzICk7XG5cdFx0YXJyYXlGb3JFYWNoKCBvYmplY3RLZXlzKCBhdHRyaWJ1dGVzICksIGZ1bmN0aW9uKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHRlcnJvclsgYXR0cmlidXRlIF0gPSBhdHRyaWJ1dGVzWyBhdHRyaWJ1dGUgXTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBlcnJvcjtcblx0fTtcblxuXG5cblxuXHR2YXIgdmFsaWRhdGUgPSBmdW5jdGlvbiggY29kZSwgY2hlY2ssIGF0dHJpYnV0ZXMgKSB7XG5cdFx0aWYgKCAhY2hlY2sgKSB7XG5cdFx0XHR0aHJvdyBjcmVhdGVFcnJvciggY29kZSwgYXR0cmlidXRlcyApO1xuXHRcdH1cblx0fTtcblxuXG5cblxuXHR2YXIgdmFsaWRhdGVQcmVzZW5jZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0XHR2YWxpZGF0ZSggXCJFX01JU1NJTkdfUEFSQU1FVEVSXCIsIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiwge1xuXHRcdFx0bmFtZTogbmFtZVxuXHRcdH0pO1xuXHR9O1xuXG5cblxuXG5cdHZhciB2YWxpZGF0ZVR5cGUgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUsIGNoZWNrLCBleHBlY3RlZCApIHtcblx0XHR2YWxpZGF0ZSggXCJFX0lOVkFMSURfUEFSX1RZUEVcIiwgY2hlY2ssIHtcblx0XHRcdGV4cGVjdGVkOiBleHBlY3RlZCxcblx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHR2YWx1ZTogdmFsdWVcblx0XHR9KTtcblx0fTtcblxuXG5cblxuXHR2YXIgdmFsaWRhdGVUeXBlUGF0aCA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0XHR2YWxpZGF0ZVR5cGUoIHZhbHVlLCBuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgYXJyYXlJc0FycmF5KCB2YWx1ZSApLCBcIlN0cmluZyBvciBBcnJheVwiICk7XG5cdH07XG5cblxuXG5cblx0LyoqXG5cdCAqIEZ1bmN0aW9uIGluc3BpcmVkIGJ5IGpRdWVyeSBDb3JlLCBidXQgcmVkdWNlZCB0byBvdXIgdXNlIGNhc2UuXG5cdCAqL1xuXHR2YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPT0gbnVsbCAmJiBcIlwiICsgb2JqID09PSBcIltvYmplY3QgT2JqZWN0XVwiO1xuXHR9O1xuXG5cblxuXG5cdHZhciB2YWxpZGF0ZVR5cGVQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0XHR2YWxpZGF0ZVR5cGUoIHZhbHVlLCBuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgaXNQbGFpbk9iamVjdCggdmFsdWUgKSwgXCJQbGFpbiBPYmplY3RcIiApO1xuXHR9O1xuXG5cblxuXG5cdHZhciB2YWxpZGF0ZVR5cGVTdHJpbmcgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdFx0dmFsaWRhdGVUeXBlKCB2YWx1ZSwgbmFtZSwgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiLCBcImEgc3RyaW5nXCIgKTtcblx0fTtcblxuXG5cblxuXHQvLyBAcGF0aDogbm9ybWFsaXplZCBwYXRoXG5cdHZhciByZXNvdXJjZUdldCA9IGZ1bmN0aW9uKCBkYXRhLCBwYXRoICkge1xuXHRcdHZhciBpLFxuXHRcdFx0bm9kZSA9IGRhdGEsXG5cdFx0XHRsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuZ3RoIC0gMTsgaSsrICkge1xuXHRcdFx0bm9kZSA9IG5vZGVbIHBhdGhbIGkgXSBdO1xuXHRcdFx0aWYgKCAhbm9kZSApIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGVbIHBhdGhbIGkgXSBdO1xuXHR9O1xuXG5cblxuXG5cdC8qKlxuXHQgKiBzZXRBdmFpbGFibGVCdW5kbGVzKCBDbGRyLCBqc29uIClcblx0ICpcblx0ICogQENsZHIgW0NsZHIgY2xhc3NdXG5cdCAqXG5cdCAqIEBqc29uIHJlc29sdmVkL3VucmVzb2x2ZWQgY2xkciBkYXRhLlxuXHQgKlxuXHQgKiBTZXQgYXZhaWxhYmxlIGJ1bmRsZXMgcXVldWUgYmFzZWQgb24gcGFzc2VkIGpzb24gQ0xEUiBkYXRhLiBDb25zaWRlcnMgYSBidW5kbGUgYXMgYW55IFN0cmluZyBhdCAvbWFpbi97YnVuZGxlfS5cblx0ICovXG5cdHZhciBjb3JlU2V0QXZhaWxhYmxlQnVuZGxlcyA9IGZ1bmN0aW9uKCBDbGRyLCBqc29uICkge1xuXHRcdHZhciBidW5kbGUsXG5cdFx0XHRhdmFpbGFibGVCdW5kbGVNYXBRdWV1ZSA9IENsZHIuX2F2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlLFxuXHRcdFx0bWFpbiA9IHJlc291cmNlR2V0KCBqc29uLCBbIFwibWFpblwiIF0gKTtcblxuXHRcdGlmICggbWFpbiApIHtcblx0XHRcdGZvciAoIGJ1bmRsZSBpbiBtYWluICkge1xuXHRcdFx0XHRpZiAoIG1haW4uaGFzT3duUHJvcGVydHkoIGJ1bmRsZSApICYmIGJ1bmRsZSAhPT0gXCJyb290XCIgJiZcblx0XHRcdFx0XHRcdFx0YXZhaWxhYmxlQnVuZGxlTWFwUXVldWUuaW5kZXhPZiggYnVuZGxlICkgPT09IC0xICkge1xuXHRcdFx0XHRcdGF2YWlsYWJsZUJ1bmRsZU1hcFF1ZXVlLnB1c2goIGJ1bmRsZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cblxuXHR2YXIgYWx3YXlzQXJyYXkgPSBmdW5jdGlvbiggc29tZXRoaW5nT3JBcnJheSApIHtcblx0XHRyZXR1cm4gYXJyYXlJc0FycmF5KCBzb21ldGhpbmdPckFycmF5ICkgPyAgc29tZXRoaW5nT3JBcnJheSA6IFsgc29tZXRoaW5nT3JBcnJheSBdO1xuXHR9O1xuXG5cblx0dmFyIGpzb25NZXJnZSA9IChmdW5jdGlvbigpIHtcblxuXHQvLyBSZXR1cm5zIG5ldyBkZWVwbHkgbWVyZ2VkIEpTT04uXG5cdC8vXG5cdC8vIEVnLlxuXHQvLyBtZXJnZSggeyBhOiB7IGI6IDEsIGM6IDIgfSB9LCB7IGE6IHsgYjogMywgZDogNCB9IH0gKVxuXHQvLyAtPiB7IGE6IHsgYjogMywgYzogMiwgZDogNCB9IH1cblx0Ly9cblx0Ly8gQGFyZ3VtZW50cyBKU09OJ3Ncblx0Ly8gXG5cdHZhciBtZXJnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXN0aW5hdGlvbiA9IHt9LFxuXHRcdFx0c291cmNlcyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuXHRcdGFycmF5Rm9yRWFjaCggc291cmNlcywgZnVuY3Rpb24oIHNvdXJjZSApIHtcblx0XHRcdHZhciBwcm9wO1xuXHRcdFx0Zm9yICggcHJvcCBpbiBzb3VyY2UgKSB7XG5cdFx0XHRcdGlmICggcHJvcCBpbiBkZXN0aW5hdGlvbiAmJiB0eXBlb2YgZGVzdGluYXRpb25bIHByb3AgXSA9PT0gXCJvYmplY3RcIiAmJiAhYXJyYXlJc0FycmF5KCBkZXN0aW5hdGlvblsgcHJvcCBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBNZXJnZSBPYmplY3RzXG5cdFx0XHRcdFx0ZGVzdGluYXRpb25bIHByb3AgXSA9IG1lcmdlKCBkZXN0aW5hdGlvblsgcHJvcCBdLCBzb3VyY2VbIHByb3AgXSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBTZXQgbmV3IHZhbHVlc1xuXHRcdFx0XHRcdGRlc3RpbmF0aW9uWyBwcm9wIF0gPSBzb3VyY2VbIHByb3AgXTtcblxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGRlc3RpbmF0aW9uO1xuXHR9O1xuXG5cdHJldHVybiBtZXJnZTtcblxufSgpKTtcblxuXG5cdC8qKlxuXHQgKiBsb2FkKCBDbGRyLCBzb3VyY2UsIGpzb25zIClcblx0ICpcblx0ICogQENsZHIgW0NsZHIgY2xhc3NdXG5cdCAqXG5cdCAqIEBzb3VyY2UgW09iamVjdF1cblx0ICpcblx0ICogQGpzb25zIFthcmd1bWVudHNdXG5cdCAqL1xuXHR2YXIgY29yZUxvYWQgPSBmdW5jdGlvbiggQ2xkciwgc291cmNlLCBqc29ucyApIHtcblx0XHR2YXIgaSwgaiwganNvbjtcblxuXHRcdHZhbGlkYXRlUHJlc2VuY2UoIGpzb25zWyAwIF0sIFwianNvblwiICk7XG5cblx0XHQvLyBTdXBwb3J0IGFyYml0cmFyeSBwYXJhbWV0ZXJzLCBlLmcuLCBgQ2xkci5sb2FkKHsuLi59LCB7Li4ufSlgLlxuXHRcdGZvciAoIGkgPSAwOyBpIDwganNvbnMubGVuZ3RoOyBpKysgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgcGFyYW1ldGVycywgZS5nLiwgYENsZHIubG9hZChbey4uLn0sIHsuLi59XSlgLlxuXHRcdFx0anNvbiA9IGFsd2F5c0FycmF5KCBqc29uc1sgaSBdICk7XG5cblx0XHRcdGZvciAoIGogPSAwOyBqIDwganNvbi5sZW5ndGg7IGorKyApIHtcblx0XHRcdFx0dmFsaWRhdGVUeXBlUGxhaW5PYmplY3QoIGpzb25bIGogXSwgXCJqc29uXCIgKTtcblx0XHRcdFx0c291cmNlID0ganNvbk1lcmdlKCBzb3VyY2UsIGpzb25bIGogXSApO1xuXHRcdFx0XHRjb3JlU2V0QXZhaWxhYmxlQnVuZGxlcyggQ2xkciwganNvblsgaiBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNvdXJjZTtcblx0fTtcblxuXG5cblx0dmFyIGl0ZW1HZXRSZXNvbHZlZCA9IGZ1bmN0aW9uKCBDbGRyLCBwYXRoLCBhdHRyaWJ1dGVzICkge1xuXHRcdC8vIFJlc29sdmUgcGF0aFxuXHRcdHZhciBub3JtYWxpemVkUGF0aCA9IHBhdGhOb3JtYWxpemUoIHBhdGgsIGF0dHJpYnV0ZXMgKTtcblxuXHRcdHJldHVybiByZXNvdXJjZUdldCggQ2xkci5fcmVzb2x2ZWQsIG5vcm1hbGl6ZWRQYXRoICk7XG5cdH07XG5cblxuXG5cblx0LyoqXG5cdCAqIG5ldyBDbGRyKClcblx0ICovXG5cdHZhciBDbGRyID0gZnVuY3Rpb24oIGxvY2FsZSApIHtcblx0XHR0aGlzLmluaXQoIGxvY2FsZSApO1xuXHR9O1xuXG5cdC8vIEJ1aWxkIG9wdGltaXphdGlvbiBoYWNrIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGZ1bmN0aW9ucyBhY3Jvc3MgbW9kdWxlcy5cblx0Q2xkci5fYWx3YXlzQXJyYXkgPSBhbHdheXNBcnJheTtcblx0Q2xkci5fY29yZUxvYWQgPSBjb3JlTG9hZDtcblx0Q2xkci5fY3JlYXRlRXJyb3IgPSBjcmVhdGVFcnJvcjtcblx0Q2xkci5faXRlbUdldFJlc29sdmVkID0gaXRlbUdldFJlc29sdmVkO1xuXHRDbGRyLl9qc29uTWVyZ2UgPSBqc29uTWVyZ2U7XG5cdENsZHIuX3BhdGhOb3JtYWxpemUgPSBwYXRoTm9ybWFsaXplO1xuXHRDbGRyLl9yZXNvdXJjZUdldCA9IHJlc291cmNlR2V0O1xuXHRDbGRyLl92YWxpZGF0ZVByZXNlbmNlID0gdmFsaWRhdGVQcmVzZW5jZTtcblx0Q2xkci5fdmFsaWRhdGVUeXBlID0gdmFsaWRhdGVUeXBlO1xuXHRDbGRyLl92YWxpZGF0ZVR5cGVQYXRoID0gdmFsaWRhdGVUeXBlUGF0aDtcblx0Q2xkci5fdmFsaWRhdGVUeXBlUGxhaW5PYmplY3QgPSB2YWxpZGF0ZVR5cGVQbGFpbk9iamVjdDtcblxuXHRDbGRyLl9hdmFpbGFibGVCdW5kbGVNYXAgPSB7fTtcblx0Q2xkci5fYXZhaWxhYmxlQnVuZGxlTWFwUXVldWUgPSBbXTtcblx0Q2xkci5fcmVzb2x2ZWQgPSB7fTtcblxuXHQvLyBBbGxvdyB1c2VyIHRvIG92ZXJyaWRlIGxvY2FsZSBzZXBhcmF0b3IgXCItXCIgKGRlZmF1bHQpIHwgXCJfXCIuIEFjY29yZGluZyB0byBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jVW5pY29kZV9sYW5ndWFnZV9pZGVudGlmaWVyLCBib3RoIFwiLVwiIGFuZCBcIl9cIiBhcmUgdmFsaWQgbG9jYWxlIHNlcGFyYXRvcnMgKGVnLiBcImVuX0dCXCIsIFwiZW4tR0JcIikuIEFjY29yZGluZyB0byBodHRwOi8vdW5pY29kZS5vcmcvY2xkci90cmFjL3RpY2tldC82Nzg2IGl0cyB1c2FnZSBtdXN0IGJlIGNvbnNpc3RlbnQgdGhyb3VnaG91dCB0aGUgZGF0YSBzZXQuXG5cdENsZHIubG9jYWxlU2VwID0gXCItXCI7XG5cblx0LyoqXG5cdCAqIENsZHIubG9hZCgganNvbiBbLCBqc29uLCAuLi5dIClcblx0ICpcblx0ICogQGpzb24gW0pTT05dIENMRFIgZGF0YSBvciBbQXJyYXldIEFycmF5IG9mIEBqc29uJ3MuXG5cdCAqXG5cdCAqIExvYWQgcmVzb2x2ZWQgY2xkciBkYXRhLlxuXHQgKi9cblx0Q2xkci5sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0Q2xkci5fcmVzb2x2ZWQgPSBjb3JlTG9hZCggQ2xkciwgQ2xkci5fcmVzb2x2ZWQsIGFyZ3VtZW50cyApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAuaW5pdCgpIGF1dG9tYXRpY2FsbHkgcnVuIG9uIGluc3RhbnRpYXRpb24vY29uc3RydWN0aW9uLlxuXHQgKi9cblx0Q2xkci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCBsb2NhbGUgKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZXMsIGxhbmd1YWdlLCBtYXhMYW5ndWFnZUlkLCBtaW5MYW5ndWFnZUlkLCBzY3JpcHQsIHN1YnRhZ3MsIHRlcnJpdG9yeSwgdW5pY29kZUxvY2FsZUV4dGVuc2lvbnMsIHZhcmlhbnQsXG5cdFx0XHRzZXAgPSBDbGRyLmxvY2FsZVNlcCxcblx0XHRcdHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zUmF3ID0gXCJcIjtcblxuXHRcdHZhbGlkYXRlUHJlc2VuY2UoIGxvY2FsZSwgXCJsb2NhbGVcIiApO1xuXHRcdHZhbGlkYXRlVHlwZVN0cmluZyggbG9jYWxlLCBcImxvY2FsZVwiICk7XG5cblx0XHRzdWJ0YWdzID0gY29yZVN1YnRhZ3MoIGxvY2FsZSApO1xuXG5cdFx0aWYgKCBzdWJ0YWdzLmxlbmd0aCA9PT0gNSApIHtcblx0XHRcdHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zID0gc3VidGFncy5wb3AoKTtcblx0XHRcdHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zUmF3ID0gc2VwICsgXCJ1XCIgKyBzZXAgKyB1bmljb2RlTG9jYWxlRXh0ZW5zaW9ucztcblx0XHRcdC8vIFJlbW92ZSB0cmFpbGluZyBudWxsIHdoZW4gdGhlcmUgaXMgdW5pY29kZUxvY2FsZUV4dGVuc2lvbnMgYnV0IG5vIHZhcmlhbnRzLlxuXHRcdFx0aWYgKCAhc3VidGFnc1sgMyBdICkge1xuXHRcdFx0XHRzdWJ0YWdzLnBvcCgpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXJpYW50ID0gc3VidGFnc1sgMyBdO1xuXG5cdFx0Ly8gTm9ybWFsaXplIGxvY2FsZSBjb2RlLlxuXHRcdC8vIEdldCAob3IgZGVkdWNlKSB0aGUgXCJ0cmlwbGUgc3VidGFnc1wiOiBsYW5ndWFnZSwgdGVycml0b3J5IChhbHNvIGFsaWFzZWQgYXMgcmVnaW9uKSwgYW5kIHNjcmlwdCBzdWJ0YWdzLlxuXHRcdC8vIEdldCB0aGUgdmFyaWFudCBzdWJ0YWdzIChjYWxlbmRhciwgY29sbGF0aW9uLCBjdXJyZW5jeSwgZXRjKS5cblx0XHQvLyByZWZzOlxuXHRcdC8vIC0gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvI0ZpZWxkX0RlZmluaXRpb25zXG5cdFx0Ly8gLSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS8jTGFuZ3VhZ2VfYW5kX0xvY2FsZV9JRHNcblx0XHQvLyAtIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyNVbmljb2RlX2xvY2FsZV9pZGVudGlmaWVyXG5cblx0XHQvLyBXaGVuIGEgbG9jYWxlIGlkIGRvZXMgbm90IHNwZWNpZnkgYSBsYW5ndWFnZSwgb3IgdGVycml0b3J5IChyZWdpb24pLCBvciBzY3JpcHQsIHRoZXkgYXJlIG9idGFpbmVkIGJ5IExpa2VseSBTdWJ0YWdzLlxuXHRcdG1heExhbmd1YWdlSWQgPSBjb3JlTGlrZWx5U3VidGFncyggQ2xkciwgdGhpcywgc3VidGFncywgeyBmb3JjZTogdHJ1ZSB9ICkgfHwgc3VidGFncztcblx0XHRsYW5ndWFnZSA9IG1heExhbmd1YWdlSWRbIDAgXTtcblx0XHRzY3JpcHQgPSBtYXhMYW5ndWFnZUlkWyAxIF07XG5cdFx0dGVycml0b3J5ID0gbWF4TGFuZ3VhZ2VJZFsgMiBdO1xuXG5cdFx0bWluTGFuZ3VhZ2VJZCA9IGNvcmVSZW1vdmVMaWtlbHlTdWJ0YWdzKCBDbGRyLCB0aGlzLCBtYXhMYW5ndWFnZUlkICkuam9pbiggc2VwICk7XG5cblx0XHQvLyBTZXQgYXR0cmlidXRlc1xuXHRcdHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgPSB7XG5cdFx0XHRidW5kbGU6IGJ1bmRsZUxvb2t1cCggQ2xkciwgdGhpcywgbWluTGFuZ3VhZ2VJZCApLFxuXG5cdFx0XHQvLyBVbmljb2RlIExhbmd1YWdlIElkXG5cdFx0XHRtaW5MYW5ndWFnZUlkOiBtaW5MYW5ndWFnZUlkICsgdW5pY29kZUxvY2FsZUV4dGVuc2lvbnNSYXcsXG5cdFx0XHRtYXhMYW5ndWFnZUlkOiBtYXhMYW5ndWFnZUlkLmpvaW4oIHNlcCApICsgdW5pY29kZUxvY2FsZUV4dGVuc2lvbnNSYXcsXG5cblx0XHRcdC8vIFVuaWNvZGUgTGFuZ3VhZ2UgSWQgU3VidGFic1xuXHRcdFx0bGFuZ3VhZ2U6IGxhbmd1YWdlLFxuXHRcdFx0c2NyaXB0OiBzY3JpcHQsXG5cdFx0XHR0ZXJyaXRvcnk6IHRlcnJpdG9yeSxcblx0XHRcdHJlZ2lvbjogdGVycml0b3J5LCAvKiBhbGlhcyAqL1xuXHRcdFx0dmFyaWFudDogdmFyaWFudFxuXHRcdH07XG5cblx0XHQvLyBVbmljb2RlIGxvY2FsZSBleHRlbnNpb25zLlxuXHRcdHVuaWNvZGVMb2NhbGVFeHRlbnNpb25zICYmICggXCItXCIgKyB1bmljb2RlTG9jYWxlRXh0ZW5zaW9ucyApLnJlcGxhY2UoIC8tW2Etel17Myw4fXwoLVthLXpdezJ9KS0oW2Etel17Myw4fSkvZywgZnVuY3Rpb24oIGF0dHJpYnV0ZSwga2V5LCB0eXBlICkge1xuXG5cdFx0XHRpZiAoIGtleSApIHtcblxuXHRcdFx0XHQvLyBFeHRlbnNpb24gaXMgaW4gdGhlIGBrZXl3b3JkYCBmb3JtLlxuXHRcdFx0XHRhdHRyaWJ1dGVzWyBcInVcIiArIGtleSBdID0gdHlwZTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0ZW5zaW9uIGlzIGluIHRoZSBgYXR0cmlidXRlYCBmb3JtLlxuXHRcdFx0XHRhdHRyaWJ1dGVzWyBcInVcIiArIGF0dHJpYnV0ZSBdID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHRoaXMubG9jYWxlID0gbG9jYWxlO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiAuZ2V0KClcblx0ICovXG5cdENsZHIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCBwYXRoICkge1xuXG5cdFx0dmFsaWRhdGVQcmVzZW5jZSggcGF0aCwgXCJwYXRoXCIgKTtcblx0XHR2YWxpZGF0ZVR5cGVQYXRoKCBwYXRoLCBcInBhdGhcIiApO1xuXG5cdFx0cmV0dXJuIGl0ZW1HZXRSZXNvbHZlZCggQ2xkciwgcGF0aCwgdGhpcy5hdHRyaWJ1dGVzICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIC5tYWluKClcblx0ICovXG5cdENsZHIucHJvdG90eXBlLm1haW4gPSBmdW5jdGlvbiggcGF0aCApIHtcblx0XHR2YWxpZGF0ZVByZXNlbmNlKCBwYXRoLCBcInBhdGhcIiApO1xuXHRcdHZhbGlkYXRlVHlwZVBhdGgoIHBhdGgsIFwicGF0aFwiICk7XG5cblx0XHR2YWxpZGF0ZSggXCJFX01JU1NJTkdfQlVORExFXCIsIHRoaXMuYXR0cmlidXRlcy5idW5kbGUgIT09IG51bGwsIHtcblx0XHRcdGxvY2FsZTogdGhpcy5sb2NhbGVcblx0XHR9KTtcblxuXHRcdHBhdGggPSBhbHdheXNBcnJheSggcGF0aCApO1xuXHRcdHJldHVybiB0aGlzLmdldCggWyBcIm1haW4ve2J1bmRsZX1cIiBdLmNvbmNhdCggcGF0aCApICk7XG5cdH07XG5cblx0cmV0dXJuIENsZHI7XG5cblxuXG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjhcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDEzIFJhZmFlbCBYYXZpZXIgZGUgU291emFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMTEtMjZUMTU6MDNaXG4gKi9cbi8qIVxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44IDIwMTYtMTEtMjZUMTU6MDNaIE1JVCBsaWNlbnNlIMKpIFJhZmFlbCBYYXZpZXJcbiAqIGh0dHA6Ly9naXQuaW8vaDRsbVZnXG4gKi9cbihmdW5jdGlvbiggZmFjdG9yeSApIHtcblxuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRcdC8vIEFNRC5cblx0XHRkZWZpbmUoIFsgXCIuLi9jbGRyXCIgXSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBOb2RlLiBDb21tb25KUy5cblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiLi4vY2xkclwiICkgKTtcblx0fSBlbHNlIHtcblx0XHQvLyBHbG9iYWxcblx0XHRmYWN0b3J5KCBDbGRyICk7XG5cdH1cblxufShmdW5jdGlvbiggQ2xkciApIHtcblxuXHQvLyBCdWlsZCBvcHRpbWl6YXRpb24gaGFjayB0byBhdm9pZCBkdXBsaWNhdGluZyBmdW5jdGlvbnMgYWNyb3NzIG1vZHVsZXMuXG5cdHZhciBwYXRoTm9ybWFsaXplID0gQ2xkci5fcGF0aE5vcm1hbGl6ZSxcblx0XHR2YWxpZGF0ZVByZXNlbmNlID0gQ2xkci5fdmFsaWRhdGVQcmVzZW5jZSxcblx0XHR2YWxpZGF0ZVR5cGUgPSBDbGRyLl92YWxpZGF0ZVR5cGU7XG5cbi8qIVxuICogRXZlbnRFbWl0dGVyIHY0LjIuNyAtIGdpdC5pby9lZVxuICogT2xpdmVyIENhbGR3ZWxsXG4gKiBNSVQgbGljZW5zZVxuICogQHByZXNlcnZlXG4gKi9cblxudmFyIEV2ZW50RW1pdHRlcjtcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbkV2ZW50RW1pdHRlciA9IChmdW5jdGlvbiAoKSB7XG5cblxuXHQvKipcblx0ICogQ2xhc3MgZm9yIG1hbmFnaW5nIGV2ZW50cy5cblx0ICogQ2FuIGJlIGV4dGVuZGVkIHRvIHByb3ZpZGUgZXZlbnQgZnVuY3Rpb25hbGl0eSBpbiBvdGhlciBjbGFzc2VzLlxuXHQgKlxuXHQgKiBAY2xhc3MgRXZlbnRFbWl0dGVyIE1hbmFnZXMgZXZlbnQgcmVnaXN0ZXJpbmcgYW5kIGVtaXR0aW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge31cblxuXHQvLyBTaG9ydGN1dHMgdG8gaW1wcm92ZSBzcGVlZCBhbmQgc2l6ZVxuXHR2YXIgcHJvdG8gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlO1xuXHR2YXIgZXhwb3J0cyA9IHRoaXM7XG5cdHZhciBvcmlnaW5hbEdsb2JhbFZhbHVlID0gZXhwb3J0cy5FdmVudEVtaXR0ZXI7XG5cblx0LyoqXG5cdCAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgbGlzdGVuZXIgZm9yIHRoZSBldmVudCBpbiBpdCdzIHN0b3JhZ2UgYXJyYXkuXG5cdCAqXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gbGlzdGVuZXJzIEFycmF5IG9mIGxpc3RlbmVycyB0byBzZWFyY2ggdGhyb3VnaC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGxvb2sgZm9yLlxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IEluZGV4IG9mIHRoZSBzcGVjaWZpZWQgbGlzdGVuZXIsIC0xIGlmIG5vdCBmb3VuZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGluZGV4T2ZMaXN0ZW5lcihsaXN0ZW5lcnMsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGkgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuXHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdGlmIChsaXN0ZW5lcnNbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG5cdFx0XHRcdHJldHVybiBpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiAtMTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBbGlhcyBhIG1ldGhvZCB3aGlsZSBrZWVwaW5nIHRoZSBjb250ZXh0IGNvcnJlY3QsIHRvIGFsbG93IGZvciBvdmVyd3JpdGluZyBvZiB0YXJnZXQgbWV0aG9kLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgdGFyZ2V0IG1ldGhvZC5cblx0ICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBhbGlhc2VkIG1ldGhvZFxuXHQgKiBAYXBpIHByaXZhdGVcblx0ICovXG5cdGZ1bmN0aW9uIGFsaWFzKG5hbWUpIHtcblx0XHRyZXR1cm4gZnVuY3Rpb24gYWxpYXNDbG9zdXJlKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9O1xuXHR9XG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGxpc3RlbmVyIGFycmF5IGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKiBXaWxsIGluaXRpYWxpc2UgdGhlIGV2ZW50IG9iamVjdCBhbmQgbGlzdGVuZXIgYXJyYXlzIGlmIHJlcXVpcmVkLlxuXHQgKiBXaWxsIHJldHVybiBhbiBvYmplY3QgaWYgeW91IHVzZSBhIHJlZ2V4IHNlYXJjaC4gVGhlIG9iamVjdCBjb250YWlucyBrZXlzIGZvciBlYWNoIG1hdGNoZWQgZXZlbnQuIFNvIC9iYVtyel0vIG1pZ2h0IHJldHVybiBhbiBvYmplY3QgY29udGFpbmluZyBiYXIgYW5kIGJhei4gQnV0IG9ubHkgaWYgeW91IGhhdmUgZWl0aGVyIGRlZmluZWQgdGhlbSB3aXRoIGRlZmluZUV2ZW50IG9yIGFkZGVkIHNvbWUgbGlzdGVuZXJzIHRvIHRoZW0uXG5cdCAqIEVhY2ggcHJvcGVydHkgaW4gdGhlIG9iamVjdCByZXNwb25zZSBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBmdW5jdGlvbnMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJldHVybiB0aGUgbGlzdGVuZXJzIGZyb20uXG5cdCAqIEByZXR1cm4ge0Z1bmN0aW9uW118T2JqZWN0fSBBbGwgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgZXZlbnQuXG5cdCAqL1xuXHRwcm90by5nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnMoZXZ0KSB7XG5cdFx0dmFyIGV2ZW50cyA9IHRoaXMuX2dldEV2ZW50cygpO1xuXHRcdHZhciByZXNwb25zZTtcblx0XHR2YXIga2V5O1xuXG5cdFx0Ly8gUmV0dXJuIGEgY29uY2F0ZW5hdGVkIGFycmF5IG9mIGFsbCBtYXRjaGluZyBldmVudHMgaWZcblx0XHQvLyB0aGUgc2VsZWN0b3IgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG5cdFx0aWYgKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0cmVzcG9uc2UgPSB7fTtcblx0XHRcdGZvciAoa2V5IGluIGV2ZW50cykge1xuXHRcdFx0XHRpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGtleSkgJiYgZXZ0LnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdHJlc3BvbnNlW2tleV0gPSBldmVudHNba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJlc3BvbnNlID0gZXZlbnRzW2V2dF0gfHwgKGV2ZW50c1tldnRdID0gW10pO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXNwb25zZTtcblx0fTtcblxuXHQvKipcblx0ICogVGFrZXMgYSBsaXN0IG9mIGxpc3RlbmVyIG9iamVjdHMgYW5kIGZsYXR0ZW5zIGl0IGludG8gYSBsaXN0IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3RbXX0gbGlzdGVuZXJzIFJhdyBsaXN0ZW5lciBvYmplY3RzLlxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbltdfSBKdXN0IHRoZSBsaXN0ZW5lciBmdW5jdGlvbnMuXG5cdCAqL1xuXHRwcm90by5mbGF0dGVuTGlzdGVuZXJzID0gZnVuY3Rpb24gZmxhdHRlbkxpc3RlbmVycyhsaXN0ZW5lcnMpIHtcblx0XHR2YXIgZmxhdExpc3RlbmVycyA9IFtdO1xuXHRcdHZhciBpO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0ZmxhdExpc3RlbmVycy5wdXNoKGxpc3RlbmVyc1tpXS5saXN0ZW5lcik7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZsYXRMaXN0ZW5lcnM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEZldGNoZXMgdGhlIHJlcXVlc3RlZCBsaXN0ZW5lcnMgdmlhIGdldExpc3RlbmVycyBidXQgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSByZXN1bHRzIGluc2lkZSBhbiBvYmplY3QuIFRoaXMgaXMgbWFpbmx5IGZvciBpbnRlcm5hbCB1c2UgYnV0IG90aGVycyBtYXkgZmluZCBpdCB1c2VmdWwuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJldHVybiB0aGUgbGlzdGVuZXJzIGZyb20uXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQWxsIGxpc3RlbmVyIGZ1bmN0aW9ucyBmb3IgYW4gZXZlbnQgaW4gYW4gb2JqZWN0LlxuXHQgKi9cblx0cHJvdG8uZ2V0TGlzdGVuZXJzQXNPYmplY3QgPSBmdW5jdGlvbiBnZXRMaXN0ZW5lcnNBc09iamVjdChldnQpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcblx0XHR2YXIgcmVzcG9uc2U7XG5cblx0XHRpZiAobGlzdGVuZXJzIGluc3RhbmNlb2YgQXJyYXkpIHtcblx0XHRcdHJlc3BvbnNlID0ge307XG5cdFx0XHRyZXNwb25zZVtldnRdID0gbGlzdGVuZXJzO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXNwb25zZSB8fCBsaXN0ZW5lcnM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFkZHMgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuXHQgKiBUaGUgbGlzdGVuZXIgd2lsbCBub3QgYmUgYWRkZWQgaWYgaXQgaXMgYSBkdXBsaWNhdGUuXG5cdCAqIElmIHRoZSBsaXN0ZW5lciByZXR1cm5zIHRydWUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgaXQgaXMgY2FsbGVkLlxuXHQgKiBJZiB5b3UgcGFzcyBhIHJlZ3VsYXIgZXhwcmVzc2lvbiBhcyB0aGUgZXZlbnQgbmFtZSB0aGVuIHRoZSBsaXN0ZW5lciB3aWxsIGJlIGFkZGVkIHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciB0by5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGNhbGxpbmcuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8uYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcihldnQsIGxpc3RlbmVyKSB7XG5cdFx0dmFyIGxpc3RlbmVycyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3QoZXZ0KTtcblx0XHR2YXIgbGlzdGVuZXJJc1dyYXBwZWQgPSB0eXBlb2YgbGlzdGVuZXIgPT09ICdvYmplY3QnO1xuXHRcdHZhciBrZXk7XG5cblx0XHRmb3IgKGtleSBpbiBsaXN0ZW5lcnMpIHtcblx0XHRcdGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzW2tleV0sIGxpc3RlbmVyKSA9PT0gLTEpIHtcblx0XHRcdFx0bGlzdGVuZXJzW2tleV0ucHVzaChsaXN0ZW5lcklzV3JhcHBlZCA/IGxpc3RlbmVyIDoge1xuXHRcdFx0XHRcdGxpc3RlbmVyOiBsaXN0ZW5lcixcblx0XHRcdFx0XHRvbmNlOiBmYWxzZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogQWxpYXMgb2YgYWRkTGlzdGVuZXJcblx0ICovXG5cdHByb3RvLm9uID0gYWxpYXMoJ2FkZExpc3RlbmVyJyk7XG5cblx0LyoqXG5cdCAqIFNlbWktYWxpYXMgb2YgYWRkTGlzdGVuZXIuIEl0IHdpbGwgYWRkIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlXG5cdCAqIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBhZnRlciBpdCdzIGZpcnN0IGV4ZWN1dGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciB0by5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBldmVudCBpcyBlbWl0dGVkLiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyB0cnVlIHRoZW4gaXQgd2lsbCBiZSByZW1vdmVkIGFmdGVyIGNhbGxpbmcuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8uYWRkT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gYWRkT25jZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGRMaXN0ZW5lcihldnQsIHtcblx0XHRcdGxpc3RlbmVyOiBsaXN0ZW5lcixcblx0XHRcdG9uY2U6IHRydWVcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogQWxpYXMgb2YgYWRkT25jZUxpc3RlbmVyLlxuXHQgKi9cblx0cHJvdG8ub25jZSA9IGFsaWFzKCdhZGRPbmNlTGlzdGVuZXInKTtcblxuXHQvKipcblx0ICogRGVmaW5lcyBhbiBldmVudCBuYW1lLiBUaGlzIGlzIHJlcXVpcmVkIGlmIHlvdSB3YW50IHRvIHVzZSBhIHJlZ2V4IHRvIGFkZCBhIGxpc3RlbmVyIHRvIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLiBJZiB5b3UgZG9uJ3QgZG8gdGhpcyB0aGVuIGhvdyBkbyB5b3UgZXhwZWN0IGl0IHRvIGtub3cgd2hhdCBldmVudCB0byBhZGQgdG8/IFNob3VsZCBpdCBqdXN0IGFkZCB0byBldmVyeSBwb3NzaWJsZSBtYXRjaCBmb3IgYSByZWdleD8gTm8uIFRoYXQgaXMgc2NhcnkgYW5kIGJhZC5cblx0ICogWW91IG5lZWQgdG8gdGVsbCBpdCB3aGF0IGV2ZW50IG5hbWVzIHNob3VsZCBiZSBtYXRjaGVkIGJ5IGEgcmVnZXguXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBldnQgTmFtZSBvZiB0aGUgZXZlbnQgdG8gY3JlYXRlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLmRlZmluZUV2ZW50ID0gZnVuY3Rpb24gZGVmaW5lRXZlbnQoZXZ0KSB7XG5cdFx0dGhpcy5nZXRMaXN0ZW5lcnMoZXZ0KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHQvKipcblx0ICogVXNlcyBkZWZpbmVFdmVudCB0byBkZWZpbmUgbXVsdGlwbGUgZXZlbnRzLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ1tdfSBldnRzIEFuIGFycmF5IG9mIGV2ZW50IG5hbWVzIHRvIGRlZmluZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5kZWZpbmVFdmVudHMgPSBmdW5jdGlvbiBkZWZpbmVFdmVudHMoZXZ0cykge1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZ0cy5sZW5ndGg7IGkgKz0gMSkge1xuXHRcdFx0dGhpcy5kZWZpbmVFdmVudChldnRzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJlbW92ZXMgYSBsaXN0ZW5lciBmdW5jdGlvbiBmcm9tIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG5cdCAqIFdoZW4gcGFzc2VkIGEgcmVndWxhciBleHByZXNzaW9uIGFzIHRoZSBldmVudCBuYW1lLCBpdCB3aWxsIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIHJlbW92ZSB0aGUgbGlzdGVuZXIgZnJvbS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgTWV0aG9kIHRvIHJlbW92ZSBmcm9tIHRoZSBldmVudC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2dCwgbGlzdGVuZXIpIHtcblx0XHR2YXIgbGlzdGVuZXJzID0gdGhpcy5nZXRMaXN0ZW5lcnNBc09iamVjdChldnQpO1xuXHRcdHZhciBpbmRleDtcblx0XHR2YXIga2V5O1xuXG5cdFx0Zm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XG5cdFx0XHRpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0aW5kZXggPSBpbmRleE9mTGlzdGVuZXIobGlzdGVuZXJzW2tleV0sIGxpc3RlbmVyKTtcblxuXHRcdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXJzW2tleV0uc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbGlhcyBvZiByZW1vdmVMaXN0ZW5lclxuXHQgKi9cblx0cHJvdG8ub2ZmID0gYWxpYXMoJ3JlbW92ZUxpc3RlbmVyJyk7XG5cblx0LyoqXG5cdCAqIEFkZHMgbGlzdGVuZXJzIGluIGJ1bGsgdXNpbmcgdGhlIG1hbmlwdWxhdGVMaXN0ZW5lcnMgbWV0aG9kLlxuXHQgKiBJZiB5b3UgcGFzcyBhbiBvYmplY3QgYXMgdGhlIHNlY29uZCBhcmd1bWVudCB5b3UgY2FuIGFkZCB0byBtdWx0aXBsZSBldmVudHMgYXQgb25jZS4gVGhlIG9iamVjdCBzaG91bGQgY29udGFpbiBrZXkgdmFsdWUgcGFpcnMgb2YgZXZlbnRzIGFuZCBsaXN0ZW5lcnMgb3IgbGlzdGVuZXIgYXJyYXlzLiBZb3UgY2FuIGFsc28gcGFzcyBpdCBhbiBldmVudCBuYW1lIGFuZCBhbiBhcnJheSBvZiBsaXN0ZW5lcnMgdG8gYmUgYWRkZWQuXG5cdCAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIGFkZCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGFsbCBldmVudHMgdGhhdCBtYXRjaCBpdC5cblx0ICogWWVhaCwgdGhpcyBmdW5jdGlvbiBkb2VzIHF1aXRlIGEgYml0LiBUaGF0J3MgcHJvYmFibHkgYSBiYWQgdGhpbmcuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxSZWdFeHB9IGV2dCBBbiBldmVudCBuYW1lIGlmIHlvdSB3aWxsIHBhc3MgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIG5leHQuIEFuIG9iamVjdCBpZiB5b3Ugd2lzaCB0byBhZGQgdG8gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIGFkZC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5hZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcnMoZXZ0LCBsaXN0ZW5lcnMpIHtcblx0XHQvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xuXHRcdHJldHVybiB0aGlzLm1hbmlwdWxhdGVMaXN0ZW5lcnMoZmFsc2UsIGV2dCwgbGlzdGVuZXJzKTtcblx0fTtcblxuXHQvKipcblx0ICogUmVtb3ZlcyBsaXN0ZW5lcnMgaW4gYnVsayB1c2luZyB0aGUgbWFuaXB1bGF0ZUxpc3RlbmVycyBtZXRob2QuXG5cdCAqIElmIHlvdSBwYXNzIGFuIG9iamVjdCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50IHlvdSBjYW4gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIHJlbW92ZWQuXG5cdCAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIHJlbW92ZSB0aGUgbGlzdGVuZXJzIGZyb20gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb25bXX0gW2xpc3RlbmVyc10gQW4gb3B0aW9uYWwgYXJyYXkgb2YgbGlzdGVuZXIgZnVuY3Rpb25zIHRvIHJlbW92ZS5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoZXZ0LCBsaXN0ZW5lcnMpIHtcblx0XHQvLyBQYXNzIHRocm91Z2ggdG8gbWFuaXB1bGF0ZUxpc3RlbmVyc1xuXHRcdHJldHVybiB0aGlzLm1hbmlwdWxhdGVMaXN0ZW5lcnModHJ1ZSwgZXZ0LCBsaXN0ZW5lcnMpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBFZGl0cyBsaXN0ZW5lcnMgaW4gYnVsay4gVGhlIGFkZExpc3RlbmVycyBhbmQgcmVtb3ZlTGlzdGVuZXJzIG1ldGhvZHMgYm90aCB1c2UgdGhpcyB0byBkbyB0aGVpciBqb2IuIFlvdSBzaG91bGQgcmVhbGx5IHVzZSB0aG9zZSBpbnN0ZWFkLCB0aGlzIGlzIGEgbGl0dGxlIGxvd2VyIGxldmVsLlxuXHQgKiBUaGUgZmlyc3QgYXJndW1lbnQgd2lsbCBkZXRlcm1pbmUgaWYgdGhlIGxpc3RlbmVycyBhcmUgcmVtb3ZlZCAodHJ1ZSkgb3IgYWRkZWQgKGZhbHNlKS5cblx0ICogSWYgeW91IHBhc3MgYW4gb2JqZWN0IGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgeW91IGNhbiBhZGQvcmVtb3ZlIGZyb20gbXVsdGlwbGUgZXZlbnRzIGF0IG9uY2UuIFRoZSBvYmplY3Qgc2hvdWxkIGNvbnRhaW4ga2V5IHZhbHVlIHBhaXJzIG9mIGV2ZW50cyBhbmQgbGlzdGVuZXJzIG9yIGxpc3RlbmVyIGFycmF5cy5cblx0ICogWW91IGNhbiBhbHNvIHBhc3MgaXQgYW4gZXZlbnQgbmFtZSBhbmQgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRvIGJlIGFkZGVkL3JlbW92ZWQuXG5cdCAqIFlvdSBjYW4gYWxzbyBwYXNzIGl0IGEgcmVndWxhciBleHByZXNzaW9uIHRvIG1hbmlwdWxhdGUgdGhlIGxpc3RlbmVycyBvZiBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVtb3ZlIFRydWUgaWYgeW91IHdhbnQgdG8gcmVtb3ZlIGxpc3RlbmVycywgZmFsc2UgaWYgeW91IHdhbnQgdG8gYWRkLlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R8UmVnRXhwfSBldnQgQW4gZXZlbnQgbmFtZSBpZiB5b3Ugd2lsbCBwYXNzIGFuIGFycmF5IG9mIGxpc3RlbmVycyBuZXh0LiBBbiBvYmplY3QgaWYgeW91IHdpc2ggdG8gYWRkL3JlbW92ZSBmcm9tIG11bHRpcGxlIGV2ZW50cyBhdCBvbmNlLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9uW119IFtsaXN0ZW5lcnNdIEFuIG9wdGlvbmFsIGFycmF5IG9mIGxpc3RlbmVyIGZ1bmN0aW9ucyB0byBhZGQvcmVtb3ZlLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLm1hbmlwdWxhdGVMaXN0ZW5lcnMgPSBmdW5jdGlvbiBtYW5pcHVsYXRlTGlzdGVuZXJzKHJlbW92ZSwgZXZ0LCBsaXN0ZW5lcnMpIHtcblx0XHR2YXIgaTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIHNpbmdsZSA9IHJlbW92ZSA/IHRoaXMucmVtb3ZlTGlzdGVuZXIgOiB0aGlzLmFkZExpc3RlbmVyO1xuXHRcdHZhciBtdWx0aXBsZSA9IHJlbW92ZSA/IHRoaXMucmVtb3ZlTGlzdGVuZXJzIDogdGhpcy5hZGRMaXN0ZW5lcnM7XG5cblx0XHQvLyBJZiBldnQgaXMgYW4gb2JqZWN0IHRoZW4gcGFzcyBlYWNoIG9mIGl0J3MgcHJvcGVydGllcyB0byB0aGlzIG1ldGhvZFxuXHRcdGlmICh0eXBlb2YgZXZ0ID09PSAnb2JqZWN0JyAmJiAhKGV2dCBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcblx0XHRcdGZvciAoaSBpbiBldnQpIHtcblx0XHRcdFx0aWYgKGV2dC5oYXNPd25Qcm9wZXJ0eShpKSAmJiAodmFsdWUgPSBldnRbaV0pKSB7XG5cdFx0XHRcdFx0Ly8gUGFzcyB0aGUgc2luZ2xlIGxpc3RlbmVyIHN0cmFpZ2h0IHRocm91Z2ggdG8gdGhlIHNpbmd1bGFyIG1ldGhvZFxuXHRcdFx0XHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRcdHNpbmdsZS5jYWxsKHRoaXMsIGksIHZhbHVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UgcGFzcyBiYWNrIHRvIHRoZSBtdWx0aXBsZSBmdW5jdGlvblxuXHRcdFx0XHRcdFx0bXVsdGlwbGUuY2FsbCh0aGlzLCBpLCB2YWx1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGVsc2Uge1xuXHRcdFx0Ly8gU28gZXZ0IG11c3QgYmUgYSBzdHJpbmdcblx0XHRcdC8vIEFuZCBsaXN0ZW5lcnMgbXVzdCBiZSBhbiBhcnJheSBvZiBsaXN0ZW5lcnNcblx0XHRcdC8vIExvb3Agb3ZlciBpdCBhbmQgcGFzcyBlYWNoIG9uZSB0byB0aGUgbXVsdGlwbGUgbWV0aG9kXG5cdFx0XHRpID0gbGlzdGVuZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlIChpLS0pIHtcblx0XHRcdFx0c2luZ2xlLmNhbGwodGhpcywgZXZ0LCBsaXN0ZW5lcnNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgZnJvbSBhIHNwZWNpZmllZCBldmVudC5cblx0ICogSWYgeW91IGRvIG5vdCBzcGVjaWZ5IGFuIGV2ZW50IHRoZW4gYWxsIGxpc3RlbmVycyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqIFRoYXQgbWVhbnMgZXZlcnkgZXZlbnQgd2lsbCBiZSBlbXB0aWVkLlxuXHQgKiBZb3UgY2FuIGFsc28gcGFzcyBhIHJlZ2V4IHRvIHJlbW92ZSBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gW2V2dF0gT3B0aW9uYWwgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yLiBXaWxsIHJlbW92ZSBmcm9tIGV2ZXJ5IGV2ZW50IGlmIG5vdCBwYXNzZWQuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiByZW1vdmVFdmVudChldnQpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBldnQ7XG5cdFx0dmFyIGV2ZW50cyA9IHRoaXMuX2dldEV2ZW50cygpO1xuXHRcdHZhciBrZXk7XG5cblx0XHQvLyBSZW1vdmUgZGlmZmVyZW50IHRoaW5ncyBkZXBlbmRpbmcgb24gdGhlIHN0YXRlIG9mIGV2dFxuXHRcdGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRcblx0XHRcdGRlbGV0ZSBldmVudHNbZXZ0XTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZXZ0IGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHQvLyBSZW1vdmUgYWxsIGV2ZW50cyBtYXRjaGluZyB0aGUgcmVnZXguXG5cdFx0XHRmb3IgKGtleSBpbiBldmVudHMpIHtcblx0XHRcdFx0aWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIGV2dC50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHRkZWxldGUgZXZlbnRzW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHQvLyBSZW1vdmUgYWxsIGxpc3RlbmVycyBpbiBhbGwgZXZlbnRzXG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBBbGlhcyBvZiByZW1vdmVFdmVudC5cblx0ICpcblx0ICogQWRkZWQgdG8gbWlycm9yIHRoZSBub2RlIEFQSS5cblx0ICovXG5cdHByb3RvLnJlbW92ZUFsbExpc3RlbmVycyA9IGFsaWFzKCdyZW1vdmVFdmVudCcpO1xuXG5cdC8qKlxuXHQgKiBFbWl0cyBhbiBldmVudCBvZiB5b3VyIGNob2ljZS5cblx0ICogV2hlbiBlbWl0dGVkLCBldmVyeSBsaXN0ZW5lciBhdHRhY2hlZCB0byB0aGF0IGV2ZW50IHdpbGwgYmUgZXhlY3V0ZWQuXG5cdCAqIElmIHlvdSBwYXNzIHRoZSBvcHRpb25hbCBhcmd1bWVudCBhcnJheSB0aGVuIHRob3NlIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCB0byBldmVyeSBsaXN0ZW5lciB1cG9uIGV4ZWN1dGlvbi5cblx0ICogQmVjYXVzZSBpdCB1c2VzIGBhcHBseWAsIHlvdXIgYXJyYXkgb2YgYXJndW1lbnRzIHdpbGwgYmUgcGFzc2VkIGFzIGlmIHlvdSB3cm90ZSB0aGVtIG91dCBzZXBhcmF0ZWx5LlxuXHQgKiBTbyB0aGV5IHdpbGwgbm90IGFycml2ZSB3aXRoaW4gdGhlIGFycmF5IG9uIHRoZSBvdGhlciBzaWRlLCB0aGV5IHdpbGwgYmUgc2VwYXJhdGUuXG5cdCAqIFlvdSBjYW4gYWxzbyBwYXNzIGEgcmVndWxhciBleHByZXNzaW9uIHRvIGVtaXQgdG8gYWxsIGV2ZW50cyB0aGF0IG1hdGNoIGl0LlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB9IGV2dCBOYW1lIG9mIHRoZSBldmVudCB0byBlbWl0IGFuZCBleGVjdXRlIGxpc3RlbmVycyBmb3IuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFthcmdzXSBPcHRpb25hbCBhcnJheSBvZiBhcmd1bWVudHMgdG8gYmUgcGFzc2VkIHRvIGVhY2ggbGlzdGVuZXIuXG5cdCAqIEByZXR1cm4ge09iamVjdH0gQ3VycmVudCBpbnN0YW5jZSBvZiBFdmVudEVtaXR0ZXIgZm9yIGNoYWluaW5nLlxuXHQgKi9cblx0cHJvdG8uZW1pdEV2ZW50ID0gZnVuY3Rpb24gZW1pdEV2ZW50KGV2dCwgYXJncykge1xuXHRcdHZhciBsaXN0ZW5lcnMgPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KGV2dCk7XG5cdFx0dmFyIGxpc3RlbmVyO1xuXHRcdHZhciBpO1xuXHRcdHZhciBrZXk7XG5cdFx0dmFyIHJlc3BvbnNlO1xuXG5cdFx0Zm9yIChrZXkgaW4gbGlzdGVuZXJzKSB7XG5cdFx0XHRpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0aSA9IGxpc3RlbmVyc1trZXldLmxlbmd0aDtcblxuXHRcdFx0XHR3aGlsZSAoaS0tKSB7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIGxpc3RlbmVyIHJldHVybnMgdHJ1ZSB0aGVuIGl0IHNoYWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgZXZlbnRcblx0XHRcdFx0XHQvLyBUaGUgZnVuY3Rpb24gaXMgZXhlY3V0ZWQgZWl0aGVyIHdpdGggYSBiYXNpYyBjYWxsIG9yIGFuIGFwcGx5IGlmIHRoZXJlIGlzIGFuIGFyZ3MgYXJyYXlcblx0XHRcdFx0XHRsaXN0ZW5lciA9IGxpc3RlbmVyc1trZXldW2ldO1xuXG5cdFx0XHRcdFx0aWYgKGxpc3RlbmVyLm9uY2UgPT09IHRydWUpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmVzcG9uc2UgPSBsaXN0ZW5lci5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzIHx8IFtdKTtcblxuXHRcdFx0XHRcdGlmIChyZXNwb25zZSA9PT0gdGhpcy5fZ2V0T25jZVJldHVyblZhbHVlKCkpIHtcblx0XHRcdFx0XHRcdHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZ0LCBsaXN0ZW5lci5saXN0ZW5lcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH07XG5cblx0LyoqXG5cdCAqIEFsaWFzIG9mIGVtaXRFdmVudFxuXHQgKi9cblx0cHJvdG8udHJpZ2dlciA9IGFsaWFzKCdlbWl0RXZlbnQnKTtcblxuXHQvKipcblx0ICogU3VidGx5IGRpZmZlcmVudCBmcm9tIGVtaXRFdmVudCBpbiB0aGF0IGl0IHdpbGwgcGFzcyBpdHMgYXJndW1lbnRzIG9uIHRvIHRoZSBsaXN0ZW5lcnMsIGFzIG9wcG9zZWQgdG8gdGFraW5nIGEgc2luZ2xlIGFycmF5IG9mIGFyZ3VtZW50cyB0byBwYXNzIG9uLlxuXHQgKiBBcyB3aXRoIGVtaXRFdmVudCwgeW91IGNhbiBwYXNzIGEgcmVnZXggaW4gcGxhY2Ugb2YgdGhlIGV2ZW50IG5hbWUgdG8gZW1pdCB0byBhbGwgZXZlbnRzIHRoYXQgbWF0Y2ggaXQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7U3RyaW5nfFJlZ0V4cH0gZXZ0IE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXQgYW5kIGV4ZWN1dGUgbGlzdGVuZXJzIGZvci5cblx0ICogQHBhcmFtIHsuLi4qfSBPcHRpb25hbCBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gZWFjaCBsaXN0ZW5lci5cblx0ICogQHJldHVybiB7T2JqZWN0fSBDdXJyZW50IGluc3RhbmNlIG9mIEV2ZW50RW1pdHRlciBmb3IgY2hhaW5pbmcuXG5cdCAqL1xuXHRwcm90by5lbWl0ID0gZnVuY3Rpb24gZW1pdChldnQpIHtcblx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0cmV0dXJuIHRoaXMuZW1pdEV2ZW50KGV2dCwgYXJncyk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGN1cnJlbnQgdmFsdWUgdG8gY2hlY2sgYWdhaW5zdCB3aGVuIGV4ZWN1dGluZyBsaXN0ZW5lcnMuIElmIGFcblx0ICogbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoZSBvbmUgc2V0IGhlcmUgdGhlbiBpdCB3aWxsIGJlIHJlbW92ZWRcblx0ICogYWZ0ZXIgZXhlY3V0aW9uLiBUaGlzIHZhbHVlIGRlZmF1bHRzIHRvIHRydWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIG5ldyB2YWx1ZSB0byBjaGVjayBmb3Igd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R9IEN1cnJlbnQgaW5zdGFuY2Ugb2YgRXZlbnRFbWl0dGVyIGZvciBjaGFpbmluZy5cblx0ICovXG5cdHByb3RvLnNldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uIHNldE9uY2VSZXR1cm5WYWx1ZSh2YWx1ZSkge1xuXHRcdHRoaXMuX29uY2VSZXR1cm5WYWx1ZSA9IHZhbHVlO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGZXRjaGVzIHRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGFnYWluc3Qgd2hlbiBleGVjdXRpbmcgbGlzdGVuZXJzLiBJZlxuXHQgKiB0aGUgbGlzdGVuZXJzIHJldHVybiB2YWx1ZSBtYXRjaGVzIHRoaXMgb25lIHRoZW4gaXQgc2hvdWxkIGJlIHJlbW92ZWRcblx0ICogYXV0b21hdGljYWxseS4gSXQgd2lsbCByZXR1cm4gdHJ1ZSBieSBkZWZhdWx0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHsqfEJvb2xlYW59IFRoZSBjdXJyZW50IHZhbHVlIHRvIGNoZWNrIGZvciBvciB0aGUgZGVmYXVsdCwgdHJ1ZS5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRwcm90by5fZ2V0T25jZVJldHVyblZhbHVlID0gZnVuY3Rpb24gX2dldE9uY2VSZXR1cm5WYWx1ZSgpIHtcblx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eSgnX29uY2VSZXR1cm5WYWx1ZScpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fb25jZVJldHVyblZhbHVlO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRmV0Y2hlcyB0aGUgZXZlbnRzIG9iamVjdCBhbmQgY3JlYXRlcyBvbmUgaWYgcmVxdWlyZWQuXG5cdCAqXG5cdCAqIEByZXR1cm4ge09iamVjdH0gVGhlIGV2ZW50cyBzdG9yYWdlIG9iamVjdC5cblx0ICogQGFwaSBwcml2YXRlXG5cdCAqL1xuXHRwcm90by5fZ2V0RXZlbnRzID0gZnVuY3Rpb24gX2dldEV2ZW50cygpIHtcblx0XHRyZXR1cm4gdGhpcy5fZXZlbnRzIHx8ICh0aGlzLl9ldmVudHMgPSB7fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIFJldmVydHMgdGhlIGdsb2JhbCB7QGxpbmsgRXZlbnRFbWl0dGVyfSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhpcyB2ZXJzaW9uLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtGdW5jdGlvbn0gTm9uIGNvbmZsaWN0aW5nIEV2ZW50RW1pdHRlciBjbGFzcy5cblx0ICovXG5cdEV2ZW50RW1pdHRlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gbm9Db25mbGljdCgpIHtcblx0XHRleHBvcnRzLkV2ZW50RW1pdHRlciA9IG9yaWdpbmFsR2xvYmFsVmFsdWU7XG5cdFx0cmV0dXJuIEV2ZW50RW1pdHRlcjtcblx0fTtcblxuXHRyZXR1cm4gRXZlbnRFbWl0dGVyO1xufSgpKTtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxuXG5cdHZhciB2YWxpZGF0ZVR5cGVGdW5jdGlvbiA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0XHR2YWxpZGF0ZVR5cGUoIHZhbHVlLCBuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIsIFwiRnVuY3Rpb25cIiApO1xuXHR9O1xuXG5cblxuXG5cdHZhciBzdXBlckdldCwgc3VwZXJJbml0LFxuXHRcdGdsb2JhbEVlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG5cdGZ1bmN0aW9uIHZhbGlkYXRlVHlwZUV2ZW50KCB2YWx1ZSwgbmFtZSApIHtcblx0XHR2YWxpZGF0ZVR5cGUoIHZhbHVlLCBuYW1lLCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHAsIFwiU3RyaW5nIG9yIFJlZ0V4cFwiICk7XG5cdH1cblxuXHRmdW5jdGlvbiB2YWxpZGF0ZVRoZW5DYWxsKCBtZXRob2QsIHNlbGYgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBldmVudCwgbGlzdGVuZXIgKSB7XG5cdFx0XHR2YWxpZGF0ZVByZXNlbmNlKCBldmVudCwgXCJldmVudFwiICk7XG5cdFx0XHR2YWxpZGF0ZVR5cGVFdmVudCggZXZlbnQsIFwiZXZlbnRcIiApO1xuXG5cdFx0XHR2YWxpZGF0ZVByZXNlbmNlKCBsaXN0ZW5lciwgXCJsaXN0ZW5lclwiICk7XG5cdFx0XHR2YWxpZGF0ZVR5cGVGdW5jdGlvbiggbGlzdGVuZXIsIFwibGlzdGVuZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gc2VsZlsgbWV0aG9kIF0uYXBwbHkoIHNlbGYsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBvZmYoIHNlbGYgKSB7XG5cdFx0cmV0dXJuIHZhbGlkYXRlVGhlbkNhbGwoIFwib2ZmXCIsIHNlbGYgKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG9uKCBzZWxmICkge1xuXHRcdHJldHVybiB2YWxpZGF0ZVRoZW5DYWxsKCBcIm9uXCIsIHNlbGYgKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG9uY2UoIHNlbGYgKSB7XG5cdFx0cmV0dXJuIHZhbGlkYXRlVGhlbkNhbGwoIFwib25jZVwiLCBzZWxmICk7XG5cdH1cblxuXHRDbGRyLm9mZiA9IG9mZiggZ2xvYmFsRWUgKTtcblx0Q2xkci5vbiA9IG9uKCBnbG9iYWxFZSApO1xuXHRDbGRyLm9uY2UgPSBvbmNlKCBnbG9iYWxFZSApO1xuXG5cdC8qKlxuXHQgKiBPdmVybG9hZCBDbGRyLnByb3RvdHlwZS5pbml0KCkuXG5cdCAqL1xuXHRzdXBlckluaXQgPSBDbGRyLnByb3RvdHlwZS5pbml0O1xuXHRDbGRyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGVlO1xuXHRcdHRoaXMuZWUgPSBlZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblx0XHR0aGlzLm9mZiA9IG9mZiggZWUgKTtcblx0XHR0aGlzLm9uID0gb24oIGVlICk7XG5cdFx0dGhpcy5vbmNlID0gb25jZSggZWUgKTtcblx0XHRzdXBlckluaXQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBnZXRPdmVybG9hZCBpcyBlbmNhcHN1bGF0ZWQsIGJlY2F1c2Ugb2YgY2xkci91bnJlc29sdmVkLiBJZiBpdCdzIGxvYWRlZFxuXHQgKiBhZnRlciBjbGRyL2V2ZW50IChhbmQgbm90ZSBpdCBvdmVyd3JpdGVzIC5nZXQpLCBpdCBjYW4gdHJpZ2dlciB0aGlzXG5cdCAqIG92ZXJsb2FkIGFnYWluLlxuXHQgKi9cblx0ZnVuY3Rpb24gZ2V0T3ZlcmxvYWQoKSB7XG5cblx0XHQvKipcblx0XHQgKiBPdmVybG9hZCBDbGRyLnByb3RvdHlwZS5nZXQoKS5cblx0XHQgKi9cblx0XHRzdXBlckdldCA9IENsZHIucHJvdG90eXBlLmdldDtcblx0XHRDbGRyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiggcGF0aCApIHtcblx0XHRcdHZhciB2YWx1ZSA9IHN1cGVyR2V0LmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdHBhdGggPSBwYXRoTm9ybWFsaXplKCBwYXRoLCB0aGlzLmF0dHJpYnV0ZXMgKS5qb2luKCBcIi9cIiApO1xuXHRcdFx0Z2xvYmFsRWUudHJpZ2dlciggXCJnZXRcIiwgWyBwYXRoLCB2YWx1ZSBdICk7XG5cdFx0XHR0aGlzLmVlLnRyaWdnZXIoIFwiZ2V0XCIsIFsgcGF0aCwgdmFsdWUgXSApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cdH1cblxuXHRDbGRyLl9ldmVudEluaXQgPSBnZXRPdmVybG9hZDtcblx0Z2V0T3ZlcmxvYWQoKTtcblxuXHRyZXR1cm4gQ2xkcjtcblxuXG5cblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci9ldmVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci9ldmVudC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKipcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOFxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgUmFmYWVsIFhhdmllciBkZSBTb3V6YVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0xMS0yNlQxNTowM1pcbiAqL1xuLyohXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjggMjAxNi0xMS0yNlQxNTowM1ogTUlUIGxpY2Vuc2UgwqkgUmFmYWVsIFhhdmllclxuICogaHR0cDovL2dpdC5pby9oNGxtVmdcbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1ELlxuXHRcdGRlZmluZSggWyBcIi4uL2NsZHJcIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIE5vZGUuIENvbW1vbkpTLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCIuLi9jbGRyXCIgKSApO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEdsb2JhbFxuXHRcdGZhY3RvcnkoIENsZHIgKTtcblx0fVxuXG59KGZ1bmN0aW9uKCBDbGRyICkge1xuXG5cdC8vIEJ1aWxkIG9wdGltaXphdGlvbiBoYWNrIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGZ1bmN0aW9ucyBhY3Jvc3MgbW9kdWxlcy5cblx0dmFyIGFsd2F5c0FycmF5ID0gQ2xkci5fYWx3YXlzQXJyYXk7XG5cblxuXG5cdHZhciBzdXBwbGVtZW50YWxNYWluID0gZnVuY3Rpb24oIGNsZHIgKSB7XG5cblx0XHR2YXIgcHJlcGVuZCwgc3VwcGxlbWVudGFsO1xuXHRcdFxuXHRcdHByZXBlbmQgPSBmdW5jdGlvbiggcHJlcGVuZCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggcGF0aCApIHtcblx0XHRcdFx0cGF0aCA9IGFsd2F5c0FycmF5KCBwYXRoICk7XG5cdFx0XHRcdHJldHVybiBjbGRyLmdldCggWyBwcmVwZW5kIF0uY29uY2F0KCBwYXRoICkgKTtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdHN1cHBsZW1lbnRhbCA9IHByZXBlbmQoIFwic3VwcGxlbWVudGFsXCIgKTtcblxuXHRcdC8vIFdlZWsgRGF0YVxuXHRcdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNXZWVrX0RhdGFcblx0XHRzdXBwbGVtZW50YWwud2Vla0RhdGEgPSBwcmVwZW5kKCBcInN1cHBsZW1lbnRhbC93ZWVrRGF0YVwiICk7XG5cblx0XHRzdXBwbGVtZW50YWwud2Vla0RhdGEuZmlyc3REYXkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvd2Vla0RhdGEvZmlyc3REYXkve3RlcnJpdG9yeX1cIiApIHx8XG5cdFx0XHRcdGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC93ZWVrRGF0YS9maXJzdERheS8wMDFcIiApO1xuXHRcdH07XG5cblx0XHRzdXBwbGVtZW50YWwud2Vla0RhdGEubWluRGF5cyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1pbkRheXMgPSBjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvd2Vla0RhdGEvbWluRGF5cy97dGVycml0b3J5fVwiICkgfHxcblx0XHRcdFx0Y2xkci5nZXQoIFwic3VwcGxlbWVudGFsL3dlZWtEYXRhL21pbkRheXMvMDAxXCIgKTtcblx0XHRcdHJldHVybiBwYXJzZUludCggbWluRGF5cywgMTAgKTtcblx0XHR9O1xuXG5cdFx0Ly8gVGltZSBEYXRhXG5cdFx0Ly8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI1RpbWVfRGF0YVxuXHRcdHN1cHBsZW1lbnRhbC50aW1lRGF0YSA9IHByZXBlbmQoIFwic3VwcGxlbWVudGFsL3RpbWVEYXRhXCIgKTtcblxuXHRcdHN1cHBsZW1lbnRhbC50aW1lRGF0YS5hbGxvd2VkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY2xkci5nZXQoIFwic3VwcGxlbWVudGFsL3RpbWVEYXRhL3t0ZXJyaXRvcnl9L19hbGxvd2VkXCIgKSB8fFxuXHRcdFx0XHRjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvdGltZURhdGEvMDAxL19hbGxvd2VkXCIgKTtcblx0XHR9O1xuXG5cdFx0c3VwcGxlbWVudGFsLnRpbWVEYXRhLnByZWZlcnJlZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGNsZHIuZ2V0KCBcInN1cHBsZW1lbnRhbC90aW1lRGF0YS97dGVycml0b3J5fS9fcHJlZmVycmVkXCIgKSB8fFxuXHRcdFx0XHRjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvdGltZURhdGEvMDAxL19wcmVmZXJyZWRcIiApO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gc3VwcGxlbWVudGFsO1xuXG5cdH07XG5cblxuXG5cblx0dmFyIGluaXRTdXBlciA9IENsZHIucHJvdG90eXBlLmluaXQ7XG5cblx0LyoqXG5cdCAqIC5pbml0KCkgYXV0b21hdGljYWxseSByYW4gb24gY29uc3RydWN0aW9uLlxuXHQgKlxuXHQgKiBPdmVybG9hZCAuaW5pdCgpLlxuXHQgKi9cblx0Q2xkci5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGluaXRTdXBlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0dGhpcy5zdXBwbGVtZW50YWwgPSBzdXBwbGVtZW50YWxNYWluKCB0aGlzICk7XG5cdH07XG5cblx0cmV0dXJuIENsZHI7XG5cblxuXG5cbn0pKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L2NsZHIvc3VwcGxlbWVudGFsLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL3N1cHBsZW1lbnRhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKipcbiAqIENMRFIgSmF2YVNjcmlwdCBMaWJyYXJ5IHYwLjQuOFxuICogaHR0cDovL2pxdWVyeS5jb20vXG4gKlxuICogQ29weXJpZ2h0IDIwMTMgUmFmYWVsIFhhdmllciBkZSBTb3V6YVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNi0xMS0yNlQxNTowM1pcbiAqL1xuLyohXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjggMjAxNi0xMS0yNlQxNTowM1ogTUlUIGxpY2Vuc2UgwqkgUmFmYWVsIFhhdmllclxuICogaHR0cDovL2dpdC5pby9oNGxtVmdcbiAqL1xuKGZ1bmN0aW9uKCBmYWN0b3J5ICkge1xuXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0Ly8gQU1ELlxuXHRcdGRlZmluZSggWyBcIi4uL2NsZHJcIiBdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXHRcdC8vIE5vZGUuIENvbW1vbkpTLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCIuLi9jbGRyXCIgKSApO1xuXHR9IGVsc2Uge1xuXHRcdC8vIEdsb2JhbFxuXHRcdGZhY3RvcnkoIENsZHIgKTtcblx0fVxuXG59KGZ1bmN0aW9uKCBDbGRyICkge1xuXG5cdC8vIEJ1aWxkIG9wdGltaXphdGlvbiBoYWNrIHRvIGF2b2lkIGR1cGxpY2F0aW5nIGZ1bmN0aW9ucyBhY3Jvc3MgbW9kdWxlcy5cblx0dmFyIGNvcmVMb2FkID0gQ2xkci5fY29yZUxvYWQ7XG5cdHZhciBqc29uTWVyZ2UgPSBDbGRyLl9qc29uTWVyZ2U7XG5cdHZhciBwYXRoTm9ybWFsaXplID0gQ2xkci5fcGF0aE5vcm1hbGl6ZTtcblx0dmFyIHJlc291cmNlR2V0ID0gQ2xkci5fcmVzb3VyY2VHZXQ7XG5cdHZhciB2YWxpZGF0ZVByZXNlbmNlID0gQ2xkci5fdmFsaWRhdGVQcmVzZW5jZTtcblx0dmFyIHZhbGlkYXRlVHlwZVBhdGggPSBDbGRyLl92YWxpZGF0ZVR5cGVQYXRoO1xuXG5cblxuXHR2YXIgYnVuZGxlUGFyZW50TG9va3VwID0gZnVuY3Rpb24oIENsZHIsIGxvY2FsZSApIHtcblx0XHR2YXIgbm9ybWFsaXplZFBhdGgsIHBhcmVudDtcblxuXHRcdGlmICggbG9jYWxlID09PSBcInJvb3RcIiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGaXJzdCwgdHJ5IHRvIGZpbmQgcGFyZW50IG9uIHN1cHBsZW1lbnRhbCBkYXRhLlxuXHRcdG5vcm1hbGl6ZWRQYXRoID0gcGF0aE5vcm1hbGl6ZSggWyBcInN1cHBsZW1lbnRhbC9wYXJlbnRMb2NhbGVzL3BhcmVudExvY2FsZVwiLCBsb2NhbGUgXSApO1xuXHRcdHBhcmVudCA9IHJlc291cmNlR2V0KCBDbGRyLl9yZXNvbHZlZCwgbm9ybWFsaXplZFBhdGggKSB8fCByZXNvdXJjZUdldCggQ2xkci5fcmF3LCBub3JtYWxpemVkUGF0aCApO1xuXHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHR9XG5cblx0XHQvLyBPciB0cnVuY2F0ZSBsb2NhbGUuXG5cdFx0cGFyZW50ID0gbG9jYWxlLnN1YnN0ciggMCwgbG9jYWxlLmxhc3RJbmRleE9mKCBDbGRyLmxvY2FsZVNlcCApICk7XG5cdFx0aWYgKCAhcGFyZW50ICkge1xuXHRcdFx0cmV0dXJuIFwicm9vdFwiO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXJlbnQ7XG5cdH07XG5cblxuXG5cblx0Ly8gQHBhdGg6IG5vcm1hbGl6ZWQgcGF0aFxuXHR2YXIgcmVzb3VyY2VTZXQgPSBmdW5jdGlvbiggZGF0YSwgcGF0aCwgdmFsdWUgKSB7XG5cdFx0dmFyIGksXG5cdFx0XHRub2RlID0gZGF0YSxcblx0XHRcdGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW5ndGggLSAxOyBpKysgKSB7XG5cdFx0XHRpZiAoICFub2RlWyBwYXRoWyBpIF0gXSApIHtcblx0XHRcdFx0bm9kZVsgcGF0aFsgaSBdIF0gPSB7fTtcblx0XHRcdH1cblx0XHRcdG5vZGUgPSBub2RlWyBwYXRoWyBpIF0gXTtcblx0XHR9XG5cdFx0bm9kZVsgcGF0aFsgaSBdIF0gPSB2YWx1ZTtcblx0fTtcblxuXG5cdHZhciBpdGVtTG9va3VwID0gKGZ1bmN0aW9uKCkge1xuXG5cdHZhciBsb29rdXA7XG5cblx0bG9va3VwID0gZnVuY3Rpb24oIENsZHIsIGxvY2FsZSwgcGF0aCwgYXR0cmlidXRlcywgY2hpbGRMb2NhbGUgKSB7XG5cdFx0dmFyIG5vcm1hbGl6ZWRQYXRoLCBwYXJlbnQsIHZhbHVlO1xuXG5cdFx0Ly8gMTogRmluaXNoIHJlY3Vyc2lvblxuXHRcdC8vIDI6IEF2b2lkIGluZmluaXRlIGxvb3Bcblx0XHRpZiAoIHR5cGVvZiBsb2NhbGUgPT09IFwidW5kZWZpbmVkXCIgLyogMSAqLyB8fCBsb2NhbGUgPT09IGNoaWxkTG9jYWxlIC8qIDIgKi8gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVzb2x2ZSBwYXRoXG5cdFx0bm9ybWFsaXplZFBhdGggPSBwYXRoTm9ybWFsaXplKCBwYXRoLCBhdHRyaWJ1dGVzICk7XG5cblx0XHQvLyBDaGVjayByZXNvbHZlZCAoY2FjaGVkKSBkYXRhIGZpcnN0XG5cdFx0Ly8gMTogRHVlIHRvICMxNiwgbmV2ZXIgdXNlIHRoZSBjYWNoZWQgcmVzb2x2ZWQgbm9uLWxlYWYgbm9kZXMuIEl0IG1heSBub3Rcblx0XHQvLyAgICByZXByZXNlbnQgaXRzIGxlYWZzIGluIGl0cyBlbnRpcmV0eS5cblx0XHR2YWx1ZSA9IHJlc291cmNlR2V0KCBDbGRyLl9yZXNvbHZlZCwgbm9ybWFsaXplZFBhdGggKTtcblx0XHRpZiAoIHZhbHVlICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiAvKiAxICovICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIHJhdyBkYXRhXG5cdFx0dmFsdWUgPSByZXNvdXJjZUdldCggQ2xkci5fcmF3LCBub3JtYWxpemVkUGF0aCApO1xuXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHQvLyBPciwgbG9va3VwIGF0IHBhcmVudCBsb2NhbGVcblx0XHRcdHBhcmVudCA9IGJ1bmRsZVBhcmVudExvb2t1cCggQ2xkciwgbG9jYWxlICk7XG5cdFx0XHR2YWx1ZSA9IGxvb2t1cCggQ2xkciwgcGFyZW50LCBwYXRoLCBqc29uTWVyZ2UoIGF0dHJpYnV0ZXMsIHsgYnVuZGxlOiBwYXJlbnQgfSksIGxvY2FsZSApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHQvLyBTZXQgcmVzb2x2ZWQgKGNhY2hlZClcblx0XHRcdHJlc291cmNlU2V0KCBDbGRyLl9yZXNvbHZlZCwgbm9ybWFsaXplZFBhdGgsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdHJldHVybiBsb29rdXA7XG5cbn0oKSk7XG5cblxuXHRDbGRyLl9yYXcgPSB7fTtcblxuXHQvKipcblx0ICogQ2xkci5sb2FkKCBqc29uIFssIGpzb24sIC4uLl0gKVxuXHQgKlxuXHQgKiBAanNvbiBbSlNPTl0gQ0xEUiBkYXRhIG9yIFtBcnJheV0gQXJyYXkgb2YgQGpzb24ncy5cblx0ICpcblx0ICogTG9hZCByZXNvbHZlZCBvciB1bnJlc29sdmVkIGNsZHIgZGF0YS5cblx0ICogT3ZlcndyaXRlIENsZHIubG9hZCgpLlxuXHQgKi9cblx0Q2xkci5sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0Q2xkci5fcmF3ID0gY29yZUxvYWQoIENsZHIsIENsZHIuX3JhdywgYXJndW1lbnRzICk7XG5cdH07XG5cblx0LyoqXG5cdCAqIE92ZXJ3cml0ZSBDbGRyLnByb3RvdHlwZS5nZXQoKS5cblx0ICovXG5cdENsZHIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKCBwYXRoICkge1xuXHRcdHZhbGlkYXRlUHJlc2VuY2UoIHBhdGgsIFwicGF0aFwiICk7XG5cdFx0dmFsaWRhdGVUeXBlUGF0aCggcGF0aCwgXCJwYXRoXCIgKTtcblxuXHRcdC8vIDE6IHVzZSBidW5kbGUgYXMgbG9jYWxlIG9uIGl0ZW0gbG9va3VwIGZvciBzaW1wbGlmaWNhdGlvbiBwdXJwb3NlcywgYmVjYXVzZSBubyBvdGhlciBleHRlbmRlZCBzdWJ0YWcgaXMgdXNlZCBhbnl3YXkgb24gYnVuZGxlIHBhcmVudCBsb29rdXAuXG5cdFx0Ly8gMjogZHVyaW5nIGluaXQoKSwgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCBidXQgYnVuZGxlIGlzIHlldCBub3QgZGVmaW5lZC4gVXNlIFwiXCIgYXMgYSB3b3JrYXJvdW5kIGluIHRoaXMgdmVyeSBzcGVjaWZpYyBzY2VuYXJpby5cblx0XHRyZXR1cm4gaXRlbUxvb2t1cCggQ2xkciwgdGhpcy5hdHRyaWJ1dGVzICYmIHRoaXMuYXR0cmlidXRlcy5idW5kbGUgLyogMSAqLyB8fCBcIlwiIC8qIDIgKi8sIHBhdGgsIHRoaXMuYXR0cmlidXRlcyApO1xuXHR9O1xuXG5cdC8vIEluIGNhc2UgY2xkci91bnJlc29sdmVkIGlzIGxvYWRlZCBhZnRlciBjbGRyL2V2ZW50LCB3ZSB0cmlnZ2VyIGl0cyBvdmVybG9hZHMgYWdhaW4uIEJlY2F1c2UsIC5nZXQgaXMgb3ZlcndyaXR0ZW4gaW4gaGVyZS5cblx0aWYgKCBDbGRyLl9ldmVudEluaXQgKSB7XG5cdFx0Q2xkci5fZXZlbnRJbml0KCk7XG5cdH1cblxuXHRyZXR1cm4gQ2xkcjtcblxuXG5cblxufSkpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY2xkcmpzL2Rpc3QvY2xkci91bnJlc29sdmVkLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9jbGRyL3VucmVzb2x2ZWQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqXG4gKiBDTERSIEphdmFTY3JpcHQgTGlicmFyeSB2MC40LjhcbiAqIGh0dHA6Ly9qcXVlcnkuY29tL1xuICpcbiAqIENvcHlyaWdodCAyMDEzIFJhZmFlbCBYYXZpZXIgZGUgU291emFcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMTEtMjZUMTU6MDNaXG4gKi9cbi8qIVxuICogQ0xEUiBKYXZhU2NyaXB0IExpYnJhcnkgdjAuNC44IDIwMTYtMTEtMjZUMTU6MDNaIE1JVCBsaWNlbnNlIMKpIFJhZmFlbCBYYXZpZXJcbiAqIGh0dHA6Ly9naXQuaW8vaDRsbVZnXG4gKi9cblxuLy8gQ2xkclxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCBcIi4vY2xkclwiICk7XG5cbi8vIEV4dGVudCBDbGRyIHdpdGggdGhlIGZvbGxvd2luZyBtb2R1bGVzXG5yZXF1aXJlKCBcIi4vY2xkci9ldmVudFwiICk7XG5yZXF1aXJlKCBcIi4vY2xkci9zdXBwbGVtZW50YWxcIiApO1xucmVxdWlyZSggXCIuL2NsZHIvdW5yZXNvbHZlZFwiICk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jbGRyanMvZGlzdC9ub2RlX21haW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2NsZHJqcy9kaXN0L25vZGVfbWFpbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgZGVmaW5lID0gZmFsc2U7XG5cbi8qKlxuICogR2xvYmFsaXplIHYxLjMuMFxuICpcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wNy0wM1QyMTozN1pcbiAqL1xuLyohXG4gKiBHbG9iYWxpemUgdjEuMy4wIDIwMTctMDctMDNUMjE6MzdaIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2dpdC5pby9UcmRRYndcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXG5cdC8vIFVNRCByZXR1cm5FeHBvcnRzXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1xuXHRcdFx0XCJjbGRyXCIsXG5cdFx0XHRcImNsZHIvZXZlbnRcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBOb2RlLCBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCJjbGRyanNcIiApICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBHbG9iYWxcblx0XHRyb290Lkdsb2JhbGl6ZSA9IGZhY3RvcnkoIHJvb3QuQ2xkciApO1xuXHR9XG59KCB0aGlzLCBmdW5jdGlvbiggQ2xkciApIHtcblxuXG4vKipcbiAqIEEgdG9TdHJpbmcgbWV0aG9kIHRoYXQgb3V0cHV0cyBtZWFuaW5nZnVsIHZhbHVlcyBmb3Igb2JqZWN0cyBvciBhcnJheXMgYW5kXG4gKiBzdGlsbCBwZXJmb3JtcyBhcyBmYXN0IGFzIGEgcGxhaW4gc3RyaW5nIGluIGNhc2UgdmFyaWFibGUgaXMgc3RyaW5nLCBvciBhc1xuICogZmFzdCBhcyBgXCJcIiArIG51bWJlcmAgaW4gY2FzZSB2YXJpYWJsZSBpcyBhIG51bWJlci5cbiAqIFJlZjogaHR0cDovL2pzcGVyZi5jb20vbXktc3RyaW5naWZ5XG4gKi9cbnZhciB0b1N0cmluZyA9IGZ1bmN0aW9uKCB2YXJpYWJsZSApIHtcblx0cmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PT0gXCJzdHJpbmdcIiA/IHZhcmlhYmxlIDogKCB0eXBlb2YgdmFyaWFibGUgPT09IFwibnVtYmVyXCIgPyBcIlwiICtcblx0XHR2YXJpYWJsZSA6IEpTT04uc3RyaW5naWZ5KCB2YXJpYWJsZSApICk7XG59O1xuXG5cblxuXG4vKipcbiAqIGZvcm1hdE1lc3NhZ2UoIG1lc3NhZ2UsIGRhdGEgKVxuICpcbiAqIEBtZXNzYWdlIFtTdHJpbmddIEEgbWVzc2FnZSB3aXRoIG9wdGlvbmFsIHt2YXJzfSB0byBiZSByZXBsYWNlZC5cbiAqXG4gKiBAZGF0YSBbQXJyYXkgb3IgSlNPTl0gT2JqZWN0IHdpdGggcmVwbGFjaW5nLXZhcmlhYmxlcyBjb250ZW50LlxuICpcbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIG1lc3NhZ2UuIEZvciBleGFtcGxlOlxuICpcbiAqIC0gZm9ybWF0TWVzc2FnZSggXCJ7MH0gc2Vjb25kXCIsIFsgMSBdICk7IC8vIDEgc2Vjb25kXG4gKlxuICogLSBmb3JtYXRNZXNzYWdlKCBcInswfS97MX1cIiwgW1wibVwiLCBcInNcIl0gKTsgLy8gbS9zXG4gKlxuICogLSBmb3JtYXRNZXNzYWdlKCBcIntuYW1lfSA8e2VtYWlsfT5cIiwge1xuICogICAgIG5hbWU6IFwiRm9vXCIsXG4gKiAgICAgZW1haWw6IFwiYmFyQGJhei5xdXhcIlxuICogICB9KTsgLy8gRm9vIDxiYXJAYmF6LnF1eD5cbiAqL1xudmFyIGZvcm1hdE1lc3NhZ2UgPSBmdW5jdGlvbiggbWVzc2FnZSwgZGF0YSApIHtcblxuXHQvLyBSZXBsYWNlIHthdHRyaWJ1dGV9J3Ncblx0bWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSggL3tbMC05YS16QS1aLV8uIF0rfS9nLCBmdW5jdGlvbiggbmFtZSApIHtcblx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKCAvXnsoW159XSopfSQvLCBcIiQxXCIgKTtcblx0XHRyZXR1cm4gdG9TdHJpbmcoIGRhdGFbIG5hbWUgXSApO1xuXHR9KTtcblxuXHRyZXR1cm4gbWVzc2FnZTtcbn07XG5cblxuXG5cbnZhciBvYmplY3RFeHRlbmQgPSBmdW5jdGlvbigpIHtcblx0dmFyIGRlc3RpbmF0aW9uID0gYXJndW1lbnRzWyAwIF0sXG5cdFx0c291cmNlcyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXG5cdHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbiggc291cmNlICkge1xuXHRcdHZhciBwcm9wO1xuXHRcdGZvciAoIHByb3AgaW4gc291cmNlICkge1xuXHRcdFx0ZGVzdGluYXRpb25bIHByb3AgXSA9IHNvdXJjZVsgcHJvcCBdO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxuXG5cblxudmFyIGNyZWF0ZUVycm9yID0gZnVuY3Rpb24oIGNvZGUsIG1lc3NhZ2UsIGF0dHJpYnV0ZXMgKSB7XG5cdHZhciBlcnJvcjtcblxuXHRtZXNzYWdlID0gY29kZSArICggbWVzc2FnZSA/IFwiOiBcIiArIGZvcm1hdE1lc3NhZ2UoIG1lc3NhZ2UsIGF0dHJpYnV0ZXMgKSA6IFwiXCIgKTtcblx0ZXJyb3IgPSBuZXcgRXJyb3IoIG1lc3NhZ2UgKTtcblx0ZXJyb3IuY29kZSA9IGNvZGU7XG5cblx0b2JqZWN0RXh0ZW5kKCBlcnJvciwgYXR0cmlidXRlcyApO1xuXG5cdHJldHVybiBlcnJvcjtcbn07XG5cblxuXG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzYxNjQ2MS9nZW5lcmF0ZS1hLWhhc2gtZnJvbS1zdHJpbmctaW4tamF2YXNjcmlwdC1qcXVlcnlcbnZhciBzdHJpbmdIYXNoID0gZnVuY3Rpb24oIHN0ciApIHtcblx0cmV0dXJuIFtdLnJlZHVjZS5jYWxsKCBzdHIsIGZ1bmN0aW9uKCBoYXNoLCBpICkge1xuXHRcdHZhciBjaHIgPSBpLmNoYXJDb2RlQXQoIDAgKTtcblx0XHRoYXNoID0gKCAoIGhhc2ggPDwgNSApIC0gaGFzaCApICsgY2hyO1xuXHRcdHJldHVybiBoYXNoIHwgMDtcblx0fSwgMCApO1xufTtcblxuXG5cblxudmFyIHJ1bnRpbWVLZXkgPSBmdW5jdGlvbiggZm5OYW1lLCBsb2NhbGUsIGFyZ3MsIGFyZ3NTdHIgKSB7XG5cdHZhciBoYXNoO1xuXHRhcmdzU3RyID0gYXJnc1N0ciB8fCBKU09OLnN0cmluZ2lmeSggYXJncyApO1xuXHRoYXNoID0gc3RyaW5nSGFzaCggZm5OYW1lICsgbG9jYWxlICsgYXJnc1N0ciApO1xuXHRyZXR1cm4gaGFzaCA+IDAgPyBcImFcIiArIGhhc2ggOiBcImJcIiArIE1hdGguYWJzKCBoYXNoICk7XG59O1xuXG5cblxuXG52YXIgZnVuY3Rpb25OYW1lID0gZnVuY3Rpb24oIGZuICkge1xuXHRpZiAoIGZuLm5hbWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRyZXR1cm4gZm4ubmFtZTtcblx0fVxuXG5cdC8vIGZuLm5hbWUgaXMgbm90IHN1cHBvcnRlZCBieSBJRS5cblx0dmFyIG1hdGNoZXMgPSAvXmZ1bmN0aW9uXFxzKyhbXFx3XFwkXSspXFxzKlxcKC8uZXhlYyggZm4udG9TdHJpbmcoKSApO1xuXG5cdGlmICggbWF0Y2hlcyAmJiBtYXRjaGVzLmxlbmd0aCA+IDAgKSB7XG5cdFx0cmV0dXJuIG1hdGNoZXNbIDEgXTtcblx0fVxufTtcblxuXG5cblxudmFyIHJ1bnRpbWVCaW5kID0gZnVuY3Rpb24oIGFyZ3MsIGNsZHIsIGZuLCBydW50aW1lQXJncyApIHtcblxuXHR2YXIgYXJnc1N0ciA9IEpTT04uc3RyaW5naWZ5KCBhcmdzICksXG5cdFx0Zm5OYW1lID0gZnVuY3Rpb25OYW1lKCBmbiApLFxuXHRcdGxvY2FsZSA9IGNsZHIubG9jYWxlO1xuXG5cdC8vIElmIG5hbWUgb2YgdGhlIGZ1bmN0aW9uIGlzIG5vdCBhdmFpbGFibGUsIHRoaXMgaXMgbW9zdCBsaWtlbHkgZHVlIHRvIHVnbGlmaWNhdGlvbixcblx0Ly8gd2hpY2ggbW9zdCBsaWtlbHkgbWVhbnMgd2UgYXJlIGluIHByb2R1Y3Rpb24sIGFuZCBydW50aW1lQmluZCBoZXJlIGlzIG5vdCBuZWNlc3NhcnkuXG5cdGlmICggIWZuTmFtZSApIHtcblx0XHRyZXR1cm4gZm47XG5cdH1cblxuXHRmbi5ydW50aW1lS2V5ID0gcnVudGltZUtleSggZm5OYW1lLCBsb2NhbGUsIG51bGwsIGFyZ3NTdHIgKTtcblxuXHRmbi5nZW5lcmF0b3JTdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJHbG9iYWxpemUoXFxcIlwiICsgbG9jYWxlICsgXCJcXFwiKS5cIiArIGZuTmFtZSArIFwiKFwiICsgYXJnc1N0ci5zbGljZSggMSwgLTEgKSArIFwiKVwiO1xuXHR9O1xuXG5cdGZuLnJ1bnRpbWVBcmdzID0gcnVudGltZUFyZ3M7XG5cblx0cmV0dXJuIGZuO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlID0gZnVuY3Rpb24oIGNvZGUsIG1lc3NhZ2UsIGNoZWNrLCBhdHRyaWJ1dGVzICkge1xuXHRpZiAoICFjaGVjayApIHtcblx0XHR0aHJvdyBjcmVhdGVFcnJvciggY29kZSwgbWVzc2FnZSwgYXR0cmlidXRlcyApO1xuXHR9XG59O1xuXG5cblxuXG52YXIgYWx3YXlzQXJyYXkgPSBmdW5jdGlvbiggc3RyaW5nT3JBcnJheSApIHtcblx0cmV0dXJuIEFycmF5LmlzQXJyYXkoIHN0cmluZ09yQXJyYXkgKSA/IHN0cmluZ09yQXJyYXkgOiBzdHJpbmdPckFycmF5ID8gWyBzdHJpbmdPckFycmF5IF0gOiBbXTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZUNsZHIgPSBmdW5jdGlvbiggcGF0aCwgdmFsdWUsIG9wdGlvbnMgKSB7XG5cdHZhciBza2lwQm9vbGVhbjtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0c2tpcEJvb2xlYW4gPSBhbHdheXNBcnJheSggb3B0aW9ucy5za2lwICkuc29tZShmdW5jdGlvbiggcGF0aFJlICkge1xuXHRcdHJldHVybiBwYXRoUmUudGVzdCggcGF0aCApO1xuXHR9KTtcblxuXHR2YWxpZGF0ZSggXCJFX01JU1NJTkdfQ0xEUlwiLCBcIk1pc3NpbmcgcmVxdWlyZWQgQ0xEUiBjb250ZW50IGB7cGF0aH1gLlwiLCB2YWx1ZSB8fCBza2lwQm9vbGVhbiwge1xuXHRcdHBhdGg6IHBhdGhcblx0fSk7XG59O1xuXG5cblxuXG52YXIgdmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHR2YWxpZGF0ZSggXCJFX0RFRkFVTFRfTE9DQUxFX05PVF9ERUZJTkVEXCIsIFwiRGVmYXVsdCBsb2NhbGUgaGFzIG5vdCBiZWVuIGRlZmluZWQuXCIsXG5cdFx0dmFsdWUgIT09IHVuZGVmaW5lZCwge30gKTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZSggXCJFX01JU1NJTkdfUEFSQU1FVEVSXCIsIFwiTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXIgYHtuYW1lfWAuXCIsXG5cdFx0dmFsdWUgIT09IHVuZGVmaW5lZCwgeyBuYW1lOiBuYW1lIH0pO1xufTtcblxuXG5cblxuLyoqXG4gKiByYW5nZSggdmFsdWUsIG5hbWUsIG1pbmltdW0sIG1heGltdW0gKVxuICpcbiAqIEB2YWx1ZSBbTnVtYmVyXS5cbiAqXG4gKiBAbmFtZSBbU3RyaW5nXSBuYW1lIG9mIHZhcmlhYmxlLlxuICpcbiAqIEBtaW5pbXVtIFtOdW1iZXJdLiBUaGUgbG93ZXN0IHZhbGlkIHZhbHVlLCBpbmNsdXNpdmUuXG4gKlxuICogQG1heGltdW0gW051bWJlcl0uIFRoZSBncmVhdGVzdCB2YWxpZCB2YWx1ZSwgaW5jbHVzaXZlLlxuICovXG52YXIgdmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSwgbWluaW11bSwgbWF4aW11bSApIHtcblx0dmFsaWRhdGUoXG5cdFx0XCJFX1BBUl9PVVRfT0ZfUkFOR0VcIixcblx0XHRcIlBhcmFtZXRlciBge25hbWV9YCBoYXMgdmFsdWUgYHt2YWx1ZX1gIG91dCBvZiByYW5nZSBbe21pbmltdW19LCB7bWF4aW11bX1dLlwiLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPj0gbWluaW11bSAmJiB2YWx1ZSA8PSBtYXhpbXVtLFxuXHRcdHtcblx0XHRcdG1heGltdW06IG1heGltdW0sXG5cdFx0XHRtaW5pbXVtOiBtaW5pbXVtLFxuXHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdH1cblx0KTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGUgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUsIGNoZWNrLCBleHBlY3RlZCApIHtcblx0dmFsaWRhdGUoXG5cdFx0XCJFX0lOVkFMSURfUEFSX1RZUEVcIixcblx0XHRcIkludmFsaWQgYHtuYW1lfWAgcGFyYW1ldGVyICh7dmFsdWV9KS4ge2V4cGVjdGVkfSBleHBlY3RlZC5cIixcblx0XHRjaGVjayxcblx0XHR7XG5cdFx0XHRleHBlY3RlZDogZXhwZWN0ZWQsXG5cdFx0XHRuYW1lOiBuYW1lLFxuXHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0fVxuXHQpO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZUxvY2FsZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxuXHRcdHZhbHVlLFxuXHRcdG5hbWUsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgfHwgdmFsdWUgaW5zdGFuY2VvZiBDbGRyLFxuXHRcdFwiU3RyaW5nIG9yIENsZHIgaW5zdGFuY2VcIlxuXHQpO1xufTtcblxuXG5cblxuLyoqXG4gKiBGdW5jdGlvbiBpbnNwaXJlZCBieSBqUXVlcnkgQ29yZSwgYnV0IHJlZHVjZWQgdG8gb3VyIHVzZSBjYXNlLlxuICovXG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdHJldHVybiBvYmogIT09IG51bGwgJiYgXCJcIiArIG9iaiA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxuXHRcdHZhbHVlLFxuXHRcdG5hbWUsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCBpc1BsYWluT2JqZWN0KCB2YWx1ZSApLFxuXHRcdFwiUGxhaW4gT2JqZWN0XCJcblx0KTtcbn07XG5cblxuXG5cbnZhciBhbHdheXNDbGRyID0gZnVuY3Rpb24oIGxvY2FsZU9yQ2xkciApIHtcblx0cmV0dXJuIGxvY2FsZU9yQ2xkciBpbnN0YW5jZW9mIENsZHIgPyBsb2NhbGVPckNsZHIgOiBuZXcgQ2xkciggbG9jYWxlT3JDbGRyICk7XG59O1xuXG5cblxuXG4vLyByZWY6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvR3VpZGUvUmVndWxhcl9FeHByZXNzaW9ucz9yZWRpcmVjdGxvY2FsZT1lbi1VUyZyZWRpcmVjdHNsdWc9SmF2YVNjcmlwdCUyRkd1aWRlJTJGUmVndWxhcl9FeHByZXNzaW9uc1xudmFyIHJlZ2V4cEVzY2FwZSA9IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggLyhbLiorP149IToke30oKXxcXFtcXF1cXC9cXFxcXSkvZywgXCJcXFxcJDFcIiApO1xufTtcblxuXG5cblxudmFyIHN0cmluZ1BhZCA9IGZ1bmN0aW9uKCBzdHIsIGNvdW50LCByaWdodCApIHtcblx0dmFyIGxlbmd0aDtcblx0aWYgKCB0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHN0ciA9IFN0cmluZyggc3RyICk7XG5cdH1cblx0Zm9yICggbGVuZ3RoID0gc3RyLmxlbmd0aDsgbGVuZ3RoIDwgY291bnQ7IGxlbmd0aCArPSAxICkge1xuXHRcdHN0ciA9ICggcmlnaHQgPyAoIHN0ciArIFwiMFwiICkgOiAoIFwiMFwiICsgc3RyICkgKTtcblx0fVxuXHRyZXR1cm4gc3RyO1xufTtcblxuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVMaWtlbHlTdWJ0YWdzKCBjbGRyICkge1xuXHRjbGRyLm9uY2UoIFwiZ2V0XCIsIHZhbGlkYXRlQ2xkciApO1xuXHRjbGRyLmdldCggXCJzdXBwbGVtZW50YWwvbGlrZWx5U3VidGFnc1wiICk7XG59XG5cbi8qKlxuICogW25ld10gR2xvYmFsaXplKCBsb2NhbGV8Y2xkciApXG4gKlxuICogQGxvY2FsZSBbU3RyaW5nXVxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXVxuICpcbiAqIENyZWF0ZSBhIEdsb2JhbGl6ZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gR2xvYmFsaXplKCBsb2NhbGUgKSB7XG5cdGlmICggISggdGhpcyBpbnN0YW5jZW9mIEdsb2JhbGl6ZSApICkge1xuXHRcdHJldHVybiBuZXcgR2xvYmFsaXplKCBsb2NhbGUgKTtcblx0fVxuXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIGxvY2FsZSwgXCJsb2NhbGVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVMb2NhbGUoIGxvY2FsZSwgXCJsb2NhbGVcIiApO1xuXG5cdHRoaXMuY2xkciA9IGFsd2F5c0NsZHIoIGxvY2FsZSApO1xuXG5cdHZhbGlkYXRlTGlrZWx5U3VidGFncyggdGhpcy5jbGRyICk7XG59XG5cbi8qKlxuICogR2xvYmFsaXplLmxvYWQoIGpzb24sIC4uLiApXG4gKlxuICogQGpzb24gW0pTT05dXG4gKlxuICogTG9hZCByZXNvbHZlZCBvciB1bnJlc29sdmVkIGNsZHIgZGF0YS5cbiAqIFNvbWV3aGF0IGVxdWl2YWxlbnQgdG8gcHJldmlvdXMgR2xvYmFsaXplLmFkZEN1bHR1cmVJbmZvKC4uLikuXG4gKi9cbkdsb2JhbGl6ZS5sb2FkID0gZnVuY3Rpb24oKSB7XG5cblx0Ly8gdmFsaWRhdGlvbnMgYXJlIGRlbGVnYXRlZCB0byBDbGRyLmxvYWQoKS5cblx0Q2xkci5sb2FkLmFwcGx5KCBDbGRyLCBhcmd1bWVudHMgKTtcbn07XG5cbi8qKlxuICogR2xvYmFsaXplLmxvY2FsZSggW2xvY2FsZXxjbGRyXSApXG4gKlxuICogQGxvY2FsZSBbU3RyaW5nXVxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXVxuICpcbiAqIFNldCBkZWZhdWx0IENsZHIgaW5zdGFuY2UgaWYgbG9jYWxlIG9yIGNsZHIgYXJndW1lbnQgaXMgcGFzc2VkLlxuICpcbiAqIFJldHVybiB0aGUgZGVmYXVsdCBDbGRyIGluc3RhbmNlLlxuICovXG5HbG9iYWxpemUubG9jYWxlID0gZnVuY3Rpb24oIGxvY2FsZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTG9jYWxlKCBsb2NhbGUsIFwibG9jYWxlXCIgKTtcblxuXHRpZiAoIGFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0dGhpcy5jbGRyID0gYWx3YXlzQ2xkciggbG9jYWxlICk7XG5cdFx0dmFsaWRhdGVMaWtlbHlTdWJ0YWdzKCB0aGlzLmNsZHIgKTtcblx0fVxuXHRyZXR1cm4gdGhpcy5jbGRyO1xufTtcblxuLyoqXG4gKiBPcHRpbWl6YXRpb24gdG8gYXZvaWQgZHVwbGljYXRpbmcgc29tZSBpbnRlcm5hbCBmdW5jdGlvbnMgYWNyb3NzIG1vZHVsZXMuXG4gKi9cbkdsb2JhbGl6ZS5fYWx3YXlzQXJyYXkgPSBhbHdheXNBcnJheTtcbkdsb2JhbGl6ZS5fY3JlYXRlRXJyb3IgPSBjcmVhdGVFcnJvcjtcbkdsb2JhbGl6ZS5fZm9ybWF0TWVzc2FnZSA9IGZvcm1hdE1lc3NhZ2U7XG5HbG9iYWxpemUuX2lzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuR2xvYmFsaXplLl9vYmplY3RFeHRlbmQgPSBvYmplY3RFeHRlbmQ7XG5HbG9iYWxpemUuX3JlZ2V4cEVzY2FwZSA9IHJlZ2V4cEVzY2FwZTtcbkdsb2JhbGl6ZS5fcnVudGltZUJpbmQgPSBydW50aW1lQmluZDtcbkdsb2JhbGl6ZS5fc3RyaW5nUGFkID0gc3RyaW5nUGFkO1xuR2xvYmFsaXplLl92YWxpZGF0ZSA9IHZhbGlkYXRlO1xuR2xvYmFsaXplLl92YWxpZGF0ZUNsZHIgPSB2YWxpZGF0ZUNsZHI7XG5HbG9iYWxpemUuX3ZhbGlkYXRlRGVmYXVsdExvY2FsZSA9IHZhbGlkYXRlRGVmYXVsdExvY2FsZTtcbkdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2U7XG5HbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UgPSB2YWxpZGF0ZVBhcmFtZXRlclJhbmdlO1xuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCA9IHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0O1xuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGUgPSB2YWxpZGF0ZVBhcmFtZXRlclR5cGU7XG5cbnJldHVybiBHbG9iYWxpemU7XG5cblxuXG5cbn0pKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGRlZmluZSA9IGZhbHNlO1xuXG4vKiFcbiAqIEdsb2JhbGl6ZSB2MS4zLjBcbiAqXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDctMDNUMjE6MzdaXG4gKi9cbihmdW5jdGlvbiggcm9vdCwgZmFjdG9yeSApIHtcblxuXHQvLyBVTUQgcmV0dXJuRXhwb3J0c1xuXHRpZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXG5cdFx0Ly8gQU1EXG5cdFx0ZGVmaW5lKFtcblx0XHRcdFwiY2xkclwiLFxuXHRcdFx0XCIuLi9nbG9iYWxpemVcIixcblx0XHRcdFwiLi9udW1iZXJcIixcblx0XHRcdFwiY2xkci9ldmVudFwiLFxuXHRcdFx0XCJjbGRyL3N1cHBsZW1lbnRhbFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIE5vZGUsIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImNsZHJqc1wiICksIHJlcXVpcmUoIFwiLi4vZ2xvYmFsaXplXCIgKSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gR2xvYmFsXG5cdFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XG5cbnZhciBhbHdheXNBcnJheSA9IEdsb2JhbGl6ZS5fYWx3YXlzQXJyYXksXG5cdGZvcm1hdE1lc3NhZ2UgPSBHbG9iYWxpemUuX2Zvcm1hdE1lc3NhZ2UsXG5cdG51bWJlck51bWJlcmluZ1N5c3RlbSA9IEdsb2JhbGl6ZS5fbnVtYmVyTnVtYmVyaW5nU3lzdGVtLFxuXHRudW1iZXJQYXR0ZXJuID0gR2xvYmFsaXplLl9udW1iZXJQYXR0ZXJuLFxuXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXG5cdHN0cmluZ1BhZCA9IEdsb2JhbGl6ZS5fc3RyaW5nUGFkLFxuXHR2YWxpZGF0ZUNsZHIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlQ2xkcixcblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlcixcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0O1xuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVDdXJyZW5jeSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxuXHRcdHZhbHVlLFxuXHRcdG5hbWUsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgKCAvXltBLVphLXpdezN9JC8gKS50ZXN0KCB2YWx1ZSApLFxuXHRcdFwiMy1sZXR0ZXIgY3VycmVuY3kgY29kZSBzdHJpbmcgYXMgZGVmaW5lZCBieSBJU08gNDIxN1wiXG5cdCk7XG59O1xuXG5cblxuXG4vKipcbiAqIHN1cHBsZW1lbnRhbE92ZXJyaWRlKCBjdXJyZW5jeSwgcGF0dGVybiwgY2xkciApXG4gKlxuICogUmV0dXJuIHBhdHRlcm4gd2l0aCBmcmFjdGlvbiBkaWdpdHMgb3ZlcnJpZGVuIGJ5IHN1cHBsZW1lbnRhbCBjdXJyZW5jeSBkYXRhLlxuICovXG52YXIgY3VycmVuY3lTdXBwbGVtZW50YWxPdmVycmlkZSA9IGZ1bmN0aW9uKCBjdXJyZW5jeSwgcGF0dGVybiwgY2xkciApIHtcblx0dmFyIGRpZ2l0cyxcblx0XHRmcmFjdGlvbiA9IFwiXCIsXG5cdFx0ZnJhY3Rpb25EYXRhID0gY2xkci5zdXBwbGVtZW50YWwoWyBcImN1cnJlbmN5RGF0YS9mcmFjdGlvbnNcIiwgY3VycmVuY3kgXSkgfHxcblx0XHRcdGNsZHIuc3VwcGxlbWVudGFsKCBcImN1cnJlbmN5RGF0YS9mcmFjdGlvbnMvREVGQVVMVFwiICk7XG5cblx0ZGlnaXRzID0gK2ZyYWN0aW9uRGF0YS5fZGlnaXRzO1xuXG5cdGlmICggZGlnaXRzICkge1xuXHRcdGZyYWN0aW9uID0gXCIuXCIgKyBzdHJpbmdQYWQoIFwiMFwiLCBkaWdpdHMgKS5zbGljZSggMCwgLTEgKSArIGZyYWN0aW9uRGF0YS5fcm91bmRpbmc7XG5cdH1cblxuXHRyZXR1cm4gcGF0dGVybi5yZXBsYWNlKCAvXFwuKCMrfDAqWzAtOV18MCtbMC05XT8pL2csIGZyYWN0aW9uICk7XG59O1xuXG5cblxuXG52YXIgb2JqZWN0RmlsdGVyID0gZnVuY3Rpb24oIG9iamVjdCwgdGVzdFJlICkge1xuXHR2YXIga2V5LFxuXHRcdGNvcHkgPSB7fTtcblxuXHRmb3IgKCBrZXkgaW4gb2JqZWN0ICkge1xuXHRcdGlmICggdGVzdFJlLnRlc3QoIGtleSApICkge1xuXHRcdFx0Y29weVsga2V5IF0gPSBvYmplY3RbIGtleSBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb3B5O1xufTtcblxuXG5cblxudmFyIGN1cnJlbmN5VW5pdFBhdHRlcm5zID0gZnVuY3Rpb24oIGNsZHIgKSB7XG5cdHJldHVybiBvYmplY3RGaWx0ZXIoIGNsZHIubWFpbihbXG5cdFx0XCJudW1iZXJzXCIsXG5cdFx0XCJjdXJyZW5jeUZvcm1hdHMtbnVtYmVyU3lzdGVtLVwiICsgbnVtYmVyTnVtYmVyaW5nU3lzdGVtKCBjbGRyIClcblx0XSksIC9edW5pdFBhdHRlcm4vICk7XG59O1xuXG5cblxuXG4vKipcbiAqIGNvZGVQcm9wZXJ0aWVzKCBjdXJyZW5jeSwgY2xkciApXG4gKlxuICogUmV0dXJuIG51bWJlciBwYXR0ZXJuIHdpdGggdGhlIGFwcHJvcHJpYXRlIGN1cnJlbmN5IGNvZGUgaW4gYXMgbGl0ZXJhbC5cbiAqL1xudmFyIGN1cnJlbmN5Q29kZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggY3VycmVuY3ksIGNsZHIgKSB7XG5cdHZhciBwYXR0ZXJuID0gbnVtYmVyUGF0dGVybiggXCJkZWNpbWFsXCIsIGNsZHIgKTtcblxuXHQvLyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGFuZCB0aGUgcm91bmRpbmcgZm9yIGVhY2ggY3VycmVuY3kgaXMgbm90IGxvY2FsZS1zcGVjaWZpYy4gVGhvc2Vcblx0Ly8gdmFsdWVzIG92ZXJyaWRkZW4gYnkgU3VwcGxlbWVudGFsIEN1cnJlbmN5IERhdGEuXG5cdHBhdHRlcm4gPSBjdXJyZW5jeVN1cHBsZW1lbnRhbE92ZXJyaWRlKCBjdXJyZW5jeSwgcGF0dGVybiwgY2xkciApO1xuXG5cdHJldHVybiB7XG5cdFx0Y3VycmVuY3k6IGN1cnJlbmN5LFxuXHRcdHBhdHRlcm46IHBhdHRlcm4sXG5cdFx0dW5pdFBhdHRlcm5zOiBjdXJyZW5jeVVuaXRQYXR0ZXJucyggY2xkciApXG5cdH07XG59O1xuXG5cblxuXG4vKipcbiAqIG5hbWVGb3JtYXQoIGZvcm1hdHRlZE51bWJlciwgcGx1cmFsRm9ybSwgcHJvcGVydGllcyApXG4gKlxuICogUmV0dXJuIHRoZSBhcHByb3ByaWF0ZSBuYW1lIGZvcm0gY3VycmVuY3kgZm9ybWF0LlxuICovXG52YXIgY3VycmVuY3lOYW1lRm9ybWF0ID0gZnVuY3Rpb24oIGZvcm1hdHRlZE51bWJlciwgcGx1cmFsRm9ybSwgcHJvcGVydGllcyApIHtcblx0dmFyIGRpc3BsYXlOYW1lLCB1bml0UGF0dGVybixcblx0XHRkaXNwbGF5TmFtZXMgPSBwcm9wZXJ0aWVzLmRpc3BsYXlOYW1lcyB8fCB7fSxcblx0XHR1bml0UGF0dGVybnMgPSBwcm9wZXJ0aWVzLnVuaXRQYXR0ZXJucztcblxuXHRkaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lc1sgXCJkaXNwbGF5TmFtZS1jb3VudC1cIiArIHBsdXJhbEZvcm0gXSB8fFxuXHRcdGRpc3BsYXlOYW1lc1sgXCJkaXNwbGF5TmFtZS1jb3VudC1vdGhlclwiIF0gfHxcblx0XHRkaXNwbGF5TmFtZXMuZGlzcGxheU5hbWUgfHxcblx0XHRwcm9wZXJ0aWVzLmN1cnJlbmN5O1xuXHR1bml0UGF0dGVybiA9IHVuaXRQYXR0ZXJuc1sgXCJ1bml0UGF0dGVybi1jb3VudC1cIiArIHBsdXJhbEZvcm0gXSB8fFxuXHRcdHVuaXRQYXR0ZXJuc1sgXCJ1bml0UGF0dGVybi1jb3VudC1vdGhlclwiIF07XG5cblx0cmV0dXJuIGZvcm1hdE1lc3NhZ2UoIHVuaXRQYXR0ZXJuLCBbIGZvcm1hdHRlZE51bWJlciwgZGlzcGxheU5hbWUgXSk7XG59O1xuXG5cblxuXG52YXIgY3VycmVuY3lGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApIHtcblx0dmFyIGZuO1xuXG5cdC8vIFJldHVybiBmb3JtYXR0ZXIgd2hlbiBzdHlsZSBpcyBcImNvZGVcIiBvciBcIm5hbWVcIi5cblx0aWYgKCBwbHVyYWxHZW5lcmF0b3IgJiYgcHJvcGVydGllcyApIHtcblx0XHRmbiA9IGZ1bmN0aW9uIGN1cnJlbmN5Rm9ybWF0dGVyKCB2YWx1ZSApIHtcblx0XHRcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0XHRcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRcdFx0cmV0dXJuIGN1cnJlbmN5TmFtZUZvcm1hdChcblx0XHRcdFx0bnVtYmVyRm9ybWF0dGVyKCB2YWx1ZSApLFxuXHRcdFx0XHRwbHVyYWxHZW5lcmF0b3IoIHZhbHVlICksXG5cdFx0XHRcdHByb3BlcnRpZXNcblx0XHRcdCk7XG5cdFx0fTtcblxuXHQvLyBSZXR1cm4gZm9ybWF0dGVyIHdoZW4gc3R5bGUgaXMgXCJzeW1ib2xcIiBvciBcImFjY291bnRpbmdcIi5cblx0fSBlbHNlIHtcblx0XHRmbiA9IGZ1bmN0aW9uIGN1cnJlbmN5Rm9ybWF0dGVyKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiBudW1iZXJGb3JtYXR0ZXIoIHZhbHVlICk7XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBmbjtcbn07XG5cblxuXG5cbi8qKlxuICogbmFtZVByb3BlcnRpZXMoIGN1cnJlbmN5LCBjbGRyIClcbiAqXG4gKiBSZXR1cm4gbnVtYmVyIHBhdHRlcm4gd2l0aCB0aGUgYXBwcm9wcmlhdGUgY3VycmVuY3kgY29kZSBpbiBhcyBsaXRlcmFsLlxuICovXG52YXIgY3VycmVuY3lOYW1lUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBjdXJyZW5jeSwgY2xkciApIHtcblx0dmFyIHByb3BlcnRpZXMgPSBjdXJyZW5jeUNvZGVQcm9wZXJ0aWVzKCBjdXJyZW5jeSwgY2xkciApO1xuXG5cdHByb3BlcnRpZXMuZGlzcGxheU5hbWVzID0gb2JqZWN0RmlsdGVyKCBjbGRyLm1haW4oW1xuXHRcdFwibnVtYmVycy9jdXJyZW5jaWVzXCIsXG5cdFx0Y3VycmVuY3lcblx0XSksIC9eZGlzcGxheU5hbWUvICk7XG5cblx0cmV0dXJuIHByb3BlcnRpZXM7XG59O1xuXG5cblxuXG4vKipcbiAqIFVuaWNvZGUgcmVndWxhciBleHByZXNzaW9uIGZvcjogZXZlcnl0aGluZyBleGNlcHQgbWF0aCBzeW1ib2xzLCBjdXJyZW5jeSBzaWducywgZGluZ2JhdHMsIGFuZFxuICogYm94LWRyYXdpbmcgY2hhcmFjdGVycy5cbiAqXG4gKiBHZW5lcmF0ZWQgYnk6XG4gKlxuICogcmVnZW5lcmF0ZSgpXG4gKiAgIC5hZGRSYW5nZSggMHgwLCAweDEwRkZGRiApXG4gKiAgIC5yZW1vdmUoIHJlcXVpcmUoIFwidW5pY29kZS03LjAuMC9jYXRlZ29yaWVzL1Mvc3ltYm9sc1wiICkgKS50b1N0cmluZygpO1xuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3JlZ2VuZXJhdGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3VuaWNvZGUtNy4wLjBcbiAqL1xudmFyIHJlZ2V4cE5vdFMgPSAvW1xcMC0jJS1cXCosLTtcXD8tXFxdX2EtXFx7XFx9XFx4N0YtXFx4QTFcXHhBN1xceEFBXFx4QUJcXHhBRFxceEIyXFx4QjNcXHhCNS1cXHhCN1xceEI5LVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzAwLVxcdTAzNzRcXHUwMzc2LVxcdTAzODNcXHUwMzg2LVxcdTAzRjVcXHUwM0Y3LVxcdTA0ODFcXHUwNDgzLVxcdTA1OENcXHUwNTkwLVxcdTA2MDVcXHUwNjA5XFx1MDYwQVxcdTA2MENcXHUwNjBEXFx1MDYxMC1cXHUwNkREXFx1MDZERi1cXHUwNkU4XFx1MDZFQS1cXHUwNkZDXFx1MDZGRi1cXHUwN0Y1XFx1MDdGNy1cXHUwOUYxXFx1MDlGNC1cXHUwOUY5XFx1MDlGQy1cXHUwQUYwXFx1MEFGMi1cXHUwQjZGXFx1MEI3MS1cXHUwQkYyXFx1MEJGQi1cXHUwQzdFXFx1MEM4MC1cXHUwRDc4XFx1MEQ3QS1cXHUwRTNFXFx1MEU0MC1cXHUwRjAwXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGMThcXHUwRjE5XFx1MEYyMC1cXHUwRjMzXFx1MEYzNVxcdTBGMzdcXHUwRjM5LVxcdTBGQkRcXHUwRkM2XFx1MEZDRFxcdTBGRDAtXFx1MEZENFxcdTBGRDktXFx1MTA5RFxcdTEwQTAtXFx1MTM4RlxcdTEzOUEtXFx1MTdEQVxcdTE3REMtXFx1MTkzRlxcdTE5NDEtXFx1MTlERFxcdTFBMDAtXFx1MUI2MFxcdTFCNkItXFx1MUI3M1xcdTFCN0QtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQ0NcXHUxRkQwLVxcdTFGRENcXHUxRkUwLVxcdTFGRUNcXHUxRkYwLVxcdTFGRkNcXHUxRkZGLVxcdTIwNDNcXHUyMDQ1LVxcdTIwNTFcXHUyMDUzLVxcdTIwNzlcXHUyMDdELVxcdTIwODlcXHUyMDhELVxcdTIwOUZcXHUyMEJFLVxcdTIwRkZcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE1MC1cXHUyMThGXFx1MjMwOC1cXHUyMzBCXFx1MjMyOVxcdTIzMkFcXHUyM0ZCLVxcdTIzRkZcXHUyNDI3LVxcdTI0M0ZcXHUyNDRCLVxcdTI0OUJcXHUyNEVBLVxcdTI0RkZcXHUyNzY4LVxcdTI3OTNcXHUyN0M1XFx1MjdDNlxcdTI3RTYtXFx1MjdFRlxcdTI5ODMtXFx1Mjk5OFxcdTI5RDgtXFx1MjlEQlxcdTI5RkNcXHUyOUZEXFx1MkI3NFxcdTJCNzVcXHUyQjk2XFx1MkI5N1xcdTJCQkEtXFx1MkJCQ1xcdTJCQzlcXHUyQkQyLVxcdTJDRTRcXHUyQ0VCLVxcdTJFN0ZcXHUyRTlBXFx1MkVGNC1cXHUyRUZGXFx1MkZENi1cXHUyRkVGXFx1MkZGQy1cXHUzMDAzXFx1MzAwNS1cXHUzMDExXFx1MzAxNC1cXHUzMDFGXFx1MzAyMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNEXFx1MzA0MC1cXHUzMDlBXFx1MzA5RC1cXHUzMThGXFx1MzE5Mi1cXHUzMTk1XFx1MzFBMC1cXHUzMUJGXFx1MzFFNC1cXHUzMUZGXFx1MzIxRi1cXHUzMjI5XFx1MzI0OC1cXHUzMjRGXFx1MzI1MS1cXHUzMjVGXFx1MzI4MC1cXHUzMjg5XFx1MzJCMS1cXHUzMkJGXFx1MzJGRlxcdTM0MDAtXFx1NERCRlxcdTRFMDAtXFx1QTQ4RlxcdUE0QzctXFx1QTZGRlxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTgyN1xcdUE4MkMtXFx1QTgzNVxcdUE4M0EtXFx1QUE3NlxcdUFBN0EtXFx1QUI1QVxcdUFCNUMtXFx1RDdGRlxcdURDMDAtXFx1RkIyOFxcdUZCMkEtXFx1RkJCMVxcdUZCQzItXFx1RkRGQlxcdUZERkUtXFx1RkU2MVxcdUZFNjNcXHVGRTY3XFx1RkU2OFxcdUZFNkEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYxQlxcdUZGMUYtXFx1RkYzRFxcdUZGM0ZcXHVGRjQxLVxcdUZGNUJcXHVGRjVEXFx1RkY1Ri1cXHVGRkRGXFx1RkZFN1xcdUZGRUYtXFx1RkZGQlxcdUZGRkVcXHVGRkZGXXxcXHVEODAwW1xcdURDMDAtXFx1REQzNlxcdURENDAtXFx1REQ3OFxcdUREOEFcXHVERDhCXFx1REQ4RC1cXHVERDhGXFx1REQ5Qy1cXHVERDlGXFx1RERBMS1cXHVERENGXFx1RERGRC1cXHVERkZGXXxbXFx1RDgwMVxcdUQ4MDMtXFx1RDgxOVxcdUQ4MUItXFx1RDgyRVxcdUQ4MzAtXFx1RDgzM1xcdUQ4MzYtXFx1RDgzQVxcdUQ4M0YtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXXxcXHVEODAyW1xcdURDMDAtXFx1REM3NlxcdURDNzktXFx1REVDN1xcdURFQzktXFx1REZGRl18XFx1RDgxQVtcXHVEQzAwLVxcdURGM0JcXHVERjQwLVxcdURGNDRcXHVERjQ2LVxcdURGRkZdfFxcdUQ4MkZbXFx1REMwMC1cXHVEQzlCXFx1REM5RC1cXHVERkZGXXxcXHVEODM0W1xcdURDRjYtXFx1RENGRlxcdUREMjdcXHVERDI4XFx1REQ2NS1cXHVERDY5XFx1REQ2RC1cXHVERDgyXFx1REQ4NS1cXHVERDhCXFx1RERBQS1cXHVEREFEXFx1RERERS1cXHVEREZGXFx1REU0Mi1cXHVERTQ0XFx1REU0Ni1cXHVERUZGXFx1REY1Ny1cXHVERkZGXXxcXHVEODM1W1xcdURDMDAtXFx1REVDMFxcdURFQzItXFx1REVEQVxcdURFREMtXFx1REVGQVxcdURFRkMtXFx1REYxNFxcdURGMTYtXFx1REYzNFxcdURGMzYtXFx1REY0RVxcdURGNTAtXFx1REY2RVxcdURGNzAtXFx1REY4OFxcdURGOEEtXFx1REZBOFxcdURGQUEtXFx1REZDMlxcdURGQzQtXFx1REZGRl18XFx1RDgzQltcXHVEQzAwLVxcdURFRUZcXHVERUYyLVxcdURGRkZdfFxcdUQ4M0NbXFx1REMyQy1cXHVEQzJGXFx1REM5NC1cXHVEQzlGXFx1RENBRlxcdURDQjBcXHVEQ0MwXFx1RENEMFxcdURDRjYtXFx1REQwRlxcdUREMkZcXHVERDZDLVxcdURENkZcXHVERDlCLVxcdURERTVcXHVERTAzLVxcdURFMEZcXHVERTNCLVxcdURFM0ZcXHVERTQ5LVxcdURFNEZcXHVERTUyLVxcdURFRkZcXHVERjJELVxcdURGMkZcXHVERjdFXFx1REY3RlxcdURGQ0YtXFx1REZEM1xcdURGRjgtXFx1REZGRl18XFx1RDgzRFtcXHVEQ0ZGXFx1REQ0Qi1cXHVERDRGXFx1REQ3QVxcdUREQTRcXHVERTQzXFx1REU0NFxcdURFRDAtXFx1REVERlxcdURFRUQtXFx1REVFRlxcdURFRjQtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURGRkZdfFtcXHVEODAwLVxcdURCRkZdLztcblxuXG5cblxuLyoqXG4gKiBzeW1ib2xQcm9wZXJ0aWVzKCBjdXJyZW5jeSwgY2xkciApXG4gKlxuICogUmV0dXJuIHBhdHRlcm4gcmVwbGFjaW5nIGDCpGAgd2l0aCB0aGUgYXBwcm9wcmlhdGUgY3VycmVuY3kgc3ltYm9sIGxpdGVyYWwuXG4gKi9cbnZhciBjdXJyZW5jeVN5bWJvbFByb3BlcnRpZXMgPSBmdW5jdGlvbiggY3VycmVuY3ksIGNsZHIsIG9wdGlvbnMgKSB7XG5cdHZhciBjdXJyZW5jeVNwYWNpbmcsIHBhdHRlcm4sXG5cdFx0cmVnZXhwID0ge1xuXHRcdFx0XCJbOmRpZ2l0Ol1cIjogL1xcZC8sXG5cdFx0XHRcIls6XlM6XVwiOiByZWdleHBOb3RTXG5cdFx0fSxcblx0XHRzeW1ib2wgPSBjbGRyLm1haW4oW1xuXHRcdFx0XCJudW1iZXJzL2N1cnJlbmNpZXNcIixcblx0XHRcdGN1cnJlbmN5LFxuXHRcdFx0XCJzeW1ib2xcIlxuXHRcdF0pO1xuXG5cdGN1cnJlbmN5U3BhY2luZyA9IFsgXCJiZWZvcmVDdXJyZW5jeVwiLCBcImFmdGVyQ3VycmVuY3lcIiBdLm1hcChmdW5jdGlvbiggcG9zaXRpb24gKSB7XG5cdFx0cmV0dXJuIGNsZHIubWFpbihbXG5cdFx0XHRcIm51bWJlcnNcIixcblx0XHRcdFwiY3VycmVuY3lGb3JtYXRzLW51bWJlclN5c3RlbS1cIiArIG51bWJlck51bWJlcmluZ1N5c3RlbSggY2xkciApLFxuXHRcdFx0XCJjdXJyZW5jeVNwYWNpbmdcIixcblx0XHRcdHBvc2l0aW9uXG5cdFx0XSk7XG5cdH0pO1xuXG5cdHBhdHRlcm4gPSBjbGRyLm1haW4oW1xuXHRcdFwibnVtYmVyc1wiLFxuXHRcdFwiY3VycmVuY3lGb3JtYXRzLW51bWJlclN5c3RlbS1cIiArIG51bWJlck51bWJlcmluZ1N5c3RlbSggY2xkciApLFxuXHRcdG9wdGlvbnMuc3R5bGUgPT09IFwiYWNjb3VudGluZ1wiID8gXCJhY2NvdW50aW5nXCIgOiBcInN0YW5kYXJkXCJcblx0XSk7XG5cblx0cGF0dGVybiA9XG5cblx0XHQvLyBUaGUgbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIGFuZCB0aGUgcm91bmRpbmcgZm9yIGVhY2ggY3VycmVuY3kgaXMgbm90IGxvY2FsZS1zcGVjaWZpYy5cblx0XHQvLyBUaG9zZSB2YWx1ZXMgYXJlIG92ZXJyaWRkZW4gYnkgU3VwcGxlbWVudGFsIEN1cnJlbmN5IERhdGEuXG5cdFx0Y3VycmVuY3lTdXBwbGVtZW50YWxPdmVycmlkZSggY3VycmVuY3ksIHBhdHRlcm4sIGNsZHIgKVxuXG5cdFx0Ly8gUmVwbGFjZSBcIsKkXCIgKFxcdTAwQTQpIHdpdGggdGhlIGFwcHJvcHJpYXRlIHN5bWJvbCBsaXRlcmFsLlxuXHRcdC5zcGxpdCggXCI7XCIgKS5tYXAoZnVuY3Rpb24oIHBhdHRlcm4gKSB7XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuLnNwbGl0KCBcIlxcdTAwQTRcIiApLm1hcChmdW5jdGlvbiggcGFydCwgaSApIHtcblx0XHRcdFx0dmFyIGN1cnJlbmN5TWF0Y2ggPSByZWdleHBbIGN1cnJlbmN5U3BhY2luZ1sgaSBdLmN1cnJlbmN5TWF0Y2ggXSxcblx0XHRcdFx0XHRzdXJyb3VuZGluZ01hdGNoID0gcmVnZXhwWyBjdXJyZW5jeVNwYWNpbmdbIGkgXS5zdXJyb3VuZGluZ01hdGNoIF0sXG5cdFx0XHRcdFx0aW5zZXJ0QmV0d2VlbiA9IFwiXCI7XG5cblx0XHRcdFx0Ly8gRm9yIGN1cnJlbmN5TWF0Y2ggYW5kIHN1cnJvdW5kaW5nTWF0Y2ggZGVmaW5pdGlvbnMsIHJlYWQgWzFdLlxuXHRcdFx0XHQvLyBXaGVuIGkgPT09IDAsIGJlZm9yZUN1cnJlbmN5IGlzIGJlaW5nIGhhbmRsZWQuIE90aGVyd2lzZSwgYWZ0ZXJDdXJyZW5jeS5cblx0XHRcdFx0Ly8gMTogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWwjQ3VycmVuY2llc1xuXHRcdFx0XHRjdXJyZW5jeU1hdGNoID0gY3VycmVuY3lNYXRjaC50ZXN0KCBzeW1ib2wuY2hhckF0KCBpID8gc3ltYm9sLmxlbmd0aCAtIDEgOiAwICkgKTtcblx0XHRcdFx0c3Vycm91bmRpbmdNYXRjaCA9IHN1cnJvdW5kaW5nTWF0Y2gudGVzdChcblx0XHRcdFx0XHRwYXJ0LmNoYXJBdCggaSA/IDAgOiBwYXJ0Lmxlbmd0aCAtIDEgKS5yZXBsYWNlKCAvWyNALC5dL2csIFwiMFwiIClcblx0XHRcdFx0KTtcblxuXHRcdFx0XHRpZiAoIGN1cnJlbmN5TWF0Y2ggJiYgcGFydCAmJiBzdXJyb3VuZGluZ01hdGNoICkge1xuXHRcdFx0XHRcdGluc2VydEJldHdlZW4gPSBjdXJyZW5jeVNwYWNpbmdbIGkgXS5pbnNlcnRCZXR3ZWVuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuICggaSA/IGluc2VydEJldHdlZW4gOiBcIlwiICkgKyBwYXJ0ICsgKCBpID8gXCJcIiA6IGluc2VydEJldHdlZW4gKTtcblx0XHRcdH0pLmpvaW4oIFwiJ1wiICsgc3ltYm9sICsgXCInXCIgKTtcblx0XHR9KS5qb2luKCBcIjtcIiApO1xuXG5cdHJldHVybiB7XG5cdFx0cGF0dGVybjogcGF0dGVyblxuXHR9O1xufTtcblxuXG5cblxuLyoqXG4gKiBvYmplY3RPbWl0KCBvYmplY3QsIGtleXMgKVxuICpcbiAqIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCwgZmlsdGVyZWQgdG8gb21pdCB0aGUgYmxhY2tsaXN0ZWQga2V5IG9yIGFycmF5IG9mIGtleXMuXG4gKi9cbnZhciBvYmplY3RPbWl0ID0gZnVuY3Rpb24oIG9iamVjdCwga2V5cyApIHtcblx0dmFyIGtleSxcblx0XHRjb3B5ID0ge307XG5cblx0a2V5cyA9IGFsd2F5c0FycmF5KCBrZXlzICk7XG5cblx0Zm9yICgga2V5IGluIG9iamVjdCApIHtcblx0XHRpZiAoIGtleXMuaW5kZXhPZigga2V5ICkgPT09IC0xICkge1xuXHRcdFx0Y29weVsga2V5IF0gPSBvYmplY3RbIGtleSBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb3B5O1xufTtcblxuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXF1aXJlZENsZHIoIHBhdGgsIHZhbHVlICkge1xuXHR2YWxpZGF0ZUNsZHIoIHBhdGgsIHZhbHVlLCB7XG5cdFx0c2tpcDogWyAvc3VwcGxlbWVudGFsXFwvY3VycmVuY3lEYXRhXFwvZnJhY3Rpb25zXFwvW0EtWmEtel17M30kLyBdXG5cdH0pO1xufVxuXG4vKipcbiAqIC5jdXJyZW5jeUZvcm1hdHRlciggY3VycmVuY3kgWywgb3B0aW9uc10gKVxuICpcbiAqIEBjdXJyZW5jeSBbU3RyaW5nXSAzLWxldHRlciBjdXJyZW5jeSBjb2RlIGFzIGRlZmluZWQgYnkgSVNPIDQyMTcuXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF06XG4gKiAtIHN0eWxlOiBbU3RyaW5nXSBcInN5bWJvbFwiIChkZWZhdWx0KSwgXCJhY2NvdW50aW5nXCIsIFwiY29kZVwiIG9yIFwibmFtZVwiLlxuICogLSBzZWUgYWxzbyBudW1iZXIvZm9ybWF0IG9wdGlvbnMuXG4gKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgY3VycmVuY3kgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCBkZWZhdWx0L2luc3RhbmNlXG4gKiBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5jdXJyZW5jeUZvcm1hdHRlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLmN1cnJlbmN5Rm9ybWF0dGVyID0gZnVuY3Rpb24oIGN1cnJlbmN5LCBvcHRpb25zICkge1xuXHR2YXIgYXJncywgY2xkciwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMsIHJldHVybkZuLCBzdHlsZTtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCBjdXJyZW5jeSwgXCJjdXJyZW5jeVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZUN1cnJlbmN5KCBjdXJyZW5jeSwgXCJjdXJyZW5jeVwiICk7XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFwib3B0aW9uc1wiICk7XG5cblx0Y2xkciA9IHRoaXMuY2xkcjtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0YXJncyA9IFsgY3VycmVuY3ksIG9wdGlvbnMgXTtcblx0c3R5bGUgPSBvcHRpb25zLnN0eWxlIHx8IFwic3ltYm9sXCI7XG5cblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XG5cblx0Ly8gR2V0IHByb3BlcnRpZXMgZ2l2ZW4gc3R5bGUgKFwic3ltYm9sXCIgZGVmYXVsdCwgXCJjb2RlXCIgb3IgXCJuYW1lXCIpLlxuXHRjbGRyLm9uKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkQ2xkciApO1xuXHRwcm9wZXJ0aWVzID0gKHtcblx0XHRhY2NvdW50aW5nOiBjdXJyZW5jeVN5bWJvbFByb3BlcnRpZXMsXG5cdFx0Y29kZTogY3VycmVuY3lDb2RlUHJvcGVydGllcyxcblx0XHRuYW1lOiBjdXJyZW5jeU5hbWVQcm9wZXJ0aWVzLFxuXHRcdHN5bWJvbDogY3VycmVuY3lTeW1ib2xQcm9wZXJ0aWVzXG5cdH1bIHN0eWxlIF0gKSggY3VycmVuY3ksIGNsZHIsIG9wdGlvbnMgKTtcblx0Y2xkci5vZmYoIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRDbGRyICk7XG5cblx0Ly8gb3B0aW9ucyA9IG9wdGlvbnMgbWludXMgc3R5bGUsIHBsdXMgcmF3IHBhdHRlcm4uXG5cdG9wdGlvbnMgPSBvYmplY3RPbWl0KCBvcHRpb25zLCBcInN0eWxlXCIgKTtcblx0b3B0aW9ucy5yYXcgPSBwcm9wZXJ0aWVzLnBhdHRlcm47XG5cblx0Ly8gUmV0dXJuIGZvcm1hdHRlciB3aGVuIHN0eWxlIGlzIFwic3ltYm9sXCIgb3IgXCJhY2NvdW50aW5nXCIuXG5cdGlmICggc3R5bGUgPT09IFwic3ltYm9sXCIgfHwgc3R5bGUgPT09IFwiYWNjb3VudGluZ1wiICkge1xuXHRcdG51bWJlckZvcm1hdHRlciA9IHRoaXMubnVtYmVyRm9ybWF0dGVyKCBvcHRpb25zICk7XG5cblx0XHRyZXR1cm5GbiA9IGN1cnJlbmN5Rm9ybWF0dGVyRm4oIG51bWJlckZvcm1hdHRlciApO1xuXG5cdFx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIG51bWJlckZvcm1hdHRlciBdICk7XG5cblx0Ly8gUmV0dXJuIGZvcm1hdHRlciB3aGVuIHN0eWxlIGlzIFwiY29kZVwiIG9yIFwibmFtZVwiLlxuXHR9IGVsc2Uge1xuXHRcdG51bWJlckZvcm1hdHRlciA9IHRoaXMubnVtYmVyRm9ybWF0dGVyKCBvcHRpb25zICk7XG5cdFx0cGx1cmFsR2VuZXJhdG9yID0gdGhpcy5wbHVyYWxHZW5lcmF0b3IoKTtcblxuXHRcdHJldHVybkZuID0gY3VycmVuY3lGb3JtYXR0ZXJGbiggbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKTtcblxuXHRcdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyBdICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG4vKipcbiAqIC5jdXJyZW5jeVBhcnNlciggY3VycmVuY3kgWywgb3B0aW9uc10gKVxuICpcbiAqIEBjdXJyZW5jeSBbU3RyaW5nXSAzLWxldHRlciBjdXJyZW5jeSBjb2RlIGFzIGRlZmluZWQgYnkgSVNPIDQyMTcuXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGN1cnJlbmN5Rm9ybWF0dGVyLlxuICpcbiAqIFJldHVybiB0aGUgY3VycmVuY3kgcGFyc2VyIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgdGhlIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUuY3VycmVuY3lQYXJzZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5jdXJyZW5jeVBhcnNlciA9IGZ1bmN0aW9uKCAvKiBjdXJyZW5jeSwgb3B0aW9ucyAqLyApIHtcblxuXHQvLyBUT0RPIGltcGxlbWVudCBwYXJzZXIuXG5cbn07XG5cbi8qKlxuICogLmZvcm1hdEN1cnJlbmN5KCB2YWx1ZSwgY3VycmVuY3kgWywgb3B0aW9uc10gKVxuICpcbiAqIEB2YWx1ZSBbTnVtYmVyXSBudW1iZXIgdG8gYmUgZm9ybWF0dGVkLlxuICpcbiAqIEBjdXJyZW5jeSBbU3RyaW5nXSAzLWxldHRlciBjdXJyZW5jeSBjb2RlIGFzIGRlZmluZWQgYnkgSVNPIDQyMTcuXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGN1cnJlbmN5Rm9ybWF0dGVyLlxuICpcbiAqIEZvcm1hdCBhIGN1cnJlbmN5IGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgdGhlIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUuZm9ybWF0Q3VycmVuY3kgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXRDdXJyZW5jeSA9IGZ1bmN0aW9uKCB2YWx1ZSwgY3VycmVuY3ksIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0cmV0dXJuIHRoaXMuY3VycmVuY3lGb3JtYXR0ZXIoIGN1cnJlbmN5LCBvcHRpb25zICkoIHZhbHVlICk7XG59O1xuXG4vKipcbiAqIC5wYXJzZUN1cnJlbmN5KCB2YWx1ZSwgY3VycmVuY3kgWywgb3B0aW9uc10gKVxuICpcbiAqIEB2YWx1ZSBbU3RyaW5nXVxuICpcbiAqIEBjdXJyZW5jeSBbU3RyaW5nXSAzLWxldHRlciBjdXJyZW5jeSBjb2RlIGFzIGRlZmluZWQgYnkgSVNPIDQyMTcuXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF06IFNlZSBjdXJyZW5jeUZvcm1hdHRlci5cbiAqXG4gKiBSZXR1cm4gdGhlIHBhcnNlZCBjdXJyZW5jeSBvciBOYU4gd2hlbiB2YWx1ZSBpcyBpbnZhbGlkLlxuICovXG5HbG9iYWxpemUucGFyc2VDdXJyZW5jeSA9XG5HbG9iYWxpemUucHJvdG90eXBlLnBhcnNlQ3VycmVuY3kgPSBmdW5jdGlvbiggLyogdmFsdWUsIGN1cnJlbmN5LCBvcHRpb25zICovICkge1xufTtcblxucmV0dXJuIEdsb2JhbGl6ZTtcblxuXG5cblxufSkpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvY3VycmVuY3kuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9jdXJyZW5jeS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgZGVmaW5lID0gZmFsc2U7XG5cbi8qKlxuICogR2xvYmFsaXplIHYxLjMuMFxuICpcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wNy0wM1QyMTozN1pcbiAqL1xuLyohXG4gKiBHbG9iYWxpemUgdjEuMy4wIDIwMTctMDctMDNUMjE6MzdaIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2dpdC5pby9UcmRRYndcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXG5cdC8vIFVNRCByZXR1cm5FeHBvcnRzXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1xuXHRcdFx0XCJjbGRyXCIsXG5cdFx0XHRcIi4uL2dsb2JhbGl6ZVwiLFxuXHRcdFx0XCIuL251bWJlclwiLFxuXHRcdFx0XCJjbGRyL2V2ZW50XCIsXG5cdFx0XHRcImNsZHIvc3VwcGxlbWVudGFsXCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gTm9kZSwgQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiY2xkcmpzXCIgKSwgcmVxdWlyZSggXCIuLi9nbG9iYWxpemVcIiApICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBFeHRlbmQgZ2xvYmFsXG5cdFx0ZmFjdG9yeSggcm9vdC5DbGRyLCByb290Lkdsb2JhbGl6ZSApO1xuXHR9XG59KHRoaXMsIGZ1bmN0aW9uKCBDbGRyLCBHbG9iYWxpemUgKSB7XG5cbnZhciBjcmVhdGVFcnJvciA9IEdsb2JhbGl6ZS5fY3JlYXRlRXJyb3IsXG5cdGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlID0gR2xvYmFsaXplLl9jcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSxcblx0Zm9ybWF0TWVzc2FnZSA9IEdsb2JhbGl6ZS5fZm9ybWF0TWVzc2FnZSxcblx0aXNQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5faXNQbGFpbk9iamVjdCxcblx0bG9vc2VNYXRjaGluZyA9IEdsb2JhbGl6ZS5fbG9vc2VNYXRjaGluZyxcblx0bnVtYmVyTnVtYmVyaW5nU3lzdGVtRGlnaXRzTWFwID0gR2xvYmFsaXplLl9udW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXAsXG5cdG51bWJlclN5bWJvbCA9IEdsb2JhbGl6ZS5fbnVtYmVyU3ltYm9sLFxuXHRyZWdleHBFc2NhcGUgPSBHbG9iYWxpemUuX3JlZ2V4cEVzY2FwZSxcblx0cmVtb3ZlTGl0ZXJhbFF1b3RlcyA9IEdsb2JhbGl6ZS5fcmVtb3ZlTGl0ZXJhbFF1b3Rlcyxcblx0cnVudGltZUJpbmQgPSBHbG9iYWxpemUuX3J1bnRpbWVCaW5kLFxuXHRzdHJpbmdQYWQgPSBHbG9iYWxpemUuX3N0cmluZ1BhZCxcblx0dmFsaWRhdGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlLFxuXHR2YWxpZGF0ZUNsZHIgPSBHbG9iYWxpemUuX3ZhbGlkYXRlQ2xkcixcblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlID0gR2xvYmFsaXplLl92YWxpZGF0ZURlZmF1bHRMb2NhbGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nO1xuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVEYXRlID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoIHZhbHVlLCBuYW1lLCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSwgXCJEYXRlXCIgKTtcbn07XG5cblxuXG5cbnZhciBjcmVhdGVFcnJvckludmFsaWRQYXJhbWV0ZXJWYWx1ZSA9IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0cmV0dXJuIGNyZWF0ZUVycm9yKCBcIkVfSU5WQUxJRF9QQVJfVkFMVUVcIiwgXCJJbnZhbGlkIGB7bmFtZX1gIHZhbHVlICh7dmFsdWV9KS5cIiwge1xuXHRcdG5hbWU6IG5hbWUsXG5cdFx0dmFsdWU6IHZhbHVlXG5cdH0pO1xufTtcblxuXG5cblxuLyoqXG4gKiBDcmVhdGUgYSBtYXAgYmV0d2VlbiB0aGUgc2tlbGV0b24gZmllbGRzIGFuZCB0aGVpciBwb3NpdGlvbnMsIGUuZy4sXG4gKiB7XG4gKiAgIEc6IDBcbiAqICAgeTogMVxuICogICAuLi5cbiAqIH1cbiAqL1xudmFyIHZhbGlkYXRlU2tlbGV0b25GaWVsZHNQb3NNYXAgPSBcIkd5WXVVclFxTUxsd1dFZWNkREZnaEhLa21zU0F6Wk92Vlh4XCIuc3BsaXQoIFwiXCIgKS5yZWR1Y2UoZnVuY3Rpb24oIG1lbW8sIGl0ZW0sIGkgKSB7XG5cdG1lbW9bIGl0ZW0gXSA9IGk7XG5cdHJldHVybiBtZW1vO1xufSwge30pO1xuXG5cblxuXG4vKipcbiAqIHZhbGlkYXRlU2tlbGV0b24oIHNrZWxldG9uIClcbiAqXG4gKiBza2VsZXRvbjogQXNzdW1lIGBqYCBoYXMgYWxyZWFkeSBiZWVuIGNvbnZlcnRlZCBpbnRvIGEgbG9jYWxpemVkIGhvdXIgZmllbGQuXG4gKi9cbnZhciB2YWxpZGF0ZVNrZWxldG9uID0gZnVuY3Rpb24gdmFsaWRhdGVTa2VsZXRvbiggc2tlbGV0b24gKSB7XG5cdHZhciBsYXN0LFxuXG5cdFx0Ly8gVXNpbmcgZWFzaWVyIHRvIHJlYWQgdmFyaWFibGUuXG5cdFx0ZmllbGRzUG9zTWFwID0gdmFsaWRhdGVTa2VsZXRvbkZpZWxkc1Bvc01hcDtcblxuXHQvLyBcIlRoZSBmaWVsZHMgYXJlIGZyb20gdGhlIERhdGUgRmllbGQgU3ltYm9sIFRhYmxlIGluIERhdGUgRm9ybWF0IFBhdHRlcm5zXCJcblx0Ly8gUmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjYXZhaWxhYmxlRm9ybWF0c19hcHBlbmRJdGVtc1xuXHQvLyBJLmUuLCBjaGVjayBmb3IgaW52YWxpZCBjaGFyYWN0ZXJzLlxuXHRza2VsZXRvbi5yZXBsYWNlKCAvW15HeVl1VXJRcU1MbHdXRWVjZERGZ2hIS2ttc1NBelpPdlZYeF0vLCBmdW5jdGlvbiggZmllbGQgKSB7XG5cdFx0dGhyb3cgY3JlYXRlRXJyb3IoXG5cdFx0XHRcIkVfSU5WQUxJRF9PUFRJT05TXCIsIFwiSW52YWxpZCBmaWVsZCBge2ludmFsaWRGaWVsZH1gIG9mIHNrZWxldG9uIGB7dmFsdWV9YFwiLFxuXHRcdFx0e1xuXHRcdFx0XHRpbnZhbGlkRmllbGQ6IGZpZWxkLFxuXHRcdFx0XHR0eXBlOiBcInNrZWxldG9uXCIsXG5cdFx0XHRcdHZhbHVlOiBza2VsZXRvblxuXHRcdFx0fVxuXHRcdCk7XG5cdH0pO1xuXG5cdC8vIFwiVGhlIGNhbm9uaWNhbCBvcmRlciBpcyBmcm9tIHRvcCB0byBib3R0b20gaW4gdGhhdCB0YWJsZTsgdGhhdCBpcywgeU0gbm90IE15XCIuXG5cdC8vIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNhdmFpbGFibGVGb3JtYXRzX2FwcGVuZEl0ZW1zXG5cdC8vIEkuZS4sIGNoZWNrIGZvciBpbnZhbGlkIG9yZGVyLlxuXHRza2VsZXRvbi5zcGxpdCggXCJcIiApLmV2ZXJ5KGZ1bmN0aW9uKCBmaWVsZCApIHtcblx0XHRpZiAoIGZpZWxkc1Bvc01hcFsgZmllbGQgXSA8IGxhc3QgKSB7XG5cdFx0XHR0aHJvdyBjcmVhdGVFcnJvcihcblx0XHRcdFx0XCJFX0lOVkFMSURfT1BUSU9OU1wiLCBcIkludmFsaWQgb3JkZXIgYHtpbnZhbGlkRmllbGR9YCBvZiBza2VsZXRvbiBge3ZhbHVlfWBcIixcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGludmFsaWRGaWVsZDogZmllbGQsXG5cdFx0XHRcdFx0dHlwZTogXCJza2VsZXRvblwiLFxuXHRcdFx0XHRcdHZhbHVlOiBza2VsZXRvblxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblx0XHRsYXN0ID0gZmllbGRzUG9zTWFwWyBmaWVsZCBdO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9KTtcbn07XG5cblxuXG5cbi8qKlxuICogUmV0dXJucyBhIG5ldyBvYmplY3QgY3JlYXRlZCBieSB1c2luZyBgb2JqZWN0YCdzIHZhbHVlcyBhcyBrZXlzLCBhbmQgdGhlIGtleXMgYXMgdmFsdWVzLlxuICovXG52YXIgb2JqZWN0SW52ZXJ0ID0gZnVuY3Rpb24oIG9iamVjdCwgZm4gKSB7XG5cdGZuID0gZm4gfHwgZnVuY3Rpb24oIG9iamVjdCwga2V5LCB2YWx1ZSApIHtcblx0XHRvYmplY3RbIHZhbHVlIF0gPSBrZXk7XG5cdFx0cmV0dXJuIG9iamVjdDtcblx0fTtcblx0cmV0dXJuIE9iamVjdC5rZXlzKCBvYmplY3QgKS5yZWR1Y2UoZnVuY3Rpb24oIG5ld09iamVjdCwga2V5ICkge1xuXHRcdHJldHVybiBmbiggbmV3T2JqZWN0LCBrZXksIG9iamVjdFsga2V5IF0gKTtcblx0fSwge30pO1xufTtcblxuXG5cblxuLy8gSW52ZXJ0IGtleSBhbmQgdmFsdWVzLCBlLmcuLCB7XCJlXCI6IFwiZUVjXCJ9ID09PiB7XCJlXCI6IFwiZVwiLCBcIkVcIjogXCJlXCIsIFwiY1wiOiBcImVcIn0uXG52YXIgZGF0ZUV4cGFuZFBhdHRlcm5TaW1pbGFyRmllbGRzTWFwID0gb2JqZWN0SW52ZXJ0KHtcblx0XCJlXCI6IFwiZUVjXCIsXG5cdFwiTFwiOiBcIk1MXCJcbn0sIGZ1bmN0aW9uKCBvYmplY3QsIGtleSwgdmFsdWUgKSB7XG5cdHZhbHVlLnNwbGl0KCBcIlwiICkuZm9yRWFjaChmdW5jdGlvbiggZmllbGQgKSB7XG5cdFx0b2JqZWN0WyBmaWVsZCBdID0ga2V5O1xuXHR9KTtcblx0cmV0dXJuIG9iamVjdDtcbn0pO1xuXG5cblxuXG52YXIgZGF0ZUV4cGFuZFBhdHRlcm5Ob3JtYWxpemVQYXR0ZXJuVHlwZSA9IGZ1bmN0aW9uKCBjaGFyYWN0ZXIgKSB7XG5cdHJldHVybiBkYXRlRXhwYW5kUGF0dGVyblNpbWlsYXJGaWVsZHNNYXBbIGNoYXJhY3RlciBdIHx8IGNoYXJhY3Rlcjtcbn07XG5cblxuXG5cbnZhciBkYXRlUGF0dGVyblJlID0gKCAvKFthLXpdKVxcMSp8JyhbXiddfCcnKSsnfCcnfC4vaWcgKTtcblxuXG5cblxudmFyIHN0cmluZ1JlcGVhdCA9IGZ1bmN0aW9uKCBzdHIsIGNvdW50ICkge1xuXHR2YXIgaSwgcmVzdWx0ID0gXCJcIjtcblx0Zm9yICggaSA9IDA7IGkgPCBjb3VudDsgaSsrICkge1xuXHRcdHJlc3VsdCA9IHJlc3VsdCArIHN0cjtcblx0fVxuXHRyZXR1cm4gcmVzdWx0O1xufTtcblxuXG5cblxudmFyIGRhdGVFeHBhbmRQYXR0ZXJuQXVnbWVudEZvcm1hdCA9IGZ1bmN0aW9uKCByZXF1ZXN0ZWRTa2VsZXRvbiwgYmVzdE1hdGNoRm9ybWF0ICkge1xuXHR2YXIgaSwgaiwgbWF0Y2hlZFR5cGUsIG1hdGNoZWRMZW5ndGgsIHJlcXVlc3RlZFR5cGUsIHJlcXVlc3RlZExlbmd0aCxcblxuXHRcdC8vIFVzaW5nIGFuIGVhc2llciB0byByZWFkIHZhcmlhYmxlLlxuXHRcdG5vcm1hbGl6ZVBhdHRlcm5UeXBlID0gZGF0ZUV4cGFuZFBhdHRlcm5Ob3JtYWxpemVQYXR0ZXJuVHlwZTtcblxuXHRyZXF1ZXN0ZWRTa2VsZXRvbiA9IHJlcXVlc3RlZFNrZWxldG9uLm1hdGNoKCBkYXRlUGF0dGVyblJlICk7XG5cdGJlc3RNYXRjaEZvcm1hdCA9IGJlc3RNYXRjaEZvcm1hdC5tYXRjaCggZGF0ZVBhdHRlcm5SZSApO1xuXG5cdGZvciAoIGkgPSAwOyBpIDwgYmVzdE1hdGNoRm9ybWF0Lmxlbmd0aDsgaSsrICkge1xuXHRcdG1hdGNoZWRUeXBlID0gYmVzdE1hdGNoRm9ybWF0W2ldLmNoYXJBdCggMCApO1xuXHRcdG1hdGNoZWRMZW5ndGggPSBiZXN0TWF0Y2hGb3JtYXRbaV0ubGVuZ3RoO1xuXHRcdGZvciAoIGogPSAwOyBqIDwgcmVxdWVzdGVkU2tlbGV0b24ubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRyZXF1ZXN0ZWRUeXBlID0gcmVxdWVzdGVkU2tlbGV0b25bal0uY2hhckF0KCAwICk7XG5cdFx0XHRyZXF1ZXN0ZWRMZW5ndGggPSByZXF1ZXN0ZWRTa2VsZXRvbltqXS5sZW5ndGg7XG5cdFx0XHRpZiAoIG5vcm1hbGl6ZVBhdHRlcm5UeXBlKCBtYXRjaGVkVHlwZSApID09PSBub3JtYWxpemVQYXR0ZXJuVHlwZSggcmVxdWVzdGVkVHlwZSApICYmXG5cdFx0XHRcdG1hdGNoZWRMZW5ndGggPCByZXF1ZXN0ZWRMZW5ndGhcblx0XHRcdCkge1xuXHRcdFx0XHRiZXN0TWF0Y2hGb3JtYXRbaV0gPSBzdHJpbmdSZXBlYXQoIG1hdGNoZWRUeXBlLCByZXF1ZXN0ZWRMZW5ndGggKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gYmVzdE1hdGNoRm9ybWF0LmpvaW4oIFwiXCIgKTtcbn07XG5cblxuXG5cbnZhciBkYXRlRXhwYW5kUGF0dGVybkNvbXBhcmVGb3JtYXRzID0gZnVuY3Rpb24oIGZvcm1hdEEsIGZvcm1hdEIgKSB7XG5cdHZhciBhLCBiLCBkaXN0YW5jZSwgbGVuQSwgbGVuQiwgdHlwZUEsIHR5cGVCLCBpLCBqLFxuXG5cdFx0Ly8gVXNpbmcgZWFzaWVyIHRvIHJlYWQgdmFyaWFibGVzLlxuXHRcdG5vcm1hbGl6ZVBhdHRlcm5UeXBlID0gZGF0ZUV4cGFuZFBhdHRlcm5Ob3JtYWxpemVQYXR0ZXJuVHlwZTtcblxuXHRpZiAoIGZvcm1hdEEgPT09IGZvcm1hdEIgKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRmb3JtYXRBID0gZm9ybWF0QS5tYXRjaCggZGF0ZVBhdHRlcm5SZSApO1xuXHRmb3JtYXRCID0gZm9ybWF0Qi5tYXRjaCggZGF0ZVBhdHRlcm5SZSApO1xuXG5cdGlmICggZm9ybWF0QS5sZW5ndGggIT09IGZvcm1hdEIubGVuZ3RoICkge1xuXHRcdHJldHVybiAtMTtcblx0fVxuXG5cdGRpc3RhbmNlID0gMTtcblx0Zm9yICggaSA9IDA7IGkgPCBmb3JtYXRBLmxlbmd0aDsgaSsrICkge1xuXHRcdGEgPSBmb3JtYXRBWyBpIF0uY2hhckF0KCAwICk7XG5cdFx0dHlwZUEgPSBub3JtYWxpemVQYXR0ZXJuVHlwZSggYSApO1xuXHRcdHR5cGVCID0gbnVsbDtcblx0XHRmb3IgKCBqID0gMDsgaiA8IGZvcm1hdEIubGVuZ3RoOyBqKysgKSB7XG5cdFx0XHRiID0gZm9ybWF0QlsgaiBdLmNoYXJBdCggMCApO1xuXHRcdFx0dHlwZUIgPSBub3JtYWxpemVQYXR0ZXJuVHlwZSggYiApO1xuXHRcdFx0aWYgKCB0eXBlQSA9PT0gdHlwZUIgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZUIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIHR5cGVCID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0XHRsZW5BID0gZm9ybWF0QVsgaSBdLmxlbmd0aDtcblx0XHRsZW5CID0gZm9ybWF0QlsgaiBdLmxlbmd0aDtcblx0XHRkaXN0YW5jZSA9IGRpc3RhbmNlICsgTWF0aC5hYnMoIGxlbkEgLSBsZW5CICk7XG5cblx0XHQvLyBNb3N0IHN5bWJvbHMgaGF2ZSBhIHNtYWxsIGRpc3RhbmNlIGZyb20gZWFjaCBvdGhlciwgZS5nLiwgTSDiiYUgTDsgRSDiiYUgYzsgYSDiiYUgYiDiiYUgQjtcblx0XHQvLyBIIOKJhSBrIOKJhSBoIOKJhSBLOyAuLi5cblx0XHRpZiAoIGEgIT09IGIgKSB7XG5cdFx0XHRkaXN0YW5jZSArPSAxO1xuXHRcdH1cblxuXHRcdC8vIE51bWVyaWMgKGw8MykgYW5kIHRleHQgZmllbGRzIChsPj0zKSBhcmUgZ2l2ZW4gYSBsYXJnZXIgZGlzdGFuY2UgZnJvbSBlYWNoIG90aGVyLlxuXHRcdGlmICggKCBsZW5BIDwgMyAmJiBsZW5CID49IDMgKSB8fCAoIGxlbkEgPj0gMyAmJiBsZW5CIDwgMyApICkge1xuXHRcdFx0ZGlzdGFuY2UgKz0gMjA7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBkaXN0YW5jZTtcbn07XG5cblxuXG5cbnZhciBkYXRlRXhwYW5kUGF0dGVybkdldEJlc3RNYXRjaFBhdHRlcm4gPSBmdW5jdGlvbiggY2xkciwgYXNrZWRTa2VsZXRvbiApIHtcblx0dmFyIGF2YWlsYWJsZUZvcm1hdHMsIHBhdHRlcm4sIHJhdGVkRm9ybWF0cywgc2tlbGV0b24sXG5cdFx0cGF0aCA9IFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXRlVGltZUZvcm1hdHMvYXZhaWxhYmxlRm9ybWF0c1wiLFxuXG5cdFx0Ly8gVXNpbmcgZWFzaWVyIHRvIHJlYWQgdmFyaWFibGVzLlxuXHRcdGF1Z21lbnRGb3JtYXQgPSBkYXRlRXhwYW5kUGF0dGVybkF1Z21lbnRGb3JtYXQsXG5cdFx0Y29tcGFyZUZvcm1hdHMgPSBkYXRlRXhwYW5kUGF0dGVybkNvbXBhcmVGb3JtYXRzO1xuXG5cdHBhdHRlcm4gPSBjbGRyLm1haW4oWyBwYXRoLCBhc2tlZFNrZWxldG9uIF0pO1xuXG5cdGlmICggYXNrZWRTa2VsZXRvbiAmJiAhcGF0dGVybiApIHtcblx0XHRhdmFpbGFibGVGb3JtYXRzID0gY2xkci5tYWluKFsgcGF0aCBdKTtcblx0XHRyYXRlZEZvcm1hdHMgPSBbXTtcblxuXHRcdGZvciAoIHNrZWxldG9uIGluIGF2YWlsYWJsZUZvcm1hdHMgKSB7XG5cdFx0XHRyYXRlZEZvcm1hdHMucHVzaCh7XG5cdFx0XHRcdHNrZWxldG9uOiBza2VsZXRvbixcblx0XHRcdFx0cGF0dGVybjogYXZhaWxhYmxlRm9ybWF0c1sgc2tlbGV0b24gXSxcblx0XHRcdFx0cmF0ZTogY29tcGFyZUZvcm1hdHMoIGFza2VkU2tlbGV0b24sIHNrZWxldG9uIClcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJhdGVkRm9ybWF0cyA9IHJhdGVkRm9ybWF0c1xuXHRcdFx0LmZpbHRlciggZnVuY3Rpb24oIGZvcm1hdCApIHtcblx0XHRcdFx0cmV0dXJuIGZvcm1hdC5yYXRlID4gLTE7XG5cdFx0XHR9IClcblx0XHRcdC5zb3J0KCBmdW5jdGlvbiggZm9ybWF0QSwgZm9ybWF0QiApIHtcblx0XHRcdFx0cmV0dXJuIGZvcm1hdEEucmF0ZSAtIGZvcm1hdEIucmF0ZTtcblx0XHRcdH0pO1xuXG5cdFx0aWYgKCByYXRlZEZvcm1hdHMubGVuZ3RoICkge1xuXHRcdFx0cGF0dGVybiA9IGF1Z21lbnRGb3JtYXQoIGFza2VkU2tlbGV0b24sIHJhdGVkRm9ybWF0c1swXS5wYXR0ZXJuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHBhdHRlcm47XG59O1xuXG5cblxuXG4vKipcbiAqIGV4cGFuZFBhdHRlcm4oIG9wdGlvbnMsIGNsZHIgKVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIGlmIFN0cmluZywgaXQncyBjb25zaWRlcmVkIGEgc2tlbGV0b24uIE9iamVjdCBhY2NlcHRzOlxuICogLSBza2VsZXRvbjogW1N0cmluZ10gbG9va3VwIGF2YWlsYWJsZUZvcm1hdDtcbiAqIC0gZGF0ZTogW1N0cmluZ10gKCBcImZ1bGxcIiB8IFwibG9uZ1wiIHwgXCJtZWRpdW1cIiB8IFwic2hvcnRcIiApO1xuICogLSB0aW1lOiBbU3RyaW5nXSAoIFwiZnVsbFwiIHwgXCJsb25nXCIgfCBcIm1lZGl1bVwiIHwgXCJzaG9ydFwiICk7XG4gKiAtIGRhdGV0aW1lOiBbU3RyaW5nXSAoIFwiZnVsbFwiIHwgXCJsb25nXCIgfCBcIm1lZGl1bVwiIHwgXCJzaG9ydFwiICk7XG4gKiAtIHJhdzogW1N0cmluZ10gRm9yIG1vcmUgaW5mbyBzZWUgZGF0ZXRpbWUvZm9ybWF0LmpzLlxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBSZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcGF0dGVybi5cbiAqIEVnIGZvciBcImVuXCI6XG4gKiAtIFwiR3lNTU1kXCIgcmV0dXJucyBcIk1NTSBkLCB5IEdcIjtcbiAqIC0geyBza2VsZXRvbjogXCJHeU1NTWRcIiB9IHJldHVybnMgXCJNTU0gZCwgeSBHXCI7XG4gKiAtIHsgZGF0ZTogXCJmdWxsXCIgfSByZXR1cm5zIFwiRUVFRSwgTU1NTSBkLCB5XCI7XG4gKiAtIHsgdGltZTogXCJmdWxsXCIgfSByZXR1cm5zIFwiaDptbTpzcyBhIHp6enpcIjtcbiAqIC0geyBkYXRldGltZTogXCJmdWxsXCIgfSByZXR1cm5zIFwiRUVFRSwgTU1NTSBkLCB5ICdhdCcgaDptbTpzcyBhIHp6enpcIjtcbiAqIC0geyByYXc6IFwiZGQvbW1cIiB9IHJldHVybnMgXCJkZC9tbVwiO1xuICovXG52YXIgZGF0ZUV4cGFuZFBhdHRlcm4gPSBmdW5jdGlvbiggb3B0aW9ucywgY2xkciApIHtcblx0dmFyIGRhdGVTa2VsZXRvbiwgcmVzdWx0LCBza2VsZXRvbiwgdGltZVNrZWxldG9uLCB0eXBlLFxuXG5cdFx0Ly8gVXNpbmcgZWFzaWVyIHRvIHJlYWQgdmFyaWFibGVzLlxuXHRcdGdldEJlc3RNYXRjaFBhdHRlcm4gPSBkYXRlRXhwYW5kUGF0dGVybkdldEJlc3RNYXRjaFBhdHRlcm47XG5cblx0ZnVuY3Rpb24gY29tYmluZURhdGVUaW1lKCB0eXBlLCBkYXRlUGF0dGVybiwgdGltZVBhdHRlcm4gKSB7XG5cdFx0cmV0dXJuIGZvcm1hdE1lc3NhZ2UoXG5cdFx0XHRjbGRyLm1haW4oW1xuXHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF0ZVRpbWVGb3JtYXRzXCIsXG5cdFx0XHRcdHR5cGVcblx0XHRcdF0pLFxuXHRcdFx0WyB0aW1lUGF0dGVybiwgZGF0ZVBhdHRlcm4gXVxuXHRcdCk7XG5cdH1cblxuXHRzd2l0Y2ggKCB0cnVlICkge1xuXHRcdGNhc2UgXCJza2VsZXRvblwiIGluIG9wdGlvbnM6XG5cdFx0XHRza2VsZXRvbiA9IG9wdGlvbnMuc2tlbGV0b247XG5cblx0XHRcdC8vIFByZWZlcnJlZCBob3VyIChqKS5cblx0XHRcdHNrZWxldG9uID0gc2tlbGV0b24ucmVwbGFjZSggL2ovZywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBjbGRyLnN1cHBsZW1lbnRhbC50aW1lRGF0YS5wcmVmZXJyZWQoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR2YWxpZGF0ZVNrZWxldG9uKCBza2VsZXRvbiApO1xuXG5cdFx0XHQvLyBUcnkgZGlyZWN0IG1hcCAobm90ZSB0aGF0IGdldEJlc3RNYXRjaFBhdHRlcm4gaGFuZGxlcyBpdCkuXG5cdFx0XHQvLyAuLi4gb3IsIHRyeSB0byBcImJlc3QgbWF0Y2hcIiB0aGUgd2hvbGUgc2tlbGV0b24uXG5cdFx0XHRyZXN1bHQgPSBnZXRCZXN0TWF0Y2hQYXR0ZXJuKFxuXHRcdFx0XHRjbGRyLFxuXHRcdFx0XHRza2VsZXRvblxuXHRcdFx0KTtcblx0XHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Ly8gLi4uIG9yLCB0cnkgdG8gXCJiZXN0IG1hdGNoXCIgdGhlIGRhdGUgYW5kIHRpbWUgcGFydHMgaW5kaXZpZHVhbGx5LlxuXHRcdFx0dGltZVNrZWxldG9uID0gc2tlbGV0b24uc3BsaXQoIC9bXmhIS2ttc1NBelpPdlZYeF0vICkuc2xpY2UoIC0xIClbIDAgXTtcblx0XHRcdGRhdGVTa2VsZXRvbiA9IHNrZWxldG9uLnNwbGl0KCAvW15HeVl1VXJRcU1MbHdXZERGZ0VlY10vIClbIDAgXTtcblx0XHRcdGRhdGVTa2VsZXRvbiA9IGdldEJlc3RNYXRjaFBhdHRlcm4oXG5cdFx0XHRcdGNsZHIsXG5cdFx0XHRcdGRhdGVTa2VsZXRvblxuXHRcdFx0KTtcblx0XHRcdHRpbWVTa2VsZXRvbiA9IGdldEJlc3RNYXRjaFBhdHRlcm4oXG5cdFx0XHRcdGNsZHIsXG5cdFx0XHRcdHRpbWVTa2VsZXRvblxuXHRcdFx0KTtcblxuXHRcdFx0aWYgKCAvKE1NTU18TExMTCkuKltFY10vLnRlc3QoIGRhdGVTa2VsZXRvbiApICkge1xuXHRcdFx0XHR0eXBlID0gXCJmdWxsXCI7XG5cdFx0XHR9IGVsc2UgaWYgKCAvTU1NTXxMTExMLy50ZXN0KCBkYXRlU2tlbGV0b24gKSApIHtcblx0XHRcdFx0dHlwZSA9IFwibG9uZ1wiO1xuXHRcdFx0fSBlbHNlIGlmICggL01NTXxMTEwvLnRlc3QoIGRhdGVTa2VsZXRvbiApICkge1xuXHRcdFx0XHR0eXBlID0gXCJtZWRpdW1cIjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSBcInNob3J0XCI7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZGF0ZVNrZWxldG9uICYmIHRpbWVTa2VsZXRvbiApIHtcblx0XHRcdFx0cmVzdWx0ID0gY29tYmluZURhdGVUaW1lKCB0eXBlLCBkYXRlU2tlbGV0b24sIHRpbWVTa2VsZXRvbiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzdWx0ID0gZGF0ZVNrZWxldG9uIHx8IHRpbWVTa2VsZXRvbjtcblx0XHRcdH1cblxuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwiZGF0ZVwiIGluIG9wdGlvbnM6XG5cdFx0Y2FzZSBcInRpbWVcIiBpbiBvcHRpb25zOlxuXHRcdFx0cmVzdWx0ID0gY2xkci5tYWluKFtcblx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuXCIsXG5cdFx0XHRcdFwiZGF0ZVwiIGluIG9wdGlvbnMgPyBcImRhdGVGb3JtYXRzXCIgOiBcInRpbWVGb3JtYXRzXCIsXG5cdFx0XHRcdCggb3B0aW9ucy5kYXRlIHx8IG9wdGlvbnMudGltZSApXG5cdFx0XHRdKTtcblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBcImRhdGV0aW1lXCIgaW4gb3B0aW9uczpcblx0XHRcdHJlc3VsdCA9IGNvbWJpbmVEYXRlVGltZSggb3B0aW9ucy5kYXRldGltZSxcblx0XHRcdFx0Y2xkci5tYWluKFsgXCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RhdGVGb3JtYXRzXCIsIG9wdGlvbnMuZGF0ZXRpbWUgXSksXG5cdFx0XHRcdGNsZHIubWFpbihbIFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi90aW1lRm9ybWF0c1wiLCBvcHRpb25zLmRhdGV0aW1lIF0pXG5cdFx0XHQpO1xuXHRcdFx0YnJlYWs7XG5cblx0XHRjYXNlIFwicmF3XCIgaW4gb3B0aW9uczpcblx0XHRcdHJlc3VsdCA9IG9wdGlvbnMucmF3O1xuXHRcdFx0YnJlYWs7XG5cblx0XHRkZWZhdWx0OlxuXHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JJbnZhbGlkUGFyYW1ldGVyVmFsdWUoe1xuXHRcdFx0XHRuYW1lOiBcIm9wdGlvbnNcIixcblx0XHRcdFx0dmFsdWU6IG9wdGlvbnNcblx0XHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cblxuXG5cbnZhciBkYXRlV2Vla0RheXMgPSBbIFwic3VuXCIsIFwibW9uXCIsIFwidHVlXCIsIFwid2VkXCIsIFwidGh1XCIsIFwiZnJpXCIsIFwic2F0XCIgXTtcblxuXG5cblxuLyoqXG4gKiBmaXJzdERheU9mV2Vla1xuICovXG52YXIgZGF0ZUZpcnN0RGF5T2ZXZWVrID0gZnVuY3Rpb24oIGNsZHIgKSB7XG5cdHJldHVybiBkYXRlV2Vla0RheXMuaW5kZXhPZiggY2xkci5zdXBwbGVtZW50YWwud2Vla0RhdGEuZmlyc3REYXkoKSApO1xufTtcblxuXG5cblxuLyoqXG4gKiBnZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgdHlwZSApXG4gKi9cbnZhciBkYXRlR2V0VGltZVpvbmVOYW1lID0gZnVuY3Rpb24oIGxlbmd0aCwgdHlwZSwgdGltZVpvbmUsIGNsZHIgKSB7XG5cdHZhciBtZXRhWm9uZSwgcmVzdWx0O1xuXG5cdGlmICggIXRpbWVab25lICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdHJlc3VsdCA9IGNsZHIubWFpbihbXG5cdFx0XCJkYXRlcy90aW1lWm9uZU5hbWVzL3pvbmVcIixcblx0XHR0aW1lWm9uZSxcblx0XHRsZW5ndGggPCA0ID8gXCJzaG9ydFwiIDogXCJsb25nXCIsXG5cdFx0dHlwZVxuXHRdKTtcblxuXHRpZiAoIHJlc3VsdCApIHtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0Ly8gVGhlIGxhdGVzdCBtZXRhem9uZSBkYXRhIG9mIHRoZSBtZXRhem9uZSBhcnJheS5cblx0Ly8gVE9ETyBleHBhbmQgdG8gc3VwcG9ydCB0aGUgaGlzdG9yaWMgbWV0YXpvbmVzIGJhc2VkIG9uIHRoZSBnaXZlbiBkYXRlLlxuXHRtZXRhWm9uZSA9IGNsZHIuc3VwcGxlbWVudGFsKFtcblx0XHRcIm1ldGFab25lcy9tZXRhem9uZUluZm8vdGltZXpvbmVcIiwgdGltZVpvbmUsIDAsXG5cdFx0XCJ1c2VzTWV0YXpvbmUvX216b25lXCJcblx0XSk7XG5cblx0cmV0dXJuIGNsZHIubWFpbihbXG5cdFx0XCJkYXRlcy90aW1lWm9uZU5hbWVzL21ldGF6b25lXCIsXG5cdFx0bWV0YVpvbmUsXG5cdFx0bGVuZ3RoIDwgNCA/IFwic2hvcnRcIiA6IFwibG9uZ1wiLFxuXHRcdHR5cGVcblx0XSk7XG59O1xuXG5cblxuXG4vKipcbiAqIHRpbWV6b25lSG91ckZvcm1hdFNob3J0SCggaG91ckZvcm1hdCApXG4gKlxuICogQGhvdXJGb3JtYXQgW1N0cmluZ11cbiAqXG4gKiBVbm9mZmljaWFsIGRlZHVjdGlvbiBvZiB0aGUgc2hvcnQgaG91ckZvcm1hdCBnaXZlbiB0aW1lIHpvbmUgYGhvdXJGb3JtYXRgIGVsZW1lbnQuXG4gKiBPZmZpY2lhbCBzcGVjIGlzIHBlbmRpbmcgcmVzb2x1dGlvbjogaHR0cDovL3VuaWNvZGUub3JnL2NsZHIvdHJhYy90aWNrZXQvODI5M1xuICpcbiAqIEV4YW1wbGU6XG4gKiAtIFwiK0hILm1tOy1ISC5tbVwiID0+IFwiK0g7LUhcIlxuICogLSBcIitISDptbTstSEg6bW1cIiA9PiBcIitIOy1IXCJcbiAqIC0gXCIrSEg6bW074oiSSEg6bW1cIiA9PiBcIitIO+KIkkhcIiAoTm90ZSBNSU5VUyBTSUdOIFxcdTIyMTIpXG4gKiAtIFwiK0hIbW07LUhIbW1cIiA9PiBcIitIOi1IXCJcbiAqL1xudmFyIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIID0gZnVuY3Rpb24oIGhvdXJGb3JtYXQgKSB7XG5cdHJldHVybiBob3VyRm9ybWF0XG5cdFx0LnNwbGl0KCBcIjtcIiApXG5cdFx0Lm1hcChmdW5jdGlvbiggZm9ybWF0ICkge1xuXHRcdFx0cmV0dXJuIGZvcm1hdC5zbGljZSggMCwgZm9ybWF0LmluZGV4T2YoIFwiSFwiICkgKyAxICk7XG5cdFx0fSlcblx0XHQuam9pbiggXCI7XCIgKTtcbn07XG5cblxuXG5cbi8qKlxuICogdGltZXpvbmVIb3VyRm9ybWF0TG9uZ0htKCBob3VyRm9ybWF0IClcbiAqXG4gKiBAaG91ckZvcm1hdCBbU3RyaW5nXVxuICpcbiAqIFVub2ZmaWNpYWwgZGVkdWN0aW9uIG9mIHRoZSBzaG9ydCBob3VyRm9ybWF0IGdpdmVuIHRpbWUgem9uZSBgaG91ckZvcm1hdGAgZWxlbWVudC5cbiAqIE9mZmljaWFsIHNwZWMgaXMgcGVuZGluZyByZXNvbHV0aW9uOiBodHRwOi8vdW5pY29kZS5vcmcvY2xkci90cmFjL3RpY2tldC84MjkzXG4gKlxuICogRXhhbXBsZSAoaEZvcm1hdCA9PT0gXCJIXCIpOiAodXNlZCBmb3Igc2hvcnQgSG0pXG4gKiAtIFwiK0hILm1tOy1ISC5tbVwiID0+IFwiK0gubW07LUgubW1cIlxuICogLSBcIitISDptbTstSEg6bW1cIiA9PiBcIitIOm1tOy1IOm1tXCJcbiAqIC0gXCIrSEg6bW074oiSSEg6bW1cIiA9PiBcIitIOm1tO+KIkkg6bW1cIiAoTm90ZSBNSU5VUyBTSUdOIFxcdTIyMTIpXG4gKiAtIFwiK0hIbW07LUhIbW1cIiA9PiBcIitIbW06LUhtbVwiXG4gKlxuICogRXhhbXBsZSAoaEZvcm1hdCA9PT0gXCJISFwiOiAodXNlZCBmb3IgbG9uZyBIbSlcbiAqIC0gXCIrSEgubW07LUhILm1tXCIgPT4gXCIrSEgubW07LUhILm1tXCJcbiAqIC0gXCIrSEg6bW07LUhIOm1tXCIgPT4gXCIrSEg6bW07LUhIOm1tXCJcbiAqIC0gXCIrSDptbTstSDptbVwiICAgPT4gXCIrSEg6bW07LUhIOm1tXCJcbiAqIC0gXCIrSEg6bW074oiSSEg6bW1cIiA9PiBcIitISDptbTviiJJISDptbVwiIChOb3RlIE1JTlVTIFNJR04gXFx1MjIxMilcbiAqIC0gXCIrSEhtbTstSEhtbVwiID0+IFwiK0hIbW06LUhIbW1cIlxuICovXG52YXIgZGF0ZVRpbWV6b25lSG91ckZvcm1hdEhtID0gZnVuY3Rpb24oIGhvdXJGb3JtYXQsIGhGb3JtYXQgKSB7XG5cdHJldHVybiBob3VyRm9ybWF0XG5cdFx0LnNwbGl0KCBcIjtcIiApXG5cdFx0Lm1hcChmdW5jdGlvbiggZm9ybWF0ICkge1xuXHRcdFx0dmFyIHBhcnRzID0gZm9ybWF0LnNwbGl0KCAvSCsvICk7XG5cdFx0XHRwYXJ0cy5zcGxpY2UoIDEsIDAsIGhGb3JtYXQgKTtcblx0XHRcdHJldHVybiBwYXJ0cy5qb2luKCBcIlwiICk7XG5cdFx0fSlcblx0XHQuam9pbiggXCI7XCIgKTtcbn07XG5cblxuXG5cbnZhciBydW50aW1lQ2FjaGVEYXRhQmluZCA9IGZ1bmN0aW9uKCBrZXksIGRhdGEgKSB7XG5cdHZhciBmbiA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkYXRhO1xuXHR9O1xuXHRmbi5kYXRhQ2FjaGVLZXkgPSBrZXk7XG5cdHJldHVybiBmbjtcbn07XG5cblxuXG5cbi8qKlxuICogcHJvcGVydGllcyggcGF0dGVybiwgY2xkciApXG4gKlxuICogQHBhdHRlcm4gW1N0cmluZ10gcmF3IHBhdHRlcm4uXG4gKiByZWY6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNEYXRlX0Zvcm1hdF9QYXR0ZXJuc1xuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBSZXR1cm4gdGhlIHByb3BlcnRpZXMgZ2l2ZW4gdGhlIHBhdHRlcm4gYW5kIGNsZHIuXG4gKlxuICogVE9ETyBTdXBwb3J0IG90aGVyIGNhbGVuZGFyIHR5cGVzLlxuICovXG52YXIgZGF0ZUZvcm1hdFByb3BlcnRpZXMgPSBmdW5jdGlvbiggcGF0dGVybiwgY2xkciwgdGltZVpvbmUgKSB7XG5cdHZhciBwcm9wZXJ0aWVzID0ge1xuXHRcdFx0bnVtYmVyRm9ybWF0dGVyczoge30sXG5cdFx0XHRwYXR0ZXJuOiBwYXR0ZXJuLFxuXHRcdFx0dGltZVNlcGFyYXRvcjogbnVtYmVyU3ltYm9sKCBcInRpbWVTZXBhcmF0b3JcIiwgY2xkciApXG5cdFx0fSxcblx0XHR3aWR0aHMgPSBbIFwiYWJicmV2aWF0ZWRcIiwgXCJ3aWRlXCIsIFwibmFycm93XCIgXTtcblxuXHRmdW5jdGlvbiBzZXROdW1iZXJGb3JtYXR0ZXJQYXR0ZXJuKCBwYWQgKSB7XG5cdFx0cHJvcGVydGllcy5udW1iZXJGb3JtYXR0ZXJzWyBwYWQgXSA9IHN0cmluZ1BhZCggXCJcIiwgcGFkICk7XG5cdH1cblxuXHRpZiAoIHRpbWVab25lICkge1xuXHRcdHByb3BlcnRpZXMudGltZVpvbmVEYXRhID0gcnVudGltZUNhY2hlRGF0YUJpbmQoIFwiaWFuYS9cIiArIHRpbWVab25lLCB7XG5cdFx0XHRvZmZzZXRzOiBjbGRyLmdldChbIFwiZ2xvYmFsaXplLWlhbmEvem9uZURhdGFcIiwgdGltZVpvbmUsIFwib2Zmc2V0c1wiIF0pLFxuXHRcdFx0dW50aWxzOiBjbGRyLmdldChbIFwiZ2xvYmFsaXplLWlhbmEvem9uZURhdGFcIiwgdGltZVpvbmUsIFwidW50aWxzXCIgXSksXG5cdFx0XHRpc2RzdHM6IGNsZHIuZ2V0KFsgXCJnbG9iYWxpemUtaWFuYS96b25lRGF0YVwiLCB0aW1lWm9uZSwgXCJpc2RzdHNcIiBdKVxuXHRcdH0pO1xuXHR9XG5cblx0cGF0dGVybi5yZXBsYWNlKCBkYXRlUGF0dGVyblJlLCBmdW5jdGlvbiggY3VycmVudCApIHtcblx0XHR2YXIgYXV4LCBjaHIsIGRheWxpZ2h0VHpOYW1lLCBmb3JtYXROdW1iZXIsIGdlbmVyaWNUek5hbWUsIGxlbmd0aCwgc3RhbmRhcmRUek5hbWU7XG5cblx0XHRjaHIgPSBjdXJyZW50LmNoYXJBdCggMCApO1xuXHRcdGxlbmd0aCA9IGN1cnJlbnQubGVuZ3RoO1xuXG5cdFx0aWYgKCBjaHIgPT09IFwialwiICkge1xuXG5cdFx0XHQvLyBMb2NhbGUgcHJlZmVycmVkIGhIS2suXG5cdFx0XHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjVGltZV9EYXRhXG5cdFx0XHRwcm9wZXJ0aWVzLnByZWZlcnJlZFRpbWUgPSBjaHIgPSBjbGRyLnN1cHBsZW1lbnRhbC50aW1lRGF0YS5wcmVmZXJyZWQoKTtcblx0XHR9XG5cblx0XHQvLyBaWlpaOiBzYW1lIGFzIFwiT09PT1wiLlxuXHRcdGlmICggY2hyID09PSBcIlpcIiAmJiBsZW5ndGggPT09IDQgKSB7XG5cdFx0XHRjaHIgPSBcIk9cIjtcblx0XHRcdGxlbmd0aCA9IDQ7XG5cdFx0fVxuXG5cdFx0Ly8gei4uLnp6ejogXCJ7c2hvcnRSZWdpb259XCIsIGVnLiBcIlBTVFwiIG9yIFwiUERUXCIuXG5cdFx0Ly8genp6ejogXCJ7cmVnaW9uTmFtZX0ge1N0YW5kYXJkIFRpbWV9XCIgb3IgXCJ7cmVnaW9uTmFtZX0ge0RheWxpZ2h0IFRpbWV9XCIsXG5cdFx0Ly8gICAgICAgZS5nLiwgXCJQYWNpZmljIFN0YW5kYXJkIFRpbWVcIiBvciBcIlBhY2lmaWMgRGF5bGlnaHQgVGltZVwiLlxuXHRcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXG5cdFx0aWYgKCBjaHIgPT09IFwielwiICkge1xuXHRcdFx0c3RhbmRhcmRUek5hbWUgPSBkYXRlR2V0VGltZVpvbmVOYW1lKCBsZW5ndGgsIFwic3RhbmRhcmRcIiwgdGltZVpvbmUsIGNsZHIgKTtcblx0XHRcdGRheWxpZ2h0VHpOYW1lID0gZGF0ZUdldFRpbWVab25lTmFtZSggbGVuZ3RoLCBcImRheWxpZ2h0XCIsIHRpbWVab25lLCBjbGRyICk7XG5cdFx0XHRpZiAoIHN0YW5kYXJkVHpOYW1lICkge1xuXHRcdFx0XHRwcm9wZXJ0aWVzLnN0YW5kYXJkVHpOYW1lID0gc3RhbmRhcmRUek5hbWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRheWxpZ2h0VHpOYW1lICkge1xuXHRcdFx0XHRwcm9wZXJ0aWVzLmRheWxpZ2h0VHpOYW1lID0gZGF5bGlnaHRUek5hbWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhbGwgdGhyb3VnaCB0aGUgXCJPXCIgZm9ybWF0IGluIGNhc2Ugb25lIG5hbWUgaXMgbWlzc2luZy5cblx0XHRcdGlmICggIXN0YW5kYXJkVHpOYW1lIHx8ICFkYXlsaWdodFR6TmFtZSApIHtcblx0XHRcdFx0Y2hyID0gXCJPXCI7XG5cdFx0XHRcdGlmICggbGVuZ3RoIDwgNCApIHtcblx0XHRcdFx0XHRsZW5ndGggPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdi4uLnZ2djogXCJ7c2hvcnRSZWdpb259XCIsIGVnLiBcIlBUXCIuXG5cdFx0Ly8gdnZ2djogXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XCIgb3IgXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XCIsXG5cdFx0Ly8gZS5nLiwgXCJQYWNpZmljIFRpbWVcIlxuXHRcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXG5cdFx0aWYgKCBjaHIgPT09IFwidlwiICkge1xuXHRcdFx0Z2VuZXJpY1R6TmFtZSA9IGRhdGVHZXRUaW1lWm9uZU5hbWUoIGxlbmd0aCwgXCJnZW5lcmljXCIsIHRpbWVab25lLCBjbGRyICk7XG5cblx0XHRcdC8vIEZhbGwgYmFjayB0byBcIlZcIiBmb3JtYXQuXG5cdFx0XHRpZiAoICFnZW5lcmljVHpOYW1lICkge1xuXHRcdFx0XHRjaHIgPSBcIlZcIjtcblx0XHRcdFx0bGVuZ3RoID0gNDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBjaHIgKSB7XG5cblx0XHRcdC8vIEVyYVxuXHRcdFx0Y2FzZSBcIkdcIjpcblx0XHRcdFx0cHJvcGVydGllcy5lcmFzID0gY2xkci5tYWluKFtcblx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZXJhc1wiLFxuXHRcdFx0XHRcdGxlbmd0aCA8PSAzID8gXCJlcmFBYmJyXCIgOiAoIGxlbmd0aCA9PT0gNCA/IFwiZXJhTmFtZXNcIiA6IFwiZXJhTmFycm93XCIgKVxuXHRcdFx0XHRdKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFllYXJcblx0XHRcdGNhc2UgXCJ5XCI6XG5cblx0XHRcdFx0Ly8gUGxhaW4geWVhci5cblx0XHRcdFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJZXCI6XG5cblx0XHRcdFx0Ly8gWWVhciBpbiBcIldlZWsgb2YgWWVhclwiXG5cdFx0XHRcdHByb3BlcnRpZXMuZmlyc3REYXkgPSBkYXRlRmlyc3REYXlPZldlZWsoIGNsZHIgKTtcblx0XHRcdFx0cHJvcGVydGllcy5taW5EYXlzID0gY2xkci5zdXBwbGVtZW50YWwud2Vla0RhdGEubWluRGF5cygpO1xuXHRcdFx0XHRmb3JtYXROdW1iZXIgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcInVcIjogLy8gRXh0ZW5kZWQgeWVhci4gTmVlZCB0byBiZSBpbXBsZW1lbnRlZC5cblx0XHRcdGNhc2UgXCJVXCI6IC8vIEN5Y2xpYyB5ZWFyIG5hbWUuIE5lZWQgdG8gYmUgaW1wbGVtZW50ZWQuXG5cdFx0XHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdFx0XHRmZWF0dXJlOiBcInllYXIgcGF0dGVybiBgXCIgKyBjaHIgKyBcImBcIlxuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gUXVhcnRlclxuXHRcdFx0Y2FzZSBcIlFcIjpcblx0XHRcdGNhc2UgXCJxXCI6XG5cdFx0XHRcdGlmICggbGVuZ3RoID4gMiApIHtcblx0XHRcdFx0XHRpZiAoICFwcm9wZXJ0aWVzLnF1YXJ0ZXJzICkge1xuXHRcdFx0XHRcdFx0cHJvcGVydGllcy5xdWFydGVycyA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFwcm9wZXJ0aWVzLnF1YXJ0ZXJzWyBjaHIgXSApIHtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMucXVhcnRlcnNbIGNociBdID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByb3BlcnRpZXMucXVhcnRlcnNbIGNociBdWyBsZW5ndGggXSA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vcXVhcnRlcnNcIixcblx0XHRcdFx0XHRcdGNociA9PT0gXCJRXCIgPyBcImZvcm1hdFwiIDogXCJzdGFuZC1hbG9uZVwiLFxuXHRcdFx0XHRcdFx0d2lkdGhzWyBsZW5ndGggLSAzIF1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3JtYXROdW1iZXIgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBNb250aFxuXHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdGNhc2UgXCJMXCI6XG5cdFx0XHRcdGlmICggbGVuZ3RoID4gMiApIHtcblx0XHRcdFx0XHRpZiAoICFwcm9wZXJ0aWVzLm1vbnRocyApIHtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMubW9udGhzID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXByb3BlcnRpZXMubW9udGhzWyBjaHIgXSApIHtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMubW9udGhzWyBjaHIgXSA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcm9wZXJ0aWVzLm1vbnRoc1sgY2hyIF1bIGxlbmd0aCBdID0gY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9tb250aHNcIixcblx0XHRcdFx0XHRcdGNociA9PT0gXCJNXCIgPyBcImZvcm1hdFwiIDogXCJzdGFuZC1hbG9uZVwiLFxuXHRcdFx0XHRcdFx0d2lkdGhzWyBsZW5ndGggLSAzIF1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3JtYXROdW1iZXIgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBXZWVrIC0gV2VlayBvZiBZZWFyICh3KSBvciBXZWVrIG9mIE1vbnRoIChXKS5cblx0XHRcdGNhc2UgXCJ3XCI6XG5cdFx0XHRjYXNlIFwiV1wiOlxuXHRcdFx0XHRwcm9wZXJ0aWVzLmZpcnN0RGF5ID0gZGF0ZUZpcnN0RGF5T2ZXZWVrKCBjbGRyICk7XG5cdFx0XHRcdHByb3BlcnRpZXMubWluRGF5cyA9IGNsZHIuc3VwcGxlbWVudGFsLndlZWtEYXRhLm1pbkRheXMoKTtcblx0XHRcdFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIERheVxuXHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdGNhc2UgXCJEXCI6XG5cdFx0XHRjYXNlIFwiRlwiOlxuXHRcdFx0XHRmb3JtYXROdW1iZXIgPSB0cnVlO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcImdcIjpcblxuXHRcdFx0XHQvLyBNb2RpZmllZCBKdWxpYW4gZGF5LiBOZWVkIHRvIGJlIGltcGxlbWVudGVkLlxuXHRcdFx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRcdFx0ZmVhdHVyZTogXCJKdWxpYW4gZGF5IHBhdHRlcm4gYGdgXCJcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIFdlZWsgZGF5XG5cdFx0XHRjYXNlIFwiZVwiOlxuXHRcdFx0Y2FzZSBcImNcIjpcblx0XHRcdFx0aWYgKCBsZW5ndGggPD0gMiApIHtcblx0XHRcdFx0XHRwcm9wZXJ0aWVzLmZpcnN0RGF5ID0gZGF0ZUZpcnN0RGF5T2ZXZWVrKCBjbGRyICk7XG5cdFx0XHRcdFx0Zm9ybWF0TnVtYmVyID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiRVwiOlxuXHRcdFx0XHRpZiAoICFwcm9wZXJ0aWVzLmRheXMgKSB7XG5cdFx0XHRcdFx0cHJvcGVydGllcy5kYXlzID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhcHJvcGVydGllcy5kYXlzWyBjaHIgXSApIHtcblx0XHRcdFx0XHRwcm9wZXJ0aWVzLmRheXNbIGNociBdID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDYgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzaG9ydCBkYXkgbmFtZXMgYXJlIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCwgYWJicmV2aWF0ZWQgZGF5IG5hbWVzIGFyZVxuXHRcdFx0XHRcdC8vIHVzZWQgaW5zdGVhZC5cblx0XHRcdFx0XHQvLyBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LWRhdGVzLmh0bWwjbW9udGhzX2RheXNfcXVhcnRlcnNfZXJhc1xuXHRcdFx0XHRcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9jbGRyL3RyYWMvdGlja2V0LzY3OTBcblx0XHRcdFx0XHRwcm9wZXJ0aWVzLmRheXNbIGNociBdWyBsZW5ndGggXSA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlzXCIsXG5cdFx0XHRcdFx0XHRcdGNociA9PT0gXCJjXCIgPyBcInN0YW5kLWFsb25lXCIgOiBcImZvcm1hdFwiLFxuXHRcdFx0XHRcdFx0XHRcInNob3J0XCJcblx0XHRcdFx0XHRcdF0pIHx8IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlzXCIsXG5cdFx0XHRcdFx0XHRcdGNociA9PT0gXCJjXCIgPyBcInN0YW5kLWFsb25lXCIgOiBcImZvcm1hdFwiLFxuXHRcdFx0XHRcdFx0XHRcImFiYnJldmlhdGVkXCJcblx0XHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHByb3BlcnRpZXMuZGF5c1sgY2hyIF1bIGxlbmd0aCBdID0gY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlzXCIsXG5cdFx0XHRcdFx0XHRjaHIgPT09IFwiY1wiID8gXCJzdGFuZC1hbG9uZVwiIDogXCJmb3JtYXRcIixcblx0XHRcdFx0XHRcdHdpZHRoc1sgbGVuZ3RoIDwgMyA/IDAgOiBsZW5ndGggLSAzIF1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gUGVyaW9kIChBTSBvciBQTSlcblx0XHRcdGNhc2UgXCJhXCI6XG5cdFx0XHRcdHByb3BlcnRpZXMuZGF5UGVyaW9kcyA9IHtcblx0XHRcdFx0XHRhbTogY2xkci5tYWluKFxuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheVBlcmlvZHMvZm9ybWF0L3dpZGUvYW1cIlxuXHRcdFx0XHRcdCksXG5cdFx0XHRcdFx0cG06IGNsZHIubWFpbihcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlQZXJpb2RzL2Zvcm1hdC93aWRlL3BtXCJcblx0XHRcdFx0XHQpXG5cdFx0XHRcdH07XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBIb3VyXG5cdFx0XHRjYXNlIFwiaFwiOiAvLyAxLTEyXG5cdFx0XHRjYXNlIFwiSFwiOiAvLyAwLTIzXG5cdFx0XHRjYXNlIFwiS1wiOiAvLyAwLTExXG5cdFx0XHRjYXNlIFwia1wiOiAvLyAxLTI0XG5cblx0XHRcdC8vIE1pbnV0ZVxuXHRcdFx0Y2FzZSBcIm1cIjpcblxuXHRcdFx0Ly8gU2Vjb25kXG5cdFx0XHRjYXNlIFwic1wiOlxuXHRcdFx0Y2FzZSBcIlNcIjpcblx0XHRcdGNhc2UgXCJBXCI6XG5cdFx0XHRcdGZvcm1hdE51bWJlciA9IHRydWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBab25lXG5cdFx0XHRjYXNlIFwidlwiOlxuXHRcdFx0XHRpZiAoIGxlbmd0aCAhPT0gMSAmJiBsZW5ndGggIT09IDQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0XHRcdFx0ZmVhdHVyZTogXCJ0aW1lem9uZSBwYXR0ZXJuIGBcIiArIHBhdHRlcm4gKyBcImBcIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb3BlcnRpZXMuZ2VuZXJpY1R6TmFtZSA9IGdlbmVyaWNUek5hbWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiVlwiOlxuXG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdFx0XHRcdGZlYXR1cmU6IFwidGltZXpvbmUgcGF0dGVybiBgXCIgKyBwYXR0ZXJuICsgXCJgXCJcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggdGltZVpvbmUgKSB7XG5cdFx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSA9IHRpbWVab25lO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIHRpbWVab25lTmFtZSxcblx0XHRcdFx0XHRcdGV4ZW1wbGFyQ2l0eSA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcdFwiZGF0ZXMvdGltZVpvbmVOYW1lcy96b25lXCIsIHRpbWVab25lLCBcImV4ZW1wbGFyQ2l0eVwiXG5cdFx0XHRcdFx0XHRdKTtcblxuXHRcdFx0XHRcdGlmICggbGVuZ3RoID09PSAzICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhZXhlbXBsYXJDaXR5ICkge1xuXHRcdFx0XHRcdFx0XHRleGVtcGxhckNpdHkgPSBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XHRcdFwiZGF0ZXMvdGltZVpvbmVOYW1lcy96b25lL0V0Yy9Vbmtub3duL2V4ZW1wbGFyQ2l0eVwiXG5cdFx0XHRcdFx0XHRcdF0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGltZVpvbmVOYW1lID0gZXhlbXBsYXJDaXR5O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggZXhlbXBsYXJDaXR5ICYmIGxlbmd0aCA9PT0gNCApIHtcblx0XHRcdFx0XHRcdHRpbWVab25lTmFtZSA9IGZvcm1hdE1lc3NhZ2UoXG5cdFx0XHRcdFx0XHRcdGNsZHIubWFpbihcblx0XHRcdFx0XHRcdFx0XHRcImRhdGVzL3RpbWVab25lTmFtZXMvcmVnaW9uRm9ybWF0XCJcblx0XHRcdFx0XHRcdFx0KSxcblx0XHRcdFx0XHRcdFx0WyBleGVtcGxhckNpdHkgXVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoIHRpbWVab25lTmFtZSApIHtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMudGltZVpvbmVOYW1lID0gdGltZVpvbmVOYW1lO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50ID09PSBcInZcIiApIHtcblx0XHRcdFx0XHRsZW5ndGggPSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJPXCI6XG5cblx0XHRcdFx0Ly8gTzogXCJ7Z210Rm9ybWF0fStIO3tnbXRGb3JtYXR9LUhcIiBvciBcIntnbXRaZXJvRm9ybWF0fVwiLCBlZy4gXCJHTVQtOFwiIG9yIFwiR01UXCIuXG5cdFx0XHRcdC8vIE9PT086IFwie2dtdEZvcm1hdH17aG91ckZvcm1hdH1cIiBvciBcIntnbXRaZXJvRm9ybWF0fVwiLCBlZy4gXCJHTVQtMDg6MDBcIiBvciBcIkdNVFwiLlxuXHRcdFx0XHRwcm9wZXJ0aWVzLmdtdEZvcm1hdCA9IGNsZHIubWFpbiggXCJkYXRlcy90aW1lWm9uZU5hbWVzL2dtdEZvcm1hdFwiICk7XG5cdFx0XHRcdHByb3BlcnRpZXMuZ210WmVyb0Zvcm1hdCA9IGNsZHIubWFpbiggXCJkYXRlcy90aW1lWm9uZU5hbWVzL2dtdFplcm9Gb3JtYXRcIiApO1xuXG5cdFx0XHRcdC8vIFVub2ZmaWNpYWwgZGVkdWN0aW9uIG9mIHRoZSBob3VyRm9ybWF0IHZhcmlhdGlvbnMuXG5cdFx0XHRcdC8vIE9mZmljaWFsIHNwZWMgaXMgcGVuZGluZyByZXNvbHV0aW9uOiBodHRwOi8vdW5pY29kZS5vcmcvY2xkci90cmFjL3RpY2tldC84MjkzXG5cdFx0XHRcdGF1eCA9IGNsZHIubWFpbiggXCJkYXRlcy90aW1lWm9uZU5hbWVzL2hvdXJGb3JtYXRcIiApO1xuXHRcdFx0XHRwcm9wZXJ0aWVzLmhvdXJGb3JtYXQgPSBsZW5ndGggPCA0ID9cblx0XHRcdFx0XHRbIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIKCBhdXggKSwgZGF0ZVRpbWV6b25lSG91ckZvcm1hdEhtKCBhdXgsIFwiSFwiICkgXSA6XG5cdFx0XHRcdFx0ZGF0ZVRpbWV6b25lSG91ckZvcm1hdEhtKCBhdXgsIFwiSEhcIiApO1xuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiWlwiOlxuXHRcdFx0Y2FzZSBcIlhcIjpcblx0XHRcdGNhc2UgXCJ4XCI6XG5cdFx0XHRcdHNldE51bWJlckZvcm1hdHRlclBhdHRlcm4oIDEgKTtcblx0XHRcdFx0c2V0TnVtYmVyRm9ybWF0dGVyUGF0dGVybiggMiApO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cblx0XHRpZiAoIGZvcm1hdE51bWJlciApIHtcblx0XHRcdHNldE51bWJlckZvcm1hdHRlclBhdHRlcm4oIGxlbmd0aCApO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHByb3BlcnRpZXM7XG59O1xuXG5cblxuXG52YXIgZGF0ZUZvcm1hdHRlckZuID0gZnVuY3Rpb24oIGRhdGVUb1BhcnRzRm9ybWF0dGVyICkge1xuXHRyZXR1cm4gZnVuY3Rpb24gZGF0ZUZvcm1hdHRlciggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGRhdGVUb1BhcnRzRm9ybWF0dGVyKCB2YWx1ZSApLm1hcCggZnVuY3Rpb24oIHBhcnQgKSB7XG5cdFx0XHRyZXR1cm4gcGFydC52YWx1ZTtcblx0XHR9KS5qb2luKCBcIlwiICk7XG5cdH07XG59O1xuXG5cblxuXG4vKipcbiAqIHBhcnNlUHJvcGVydGllcyggY2xkciApXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIEB0aW1lWm9uZSBbU3RyaW5nXSBGSVhNRS5cbiAqXG4gKiBSZXR1cm4gcGFyc2VyIHByb3BlcnRpZXMuXG4gKi9cbnZhciBkYXRlUGFyc2VQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIGNsZHIsIHRpbWVab25lICkge1xuXHR2YXIgcHJvcGVydGllcyA9IHtcblx0XHRwcmVmZXJyZWRUaW1lRGF0YTogY2xkci5zdXBwbGVtZW50YWwudGltZURhdGEucHJlZmVycmVkKClcblx0fTtcblxuXHRpZiAoIHRpbWVab25lICkge1xuXHRcdHByb3BlcnRpZXMudGltZVpvbmVEYXRhID0gcnVudGltZUNhY2hlRGF0YUJpbmQoIFwiaWFuYS9cIiArIHRpbWVab25lLCB7XG5cdFx0XHRvZmZzZXRzOiBjbGRyLmdldChbIFwiZ2xvYmFsaXplLWlhbmEvem9uZURhdGFcIiwgdGltZVpvbmUsIFwib2Zmc2V0c1wiIF0pLFxuXHRcdFx0dW50aWxzOiBjbGRyLmdldChbIFwiZ2xvYmFsaXplLWlhbmEvem9uZURhdGFcIiwgdGltZVpvbmUsIFwidW50aWxzXCIgXSksXG5cdFx0XHRpc2RzdHM6IGNsZHIuZ2V0KFsgXCJnbG9iYWxpemUtaWFuYS96b25lRGF0YVwiLCB0aW1lWm9uZSwgXCJpc2RzdHNcIiBdKVxuXHRcdH0pO1xuXHR9XG5cblx0cmV0dXJuIHByb3BlcnRpZXM7XG59O1xuXG5cbnZhciBab25lZERhdGVUaW1lID0gKGZ1bmN0aW9uKCkge1xuZnVuY3Rpb24gZGVmaW5lUHJpdmF0ZVByb3BlcnR5KG9iamVjdCwgcHJvcGVydHksIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5LCB7XG4gICAgdmFsdWU6IHZhbHVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRVbnRpbHNJbmRleChvcmlnaW5hbCwgdW50aWxzKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBvcmlnaW5hbFRpbWUgPSBvcmlnaW5hbC5nZXRUaW1lKCk7XG5cbiAgLy8gVE9ETyBTaG91bGQgd2UgZG8gYmluYXJ5IHNlYXJjaCBmb3IgaW1wcm92ZWQgcGVyZm9ybWFuY2U/XG4gIHdoaWxlIChpbmRleCA8IHVudGlscy5sZW5ndGggLSAxICYmIG9yaWdpbmFsVGltZSA+PSB1bnRpbHNbaW5kZXhdKSB7XG4gICAgaW5kZXgrKztcbiAgfVxuICByZXR1cm4gaW5kZXg7XG59XG5cbmZ1bmN0aW9uIHNldFdyYXAoZm4pIHtcbiAgdmFyIG9mZnNldDEgPSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIHZhciByZXQgPSBmbigpO1xuICB0aGlzLm9yaWdpbmFsLnNldFRpbWUobmV3IERhdGUodGhpcy5nZXRUaW1lKCkpKTtcbiAgdmFyIG9mZnNldDIgPSB0aGlzLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gIGlmIChvZmZzZXQyIC0gb2Zmc2V0MSkge1xuICAgIHRoaXMub3JpZ2luYWwuc2V0TWludXRlcyh0aGlzLm9yaWdpbmFsLmdldE1pbnV0ZXMoKSArIG9mZnNldDIgLSBvZmZzZXQxKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG52YXIgWm9uZWREYXRlVGltZSA9IGZ1bmN0aW9uKGRhdGUsIHRpbWVab25lRGF0YSkge1xuICBkZWZpbmVQcml2YXRlUHJvcGVydHkodGhpcywgXCJvcmlnaW5hbFwiLCBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSkpO1xuICBkZWZpbmVQcml2YXRlUHJvcGVydHkodGhpcywgXCJsb2NhbFwiLCBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSkpO1xuICBkZWZpbmVQcml2YXRlUHJvcGVydHkodGhpcywgXCJ0aW1lWm9uZURhdGFcIiwgdGltZVpvbmVEYXRhKTtcbiAgZGVmaW5lUHJpdmF0ZVByb3BlcnR5KHRoaXMsIFwic2V0V3JhcFwiLCBzZXRXcmFwKTtcbiAgaWYgKCEodGltZVpvbmVEYXRhLnVudGlscyAmJiB0aW1lWm9uZURhdGEub2Zmc2V0cyAmJiB0aW1lWm9uZURhdGEuaXNkc3RzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgSUFOQSBkYXRhXCIpO1xuICB9XG4gIHRoaXMuc2V0VGltZSh0aGlzLmxvY2FsLmdldFRpbWUoKSAtIHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMCk7XG59O1xuXG5ab25lZERhdGVUaW1lLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFpvbmVkRGF0ZVRpbWUodGhpcy5vcmlnaW5hbCwgdGhpcy50aW1lWm9uZURhdGEpO1xufTtcblxuLy8gRGF0ZSBmaWVsZCBnZXR0ZXJzLlxuW1wiZ2V0RnVsbFllYXJcIiwgXCJnZXRNb250aFwiLCBcImdldERhdGVcIiwgXCJnZXREYXlcIiwgXCJnZXRIb3Vyc1wiLCBcImdldE1pbnV0ZXNcIixcblwiZ2V0U2Vjb25kc1wiLCBcImdldE1pbGxpc2Vjb25kc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAvLyBDb3JyZXNwb25kaW5nIFVUQyBtZXRob2QsIGUuZy4sIFwiZ2V0VVRDRnVsbFllYXJcIiBpZiBtZXRob2QgPT09IFwiZ2V0RnVsbFllYXJcIi5cbiAgdmFyIHV0Y01ldGhvZCA9IFwiZ2V0VVRDXCIgKyBtZXRob2Quc3Vic3RyKDMpO1xuICBab25lZERhdGVUaW1lLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWxbdXRjTWV0aG9kXSgpO1xuICB9O1xufSk7XG5cbi8vIE5vdGU6IERlZmluZSAudmFsdWVPZiA9IC5nZXRUaW1lIGZvciBhcml0aG1ldGljIG9wZXJhdGlvbnMgbGlrZSBkYXRlMSAtIGRhdGUyLlxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUudmFsdWVPZiA9XG5ab25lZERhdGVUaW1lLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLmxvY2FsLmdldFRpbWUoKSArIHRoaXMuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwICogMTAwMDtcbn07XG5cblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLmdldFRpbWV6b25lT2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpbmRleCA9IGdldFVudGlsc0luZGV4KHRoaXMub3JpZ2luYWwsIHRoaXMudGltZVpvbmVEYXRhLnVudGlscyk7XG4gIHJldHVybiB0aGlzLnRpbWVab25lRGF0YS5vZmZzZXRzW2luZGV4XTtcbn07XG5cbi8vIERhdGUgZmllbGQgc2V0dGVycy5cbltcInNldEZ1bGxZZWFyXCIsIFwic2V0TW9udGhcIiwgXCJzZXREYXRlXCIsIFwic2V0SG91cnNcIiwgXCJzZXRNaW51dGVzXCIsIFwic2V0U2Vjb25kc1wiLCBcInNldE1pbGxpc2Vjb25kc1wiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAvLyBDb3JyZXNwb25kaW5nIFVUQyBtZXRob2QsIGUuZy4sIFwic2V0VVRDRnVsbFllYXJcIiBpZiBtZXRob2QgPT09IFwic2V0RnVsbFllYXJcIi5cbiAgdmFyIHV0Y01ldGhvZCA9IFwic2V0VVRDXCIgKyBtZXRob2Quc3Vic3RyKDMpO1xuICBab25lZERhdGVUaW1lLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgbG9jYWwgPSB0aGlzLmxvY2FsO1xuICAgIC8vIE5vdGUgc2V0V3JhcCBpcyBuZWVkZWQgZm9yIHNlY29uZHMgYW5kIG1pbGxpc2Vjb25kcyBqdXN0IGJlY2F1c2VcbiAgICAvLyBhYnModmFsdWUpIGNvdWxkIGJlID49IGEgbWludXRlLlxuICAgIHJldHVybiB0aGlzLnNldFdyYXAoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbG9jYWxbdXRjTWV0aG9kXSh2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG59KTtcblxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuc2V0VGltZSA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgcmV0dXJuIHRoaXMubG9jYWwuc2V0VGltZSh0aW1lKTtcbn07XG5cblpvbmVkRGF0ZVRpbWUucHJvdG90eXBlLmlzRFNUID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpbmRleCA9IGdldFVudGlsc0luZGV4KHRoaXMub3JpZ2luYWwsIHRoaXMudGltZVpvbmVEYXRhLnVudGlscyk7XG4gIHJldHVybiBCb29sZWFuKHRoaXMudGltZVpvbmVEYXRhLmlzZHN0c1tpbmRleF0pO1xufTtcblxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5kZXggPSBnZXRVbnRpbHNJbmRleCh0aGlzLm9yaWdpbmFsLCB0aGlzLnRpbWVab25lRGF0YS51bnRpbHMpO1xuICB2YXIgYWJicnMgPSB0aGlzLnRpbWVab25lRGF0YS5hYmJycztcbiAgcmV0dXJuIHRoaXMubG9jYWwudG9JU09TdHJpbmcoKS5yZXBsYWNlKC9aJC8sIFwiXCIpICsgXCIgXCIgK1xuICAgIChhYmJycyAmJiBhYmJyc1tpbmRleF0gKyBcIiBcIiB8fCAodGhpcy5nZXRUaW1lem9uZU9mZnNldCgpICogLTEpICsgXCIgXCIpICtcbiAgICAodGhpcy5pc0RTVCgpID8gXCIoZGF5bGlnaHQgc2F2aW5ncylcIiA6IFwiXCIpO1xufTtcblxuWm9uZWREYXRlVGltZS5wcm90b3R5cGUudG9EYXRlID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgRGF0ZSh0aGlzLmdldFRpbWUoKSk7XG59O1xuXG4vLyBUeXBlIGNhc3QgZ2V0dGVycy5cbltcInRvSVNPU3RyaW5nXCIsIFwidG9KU09OXCIsIFwidG9VVENTdHJpbmdcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgWm9uZWREYXRlVGltZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpW21ldGhvZF0oKTtcbiAgfTtcbn0pO1xuXG5yZXR1cm4gWm9uZWREYXRlVGltZTtcbn0oKSk7XG5cblxuLyoqXG4gKiBpc0xlYXBZZWFyKCB5ZWFyIClcbiAqXG4gKiBAeWVhciBbTnVtYmVyXVxuICpcbiAqIFJldHVybnMgYW4gaW5kaWNhdGlvbiB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgeWVhciBpcyBhIGxlYXAgeWVhci5cbiAqL1xudmFyIGRhdGVJc0xlYXBZZWFyID0gZnVuY3Rpb24oIHllYXIgKSB7XG5cdHJldHVybiBuZXcgRGF0ZSggeWVhciwgMSwgMjkgKS5nZXRNb250aCgpID09PSAxO1xufTtcblxuXG5cblxuLyoqXG4gKiBsYXN0RGF5T2ZNb250aCggZGF0ZSApXG4gKlxuICogQGRhdGUgW0RhdGVdXG4gKlxuICogUmV0dXJuIHRoZSBsYXN0IGRheSBvZiB0aGUgZ2l2ZW4gZGF0ZSdzIG1vbnRoXG4gKi9cbnZhciBkYXRlTGFzdERheU9mTW9udGggPSBmdW5jdGlvbiggZGF0ZSApIHtcblx0cmV0dXJuIG5ldyBEYXRlKCBkYXRlLmdldEZ1bGxZZWFyKCksIGRhdGUuZ2V0TW9udGgoKSArIDEsIDAgKS5nZXREYXRlKCk7XG59O1xuXG5cblxuXG4vKipcbiAqIHN0YXJ0T2YgY2hhbmdlcyB0aGUgaW5wdXQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZ2l2ZW4gdW5pdC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgc3RhcnRpbmcgYXQgdGhlIHN0YXJ0IG9mIGEgZGF5LCByZXNldHMgaG91cnMsIG1pbnV0ZXNcbiAqIHNlY29uZHMgYW5kIG1pbGxpc2Vjb25kcyB0byAwLiBTdGFydGluZyBhdCB0aGUgbW9udGggZG9lcyB0aGUgc2FtZSwgYnV0XG4gKiBhbHNvIHNldHMgdGhlIGRhdGUgdG8gMS5cbiAqXG4gKiBSZXR1cm5zIHRoZSBtb2RpZmllZCBkYXRlXG4gKi9cbnZhciBkYXRlU3RhcnRPZiA9IGZ1bmN0aW9uKCBkYXRlLCB1bml0ICkge1xuXHRkYXRlID0gZGF0ZSBpbnN0YW5jZW9mIFpvbmVkRGF0ZVRpbWUgPyBkYXRlLmNsb25lKCkgOiBuZXcgRGF0ZSggZGF0ZS5nZXRUaW1lKCkgKTtcblx0c3dpdGNoICggdW5pdCApIHtcblx0XHRjYXNlIFwieWVhclwiOlxuXHRcdFx0ZGF0ZS5zZXRNb250aCggMCApO1xuXHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRjYXNlIFwibW9udGhcIjpcblx0XHRcdGRhdGUuc2V0RGF0ZSggMSApO1xuXHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRjYXNlIFwiZGF5XCI6XG5cdFx0XHRkYXRlLnNldEhvdXJzKCAwICk7XG5cdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgXCJob3VyXCI6XG5cdFx0XHRkYXRlLnNldE1pbnV0ZXMoIDAgKTtcblx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0Y2FzZSBcIm1pbnV0ZVwiOlxuXHRcdFx0ZGF0ZS5zZXRTZWNvbmRzKCAwICk7XG5cdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdGNhc2UgXCJzZWNvbmRcIjpcblx0XHRcdGRhdGUuc2V0TWlsbGlzZWNvbmRzKCAwICk7XG5cdH1cblx0cmV0dXJuIGRhdGU7XG59O1xuXG5cblxuXG4vKipcbiAqIERpZmZlcmVudGx5IGZyb20gbmF0aXZlIGRhdGUuc2V0RGF0ZSgpLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSBkYXRlIHdob3NlXG4gKiBkYXkgcmVtYWlucyBpbnNpZGUgdGhlIG1vbnRoIGJvdW5kYXJpZXMuIEZvciBleGFtcGxlOlxuICpcbiAqIHNldERhdGUoIEZlYkRhdGUsIDMxICk6IGEgXCJGZWIgMjhcIiBkYXRlLlxuICogc2V0RGF0ZSggU2VwRGF0ZSwgMzEgKTogYSBcIlNlcCAzMFwiIGRhdGUuXG4gKi9cbnZhciBkYXRlU2V0RGF0ZSA9IGZ1bmN0aW9uKCBkYXRlLCBkYXkgKSB7XG5cdHZhciBsYXN0RGF5ID0gbmV3IERhdGUoIGRhdGUuZ2V0RnVsbFllYXIoKSwgZGF0ZS5nZXRNb250aCgpICsgMSwgMCApLmdldERhdGUoKTtcblxuXHRkYXRlLnNldERhdGUoIGRheSA8IDEgPyAxIDogZGF5IDwgbGFzdERheSA/IGRheSA6IGxhc3REYXkgKTtcbn07XG5cblxuXG5cbi8qKlxuICogRGlmZmVyZW50bHkgZnJvbSBuYXRpdmUgZGF0ZS5zZXRNb250aCgpLCB0aGlzIGZ1bmN0aW9uIGFkanVzdHMgZGF0ZSBpZlxuICogbmVlZGVkLCBzbyBmaW5hbCBtb250aCBpcyBhbHdheXMgdGhlIG9uZSBzZXQuXG4gKlxuICogc2V0TW9udGgoIEphbjMxRGF0ZSwgMSApOiBhIFwiRmViIDI4XCIgZGF0ZS5cbiAqIHNldERhdGUoIEphbjMxRGF0ZSwgOCApOiBhIFwiU2VwIDMwXCIgZGF0ZS5cbiAqL1xudmFyIGRhdGVTZXRNb250aCA9IGZ1bmN0aW9uKCBkYXRlLCBtb250aCApIHtcblx0dmFyIG9yaWdpbmFsRGF0ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXG5cdGRhdGUuc2V0RGF0ZSggMSApO1xuXHRkYXRlLnNldE1vbnRoKCBtb250aCApO1xuXHRkYXRlU2V0RGF0ZSggZGF0ZSwgb3JpZ2luYWxEYXRlICk7XG59O1xuXG5cblxuXG52YXIgb3V0T2ZSYW5nZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgbG93LCBoaWdoICkge1xuXHRyZXR1cm4gdmFsdWUgPCBsb3cgfHwgdmFsdWUgPiBoaWdoO1xufTtcblxuXG5cblxuLyoqXG4gKiBwYXJzZSggdmFsdWUsIHRva2VucywgcHJvcGVydGllcyApXG4gKlxuICogQHZhbHVlIFtTdHJpbmddIHN0cmluZyBkYXRlLlxuICpcbiAqIEB0b2tlbnMgW09iamVjdF0gdG9rZW5zIHJldHVybmVkIGJ5IGRhdGUvdG9rZW5pemVyLlxuICpcbiAqIEBwcm9wZXJ0aWVzIFtPYmplY3RdIG91dHB1dCByZXR1cm5lZCBieSBkYXRlL3Rva2VuaXplci1wcm9wZXJ0aWVzLlxuICpcbiAqIHJlZjogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXG4gKi9cbnZhciBkYXRlUGFyc2UgPSBmdW5jdGlvbiggdmFsdWUsIHRva2VucywgcHJvcGVydGllcyApIHtcblx0dmFyIGFtUG0sIGRheSwgZGF5c09mWWVhciwgbW9udGgsIGVyYSwgaG91ciwgaG91cjEyLCB0aW1lem9uZU9mZnNldCwgdmFsaWQsXG5cdFx0WUVBUiA9IDAsXG5cdFx0TU9OVEggPSAxLFxuXHRcdERBWSA9IDIsXG5cdFx0SE9VUiA9IDMsXG5cdFx0TUlOVVRFID0gNCxcblx0XHRTRUNPTkQgPSA1LFxuXHRcdE1JTExJU0VDT05EUyA9IDYsXG5cdFx0ZGF0ZSA9IG5ldyBEYXRlKCksXG5cdFx0dHJ1bmNhdGVBdCA9IFtdLFxuXHRcdHVuaXRzID0gWyBcInllYXJcIiwgXCJtb250aFwiLCBcImRheVwiLCBcImhvdXJcIiwgXCJtaW51dGVcIiwgXCJzZWNvbmRcIiwgXCJtaWxsaXNlY29uZHNcIiBdO1xuXG5cdC8vIENyZWF0ZSBnbG9iYWxpemUgZGF0ZSB3aXRoIGdpdmVuIHRpbWV6b25lIGRhdGEuXG5cdGlmICggcHJvcGVydGllcy50aW1lWm9uZURhdGEgKSB7XG5cdFx0ZGF0ZSA9IG5ldyBab25lZERhdGVUaW1lKCBkYXRlLCBwcm9wZXJ0aWVzLnRpbWVab25lRGF0YSgpICk7XG5cdH1cblxuXHRpZiAoICF0b2tlbnMubGVuZ3RoICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFsaWQgPSB0b2tlbnMuZXZlcnkoZnVuY3Rpb24oIHRva2VuICkge1xuXHRcdHZhciBjZW50dXJ5LCBjaHIsIHZhbHVlLCBsZW5ndGg7XG5cblx0XHRpZiAoIHRva2VuLnR5cGUgPT09IFwibGl0ZXJhbFwiICkge1xuXG5cdFx0XHQvLyBjb250aW51ZVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Y2hyID0gdG9rZW4udHlwZS5jaGFyQXQoIDAgKTtcblx0XHRsZW5ndGggPSB0b2tlbi50eXBlLmxlbmd0aDtcblxuXHRcdGlmICggY2hyID09PSBcImpcIiApIHtcblxuXHRcdFx0Ly8gTG9jYWxlIHByZWZlcnJlZCBoSEtrLlxuXHRcdFx0Ly8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI1RpbWVfRGF0YVxuXHRcdFx0Y2hyID0gcHJvcGVydGllcy5wcmVmZXJyZWRUaW1lRGF0YTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBjaHIgKSB7XG5cblx0XHRcdC8vIEVyYVxuXHRcdFx0Y2FzZSBcIkdcIjpcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBZRUFSICk7XG5cdFx0XHRcdGVyYSA9ICt0b2tlbi52YWx1ZTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFllYXJcblx0XHRcdGNhc2UgXCJ5XCI6XG5cdFx0XHRcdHZhbHVlID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSAyICkge1xuXHRcdFx0XHRcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDAsIDk5ICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gbWltaWMgZG9qby9kYXRlL2xvY2FsZTogY2hvb3NlIGNlbnR1cnkgdG8gYXBwbHksIGFjY29yZGluZyB0byBhIHNsaWRpbmdcblx0XHRcdFx0XHQvLyB3aW5kb3cgb2YgODAgeWVhcnMgYmVmb3JlIGFuZCAyMCB5ZWFycyBhZnRlciBwcmVzZW50IHllYXIuXG5cdFx0XHRcdFx0Y2VudHVyeSA9IE1hdGguZmxvb3IoIGRhdGUuZ2V0RnVsbFllYXIoKSAvIDEwMCApICogMTAwO1xuXHRcdFx0XHRcdHZhbHVlICs9IGNlbnR1cnk7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA+IGRhdGUuZ2V0RnVsbFllYXIoKSArIDIwICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgLT0gMTAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRlLnNldEZ1bGxZZWFyKCB2YWx1ZSApO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIFlFQVIgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJZXCI6IC8vIFllYXIgaW4gXCJXZWVrIG9mIFllYXJcIlxuXHRcdFx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRcdFx0ZmVhdHVyZTogXCJ5ZWFyIHBhdHRlcm4gYFwiICsgY2hyICsgXCJgXCJcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIFF1YXJ0ZXIgKHNraXApXG5cdFx0XHRjYXNlIFwiUVwiOlxuXHRcdFx0Y2FzZSBcInFcIjpcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIE1vbnRoXG5cdFx0XHRjYXNlIFwiTVwiOlxuXHRcdFx0Y2FzZSBcIkxcIjpcblx0XHRcdFx0aWYgKCBsZW5ndGggPD0gMiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gK3Rva2VuLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDEsIDEyICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0dGluZyB0aGUgbW9udGggbGF0ZXIgc28gdGhhdCB3ZSBoYXZlIHRoZSBjb3JyZWN0IHllYXIgYW5kIGNhbiBkZXRlcm1pbmVcblx0XHRcdFx0Ly8gdGhlIGNvcnJlY3QgbGFzdCBkYXkgb2YgRmVicnVhcnkgaW4gY2FzZSBvZiBsZWFwIHllYXIuXG5cdFx0XHRcdG1vbnRoID0gdmFsdWU7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggTU9OVEggKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFdlZWsgKHNraXApXG5cdFx0XHRjYXNlIFwid1wiOiAvLyBXZWVrIG9mIFllYXIuXG5cdFx0XHRjYXNlIFwiV1wiOiAvLyBXZWVrIG9mIE1vbnRoLlxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gRGF5XG5cdFx0XHRjYXNlIFwiZFwiOlxuXHRcdFx0XHRkYXkgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBEQVkgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJEXCI6XG5cdFx0XHRcdGRheXNPZlllYXIgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBEQVkgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJGXCI6XG5cblx0XHRcdFx0Ly8gRGF5IG9mIFdlZWsgaW4gbW9udGguIGVnLiAybmQgV2VkIGluIEp1bHkuXG5cdFx0XHRcdC8vIFNraXBcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFdlZWsgZGF5XG5cdFx0XHRjYXNlIFwiZVwiOlxuXHRcdFx0Y2FzZSBcImNcIjpcblx0XHRcdGNhc2UgXCJFXCI6XG5cblx0XHRcdFx0Ly8gU2tpcC5cblx0XHRcdFx0Ly8gdmFsdWUgPSBhcnJheUluZGV4T2YoIGRhdGVXZWVrRGF5cywgdG9rZW4udmFsdWUgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFBlcmlvZCAoQU0gb3IgUE0pXG5cdFx0XHRjYXNlIFwiYVwiOlxuXHRcdFx0XHRhbVBtID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBIb3VyXG5cdFx0XHRjYXNlIFwiaFwiOiAvLyAxLTEyXG5cdFx0XHRcdHZhbHVlID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDEsIDEyICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhvdXIgPSBob3VyMTIgPSB0cnVlO1xuXHRcdFx0XHRkYXRlLnNldEhvdXJzKCB2YWx1ZSA9PT0gMTIgPyAwIDogdmFsdWUgKTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBIT1VSICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiS1wiOiAvLyAwLTExXG5cdFx0XHRcdHZhbHVlID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDAsIDExICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhvdXIgPSBob3VyMTIgPSB0cnVlO1xuXHRcdFx0XHRkYXRlLnNldEhvdXJzKCB2YWx1ZSApO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIEhPVVIgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJrXCI6IC8vIDEtMjRcblx0XHRcdFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMSwgMjQgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG91ciA9IHRydWU7XG5cdFx0XHRcdGRhdGUuc2V0SG91cnMoIHZhbHVlID09PSAyNCA/IDAgOiB2YWx1ZSApO1xuXHRcdFx0XHR0cnVuY2F0ZUF0LnB1c2goIEhPVVIgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJIXCI6IC8vIDAtMjNcblx0XHRcdFx0dmFsdWUgPSB0b2tlbi52YWx1ZTtcblx0XHRcdFx0aWYgKCBvdXRPZlJhbmdlKCB2YWx1ZSwgMCwgMjMgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aG91ciA9IHRydWU7XG5cdFx0XHRcdGRhdGUuc2V0SG91cnMoIHZhbHVlICk7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggSE9VUiApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gTWludXRlXG5cdFx0XHRjYXNlIFwibVwiOlxuXHRcdFx0XHR2YWx1ZSA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHRpZiAoIG91dE9mUmFuZ2UoIHZhbHVlLCAwLCA1OSApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRlLnNldE1pbnV0ZXMoIHZhbHVlICk7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggTUlOVVRFICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBTZWNvbmRcblx0XHRcdGNhc2UgXCJzXCI6XG5cdFx0XHRcdHZhbHVlID0gdG9rZW4udmFsdWU7XG5cdFx0XHRcdGlmICggb3V0T2ZSYW5nZSggdmFsdWUsIDAsIDU5ICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGUuc2V0U2Vjb25kcyggdmFsdWUgKTtcblx0XHRcdFx0dHJ1bmNhdGVBdC5wdXNoKCBTRUNPTkQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJBXCI6XG5cdFx0XHRcdGRhdGUuc2V0SG91cnMoIDAgKTtcblx0XHRcdFx0ZGF0ZS5zZXRNaW51dGVzKCAwICk7XG5cdFx0XHRcdGRhdGUuc2V0U2Vjb25kcyggMCApO1xuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiU1wiOlxuXHRcdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQoIHRva2VuLnZhbHVlICogTWF0aC5wb3coIDEwLCAzIC0gbGVuZ3RoICkgKTtcblx0XHRcdFx0ZGF0ZS5zZXRNaWxsaXNlY29uZHMoIHZhbHVlICk7XG5cdFx0XHRcdHRydW5jYXRlQXQucHVzaCggTUlMTElTRUNPTkRTICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBab25lXG5cdFx0XHRjYXNlIFwielwiOlxuXHRcdFx0Y2FzZSBcIlpcIjpcblx0XHRcdGNhc2UgXCJPXCI6XG5cdFx0XHRjYXNlIFwidlwiOlxuXHRcdFx0Y2FzZSBcIlZcIjpcblx0XHRcdGNhc2UgXCJYXCI6XG5cdFx0XHRjYXNlIFwieFwiOlxuXHRcdFx0XHRpZiAoIHR5cGVvZiB0b2tlbi52YWx1ZSA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHR0aW1lem9uZU9mZnNldCA9IHRva2VuLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9KTtcblxuXHRpZiAoICF2YWxpZCApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIDEyLWhvdXIgZm9ybWF0IG5lZWRzIEFNIG9yIFBNLCAyNC1ob3VyIGZvcm1hdCBkb2Vzbid0LCBpZS4gcmV0dXJuIG51bGxcblx0Ly8gaWYgYW1QbSAmJiAhaG91cjEyIHx8ICFhbVBtICYmIGhvdXIxMi5cblx0aWYgKCBob3VyICYmICEoICFhbVBtIF4gaG91cjEyICkgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRpZiAoIGVyYSA9PT0gMCApIHtcblxuXHRcdC8vIDEgQkMgPSB5ZWFyIDBcblx0XHRkYXRlLnNldEZ1bGxZZWFyKCBkYXRlLmdldEZ1bGxZZWFyKCkgKiAtMSArIDEgKTtcblx0fVxuXG5cdGlmICggbW9udGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRkYXRlU2V0TW9udGgoIGRhdGUsIG1vbnRoIC0gMSApO1xuXHR9XG5cblx0aWYgKCBkYXkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRpZiAoIG91dE9mUmFuZ2UoIGRheSwgMSwgZGF0ZUxhc3REYXlPZk1vbnRoKCBkYXRlICkgKSApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRkYXRlLnNldERhdGUoIGRheSApO1xuXHR9IGVsc2UgaWYgKCBkYXlzT2ZZZWFyICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0aWYgKCBvdXRPZlJhbmdlKCBkYXlzT2ZZZWFyLCAxLCBkYXRlSXNMZWFwWWVhciggZGF0ZS5nZXRGdWxsWWVhcigpICkgPyAzNjYgOiAzNjUgKSApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHRkYXRlLnNldE1vbnRoKCAwICk7XG5cdFx0ZGF0ZS5zZXREYXRlKCBkYXlzT2ZZZWFyICk7XG5cdH1cblxuXHRpZiAoIGhvdXIxMiAmJiBhbVBtID09PSBcInBtXCIgKSB7XG5cdFx0ZGF0ZS5zZXRIb3VycyggZGF0ZS5nZXRIb3VycygpICsgMTIgKTtcblx0fVxuXG5cdGlmICggdGltZXpvbmVPZmZzZXQgIT09IHVuZGVmaW5lZCApIHtcblx0XHRkYXRlLnNldE1pbnV0ZXMoIGRhdGUuZ2V0TWludXRlcygpICsgdGltZXpvbmVPZmZzZXQgLSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKTtcblx0fVxuXG5cdC8vIFRydW5jYXRlIGRhdGUgYXQgdGhlIG1vc3QgcHJlY2lzZSB1bml0IGRlZmluZWQuIEVnLlxuXHQvLyBJZiB2YWx1ZSBpcyBcIjEyLzMxXCIsIGFuZCBwYXR0ZXJuIGlzIFwiTU0vZGRcIjpcblx0Ly8gPT4gbmV3IERhdGUoIDxjdXJyZW50IFllYXI+LCAxMiwgMzEsIDAsIDAsIDAsIDAgKTtcblx0dHJ1bmNhdGVBdCA9IE1hdGgubWF4LmFwcGx5KCBudWxsLCB0cnVuY2F0ZUF0ICk7XG5cdGRhdGUgPSBkYXRlU3RhcnRPZiggZGF0ZSwgdW5pdHNbIHRydW5jYXRlQXQgXSApO1xuXG5cdC8vIEdldCBkYXRlIGJhY2sgZnJvbSBnbG9iYWxpemUgZGF0ZS5cblx0aWYgKCBkYXRlIGluc3RhbmNlb2YgWm9uZWREYXRlVGltZSApIHtcblx0XHRkYXRlID0gZGF0ZS50b0RhdGUoKTtcblx0fVxuXG5cdHJldHVybiBkYXRlO1xufTtcblxuXG5cblxuLyoqXG4gKiB0b2tlbml6ZXIoIHZhbHVlLCBudW1iZXJQYXJzZXIsIHByb3BlcnRpZXMgKVxuICpcbiAqIEB2YWx1ZSBbU3RyaW5nXSBzdHJpbmcgZGF0ZS5cbiAqXG4gKiBAbnVtYmVyUGFyc2VyIFtGdW5jdGlvbl1cbiAqXG4gKiBAcHJvcGVydGllcyBbT2JqZWN0XSBvdXRwdXQgcmV0dXJuZWQgYnkgZGF0ZS90b2tlbml6ZXItcHJvcGVydGllcy5cbiAqXG4gKiBSZXR1cm5zIGFuIEFycmF5IG9mIHRva2VucywgZWcuIHZhbHVlIFwiNSBvJ2Nsb2NrIFBNXCIsIHBhdHRlcm4gXCJoICdvJydjbG9jaycgYVwiOlxuICogW3tcbiAqICAgdHlwZTogXCJoXCIsXG4gKiAgIGxleGVtZTogXCI1XCJcbiAqIH0sIHtcbiAqICAgdHlwZTogXCJsaXRlcmFsXCIsXG4gKiAgIGxleGVtZTogXCIgXCJcbiAqIH0sIHtcbiAqICAgdHlwZTogXCJsaXRlcmFsXCIsXG4gKiAgIGxleGVtZTogXCJvJ2Nsb2NrXCJcbiAqIH0sIHtcbiAqICAgdHlwZTogXCJsaXRlcmFsXCIsXG4gKiAgIGxleGVtZTogXCIgXCJcbiAqIH0sIHtcbiAqICAgdHlwZTogXCJhXCIsXG4gKiAgIGxleGVtZTogXCJQTVwiLFxuICogICB2YWx1ZTogXCJwbVwiXG4gKiB9XVxuICpcbiAqIE9CUzogbGV4ZW1lJ3MgYXJlIGFsd2F5cyBTdHJpbmcgYW5kIG1heSByZXR1cm4gaW52YWxpZCByYW5nZXMgZGVwZW5kaW5nIG9mIHRoZSB0b2tlbiB0eXBlLlxuICogRWcuIFwiOTlcIiBmb3IgbW9udGggbnVtYmVyLlxuICpcbiAqIFJldHVybiBhbiBlbXB0eSBBcnJheSB3aGVuIG5vdCBzdWNjZXNzZnVsbHkgcGFyc2VkLlxuICovXG52YXIgZGF0ZVRva2VuaXplciA9IGZ1bmN0aW9uKCB2YWx1ZSwgbnVtYmVyUGFyc2VyLCBwcm9wZXJ0aWVzICkge1xuXHR2YXIgZGlnaXRzUmUsIHZhbGlkLFxuXHRcdHRva2VucyA9IFtdLFxuXHRcdHdpZHRocyA9IFsgXCJhYmJyZXZpYXRlZFwiLCBcIndpZGVcIiwgXCJuYXJyb3dcIiBdO1xuXG5cdGRpZ2l0c1JlID0gcHJvcGVydGllcy5kaWdpdHNSZTtcblx0dmFsdWUgPSBsb29zZU1hdGNoaW5nKCB2YWx1ZSApO1xuXG5cdHZhbGlkID0gcHJvcGVydGllcy5wYXR0ZXJuLm1hdGNoKCBkYXRlUGF0dGVyblJlICkuZXZlcnkoZnVuY3Rpb24oIGN1cnJlbnQgKSB7XG5cdFx0dmFyIGF1eCwgY2hyLCBsZW5ndGgsIG51bWVyaWMsIHRva2VuUmUsXG5cdFx0XHR0b2tlbiA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gaG91ckZvcm1hdFBhcnNlKCB0b2tlblJlLCBudW1iZXJQYXJzZXIgKSB7XG5cdFx0XHR2YXIgYXV4LCBpc1Bvc2l0aXZlLFxuXHRcdFx0XHRtYXRjaCA9IHZhbHVlLm1hdGNoKCB0b2tlblJlICk7XG5cdFx0XHRudW1iZXJQYXJzZXIgPSBudW1iZXJQYXJzZXIgfHwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gK3ZhbHVlO1xuXHRcdFx0fTtcblxuXHRcdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0aXNQb3NpdGl2ZSA9IG1hdGNoWyAxIF07XG5cblx0XHRcdC8vIGhvdXJGb3JtYXQgY29udGFpbmluZyBIIG9ubHksIGUuZy4sIGArSDstSGBcblx0XHRcdGlmICggbWF0Y2gubGVuZ3RoIDwgNiApIHtcblx0XHRcdFx0YXV4ID0gaXNQb3NpdGl2ZSA/IDEgOiAzO1xuXHRcdFx0XHR0b2tlbi52YWx1ZSA9IG51bWJlclBhcnNlciggbWF0Y2hbIGF1eCBdICkgKiA2MDtcblxuXHRcdFx0Ly8gaG91ckZvcm1hdCBjb250YWluaW5nIEggYW5kIG0sIGUuZy4sIGArSEhtbTstSEhtbWBcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoLmxlbmd0aCA8IDEwICkge1xuXHRcdFx0XHRhdXggPSBpc1Bvc2l0aXZlID8gWyAxLCAzIF0gOiBbIDUsIDcgXTtcblx0XHRcdFx0dG9rZW4udmFsdWUgPSBudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXhbIDAgXSBdICkgKiA2MCArXG5cdFx0XHRcdFx0bnVtYmVyUGFyc2VyKCBtYXRjaFsgYXV4WyAxIF0gXSApO1xuXG5cdFx0XHQvLyBob3VyRm9ybWF0IGNvbnRhaW5pbmcgSCwgbSwgYW5kIHMgZS5nLiwgYCtISG1tc3M7LUhIbW1zc2Bcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF1eCA9IGlzUG9zaXRpdmUgPyBbIDEsIDMsIDUgXSA6IFsgNywgOSwgMTEgXTtcblx0XHRcdFx0dG9rZW4udmFsdWUgPSBudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXhbIDAgXSBdICkgKiA2MCArXG5cdFx0XHRcdFx0bnVtYmVyUGFyc2VyKCBtYXRjaFsgYXV4WyAxIF0gXSApICtcblx0XHRcdFx0XHRudW1iZXJQYXJzZXIoIG1hdGNoWyBhdXhbIDIgXSBdICkgLyA2MDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBpc1Bvc2l0aXZlICkge1xuXHRcdFx0XHR0b2tlbi52YWx1ZSAqPSAtMTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25lRGlnaXRJZkxlbmd0aE9uZSgpIHtcblx0XHRcdGlmICggbGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxkL1xuXHRcdFx0XHRudW1lcmljID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHRva2VuUmUgPSBkaWdpdHNSZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbmVPclR3b0RpZ2l0c0lmTGVuZ3RoT25lKCkge1xuXHRcdFx0aWYgKCBsZW5ndGggPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXGRcXGQ/L1xuXHRcdFx0XHRudW1lcmljID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcIil7MSwyfVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25lT3JUd29EaWdpdHNJZkxlbmd0aE9uZU9yVHdvKCkge1xuXHRcdFx0aWYgKCBsZW5ndGggPT09IDEgfHwgbGVuZ3RoID09PSAyICkge1xuXG5cdFx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxkXFxkPy9cblx0XHRcdFx0bnVtZXJpYyA9IHRydWU7XG5cdFx0XHRcdHJldHVybiB0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgZGlnaXRzUmUuc291cmNlICsgXCIpezEsMn1cIiApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHR3b0RpZ2l0c0lmTGVuZ3RoVHdvKCkge1xuXHRcdFx0aWYgKCBsZW5ndGggPT09IDIgKSB7XG5cblx0XHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXGRcXGQvXG5cdFx0XHRcdG51bWVyaWMgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gdG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFwiKXsyfVwiICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQnJ1dGUtZm9yY2UgdGVzdCBldmVyeSBsb2NhbGUgZW50cnkgaW4gYW4gYXR0ZW1wdCB0byBtYXRjaCB0aGUgZ2l2ZW4gdmFsdWUuXG5cdFx0Ly8gUmV0dXJuIHRoZSBmaXJzdCBmb3VuZCBvbmUgKGFuZCBzZXQgdG9rZW4gYWNjb3JkaW5nbHkpLCBvciBudWxsLlxuXHRcdGZ1bmN0aW9uIGxvb2t1cCggcGF0aCApIHtcblx0XHRcdHZhciBhcnJheSA9IHByb3BlcnRpZXNbIHBhdGguam9pbiggXCIvXCIgKSBdO1xuXG5cdFx0XHRpZiAoICFhcnJheSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGFycmF5IG9mIHBhaXJzIFtrZXksIHZhbHVlXSBzb3J0ZWQgYnkgZGVzYyB2YWx1ZSBsZW5ndGguXG5cdFx0XHRhcnJheS5zb21lKGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWVSZSA9IGl0ZW1bIDEgXTtcblx0XHRcdFx0aWYgKCB2YWx1ZVJlLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dG9rZW4udmFsdWUgPSBpdGVtWyAwIF07XG5cdFx0XHRcdFx0dG9rZW5SZSA9IGl0ZW1bIDEgXTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR0b2tlbi50eXBlID0gY3VycmVudDtcblx0XHRjaHIgPSBjdXJyZW50LmNoYXJBdCggMCApO1xuXHRcdGxlbmd0aCA9IGN1cnJlbnQubGVuZ3RoO1xuXG5cdFx0aWYgKCBjaHIgPT09IFwiWlwiICkge1xuXG5cdFx0XHQvLyBaLi5aWlo6IHNhbWUgYXMgXCJ4eHh4XCIuXG5cdFx0XHRpZiAoIGxlbmd0aCA8IDQgKSB7XG5cdFx0XHRcdGNociA9IFwieFwiO1xuXHRcdFx0XHRsZW5ndGggPSA0O1xuXG5cdFx0XHQvLyBaWlpaOiBzYW1lIGFzIFwiT09PT1wiLlxuXHRcdFx0fSBlbHNlIGlmICggbGVuZ3RoIDwgNSApIHtcblx0XHRcdFx0Y2hyID0gXCJPXCI7XG5cdFx0XHRcdGxlbmd0aCA9IDQ7XG5cblx0XHRcdC8vIFpaWlpaOiBzYW1lIGFzIFwiWFhYWFhcIlxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hyID0gXCJYXCI7XG5cdFx0XHRcdGxlbmd0aCA9IDU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBjaHIgPT09IFwielwiICkge1xuXHRcdFx0aWYgKCBwcm9wZXJ0aWVzLnN0YW5kYXJkT3JEYXlsaWdodFR6TmFtZSApIHtcblx0XHRcdFx0dG9rZW4udmFsdWUgPSBudWxsO1xuXHRcdFx0XHR0b2tlblJlID0gcHJvcGVydGllcy5zdGFuZGFyZE9yRGF5bGlnaHRUek5hbWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdi4uLnZ2djogXCJ7c2hvcnRSZWdpb259XCIsIGVnLiBcIlBUXCIuXG5cdFx0Ly8gdnZ2djogXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XCIgb3IgXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XCIsXG5cdFx0Ly8gZS5nLiwgXCJQYWNpZmljIFRpbWVcIlxuXHRcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXG5cdFx0aWYgKCBjaHIgPT09IFwidlwiICkge1xuXHRcdFx0aWYgKCBwcm9wZXJ0aWVzLmdlbmVyaWNUek5hbWUgKSB7XG5cdFx0XHRcdHRva2VuLnZhbHVlID0gbnVsbDtcblx0XHRcdFx0dG9rZW5SZSA9IHByb3BlcnRpZXMuZ2VuZXJpY1R6TmFtZTtcblxuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIFwiVlwiIGZvcm1hdC5cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNociA9IFwiVlwiO1xuXHRcdFx0XHRsZW5ndGggPSA0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggY2hyID09PSBcIlZcIiAmJiBwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSApIHtcblx0XHRcdHRva2VuLnZhbHVlID0gbGVuZ3RoID09PSAyID8gcHJvcGVydGllcy50aW1lWm9uZU5hbWUgOiBudWxsO1xuXHRcdFx0dG9rZW5SZSA9IHByb3BlcnRpZXMudGltZVpvbmVOYW1lUmU7XG5cdFx0fVxuXG5cdFx0c3dpdGNoICggY2hyICkge1xuXG5cdFx0XHQvLyBFcmFcblx0XHRcdGNhc2UgXCJHXCI6XG5cdFx0XHRcdGxvb2t1cChbXG5cdFx0XHRcdFx0XCJncmVnb3JpYW4vZXJhc1wiLFxuXHRcdFx0XHRcdGxlbmd0aCA8PSAzID8gXCJlcmFBYmJyXCIgOiAoIGxlbmd0aCA9PT0gNCA/IFwiZXJhTmFtZXNcIiA6IFwiZXJhTmFycm93XCIgKVxuXHRcdFx0XHRdKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFllYXJcblx0XHRcdGNhc2UgXCJ5XCI6XG5cdFx0XHRjYXNlIFwiWVwiOlxuXHRcdFx0XHRudW1lcmljID0gdHJ1ZTtcblxuXHRcdFx0XHQvLyBudW1iZXIgbD0xOissIGw9Mjp7Mn0sIGw9Mzp7Myx9LCBsPTQ6ezQsfSwgLi4uXG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSAxICkge1xuXG5cdFx0XHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXGQrLy5cblx0XHRcdFx0XHR0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgZGlnaXRzUmUuc291cmNlICsgXCIpK1wiICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGxlbmd0aCA9PT0gMiApIHtcblxuXHRcdFx0XHRcdC8vIExlbmllbnQgcGFyc2luZzogdGhlcmUncyBubyB5ZWFyIHBhdHRlcm4gdG8gaW5kaWNhdGUgbm9uLXplcm8tcGFkZGVkIDItZGlnaXRzXG5cdFx0XHRcdFx0Ly8geWVhciwgc28gcGFyc2VyIGFjY2VwdHMgYm90aCB6ZXJvLXBhZGRlZCBhbmQgbm9uLXplcm8tcGFkZGVkIGZvciBgeXlgLlxuXHRcdFx0XHRcdC8vXG5cdFx0XHRcdFx0Ly8gVW5pY29kZSBlcXVpdmFsZW50IHRvIC9cXGRcXGQ/L1xuXHRcdFx0XHRcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcIil7MSwyfVwiICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gL1xcZHtsZW5ndGgsfS9cblx0XHRcdFx0XHR0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgZGlnaXRzUmUuc291cmNlICsgXCIpe1wiICsgbGVuZ3RoICsgXCIsfVwiICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFF1YXJ0ZXJcblx0XHRcdGNhc2UgXCJRXCI6XG5cdFx0XHRjYXNlIFwicVwiOlxuXG5cdFx0XHRcdC8vIG51bWJlciBsPTE6ezF9LCBsPTI6ezJ9LlxuXHRcdFx0XHQvLyBsb29rdXAgbD0zLi4uXG5cdFx0XHRcdG9uZURpZ2l0SWZMZW5ndGhPbmUoKSB8fCB0d29EaWdpdHNJZkxlbmd0aFR3bygpIHx8XG5cdFx0XHRcdFx0bG9va3VwKFtcblx0XHRcdFx0XHRcdFwiZ3JlZ29yaWFuL3F1YXJ0ZXJzXCIsXG5cdFx0XHRcdFx0XHRjaHIgPT09IFwiUVwiID8gXCJmb3JtYXRcIiA6IFwic3RhbmQtYWxvbmVcIixcblx0XHRcdFx0XHRcdHdpZHRoc1sgbGVuZ3RoIC0gMyBdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBNb250aFxuXHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdGNhc2UgXCJMXCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIGw9MTp7MSwyfSwgbD0yOnsyfS5cblx0XHRcdFx0Ly8gbG9va3VwIGw9My4uLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBMZW5pZW50IHBhcnNpbmc6IHNrZWxldG9uIFwieU1kXCIgKGkuZS4sIG9uZSBNKSBtYXkgaW5jbHVkZSBNTSBmb3IgdGhlIHBhdHRlcm4sXG5cdFx0XHRcdC8vIHRoZXJlZm9yZSBwYXJzZXIgYWNjZXB0cyBib3RoIHplcm8tcGFkZGVkIGFuZCBub24temVyby1wYWRkZWQgZm9yIE0gYW5kIE1NLlxuXHRcdFx0XHQvLyBTaW1pbGFyIGZvciBMLlxuXHRcdFx0XHRvbmVPclR3b0RpZ2l0c0lmTGVuZ3RoT25lT3JUd28oKSB8fCBsb29rdXAoW1xuXHRcdFx0XHRcdFwiZ3JlZ29yaWFuL21vbnRoc1wiLFxuXHRcdFx0XHRcdGNociA9PT0gXCJNXCIgPyBcImZvcm1hdFwiIDogXCJzdGFuZC1hbG9uZVwiLFxuXHRcdFx0XHRcdHdpZHRoc1sgbGVuZ3RoIC0gMyBdXG5cdFx0XHRcdF0pO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gRGF5XG5cdFx0XHRjYXNlIFwiRFwiOlxuXG5cdFx0XHRcdC8vIG51bWJlciB7bCwzfS5cblx0XHRcdFx0aWYgKCBsZW5ndGggPD0gMyApIHtcblxuXHRcdFx0XHRcdC8vIEVxdWl2YWxlbnQgdG8gL1xcZHtsZW5ndGgsM30vXG5cdFx0XHRcdFx0bnVtZXJpYyA9IHRydWU7XG5cdFx0XHRcdFx0dG9rZW5SZSA9IG5ldyBSZWdFeHAoIFwiXihcIiArIGRpZ2l0c1JlLnNvdXJjZSArIFwiKXtcIiArIGxlbmd0aCArIFwiLDN9XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIldcIjpcblx0XHRcdGNhc2UgXCJGXCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIGw9MTp7MX0uXG5cdFx0XHRcdG9uZURpZ2l0SWZMZW5ndGhPbmUoKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFdlZWsgZGF5XG5cdFx0XHRjYXNlIFwiZVwiOlxuXHRcdFx0Y2FzZSBcImNcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIgbD0xOnsxfSwgbD0yOnsyfS5cblx0XHRcdFx0Ly8gbG9va3VwIGZvciBsZW5ndGggPj0zLlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA8PSAyICkge1xuXHRcdFx0XHRcdG9uZURpZ2l0SWZMZW5ndGhPbmUoKSB8fCB0d29EaWdpdHNJZkxlbmd0aFR3bygpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJFXCI6XG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSA2ICkge1xuXG5cdFx0XHRcdFx0Ly8gTm90ZTogaWYgc2hvcnQgZGF5IG5hbWVzIGFyZSBub3QgZXhwbGljaXRseSBzcGVjaWZpZWQsIGFiYnJldmlhdGVkIGRheVxuXHRcdFx0XHRcdC8vIG5hbWVzIGFyZSB1c2VkIGluc3RlYWQgaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI21vbnRoc19kYXlzX3F1YXJ0ZXJzX2VyYXNcblx0XHRcdFx0XHRsb29rdXAoW1xuXHRcdFx0XHRcdFx0XCJncmVnb3JpYW4vZGF5c1wiLFxuXHRcdFx0XHRcdFx0WyBjaHIgPT09IFwiY1wiID8gXCJzdGFuZC1hbG9uZVwiIDogXCJmb3JtYXRcIiBdLFxuXHRcdFx0XHRcdFx0XCJzaG9ydFwiXG5cdFx0XHRcdFx0XSkgfHwgbG9va3VwKFtcblx0XHRcdFx0XHRcdFwiZ3JlZ29yaWFuL2RheXNcIixcblx0XHRcdFx0XHRcdFsgY2hyID09PSBcImNcIiA/IFwic3RhbmQtYWxvbmVcIiA6IFwiZm9ybWF0XCIgXSxcblx0XHRcdFx0XHRcdFwiYWJicmV2aWF0ZWRcIlxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGxvb2t1cChbXG5cdFx0XHRcdFx0XHRcImdyZWdvcmlhbi9kYXlzXCIsXG5cdFx0XHRcdFx0XHRbIGNociA9PT0gXCJjXCIgPyBcInN0YW5kLWFsb25lXCIgOiBcImZvcm1hdFwiIF0sXG5cdFx0XHRcdFx0XHR3aWR0aHNbIGxlbmd0aCA8IDMgPyAwIDogbGVuZ3RoIC0gMyBdXG5cdFx0XHRcdFx0XSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFBlcmlvZCAoQU0gb3IgUE0pXG5cdFx0XHRjYXNlIFwiYVwiOlxuXHRcdFx0XHRsb29rdXAoW1xuXHRcdFx0XHRcdFwiZ3JlZ29yaWFuL2RheVBlcmlvZHMvZm9ybWF0L3dpZGVcIlxuXHRcdFx0XHRdKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFdlZWtcblx0XHRcdGNhc2UgXCJ3XCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIGwxOnsxLDJ9LCBsMjp7Mn0uXG5cdFx0XHRcdG9uZU9yVHdvRGlnaXRzSWZMZW5ndGhPbmUoKSB8fCB0d29EaWdpdHNJZkxlbmd0aFR3bygpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gRGF5LCBIb3VyLCBNaW51dGUsIG9yIFNlY29uZFxuXHRcdFx0Y2FzZSBcImRcIjpcblx0XHRcdGNhc2UgXCJoXCI6XG5cdFx0XHRjYXNlIFwiSFwiOlxuXHRcdFx0Y2FzZSBcIktcIjpcblx0XHRcdGNhc2UgXCJrXCI6XG5cdFx0XHRjYXNlIFwialwiOlxuXHRcdFx0Y2FzZSBcIm1cIjpcblx0XHRcdGNhc2UgXCJzXCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIGwxOnsxLDJ9LCBsMjp7Mn0uXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIExlbmllbnQgcGFyc2luZzpcblx0XHRcdFx0Ly8gLSBza2VsZXRvbiBcImhtc1wiIChpLmUuLCBvbmUgbSkgYWx3YXlzIGluY2x1ZGVzIG1tIGZvciB0aGUgcGF0dGVybiwgaS5lLiwgaXQnc1xuXHRcdFx0XHQvLyAgIGltcG9zc2libGUgdG8gdXNlIGEgZGlmZmVyZW50IHNrZWxldG9uIHRvIHBhcnNlIG5vbi16ZXJvLXBhZGRlZCBtaW51dGVzLFxuXHRcdFx0XHQvLyAgIHRoZXJlZm9yZSBwYXJzZXIgYWNjZXB0cyBib3RoIHplcm8tcGFkZGVkIGFuZCBub24temVyby1wYWRkZWQgZm9yIG0uIFNpbWlsYXJcblx0XHRcdFx0Ly8gICBmb3Igc2Vjb25kcyBzLlxuXHRcdFx0XHQvLyAtIHNrZWxldG9uIFwiaG1zXCIgKGkuZS4sIG9uZSBoKSBtYXkgaW5jbHVkZSBoIG9yIGhoIGZvciB0aGUgcGF0dGVybiwgaS5lLiwgaXQnc1xuXHRcdFx0XHQvLyAgIGltcG9zc2libGUgdG8gdXNlIGEgZGlmZmVyZW50IHNrZWxldG9uIHRvIHBhcnNlciBub24temVyby1wYWRkZWQgaG91cnMgZm9yIHNvbWVcblx0XHRcdFx0Ly8gICBsb2NhbGVzLCB0aGVyZWZvcmUgcGFyc2VyIGFjY2VwdHMgYm90aCB6ZXJvLXBhZGRlZCBhbmQgbm9uLXplcm8tcGFkZGVkIGZvciBoLlxuXHRcdFx0XHQvLyAgIFNpbWlsYXIgZm9yIGQgKGluIHNrZWxldG9uIHlNZCkuXG5cdFx0XHRcdG9uZU9yVHdvRGlnaXRzSWZMZW5ndGhPbmVPclR3bygpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIlNcIjpcblxuXHRcdFx0XHQvLyBudW1iZXIge2x9LlxuXG5cdFx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxke2xlbmd0aH0vXG5cdFx0XHRcdG51bWVyaWMgPSB0cnVlO1xuXHRcdFx0XHR0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgZGlnaXRzUmUuc291cmNlICsgXCIpe1wiICsgbGVuZ3RoICsgXCJ9XCIgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJBXCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIHtsKzV9LlxuXG5cdFx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAvXFxke2xlbmd0aCs1fS9cblx0XHRcdFx0bnVtZXJpYyA9IHRydWU7XG5cdFx0XHRcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBkaWdpdHNSZS5zb3VyY2UgKyBcIil7XCIgKyAoIGxlbmd0aCArIDUgKSArIFwifVwiICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBab25lXG5cdFx0XHRjYXNlIFwidlwiOlxuXHRcdFx0Y2FzZSBcIlZcIjpcblx0XHRcdGNhc2UgXCJ6XCI6XG5cdFx0XHRcdGlmICggdG9rZW5SZSAmJiB0b2tlblJlLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBjaHIgPT09IFwiVlwiICYmIGxlbmd0aCA9PT0gMiApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiT1wiOlxuXG5cdFx0XHRcdC8vIE86IFwie2dtdEZvcm1hdH0rSDt7Z210Rm9ybWF0fS1IXCIgb3IgXCJ7Z210WmVyb0Zvcm1hdH1cIiwgZWcuIFwiR01ULThcIiBvciBcIkdNVFwiLlxuXHRcdFx0XHQvLyBPT09POiBcIntnbXRGb3JtYXR9e2hvdXJGb3JtYXR9XCIgb3IgXCJ7Z210WmVyb0Zvcm1hdH1cIiwgZWcuIFwiR01ULTA4OjAwXCIgb3IgXCJHTVRcIi5cblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gcHJvcGVydGllc1sgXCJ0aW1lWm9uZU5hbWVzL2dtdFplcm9Gb3JtYXRcIiBdICkge1xuXHRcdFx0XHRcdHRva2VuLnZhbHVlID0gMDtcblx0XHRcdFx0XHR0b2tlblJlID0gcHJvcGVydGllc1sgXCJ0aW1lWm9uZU5hbWVzL2dtdFplcm9Gb3JtYXRSZVwiIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YXV4ID0gcHJvcGVydGllc1sgXCJ0aW1lWm9uZU5hbWVzL2hvdXJGb3JtYXRcIiBdLnNvbWUoZnVuY3Rpb24oIGhvdXJGb3JtYXRSZSApIHtcblx0XHRcdFx0XHRcdGlmICggaG91ckZvcm1hdFBhcnNlKCBob3VyRm9ybWF0UmUsIG51bWJlclBhcnNlciApICkge1xuXHRcdFx0XHRcdFx0XHR0b2tlblJlID0gaG91ckZvcm1hdFJlO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoICFhdXggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJYXCI6XG5cblx0XHRcdFx0Ly8gU2FtZSBhcyB4KiwgZXhjZXB0IGl0IHVzZXMgXCJaXCIgZm9yIHplcm8gb2Zmc2V0LlxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcIlpcIiApIHtcblx0XHRcdFx0XHR0b2tlbi52YWx1ZSA9IDA7XG5cdFx0XHRcdFx0dG9rZW5SZSA9IC9eWi87XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0LyogZmFsbHMgdGhyb3VnaCAqL1xuXHRcdFx0Y2FzZSBcInhcIjpcblxuXHRcdFx0XHQvLyB4OiBob3VyRm9ybWF0KFwiK0hIW21tXTstSEhbbW1dXCIpXG5cdFx0XHRcdC8vIHh4OiBob3VyRm9ybWF0KFwiK0hIbW07LUhIbW1cIilcblx0XHRcdFx0Ly8geHh4OiBob3VyRm9ybWF0KFwiK0hIOm1tOy1ISDptbVwiKVxuXHRcdFx0XHQvLyB4eHh4OiBob3VyRm9ybWF0KFwiK0hIbW1bc3NdOy1ISG1tW3NzXVwiKVxuXHRcdFx0XHQvLyB4eHh4eDogaG91ckZvcm1hdChcIitISDptbVs6c3NdOy1ISDptbVs6c3NdXCIpXG5cdFx0XHRcdGF1eCA9IHByb3BlcnRpZXMueC5zb21lKGZ1bmN0aW9uKCBob3VyRm9ybWF0UmUgKSB7XG5cdFx0XHRcdFx0aWYgKCBob3VyRm9ybWF0UGFyc2UoIGhvdXJGb3JtYXRSZSApICkge1xuXHRcdFx0XHRcdFx0dG9rZW5SZSA9IGhvdXJGb3JtYXRSZTtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdGlmICggIWF1eCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIidcIjpcblx0XHRcdFx0dG9rZW4udHlwZSA9IFwibGl0ZXJhbFwiO1xuXHRcdFx0XHR0b2tlblJlID0gbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIHJlbW92ZUxpdGVyYWxRdW90ZXMoIGN1cnJlbnQgKSApICk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR0b2tlbi50eXBlID0gXCJsaXRlcmFsXCI7XG5cdFx0XHRcdHRva2VuUmUgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggY3VycmVudCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhdG9rZW5SZSApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBHZXQgbGV4ZW1lIGFuZCBjb25zdW1lIGl0LlxuXHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSggdG9rZW5SZSwgZnVuY3Rpb24oIGxleGVtZSApIHtcblx0XHRcdHRva2VuLmxleGVtZSA9IGxleGVtZTtcblx0XHRcdGlmICggbnVtZXJpYyApIHtcblx0XHRcdFx0dG9rZW4udmFsdWUgPSBudW1iZXJQYXJzZXIoIGxleGVtZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFwiXCI7XG5cdFx0fSk7XG5cblx0XHRpZiAoICF0b2tlbi5sZXhlbWUgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBudW1lcmljICYmIGlzTmFOKCB0b2tlbi52YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRva2Vucy5wdXNoKCB0b2tlbiApO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9KTtcblxuXHRpZiAoIHZhbHVlICE9PSBcIlwiICkge1xuXHRcdHZhbGlkID0gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdmFsaWQgPyB0b2tlbnMgOiBbXTtcbn07XG5cblxuXG5cbnZhciBkYXRlUGFyc2VyRm4gPSBmdW5jdGlvbiggbnVtYmVyUGFyc2VyLCBwYXJzZVByb3BlcnRpZXMsIHRva2VuaXplclByb3BlcnRpZXMgKSB7XG5cdHJldHVybiBmdW5jdGlvbiBkYXRlUGFyc2VyKCB2YWx1ZSApIHtcblx0XHR2YXIgdG9rZW5zO1xuXG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdFx0dG9rZW5zID0gZGF0ZVRva2VuaXplciggdmFsdWUsIG51bWJlclBhcnNlciwgdG9rZW5pemVyUHJvcGVydGllcyApO1xuXHRcdHJldHVybiBkYXRlUGFyc2UoIHZhbHVlLCB0b2tlbnMsIHBhcnNlUHJvcGVydGllcyApIHx8IG51bGw7XG5cdH07XG59O1xuXG5cblxuXG52YXIgb2JqZWN0RmlsdGVyID0gZnVuY3Rpb24oIG9iamVjdCwgdGVzdFJlICkge1xuXHR2YXIga2V5LFxuXHRcdGNvcHkgPSB7fTtcblxuXHRmb3IgKCBrZXkgaW4gb2JqZWN0ICkge1xuXHRcdGlmICggdGVzdFJlLnRlc3QoIGtleSApICkge1xuXHRcdFx0Y29weVsga2V5IF0gPSBvYmplY3RbIGtleSBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb3B5O1xufTtcblxuXG5cblxuLyoqXG4gKiB0b2tlbml6ZXJQcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyIClcbiAqXG4gKiBAcGF0dGVybiBbU3RyaW5nXSByYXcgcGF0dGVybi5cbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogUmV0dXJuIE9iamVjdCB3aXRoIGRhdGEgdGhhdCB3aWxsIGJlIHVzZWQgYnkgdG9rZW5pemVyLlxuICovXG52YXIgZGF0ZVRva2VuaXplclByb3BlcnRpZXMgPSBmdW5jdGlvbiggcGF0dGVybiwgY2xkciwgdGltZVpvbmUgKSB7XG5cdHZhciBkaWdpdHNSZVNvdXJjZSxcblx0XHRwcm9wZXJ0aWVzID0ge1xuXHRcdFx0cGF0dGVybjogbG9vc2VNYXRjaGluZyggcGF0dGVybiApXG5cdFx0fSxcblx0XHR0aW1lU2VwYXJhdG9yID0gbnVtYmVyU3ltYm9sKCBcInRpbWVTZXBhcmF0b3JcIiwgY2xkciApLFxuXHRcdHdpZHRocyA9IFsgXCJhYmJyZXZpYXRlZFwiLCBcIndpZGVcIiwgXCJuYXJyb3dcIiBdO1xuXG5cdGRpZ2l0c1JlU291cmNlID0gbnVtYmVyTnVtYmVyaW5nU3lzdGVtRGlnaXRzTWFwKCBjbGRyICk7XG5cdGRpZ2l0c1JlU291cmNlID0gZGlnaXRzUmVTb3VyY2UgPyBcIltcIiArIGRpZ2l0c1JlU291cmNlICsgXCJdXCIgOiBcIlxcXFxkXCI7XG5cdHByb3BlcnRpZXMuZGlnaXRzUmUgPSBuZXcgUmVnRXhwKCBkaWdpdHNSZVNvdXJjZSApO1xuXG5cdC8vIFRyYW5zZm9ybTpcblx0Ly8gLSBcIitIOy1IXCIgLT4gL1xcKyhcXGRcXGQ/KXwtKFxcZFxcZD8pL1xuXHQvLyAtIFwiK0hIOy1ISFwiIC0+IC9cXCsoXFxkXFxkKXwtKFxcZFxcZCkvXG5cdC8vIC0gXCIrSEhtbTstSEhtbVwiIC0+IC9cXCsoXFxkXFxkKShcXGRcXGQpfC0oXFxkXFxkKShcXGRcXGQpL1xuXHQvLyAtIFwiK0hIOm1tOy1ISDptbVwiIC0+IC9cXCsoXFxkXFxkKTooXFxkXFxkKXwtKFxcZFxcZCk6KFxcZFxcZCkvXG5cdC8vXG5cdC8vIElmIGdtdEZvcm1hdCBpcyBHTVR7MH0sIHRoZSByZWdleHAgbXVzdCBmaWxsIHswfSBpbiBlYWNoIHNpZGUsIGUuZy46XG5cdC8vIC0gXCIrSDstSFwiIC0+IC9HTVRcXCsoXFxkXFxkPyl8R01ULShcXGRcXGQ/KS9cblx0ZnVuY3Rpb24gaG91ckZvcm1hdFJlKCBob3VyRm9ybWF0LCBnbXRGb3JtYXQsIGRpZ2l0c1JlU291cmNlLCB0aW1lU2VwYXJhdG9yICkge1xuXHRcdHZhciByZTtcblxuXHRcdGlmICggIWRpZ2l0c1JlU291cmNlICkge1xuXHRcdFx0ZGlnaXRzUmVTb3VyY2UgPSBcIlxcXFxkXCI7XG5cdFx0fVxuXHRcdGlmICggIWdtdEZvcm1hdCApIHtcblx0XHRcdGdtdEZvcm1hdCA9IFwiezB9XCI7XG5cdFx0fVxuXG5cdFx0cmUgPSBob3VyRm9ybWF0XG5cdFx0XHQucmVwbGFjZSggXCIrXCIsIFwiXFxcXCtcIiApXG5cblx0XHRcdC8vIFVuaWNvZGUgZXF1aXZhbGVudCB0byAoXFxcXGRcXFxcZClcblx0XHRcdC5yZXBsYWNlKCAvSEh8bW18c3MvZywgXCIoKFwiICsgZGlnaXRzUmVTb3VyY2UgKyBcIil7Mn0pXCIgKVxuXG5cdFx0XHQvLyBVbmljb2RlIGVxdWl2YWxlbnQgdG8gKFxcXFxkXFxcXGQ/KVxuXHRcdFx0LnJlcGxhY2UoIC9IfG0vZywgXCIoKFwiICsgZGlnaXRzUmVTb3VyY2UgKyBcIil7MSwyfSlcIiApO1xuXG5cdFx0aWYgKCB0aW1lU2VwYXJhdG9yICkge1xuXHRcdFx0cmUgPSByZS5yZXBsYWNlKCAvOi9nLCB0aW1lU2VwYXJhdG9yICk7XG5cdFx0fVxuXG5cdFx0cmUgPSByZS5zcGxpdCggXCI7XCIgKS5tYXAoZnVuY3Rpb24oIHBhcnQgKSB7XG5cdFx0XHRyZXR1cm4gZ210Rm9ybWF0LnJlcGxhY2UoIFwiezB9XCIsIHBhcnQgKTtcblx0XHR9KS5qb2luKCBcInxcIiApO1xuXG5cdFx0cmV0dXJuIG5ldyBSZWdFeHAoIFwiXlwiICsgcmUgKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBvcHVsYXRlUHJvcGVydGllcyggcGF0aCwgdmFsdWUgKSB7XG5cblx0XHQvLyBTa2lwXG5cdFx0dmFyIHNraXBSZSA9IC8odGltZVpvbmVOYW1lc1xcL3pvbmV8c3VwcGxlbWVudGFsXFwvbWV0YVpvbmVzfHRpbWVab25lTmFtZXNcXC9tZXRhem9uZXx0aW1lWm9uZU5hbWVzXFwvcmVnaW9uRm9ybWF0fHRpbWVab25lTmFtZXNcXC9nbXRGb3JtYXQpLztcblx0XHRpZiAoIHNraXBSZS50ZXN0KCBwYXRoICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIGBkYXRlc2AgYW5kIGBjYWxlbmRhcnNgIHRyaW0ncyBwdXJwb3NlIGlzIHRvIHJlZHVjZSBwcm9wZXJ0aWVzJyBrZXkgc2l6ZSBvbmx5LlxuXHRcdHBhdGggPSBwYXRoLnJlcGxhY2UoIC9eLipcXC9kYXRlc1xcLy8sIFwiXCIgKS5yZXBsYWNlKCAvY2FsZW5kYXJzXFwvLywgXCJcIiApO1xuXG5cdFx0Ly8gU3BlY2lmaWMgZmlsdGVyIGZvciBcImdyZWdvcmlhbi9kYXlQZXJpb2RzL2Zvcm1hdC93aWRlXCIuXG5cdFx0aWYgKCBwYXRoID09PSBcImdyZWdvcmlhbi9kYXlQZXJpb2RzL2Zvcm1hdC93aWRlXCIgKSB7XG5cdFx0XHR2YWx1ZSA9IG9iamVjdEZpbHRlciggdmFsdWUsIC9eYW18XnBtLyApO1xuXHRcdH1cblxuXHRcdC8vIFRyYW5zZm9ybSBvYmplY3QgaW50byBhcnJheSBvZiBwYWlycyBba2V5LCAvdmFsdWUvXSwgc29ydCBieSBkZXNjIHZhbHVlIGxlbmd0aC5cblx0XHRpZiAoIGlzUGxhaW5PYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHR2YWx1ZSA9IE9iamVjdC5rZXlzKCB2YWx1ZSApLm1hcChmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gWyBrZXksIG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCBsb29zZU1hdGNoaW5nKCB2YWx1ZVsga2V5IF0gKSApICkgXTtcblx0XHRcdH0pLnNvcnQoZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdHJldHVybiBiWyAxIF0uc291cmNlLmxlbmd0aCAtIGFbIDEgXS5zb3VyY2UubGVuZ3RoO1xuXHRcdFx0fSk7XG5cblx0XHQvLyBJZiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIuXG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbHVlID0gbG9vc2VNYXRjaGluZyggdmFsdWUgKTtcblx0XHR9XG5cdFx0cHJvcGVydGllc1sgcGF0aCBdID0gdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiByZWdleHBTb3VyY2VTb21lVGVybSggdGVybXMgKSB7XG5cdFx0cmV0dXJuIFwiKFwiICsgdGVybXMuZmlsdGVyKGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0fSkucmVkdWNlKGZ1bmN0aW9uKCBtZW1vLCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIG1lbW8gKyBcInxcIiArIGl0ZW07XG5cdFx0fSkgKyBcIilcIjtcblx0fVxuXG5cdGNsZHIub24oIFwiZ2V0XCIsIHBvcHVsYXRlUHJvcGVydGllcyApO1xuXG5cdHBhdHRlcm4ubWF0Y2goIGRhdGVQYXR0ZXJuUmUgKS5mb3JFYWNoKGZ1bmN0aW9uKCBjdXJyZW50ICkge1xuXHRcdHZhciBhdXgsIGNociwgZGF5bGlnaHRUek5hbWUsIGdtdEZvcm1hdCwgbGVuZ3RoLCBzdGFuZGFyZFR6TmFtZTtcblxuXHRcdGNociA9IGN1cnJlbnQuY2hhckF0KCAwICk7XG5cdFx0bGVuZ3RoID0gY3VycmVudC5sZW5ndGg7XG5cblx0XHRpZiAoIGNociA9PT0gXCJaXCIgKSB7XG5cdFx0XHRpZiAoIGxlbmd0aCA8IDUgKSB7XG5cdFx0XHRcdGNociA9IFwiT1wiO1xuXHRcdFx0XHRsZW5ndGggPSA0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2hyID0gXCJYXCI7XG5cdFx0XHRcdGxlbmd0aCA9IDU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gei4uLnp6ejogXCJ7c2hvcnRSZWdpb259XCIsIGVnLiBcIlBTVFwiIG9yIFwiUERUXCIuXG5cdFx0Ly8genp6ejogXCJ7cmVnaW9uTmFtZX0ge1N0YW5kYXJkIFRpbWV9XCIgb3IgXCJ7cmVnaW9uTmFtZX0ge0RheWxpZ2h0IFRpbWV9XCIsXG5cdFx0Ly8gICAgICAgZS5nLiwgXCJQYWNpZmljIFN0YW5kYXJkIFRpbWVcIiBvciBcIlBhY2lmaWMgRGF5bGlnaHQgVGltZVwiLlxuXHRcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXG5cdFx0aWYgKCBjaHIgPT09IFwielwiICkge1xuXHRcdFx0c3RhbmRhcmRUek5hbWUgPSBkYXRlR2V0VGltZVpvbmVOYW1lKCBsZW5ndGgsIFwic3RhbmRhcmRcIiwgdGltZVpvbmUsIGNsZHIgKTtcblx0XHRcdGRheWxpZ2h0VHpOYW1lID0gZGF0ZUdldFRpbWVab25lTmFtZSggbGVuZ3RoLCBcImRheWxpZ2h0XCIsIHRpbWVab25lLCBjbGRyICk7XG5cdFx0XHRpZiAoIHN0YW5kYXJkVHpOYW1lICkge1xuXHRcdFx0XHRzdGFuZGFyZFR6TmFtZSA9IHJlZ2V4cEVzY2FwZSggbG9vc2VNYXRjaGluZyggc3RhbmRhcmRUek5hbWUgKSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkYXlsaWdodFR6TmFtZSApIHtcblx0XHRcdFx0ZGF5bGlnaHRUek5hbWUgPSByZWdleHBFc2NhcGUoIGxvb3NlTWF0Y2hpbmcoIGRheWxpZ2h0VHpOYW1lICkgKTtcblx0XHRcdH1cblx0XHRcdGlmICggc3RhbmRhcmRUek5hbWUgfHwgZGF5bGlnaHRUek5hbWUgKSB7XG5cdFx0XHRcdHByb3BlcnRpZXMuc3RhbmRhcmRPckRheWxpZ2h0VHpOYW1lID0gbmV3IFJlZ0V4cChcblx0XHRcdFx0XHRcIl5cIiArIHJlZ2V4cFNvdXJjZVNvbWVUZXJtKFsgc3RhbmRhcmRUek5hbWUsIGRheWxpZ2h0VHpOYW1lIF0pXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZhbGwgdGhyb3VnaCB0aGUgXCJPXCIgZm9ybWF0IGluIGNhc2Ugb25lIG5hbWUgaXMgbWlzc2luZy5cblx0XHRcdGlmICggIXN0YW5kYXJkVHpOYW1lIHx8ICFkYXlsaWdodFR6TmFtZSApIHtcblx0XHRcdFx0Y2hyID0gXCJPXCI7XG5cdFx0XHRcdGlmICggbGVuZ3RoIDwgNCApIHtcblx0XHRcdFx0XHRsZW5ndGggPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdi4uLnZ2djogXCJ7c2hvcnRSZWdpb259XCIsIGVnLiBcIlBUXCIuXG5cdFx0Ly8gdnZ2djogXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XCIgb3IgXCJ7cmVnaW9uTmFtZX0ge1RpbWV9XCIsXG5cdFx0Ly8gZS5nLiwgXCJQYWNpZmljIFRpbWVcIlxuXHRcdC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI0RhdGVfRm9ybWF0X1BhdHRlcm5zXG5cdFx0aWYgKCBjaHIgPT09IFwidlwiICkge1xuXHRcdFx0aWYgKCBsZW5ndGggIT09IDEgJiYgbGVuZ3RoICE9PSA0ICkge1xuXHRcdFx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRcdFx0ZmVhdHVyZTogXCJ0aW1lem9uZSBwYXR0ZXJuIGBcIiArIHBhdHRlcm4gKyBcImBcIlxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdHZhciBnZW5lcmljVHpOYW1lID0gZGF0ZUdldFRpbWVab25lTmFtZSggbGVuZ3RoLCBcImdlbmVyaWNcIiwgdGltZVpvbmUsIGNsZHIgKTtcblx0XHRcdGlmICggZ2VuZXJpY1R6TmFtZSApIHtcblx0XHRcdFx0cHJvcGVydGllcy5nZW5lcmljVHpOYW1lID0gbmV3IFJlZ0V4cChcblx0XHRcdFx0XHRcIl5cIiArIHJlZ2V4cEVzY2FwZSggbG9vc2VNYXRjaGluZyggZ2VuZXJpY1R6TmFtZSApIClcblx0XHRcdFx0KTtcblx0XHRcdFx0Y2hyID0gXCJPXCI7XG5cblx0XHRcdC8vIEZhbGwgYmFjayB0byBcIlZcIiBmb3JtYXQuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjaHIgPSBcIlZcIjtcblx0XHRcdFx0bGVuZ3RoID0gNDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBjaHIgKSB7XG5cblx0XHRcdC8vIEVyYVxuXHRcdFx0Y2FzZSBcIkdcIjpcblx0XHRcdFx0Y2xkci5tYWluKFtcblx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZXJhc1wiLFxuXHRcdFx0XHRcdGxlbmd0aCA8PSAzID8gXCJlcmFBYmJyXCIgOiAoIGxlbmd0aCA9PT0gNCA/IFwiZXJhTmFtZXNcIiA6IFwiZXJhTmFycm93XCIgKVxuXHRcdFx0XHRdKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFllYXJcblx0XHRcdGNhc2UgXCJ1XCI6IC8vIEV4dGVuZGVkIHllYXIuIE5lZWQgdG8gYmUgaW1wbGVtZW50ZWQuXG5cdFx0XHRjYXNlIFwiVVwiOiAvLyBDeWNsaWMgeWVhciBuYW1lLiBOZWVkIHRvIGJlIGltcGxlbWVudGVkLlxuXHRcdFx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSh7XG5cdFx0XHRcdFx0ZmVhdHVyZTogXCJ5ZWFyIHBhdHRlcm4gYFwiICsgY2hyICsgXCJgXCJcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8vIFF1YXJ0ZXJcblx0XHRcdGNhc2UgXCJRXCI6XG5cdFx0XHRjYXNlIFwicVwiOlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IDIgKSB7XG5cdFx0XHRcdFx0Y2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9xdWFydGVyc1wiLFxuXHRcdFx0XHRcdFx0Y2hyID09PSBcIlFcIiA/IFwiZm9ybWF0XCIgOiBcInN0YW5kLWFsb25lXCIsXG5cdFx0XHRcdFx0XHR3aWR0aHNbIGxlbmd0aCAtIDMgXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBNb250aFxuXHRcdFx0Y2FzZSBcIk1cIjpcblx0XHRcdGNhc2UgXCJMXCI6XG5cblx0XHRcdFx0Ly8gbnVtYmVyIGw9MTp7MSwyfSwgbD0yOnsyfS5cblx0XHRcdFx0Ly8gbG9va3VwIGw9My4uLlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IDIgKSB7XG5cdFx0XHRcdFx0Y2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9tb250aHNcIixcblx0XHRcdFx0XHRcdGNociA9PT0gXCJNXCIgPyBcImZvcm1hdFwiIDogXCJzdGFuZC1hbG9uZVwiLFxuXHRcdFx0XHRcdFx0d2lkdGhzWyBsZW5ndGggLSAzIF1cblx0XHRcdFx0XHRdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gRGF5XG5cdFx0XHRjYXNlIFwiZ1wiOlxuXG5cdFx0XHRcdC8vIE1vZGlmaWVkIEp1bGlhbiBkYXkuIE5lZWQgdG8gYmUgaW1wbGVtZW50ZWQuXG5cdFx0XHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdFx0XHRmZWF0dXJlOiBcIkp1bGlhbiBkYXkgcGF0dGVybiBgZ2BcIlxuXHRcdFx0XHR9KTtcblxuXHRcdFx0Ly8gV2VlayBkYXlcblx0XHRcdGNhc2UgXCJlXCI6XG5cdFx0XHRjYXNlIFwiY1wiOlxuXG5cdFx0XHRcdC8vIGxvb2t1cCBmb3IgbGVuZ3RoID49My5cblx0XHRcdFx0aWYgKCBsZW5ndGggPD0gMiApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiRVwiOlxuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gNiApIHtcblxuXHRcdFx0XHRcdC8vIE5vdGU6IGlmIHNob3J0IGRheSBuYW1lcyBhcmUgbm90IGV4cGxpY2l0bHkgc3BlY2lmaWVkLCBhYmJyZXZpYXRlZCBkYXlcblx0XHRcdFx0XHQvLyBuYW1lcyBhcmUgdXNlZCBpbnN0ZWFkIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtZGF0ZXMuaHRtbCNtb250aHNfZGF5c19xdWFydGVyc19lcmFzXG5cdFx0XHRcdFx0Y2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlzXCIsXG5cdFx0XHRcdFx0XHRbIGNociA9PT0gXCJjXCIgPyBcInN0YW5kLWFsb25lXCIgOiBcImZvcm1hdFwiIF0sXG5cdFx0XHRcdFx0XHRcInNob3J0XCJcblx0XHRcdFx0XHRdKSB8fCBjbGRyLm1haW4oW1xuXHRcdFx0XHRcdFx0XCJkYXRlcy9jYWxlbmRhcnMvZ3JlZ29yaWFuL2RheXNcIixcblx0XHRcdFx0XHRcdFsgY2hyID09PSBcImNcIiA/IFwic3RhbmQtYWxvbmVcIiA6IFwiZm9ybWF0XCIgXSxcblx0XHRcdFx0XHRcdFwiYWJicmV2aWF0ZWRcIlxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcImRhdGVzL2NhbGVuZGFycy9ncmVnb3JpYW4vZGF5c1wiLFxuXHRcdFx0XHRcdFx0WyBjaHIgPT09IFwiY1wiID8gXCJzdGFuZC1hbG9uZVwiIDogXCJmb3JtYXRcIiBdLFxuXHRcdFx0XHRcdFx0d2lkdGhzWyBsZW5ndGggPCAzID8gMCA6IGxlbmd0aCAtIDMgXVxuXHRcdFx0XHRcdF0pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBQZXJpb2QgKEFNIG9yIFBNKVxuXHRcdFx0Y2FzZSBcImFcIjpcblx0XHRcdFx0Y2xkci5tYWluKFxuXHRcdFx0XHRcdFwiZGF0ZXMvY2FsZW5kYXJzL2dyZWdvcmlhbi9kYXlQZXJpb2RzL2Zvcm1hdC93aWRlXCJcblx0XHRcdFx0KTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIFpvbmVcblx0XHRcdGNhc2UgXCJWXCI6XG5cblx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDEgKSB7XG5cdFx0XHRcdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0XHRcdFx0ZmVhdHVyZTogXCJ0aW1lem9uZSBwYXR0ZXJuIGBcIiArIHBhdHRlcm4gKyBcImBcIlxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCB0aW1lWm9uZSApIHtcblx0XHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMiApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU2tpcCBsb29zZU1hdGNoaW5nIHByb2Nlc3Npbmcgc2luY2UgdGltZVpvbmUgaXMgYSBjYW5vbmljYWwgcG9zaXggdmFsdWUuXG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSA9IHRpbWVab25lO1xuXHRcdFx0XHRcdFx0cHJvcGVydGllcy50aW1lWm9uZU5hbWVSZSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgcmVnZXhwRXNjYXBlKCB0aW1lWm9uZSApICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgdGltZVpvbmVOYW1lLFxuXHRcdFx0XHRcdFx0ZXhlbXBsYXJDaXR5ID0gY2xkci5tYWluKFtcblx0XHRcdFx0XHRcdFx0XCJkYXRlcy90aW1lWm9uZU5hbWVzL3pvbmVcIiwgdGltZVpvbmUsIFwiZXhlbXBsYXJDaXR5XCJcblx0XHRcdFx0XHRcdF0pO1xuXG5cdFx0XHRcdFx0aWYgKCBsZW5ndGggPT09IDMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFleGVtcGxhckNpdHkgKSB7XG5cdFx0XHRcdFx0XHRcdGV4ZW1wbGFyQ2l0eSA9IGNsZHIubWFpbihbXG5cdFx0XHRcdFx0XHRcdFx0XCJkYXRlcy90aW1lWm9uZU5hbWVzL3pvbmUvRXRjL1Vua25vd24vZXhlbXBsYXJDaXR5XCJcblx0XHRcdFx0XHRcdFx0XSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aW1lWm9uZU5hbWUgPSBleGVtcGxhckNpdHk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKCBleGVtcGxhckNpdHkgJiYgbGVuZ3RoID09PSA0ICkge1xuXHRcdFx0XHRcdFx0dGltZVpvbmVOYW1lID0gZm9ybWF0TWVzc2FnZShcblx0XHRcdFx0XHRcdFx0Y2xkci5tYWluKFxuXHRcdFx0XHRcdFx0XHRcdFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9yZWdpb25Gb3JtYXRcIlxuXHRcdFx0XHRcdFx0XHQpLFxuXHRcdFx0XHRcdFx0XHRbIGV4ZW1wbGFyQ2l0eSBdXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmICggdGltZVpvbmVOYW1lICkge1xuXHRcdFx0XHRcdFx0dGltZVpvbmVOYW1lID0gbG9vc2VNYXRjaGluZyggdGltZVpvbmVOYW1lICk7XG5cdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcblx0XHRcdFx0XHRcdHByb3BlcnRpZXMudGltZVpvbmVOYW1lUmUgPSBuZXcgUmVnRXhwKFxuXHRcdFx0XHRcdFx0XHRcIl5cIiArIHJlZ2V4cEVzY2FwZSggdGltZVpvbmVOYW1lIClcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBjdXJyZW50ID09PSBcInZcIiApIHtcblx0XHRcdFx0XHRsZW5ndGggPSAxO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJ6XCI6XG5cdFx0XHRjYXNlIFwiT1wiOlxuXHRcdFx0XHRnbXRGb3JtYXQgPSBjbGRyLm1haW4oIFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9nbXRGb3JtYXRcIiApO1xuXHRcdFx0XHRjbGRyLm1haW4oIFwiZGF0ZXMvdGltZVpvbmVOYW1lcy9nbXRaZXJvRm9ybWF0XCIgKTtcblx0XHRcdFx0Y2xkci5tYWluKCBcImRhdGVzL3RpbWVab25lTmFtZXMvaG91ckZvcm1hdFwiICk7XG5cdFx0XHRcdHByb3BlcnRpZXNbIFwidGltZVpvbmVOYW1lcy9nbXRaZXJvRm9ybWF0UmVcIiBdID1cblx0XHRcdFx0XHRuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggcHJvcGVydGllc1sgXCJ0aW1lWm9uZU5hbWVzL2dtdFplcm9Gb3JtYXRcIiBdICkgKTtcblx0XHRcdFx0YXV4ID0gcHJvcGVydGllc1sgXCJ0aW1lWm9uZU5hbWVzL2hvdXJGb3JtYXRcIiBdO1xuXHRcdFx0XHRwcm9wZXJ0aWVzWyBcInRpbWVab25lTmFtZXMvaG91ckZvcm1hdFwiIF0gPSAoXG5cdFx0XHRcdFx0bGVuZ3RoIDwgNCA/XG5cdFx0XHRcdFx0XHRbIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIbSggYXV4LCBcIkhcIiApLCBkYXRlVGltZXpvbmVIb3VyRm9ybWF0SCggYXV4ICkgXSA6XG5cdFx0XHRcdFx0XHRbIGRhdGVUaW1lem9uZUhvdXJGb3JtYXRIbSggYXV4LCBcIkhIXCIgKSBdXG5cdFx0XHRcdCkubWFwKGZ1bmN0aW9uKCBob3VyRm9ybWF0ICkge1xuXHRcdFx0XHRcdHJldHVybiBob3VyRm9ybWF0UmUoXG5cdFx0XHRcdFx0XHRob3VyRm9ybWF0LFxuXHRcdFx0XHRcdFx0Z210Rm9ybWF0LFxuXHRcdFx0XHRcdFx0ZGlnaXRzUmVTb3VyY2UsXG5cdFx0XHRcdFx0XHR0aW1lU2VwYXJhdG9yXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJYXCI6XG5cdFx0XHRjYXNlIFwieFwiOlxuXG5cdFx0XHRcdC8vIHg6IGhvdXJGb3JtYXQoXCIrSEhbbW1dOy1ISFttbV1cIilcblx0XHRcdFx0Ly8geHg6IGhvdXJGb3JtYXQoXCIrSEhtbTstSEhtbVwiKVxuXHRcdFx0XHQvLyB4eHg6IGhvdXJGb3JtYXQoXCIrSEg6bW07LUhIOm1tXCIpXG5cdFx0XHRcdC8vIHh4eHg6IGhvdXJGb3JtYXQoXCIrSEhtbVtzc107LUhIbW1bc3NdXCIpXG5cdFx0XHRcdC8vIHh4eHh4OiBob3VyRm9ybWF0KFwiK0hIOm1tWzpzc107LUhIOm1tWzpzc11cIilcblx0XHRcdFx0cHJvcGVydGllcy54ID0gW1xuXHRcdFx0XHRcdFsgXCIrSEhtbTstSEhtbVwiLCBcIitISDstSEhcIiBdLFxuXHRcdFx0XHRcdFsgXCIrSEhtbTstSEhtbVwiIF0sXG5cdFx0XHRcdFx0WyBcIitISDptbTstSEg6bW1cIiBdLFxuXHRcdFx0XHRcdFsgXCIrSEhtbXNzOy1ISG1tc3NcIiwgXCIrSEhtbTstSEhtbVwiIF0sXG5cdFx0XHRcdFx0WyBcIitISDptbTpzczstSEg6bW06c3NcIiwgXCIrSEg6bW07LUhIOm1tXCIgXVxuXHRcdFx0XHRdWyBsZW5ndGggLSAxIF0ubWFwKGZ1bmN0aW9uKCBob3VyRm9ybWF0ICkge1xuXHRcdFx0XHRcdHJldHVybiBob3VyRm9ybWF0UmUoIGhvdXJGb3JtYXQgKTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcblxuXHRjbGRyLm9mZiggXCJnZXRcIiwgcG9wdWxhdGVQcm9wZXJ0aWVzICk7XG5cblx0cmV0dXJuIHByb3BlcnRpZXM7XG59O1xuXG5cblxuXG4vKipcbiAqIGRheU9mV2VlayggZGF0ZSwgZmlyc3REYXkgKVxuICpcbiAqIEBkYXRlXG4gKlxuICogQGZpcnN0RGF5IHRoZSByZXN1bHQgb2YgYGRhdGVGaXJzdERheU9mV2VlayggY2xkciApYFxuICpcbiAqIFJldHVybiB0aGUgZGF5IG9mIHRoZSB3ZWVrIG5vcm1hbGl6ZWQgYnkgdGhlIHRlcnJpdG9yeSdzIGZpcnN0RGF5IFswLTZdLlxuICogRWcgZm9yIFwibW9uXCI6XG4gKiAtIHJldHVybiAwIGlmIHRlcnJpdG9yeSBpcyBHQiwgb3IgQlIsIG9yIERFLCBvciBGUiAod2VlayBzdGFydHMgb24gXCJtb25cIik7XG4gKiAtIHJldHVybiAxIGlmIHRlcnJpdG9yeSBpcyBVUyAod2VlayBzdGFydHMgb24gXCJzdW5cIik7XG4gKiAtIHJldHVybiAyIGlmIHRlcnJpdG9yeSBpcyBFRyAod2VlayBzdGFydHMgb24gXCJzYXRcIik7XG4gKi9cbnZhciBkYXRlRGF5T2ZXZWVrID0gZnVuY3Rpb24oIGRhdGUsIGZpcnN0RGF5ICkge1xuXHRyZXR1cm4gKCBkYXRlLmdldERheSgpIC0gZmlyc3REYXkgKyA3ICkgJSA3O1xufTtcblxuXG5cblxuLyoqXG4gKiBkaXN0YW5jZUluRGF5cyggZnJvbSwgdG8gKVxuICpcbiAqIFJldHVybiB0aGUgZGlzdGFuY2UgaW4gZGF5cyBiZXR3ZWVuIGZyb20gYW5kIHRvIERhdGVzLlxuICovXG52YXIgZGF0ZURpc3RhbmNlSW5EYXlzID0gZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHR2YXIgaW5EYXlzID0gODY0ZTU7XG5cdHJldHVybiAoIHRvLmdldFRpbWUoKSAtIGZyb20uZ2V0VGltZSgpICkgLyBpbkRheXM7XG59O1xuXG5cblxuXG4vKipcbiAqIGRheU9mWWVhclxuICpcbiAqIFJldHVybiB0aGUgZGlzdGFuY2UgaW4gZGF5cyBvZiB0aGUgZGF0ZSB0byB0aGUgYmVnaW4gb2YgdGhlIHllYXIgWzAtZF0uXG4gKi9cbnZhciBkYXRlRGF5T2ZZZWFyID0gZnVuY3Rpb24oIGRhdGUgKSB7XG5cdHJldHVybiBNYXRoLmZsb29yKCBkYXRlRGlzdGFuY2VJbkRheXMoIGRhdGVTdGFydE9mKCBkYXRlLCBcInllYXJcIiApLCBkYXRlICkgKTtcbn07XG5cblxuXG5cbi8vIEludmVydCBrZXkgYW5kIHZhbHVlcywgZS5nLiwge1wieWVhclwiOiBcInlZXCJ9ID09PiB7XCJ5XCI6IFwieWVhclwiLCBcIllcIjogXCJ5ZWFyXCJ9XG52YXIgZGF0ZUZpZWxkc01hcCA9IG9iamVjdEludmVydCh7XG5cdFwiZXJhXCI6IFwiR1wiLFxuXHRcInllYXJcIjogXCJ5WVwiLFxuXHRcInF1YXJ0ZXJcIjogXCJxUVwiLFxuXHRcIm1vbnRoXCI6IFwiTUxcIixcblx0XCJ3ZWVrXCI6IFwid1dcIixcblx0XCJkYXlcIjogXCJkREZcIixcblx0XCJ3ZWVrZGF5XCI6IFwiZWNFXCIsXG5cdFwiZGF5cGVyaW9kXCI6IFwiYVwiLFxuXHRcImhvdXJcIjogXCJoSGtLXCIsXG5cdFwibWludXRlXCI6IFwibVwiLFxuXHRcInNlY29uZFwiOiBcInNTQVwiLFxuXHRcInpvbmVcIjogXCJ6dlZPeFhcIlxufSwgZnVuY3Rpb24oIG9iamVjdCwga2V5LCB2YWx1ZSApIHtcblx0dmFsdWUuc3BsaXQoIFwiXCIgKS5mb3JFYWNoKGZ1bmN0aW9uKCBzeW1ib2wgKSB7XG5cdFx0b2JqZWN0WyBzeW1ib2wgXSA9IGtleTtcblx0fSk7XG5cdHJldHVybiBvYmplY3Q7XG59KTtcblxuXG5cblxuLyoqXG4gKiBtaWxsaXNlY29uZHNJbkRheVxuICovXG52YXIgZGF0ZU1pbGxpc2Vjb25kc0luRGF5ID0gZnVuY3Rpb24oIGRhdGUgKSB7XG5cblx0Ly8gVE9ETyBIYW5kbGUgZGF5bGlnaHQgc2F2aW5ncyBkaXNjb250aW51aXRpZXNcblx0cmV0dXJuIGRhdGUgLSBkYXRlU3RhcnRPZiggZGF0ZSwgXCJkYXlcIiApO1xufTtcblxuXG5cblxuLyoqXG4gKiBob3VyRm9ybWF0KCBkYXRlLCBmb3JtYXQsIHRpbWVTZXBhcmF0b3IsIGZvcm1hdE51bWJlciApXG4gKlxuICogUmV0dXJuIGRhdGUncyB0aW1lem9uZSBvZmZzZXQgYWNjb3JkaW5nIHRvIHRoZSBmb3JtYXQgcGFzc2VkLlxuICogRWcgZm9yIGZvcm1hdCB3aGVuIHRpbWV6b25lIG9mZnNldCBpcyAxODA6XG4gKiAtIFwiK0g7LUhcIjogLTNcbiAqIC0gXCIrSEhtbTstSEhtbVwiOiAtMDMwMFxuICogLSBcIitISDptbTstSEg6bW1cIjogLTAzOjAwXG4gKiAtIFwiK0hIOm1tOnNzOy1ISDptbTpzc1wiOiAtMDM6MDA6MDBcbiAqL1xudmFyIGRhdGVUaW1lem9uZUhvdXJGb3JtYXQgPSBmdW5jdGlvbiggZGF0ZSwgZm9ybWF0LCB0aW1lU2VwYXJhdG9yLCBmb3JtYXROdW1iZXIgKSB7XG5cdHZhciBhYnNPZmZzZXQsXG5cdFx0b2Zmc2V0ID0gZGF0ZS5nZXRUaW1lem9uZU9mZnNldCgpO1xuXG5cdGFic09mZnNldCA9IE1hdGguYWJzKCBvZmZzZXQgKTtcblx0Zm9ybWF0TnVtYmVyID0gZm9ybWF0TnVtYmVyIHx8IHtcblx0XHQxOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRyZXR1cm4gc3RyaW5nUGFkKCB2YWx1ZSwgMSApO1xuXHRcdH0sXG5cdFx0MjogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHN0cmluZ1BhZCggdmFsdWUsIDIgKTtcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIGZvcm1hdFxuXG5cdFx0Ly8gUGljayB0aGUgY29ycmVjdCBzaWduIHNpZGUgKCsgb3IgLSkuXG5cdFx0LnNwbGl0KCBcIjtcIiApWyBvZmZzZXQgPiAwID8gMSA6IDAgXVxuXG5cdFx0Ly8gTG9jYWxpemUgdGltZSBzZXBhcmF0b3Jcblx0XHQucmVwbGFjZSggXCI6XCIsIHRpbWVTZXBhcmF0b3IgKVxuXG5cdFx0Ly8gVXBkYXRlIGhvdXJzIG9mZnNldC5cblx0XHQucmVwbGFjZSggL0hIPy8sIGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHJldHVybiBmb3JtYXROdW1iZXJbIG1hdGNoLmxlbmd0aCBdKCBNYXRoLmZsb29yKCBhYnNPZmZzZXQgLyA2MCApICk7XG5cdFx0fSlcblxuXHRcdC8vIFVwZGF0ZSBtaW51dGVzIG9mZnNldCBhbmQgcmV0dXJuLlxuXHRcdC5yZXBsYWNlKCAvbW0vLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmb3JtYXROdW1iZXJbIDIgXSggTWF0aC5mbG9vciggYWJzT2Zmc2V0ICUgNjAgKSApO1xuXHRcdH0pXG5cblx0XHQvLyBVcGRhdGUgbWludXRlcyBvZmZzZXQgYW5kIHJldHVybi5cblx0XHQucmVwbGFjZSggL3NzLywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZm9ybWF0TnVtYmVyWyAyIF0oIE1hdGguZmxvb3IoIGFic09mZnNldCAlIDEgKiA2MCApICk7XG5cdFx0fSk7XG59O1xuXG5cblxuXG4vKipcbiAqIGZvcm1hdCggZGF0ZSwgcHJvcGVydGllcyApXG4gKlxuICogQGRhdGUgW0RhdGUgaW5zdGFuY2VdLlxuICpcbiAqIEBwcm9wZXJ0aWVzXG4gKlxuICogVE9ETyBTdXBwb3J0IG90aGVyIGNhbGVuZGFyIHR5cGVzLlxuICpcbiAqIERpc2Nsb3N1cmU6IHRoaXMgZnVuY3Rpb24gYm9ycm93cyBleGNlcnB0cyBvZiBkb2pvL2RhdGUvbG9jYWxlLlxuICovXG52YXIgZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uKCBkYXRlLCBudW1iZXJGb3JtYXR0ZXJzLCBwcm9wZXJ0aWVzICkge1xuXHR2YXIgcGFydHMgPSBbXTtcblxuXHR2YXIgdGltZVNlcGFyYXRvciA9IHByb3BlcnRpZXMudGltZVNlcGFyYXRvcjtcblxuXHQvLyBjcmVhdGUgZ2xvYmFsaXplIGRhdGUgd2l0aCBnaXZlbiB0aW1lem9uZSBkYXRhXG5cdGlmICggcHJvcGVydGllcy50aW1lWm9uZURhdGEgKSB7XG5cdFx0ZGF0ZSA9IG5ldyBab25lZERhdGVUaW1lKCBkYXRlLCBwcm9wZXJ0aWVzLnRpbWVab25lRGF0YSgpICk7XG5cdH1cblxuXHRwcm9wZXJ0aWVzLnBhdHRlcm4ucmVwbGFjZSggZGF0ZVBhdHRlcm5SZSwgZnVuY3Rpb24oIGN1cnJlbnQgKSB7XG5cdFx0dmFyIGF1eCwgZGF0ZUZpZWxkLCB0eXBlLCB2YWx1ZSxcblx0XHRcdGNociA9IGN1cnJlbnQuY2hhckF0KCAwICksXG5cdFx0XHRsZW5ndGggPSBjdXJyZW50Lmxlbmd0aDtcblxuXHRcdGlmICggY2hyID09PSBcImpcIiApIHtcblxuXHRcdFx0Ly8gTG9jYWxlIHByZWZlcnJlZCBoSEtrLlxuXHRcdFx0Ly8gaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1kYXRlcy5odG1sI1RpbWVfRGF0YVxuXHRcdFx0Y2hyID0gcHJvcGVydGllcy5wcmVmZXJyZWRUaW1lO1xuXHRcdH1cblxuXHRcdGlmICggY2hyID09PSBcIlpcIiApIHtcblxuXHRcdFx0Ly8gWi4uWlpaOiBzYW1lIGFzIFwieHh4eFwiLlxuXHRcdFx0aWYgKCBsZW5ndGggPCA0ICkge1xuXHRcdFx0XHRjaHIgPSBcInhcIjtcblx0XHRcdFx0bGVuZ3RoID0gNDtcblxuXHRcdFx0Ly8gWlpaWjogc2FtZSBhcyBcIk9PT09cIi5cblx0XHRcdH0gZWxzZSBpZiAoIGxlbmd0aCA8IDUgKSB7XG5cdFx0XHRcdGNociA9IFwiT1wiO1xuXHRcdFx0XHRsZW5ndGggPSA0O1xuXG5cdFx0XHQvLyBaWlpaWjogc2FtZSBhcyBcIlhYWFhYXCJcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNociA9IFwiWFwiO1xuXHRcdFx0XHRsZW5ndGggPSA1O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHouLi56eno6IFwie3Nob3J0UmVnaW9ufVwiLCBlLmcuLCBcIlBTVFwiIG9yIFwiUERUXCIuXG5cdFx0Ly8genp6ejogXCJ7cmVnaW9uTmFtZX0ge1N0YW5kYXJkIFRpbWV9XCIgb3IgXCJ7cmVnaW9uTmFtZX0ge0RheWxpZ2h0IFRpbWV9XCIsXG5cdFx0Ly8gICAgICAgZS5nLiwgXCJQYWNpZmljIFN0YW5kYXJkIFRpbWVcIiBvciBcIlBhY2lmaWMgRGF5bGlnaHQgVGltZVwiLlxuXHRcdGlmICggY2hyID09PSBcInpcIiApIHtcblx0XHRcdGlmICggZGF0ZS5pc0RTVCApIHtcblx0XHRcdFx0dmFsdWUgPSBkYXRlLmlzRFNUKCkgPyBwcm9wZXJ0aWVzLmRheWxpZ2h0VHpOYW1lIDogcHJvcGVydGllcy5zdGFuZGFyZFR6TmFtZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRmFsbCBiYWNrIHRvIFwiT1wiIGZvcm1hdC5cblx0XHRcdGlmICggIXZhbHVlICkge1xuXHRcdFx0XHRjaHIgPSBcIk9cIjtcblx0XHRcdFx0aWYgKCBsZW5ndGggPCA0ICkge1xuXHRcdFx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzd2l0Y2ggKCBjaHIgKSB7XG5cblx0XHRcdC8vIEVyYVxuXHRcdFx0Y2FzZSBcIkdcIjpcblx0XHRcdFx0dmFsdWUgPSBwcm9wZXJ0aWVzLmVyYXNbIGRhdGUuZ2V0RnVsbFllYXIoKSA8IDAgPyAwIDogMSBdO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWWVhclxuXHRcdFx0Y2FzZSBcInlcIjpcblxuXHRcdFx0XHQvLyBQbGFpbiB5ZWFyLlxuXHRcdFx0XHQvLyBUaGUgbGVuZ3RoIHNwZWNpZmllcyB0aGUgcGFkZGluZywgYnV0IGZvciB0d28gbGV0dGVycyBpdCBhbHNvIHNwZWNpZmllcyB0aGVcblx0XHRcdFx0Ly8gbWF4aW11bSBsZW5ndGguXG5cdFx0XHRcdHZhbHVlID0gZGF0ZS5nZXRGdWxsWWVhcigpO1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA9PT0gMiApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IFN0cmluZyggdmFsdWUgKTtcblx0XHRcdFx0XHR2YWx1ZSA9ICt2YWx1ZS5zdWJzdHIoIHZhbHVlLmxlbmd0aCAtIDIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIllcIjpcblxuXHRcdFx0XHQvLyBZZWFyIGluIFwiV2VlayBvZiBZZWFyXCJcblx0XHRcdFx0Ly8gVGhlIGxlbmd0aCBzcGVjaWZpZXMgdGhlIHBhZGRpbmcsIGJ1dCBmb3IgdHdvIGxldHRlcnMgaXQgYWxzbyBzcGVjaWZpZXMgdGhlXG5cdFx0XHRcdC8vIG1heGltdW0gbGVuZ3RoLlxuXHRcdFx0XHQvLyB5ZWFySW5XZWVrb2ZZZWFyID0gZGF0ZSArIERheXNJbkFXZWVrIC0gKGRheU9mV2VlayAtIGZpcnN0RGF5KSAtIG1pbkRheXNcblx0XHRcdFx0dmFsdWUgPSBuZXcgRGF0ZSggZGF0ZS5nZXRUaW1lKCkgKTtcblx0XHRcdFx0dmFsdWUuc2V0RGF0ZShcblx0XHRcdFx0XHR2YWx1ZS5nZXREYXRlKCkgKyA3IC1cblx0XHRcdFx0XHRkYXRlRGF5T2ZXZWVrKCBkYXRlLCBwcm9wZXJ0aWVzLmZpcnN0RGF5ICkgLVxuXHRcdFx0XHRcdHByb3BlcnRpZXMuZmlyc3REYXkgLVxuXHRcdFx0XHRcdHByb3BlcnRpZXMubWluRGF5c1xuXHRcdFx0XHQpO1xuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmdldEZ1bGxZZWFyKCk7XG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSAyICkge1xuXHRcdFx0XHRcdHZhbHVlID0gU3RyaW5nKCB2YWx1ZSApO1xuXHRcdFx0XHRcdHZhbHVlID0gK3ZhbHVlLnN1YnN0ciggdmFsdWUubGVuZ3RoIC0gMiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBRdWFydGVyXG5cdFx0XHRjYXNlIFwiUVwiOlxuXHRcdFx0Y2FzZSBcInFcIjpcblx0XHRcdFx0dmFsdWUgPSBNYXRoLmNlaWwoICggZGF0ZS5nZXRNb250aCgpICsgMSApIC8gMyApO1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IDIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBwcm9wZXJ0aWVzLnF1YXJ0ZXJzWyBjaHIgXVsgbGVuZ3RoIF1bIHZhbHVlIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIE1vbnRoXG5cdFx0XHRjYXNlIFwiTVwiOlxuXHRcdFx0Y2FzZSBcIkxcIjpcblx0XHRcdFx0dmFsdWUgPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IDIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBwcm9wZXJ0aWVzLm1vbnRoc1sgY2hyIF1bIGxlbmd0aCBdWyB2YWx1ZSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBXZWVrXG5cdFx0XHRjYXNlIFwid1wiOlxuXG5cdFx0XHRcdC8vIFdlZWsgb2YgWWVhci5cblx0XHRcdFx0Ly8gd295ID0gY2VpbCggKCBkb3kgKyBkb3cgb2YgMS8xICkgLyA3ICkgLSBtaW5EYXlzU3R1ZmYgPyAxIDogMC5cblx0XHRcdFx0Ly8gVE9ETyBzaG91bGQgcGFkIG9uIHd3PyBOb3QgZG9jdW1lbnRlZCwgYnV0IEkgZ3Vlc3Mgc28uXG5cdFx0XHRcdHZhbHVlID0gZGF0ZURheU9mV2VlayggZGF0ZVN0YXJ0T2YoIGRhdGUsIFwieWVhclwiICksIHByb3BlcnRpZXMuZmlyc3REYXkgKTtcblx0XHRcdFx0dmFsdWUgPSBNYXRoLmNlaWwoICggZGF0ZURheU9mWWVhciggZGF0ZSApICsgdmFsdWUgKSAvIDcgKSAtXG5cdFx0XHRcdFx0KCA3IC0gdmFsdWUgPj0gcHJvcGVydGllcy5taW5EYXlzID8gMCA6IDEgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJXXCI6XG5cblx0XHRcdFx0Ly8gV2VlayBvZiBNb250aC5cblx0XHRcdFx0Ly8gd29tID0gY2VpbCggKCBkb20gKyBkb3cgb2YgYDEvbW9udGhgICkgLyA3ICkgLSBtaW5EYXlzU3R1ZmYgPyAxIDogMC5cblx0XHRcdFx0dmFsdWUgPSBkYXRlRGF5T2ZXZWVrKCBkYXRlU3RhcnRPZiggZGF0ZSwgXCJtb250aFwiICksIHByb3BlcnRpZXMuZmlyc3REYXkgKTtcblx0XHRcdFx0dmFsdWUgPSBNYXRoLmNlaWwoICggZGF0ZS5nZXREYXRlKCkgKyB2YWx1ZSApIC8gNyApIC1cblx0XHRcdFx0XHQoIDcgLSB2YWx1ZSA+PSBwcm9wZXJ0aWVzLm1pbkRheXMgPyAwIDogMSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gRGF5XG5cdFx0XHRjYXNlIFwiZFwiOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGUuZ2V0RGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIkRcIjpcblx0XHRcdFx0dmFsdWUgPSBkYXRlRGF5T2ZZZWFyKCBkYXRlICkgKyAxO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIkZcIjpcblxuXHRcdFx0XHQvLyBEYXkgb2YgV2VlayBpbiBtb250aC4gZWcuIDJuZCBXZWQgaW4gSnVseS5cblx0XHRcdFx0dmFsdWUgPSBNYXRoLmZsb29yKCBkYXRlLmdldERhdGUoKSAvIDcgKSArIDE7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHQvLyBXZWVrIGRheVxuXHRcdFx0Y2FzZSBcImVcIjpcblx0XHRcdGNhc2UgXCJjXCI6XG5cdFx0XHRcdGlmICggbGVuZ3RoIDw9IDIgKSB7XG5cblx0XHRcdFx0XHQvLyBSYW5nZSBpcyBbMS03XSAoZGVkdWNlZCBieSBleGFtcGxlIHByb3ZpZGVkIG9uIGRvY3VtZW50YXRpb24pXG5cdFx0XHRcdFx0Ly8gVE9ETyBTaG91bGQgcGFkIHdpdGggemVyb3MgKG5vdCBzcGVjaWZpZWQgaW4gdGhlIGRvY3MpP1xuXHRcdFx0XHRcdHZhbHVlID0gZGF0ZURheU9mV2VlayggZGF0ZSwgcHJvcGVydGllcy5maXJzdERheSApICsgMTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiRVwiOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGVXZWVrRGF5c1sgZGF0ZS5nZXREYXkoKSBdO1xuXHRcdFx0XHR2YWx1ZSA9IHByb3BlcnRpZXMuZGF5c1sgY2hyIF1bIGxlbmd0aCBdWyB2YWx1ZSBdO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gUGVyaW9kIChBTSBvciBQTSlcblx0XHRcdGNhc2UgXCJhXCI6XG5cdFx0XHRcdHZhbHVlID0gcHJvcGVydGllcy5kYXlQZXJpb2RzWyBkYXRlLmdldEhvdXJzKCkgPCAxMiA/IFwiYW1cIiA6IFwicG1cIiBdO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gSG91clxuXHRcdFx0Y2FzZSBcImhcIjogLy8gMS0xMlxuXHRcdFx0XHR2YWx1ZSA9ICggZGF0ZS5nZXRIb3VycygpICUgMTIgKSB8fCAxMjtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJIXCI6IC8vIDAtMjNcblx0XHRcdFx0dmFsdWUgPSBkYXRlLmdldEhvdXJzKCk7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwiS1wiOiAvLyAwLTExXG5cdFx0XHRcdHZhbHVlID0gZGF0ZS5nZXRIb3VycygpICUgMTI7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlIFwia1wiOiAvLyAxLTI0XG5cdFx0XHRcdHZhbHVlID0gZGF0ZS5nZXRIb3VycygpIHx8IDI0O1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gTWludXRlXG5cdFx0XHRjYXNlIFwibVwiOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGUuZ2V0TWludXRlcygpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gU2Vjb25kXG5cdFx0XHRjYXNlIFwic1wiOlxuXHRcdFx0XHR2YWx1ZSA9IGRhdGUuZ2V0U2Vjb25kcygpO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Y2FzZSBcIlNcIjpcblx0XHRcdFx0dmFsdWUgPSBNYXRoLnJvdW5kKCBkYXRlLmdldE1pbGxpc2Vjb25kcygpICogTWF0aC5wb3coIDEwLCBsZW5ndGggLSAzICkgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJBXCI6XG5cdFx0XHRcdHZhbHVlID0gTWF0aC5yb3VuZCggZGF0ZU1pbGxpc2Vjb25kc0luRGF5KCBkYXRlICkgKiBNYXRoLnBvdyggMTAsIGxlbmd0aCAtIDMgKSApO1xuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0Ly8gWm9uZVxuXHRcdFx0Y2FzZSBcInpcIjpcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJ2XCI6XG5cblx0XHRcdFx0Ly8gdi4uLnZ2djogXCJ7c2hvcnRSZWdpb259XCIsIGVnLiBcIlBUXCIuXG5cdFx0XHRcdC8vIHZ2dnY6IFwie3JlZ2lvbk5hbWV9IHtUaW1lfVwiLFxuXHRcdFx0XHQvLyAgICAgICBlLmcuLCBcIlBhY2lmaWMgVGltZVwiLlxuXHRcdFx0XHRpZiAoIHByb3BlcnRpZXMuZ2VuZXJpY1R6TmFtZSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHByb3BlcnRpZXMuZ2VuZXJpY1R6TmFtZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiVlwiOlxuXG5cdFx0XHRcdC8vVlZWVjogXCJ7ZXhwbGFyQ2l0eX0ge1RpbWV9XCIsIGUuZy4sIFwiTG9zIEFuZ2VsZXMgVGltZVwiXG5cdFx0XHRcdGlmICggcHJvcGVydGllcy50aW1lWm9uZU5hbWUgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBwcm9wZXJ0aWVzLnRpbWVab25lTmFtZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggY3VycmVudCA9PT0gXCJ2XCIgKSB7XG5cdFx0XHRcdFx0bGVuZ3RoID0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlIFwiT1wiOlxuXG5cdFx0XHRcdC8vIE86IFwie2dtdEZvcm1hdH0rSDt7Z210Rm9ybWF0fS1IXCIgb3IgXCJ7Z210WmVyb0Zvcm1hdH1cIiwgZWcuIFwiR01ULThcIiBvciBcIkdNVFwiLlxuXHRcdFx0XHQvLyBPT09POiBcIntnbXRGb3JtYXR9e2hvdXJGb3JtYXR9XCIgb3IgXCJ7Z210WmVyb0Zvcm1hdH1cIiwgZWcuIFwiR01ULTA4OjAwXCIgb3IgXCJHTVRcIi5cblx0XHRcdFx0aWYgKCBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgPT09IDAgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBwcm9wZXJ0aWVzLmdtdFplcm9Gb3JtYXQ7XG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBJZiBPLi5PT08gYW5kIHRpbWV6b25lIG9mZnNldCBoYXMgbm9uLXplcm8gbWludXRlcywgc2hvdyBtaW51dGVzLlxuXHRcdFx0XHRcdGlmICggbGVuZ3RoIDwgNCApIHtcblx0XHRcdFx0XHRcdGF1eCA9IGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKTtcblx0XHRcdFx0XHRcdGF1eCA9IHByb3BlcnRpZXMuaG91ckZvcm1hdFsgYXV4ICUgNjAgLSBhdXggJSAxID09PSAwID8gMCA6IDEgXTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0YXV4ID0gcHJvcGVydGllcy5ob3VyRm9ybWF0O1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHZhbHVlID0gZGF0ZVRpbWV6b25lSG91ckZvcm1hdChcblx0XHRcdFx0XHRcdGRhdGUsXG5cdFx0XHRcdFx0XHRhdXgsXG5cdFx0XHRcdFx0XHR0aW1lU2VwYXJhdG9yLFxuXHRcdFx0XHRcdFx0bnVtYmVyRm9ybWF0dGVyc1xuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0dmFsdWUgPSBwcm9wZXJ0aWVzLmdtdEZvcm1hdC5yZXBsYWNlKCAvXFx7MFxcfS8sIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdGNhc2UgXCJYXCI6XG5cblx0XHRcdFx0Ly8gU2FtZSBhcyB4KiwgZXhjZXB0IGl0IHVzZXMgXCJaXCIgZm9yIHplcm8gb2Zmc2V0LlxuXHRcdFx0XHRpZiAoIGRhdGUuZ2V0VGltZXpvbmVPZmZzZXQoKSA9PT0gMCApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IFwiWlwiO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cblx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cblx0XHRcdGNhc2UgXCJ4XCI6XG5cblx0XHRcdFx0Ly8geDogaG91ckZvcm1hdChcIitISFttbV07LUhIW21tXVwiKVxuXHRcdFx0XHQvLyB4eDogaG91ckZvcm1hdChcIitISG1tOy1ISG1tXCIpXG5cdFx0XHRcdC8vIHh4eDogaG91ckZvcm1hdChcIitISDptbTstSEg6bW1cIilcblx0XHRcdFx0Ly8geHh4eDogaG91ckZvcm1hdChcIitISG1tW3NzXTstSEhtbVtzc11cIilcblx0XHRcdFx0Ly8geHh4eHg6IGhvdXJGb3JtYXQoXCIrSEg6bW1bOnNzXTstSEg6bW1bOnNzXVwiKVxuXHRcdFx0XHRhdXggPSBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCk7XG5cblx0XHRcdFx0Ly8gSWYgeCBhbmQgdGltZXpvbmUgb2Zmc2V0IGhhcyBub24temVybyBtaW51dGVzLCB1c2UgeHggKGkuZS4sIHNob3cgbWludXRlcykuXG5cdFx0XHRcdGlmICggbGVuZ3RoID09PSAxICYmIGF1eCAlIDYwIC0gYXV4ICUgMSAhPT0gMCApIHtcblx0XHRcdFx0XHRsZW5ndGggKz0gMTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmICh4eHh4IG9yIHh4eHh4KSBhbmQgdGltZXpvbmUgb2Zmc2V0IGhhcyB6ZXJvIHNlY29uZHMsIHVzZSB4eCBvciB4eHhcblx0XHRcdFx0Ly8gcmVzcGVjdGl2ZWx5IChpLmUuLCBkb24ndCBzaG93IG9wdGlvbmFsIHNlY29uZHMpLlxuXHRcdFx0XHRpZiAoICggbGVuZ3RoID09PSA0IHx8IGxlbmd0aCA9PT0gNSApICYmIGF1eCAlIDEgPT09IDAgKSB7XG5cdFx0XHRcdFx0bGVuZ3RoIC09IDI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YWx1ZSA9IFtcblx0XHRcdFx0XHRcIitISDstSEhcIixcblx0XHRcdFx0XHRcIitISG1tOy1ISG1tXCIsXG5cdFx0XHRcdFx0XCIrSEg6bW07LUhIOm1tXCIsXG5cdFx0XHRcdFx0XCIrSEhtbXNzOy1ISG1tc3NcIixcblx0XHRcdFx0XHRcIitISDptbTpzczstSEg6bW06c3NcIlxuXHRcdFx0XHRdWyBsZW5ndGggLSAxIF07XG5cblx0XHRcdFx0dmFsdWUgPSBkYXRlVGltZXpvbmVIb3VyRm9ybWF0KCBkYXRlLCB2YWx1ZSwgXCI6XCIgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIHRpbWVTZXBhcmF0b3Jcblx0XHRcdGNhc2UgXCI6XCI6XG5cdFx0XHRcdHZhbHVlID0gdGltZVNlcGFyYXRvcjtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vICcgbGl0ZXJhbHMuXG5cdFx0XHRjYXNlIFwiJ1wiOlxuXHRcdFx0XHR2YWx1ZSA9IHJlbW92ZUxpdGVyYWxRdW90ZXMoIGN1cnJlbnQgKTtcblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdC8vIEFueXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBhIGxpdGVyYWwsIGluY2x1ZGluZyBbICw6Ly5AI10sIGNoaW5lc2UsIGphcG9uZXNlLCBhbmRcblx0XHRcdC8vIGFyYWJpYyBjaGFyYWN0ZXJzLlxuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dmFsdWUgPSBjdXJyZW50O1xuXG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0dmFsdWUgPSBudW1iZXJGb3JtYXR0ZXJzWyBsZW5ndGggXSggdmFsdWUgKTtcblx0XHR9XG5cblx0XHRkYXRlRmllbGQgPSBkYXRlRmllbGRzTWFwWyBjaHIgXTtcblx0XHR0eXBlID0gZGF0ZUZpZWxkID8gZGF0ZUZpZWxkIDogXCJsaXRlcmFsXCI7XG5cblx0XHQvLyBDb25jYXQgdHdvIGNvbnNlY3V0aXZlIGxpdGVyYWxzXG5cdFx0aWYgKCB0eXBlID09PSBcImxpdGVyYWxcIiAmJiBwYXJ0cy5sZW5ndGggJiYgcGFydHNbIHBhcnRzLmxlbmd0aCAtIDEgXS50eXBlID09PSBcImxpdGVyYWxcIiApIHtcblx0XHRcdHBhcnRzWyBwYXJ0cy5sZW5ndGggLSAxIF0udmFsdWUgKz0gdmFsdWU7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cGFydHMucHVzaCggeyB0eXBlOiB0eXBlLCB2YWx1ZTogdmFsdWUgfSApO1xuXG5cdH0pO1xuXG5cdHJldHVybiBwYXJ0cztcblxufTtcblxuXG5cblxudmFyIGRhdGVUb1BhcnRzRm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggbnVtYmVyRm9ybWF0dGVycywgcHJvcGVydGllcyApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIGRhdGVUb1BhcnRzRm9ybWF0dGVyKCB2YWx1ZSApIHtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlRGF0ZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdFx0cmV0dXJuIGRhdGVGb3JtYXQoIHZhbHVlLCBudW1iZXJGb3JtYXR0ZXJzLCBwcm9wZXJ0aWVzICk7XG5cdH07XG5cbn07XG5cblxuXG5cbmZ1bmN0aW9uIG9wdGlvbnNIYXNTdHlsZSggb3B0aW9ucyApIHtcblx0cmV0dXJuIG9wdGlvbnMuc2tlbGV0b24gIT09IHVuZGVmaW5lZCB8fFxuXHRcdG9wdGlvbnMuZGF0ZSAhPT0gdW5kZWZpbmVkIHx8XG5cdFx0b3B0aW9ucy50aW1lICE9PSB1bmRlZmluZWQgfHxcblx0XHRvcHRpb25zLmRhdGV0aW1lICE9PSB1bmRlZmluZWQgfHxcblx0XHRvcHRpb25zLnJhdyAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVJlcXVpcmVkQ2xkciggcGF0aCwgdmFsdWUgKSB7XG5cdHZhbGlkYXRlQ2xkciggcGF0aCwgdmFsdWUsIHtcblx0XHRza2lwOiBbXG5cdFx0XHQvZGF0ZXNcXC9jYWxlbmRhcnNcXC9ncmVnb3JpYW5cXC9kYXRlVGltZUZvcm1hdHNcXC9hdmFpbGFibGVGb3JtYXRzLyxcblx0XHRcdC9kYXRlc1xcL2NhbGVuZGFyc1xcL2dyZWdvcmlhblxcL2RheXNcXC8uKlxcL3Nob3J0Lyxcblx0XHRcdC9kYXRlc1xcL3RpbWVab25lTmFtZXNcXC96b25lLyxcblx0XHRcdC9kYXRlc1xcL3RpbWVab25lTmFtZXNcXC9tZXRhem9uZS8sXG5cdFx0XHQvZ2xvYmFsaXplLWlhbmEvLFxuXHRcdFx0L3N1cHBsZW1lbnRhbFxcL21ldGFab25lcy8sXG5cdFx0XHQvc3VwcGxlbWVudGFsXFwvdGltZURhdGFcXC8oPyEwMDEpLyxcblx0XHRcdC9zdXBwbGVtZW50YWxcXC93ZWVrRGF0YVxcLyg/ITAwMSkvXG5cdFx0XVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zUHJlc2V0KCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXRFYWNoKCBcImRhdGVcIiwgb3B0aW9ucyApO1xuXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXRFYWNoKCBcInRpbWVcIiwgb3B0aW9ucyApO1xuXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXRFYWNoKCBcImRhdGV0aW1lXCIsIG9wdGlvbnMgKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zUHJlc2V0RWFjaCggdHlwZSwgb3B0aW9ucyApIHtcblx0dmFyIHZhbHVlID0gb3B0aW9uc1sgdHlwZSBdO1xuXHR2YWxpZGF0ZShcblx0XHRcIkVfSU5WQUxJRF9PUFRJT05TXCIsXG5cdFx0XCJJbnZhbGlkIGB7e3R5cGV9OiBcXFwie3ZhbHVlfVxcXCJ9YC5cIixcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IFsgXCJzaG9ydFwiLCBcIm1lZGl1bVwiLCBcImxvbmdcIiwgXCJmdWxsXCIgXS5pbmRleE9mKCB2YWx1ZSApICE9PSAtMSxcblx0XHR7IHR5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSB9XG5cdCk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0aW9uc1NrZWxldG9uKCBwYXR0ZXJuLCBza2VsZXRvbiApIHtcblx0dmFsaWRhdGUoXG5cdFx0XCJFX0lOVkFMSURfT1BUSU9OU1wiLFxuXHRcdFwiSW52YWxpZCBge3NrZWxldG9uOiBcXFwie3ZhbHVlfVxcXCJ9YCBiYXNlZCBvbiBwcm92aWRlZCBDTERSLlwiLFxuXHRcdHNrZWxldG9uID09PSB1bmRlZmluZWQgfHwgKCB0eXBlb2YgcGF0dGVybiA9PT0gXCJzdHJpbmdcIiAmJiBwYXR0ZXJuICksXG5cdFx0eyB0eXBlOiBcInNrZWxldG9uXCIsIHZhbHVlOiBza2VsZXRvbiB9XG5cdCk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVxdWlyZWRJYW5hKCB0aW1lWm9uZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBwYXRoLCB2YWx1ZSApIHtcblxuXHRcdGlmICggIS9nbG9iYWxpemUtaWFuYS8udGVzdCggcGF0aCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbGlkYXRlKFxuXHRcdFx0XCJFX01JU1NJTkdfSUFOQV9UWlwiLFxuXHRcdFx0XCJNaXNzaW5nIHJlcXVpcmVkIElBTkEgdGltZXpvbmUgY29udGVudCBmb3IgYHt0aW1lWm9uZX1gOiBge3BhdGh9YC5cIixcblx0XHRcdHZhbHVlLFxuXHRcdFx0e1xuXHRcdFx0XHRwYXRoOiBwYXRoLnJlcGxhY2UoIC9nbG9iYWxpemUtaWFuYVxcLy8sIFwiXCIgKSxcblx0XHRcdFx0dGltZVpvbmU6IHRpbWVab25lXG5cdFx0XHR9XG5cdFx0KTtcblx0fTtcbn1cblxuLyoqXG4gKiAubG9hZFRpbWVab25lKCBqc29uIClcbiAqXG4gKiBAanNvbiBbSlNPTl1cbiAqXG4gKiBMb2FkIElBTkEgdGltZXpvbmUgZGF0YS5cbiAqL1xuR2xvYmFsaXplLmxvYWRUaW1lWm9uZSA9IGZ1bmN0aW9uKCBqc29uICkge1xuXHR2YXIgY3VzdG9tRGF0YSA9IHtcblx0XHRcdFwiZ2xvYmFsaXplLWlhbmFcIjoganNvblxuXHRcdH07XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSgganNvbiwgXCJqc29uXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIGpzb24sIFwianNvblwiICk7XG5cblx0Q2xkci5sb2FkKCBjdXN0b21EYXRhICk7XG59O1xuXG4vKipcbiAqIC5kYXRlRm9ybWF0dGVyKCBvcHRpb25zIClcbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgZGF0ZS9leHBhbmRfcGF0dGVybiBmb3IgbW9yZSBpbmZvLlxuICpcbiAqIFJldHVybiBhIGRhdGUgZm9ybWF0dGVyIGZ1bmN0aW9uIChvZiB0aGUgZm9ybSBiZWxvdykgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIGFuZCB0aGVcbiAqIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICpcbiAqIGZuKCB2YWx1ZSApXG4gKlxuICogQHZhbHVlIFtEYXRlXVxuICpcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgZm9ybWF0cyBhIGRhdGUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBgZm9ybWF0YCBhbmQgdGhlIGRlZmF1bHQvaW5zdGFuY2VcbiAqIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmRhdGVGb3JtYXR0ZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5kYXRlRm9ybWF0dGVyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBhcmdzLCBkYXRlVG9QYXJ0c0Zvcm1hdHRlciwgcmV0dXJuRm47XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QoIG9wdGlvbnMsIFwib3B0aW9uc1wiICk7XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdGlmICggIW9wdGlvbnNIYXNTdHlsZSggb3B0aW9ucyApICkge1xuXHRcdG9wdGlvbnMuc2tlbGV0b24gPSBcInlNZFwiO1xuXHR9XG5cdGFyZ3MgPSBbIG9wdGlvbnMgXTtcblxuXHRkYXRlVG9QYXJ0c0Zvcm1hdHRlciA9IHRoaXMuZGF0ZVRvUGFydHNGb3JtYXR0ZXIoIG9wdGlvbnMgKTtcblx0cmV0dXJuRm4gPSBkYXRlRm9ybWF0dGVyRm4oIGRhdGVUb1BhcnRzRm9ybWF0dGVyICk7XG5cdHJ1bnRpbWVCaW5kKCBhcmdzLCB0aGlzLmNsZHIsIHJldHVybkZuLCBbIGRhdGVUb1BhcnRzRm9ybWF0dGVyIF0gKTtcblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG4vKipcbiAqIC5kYXRlVG9QYXJ0c0Zvcm1hdHRlciggb3B0aW9ucyApXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGRhdGUvZXhwYW5kX3BhdHRlcm4gZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBSZXR1cm4gYSBkYXRlIGZvcm1hdHRlciBmdW5jdGlvbiAob2YgdGhlIGZvcm0gYmVsb3cpIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgdGhlXG4gKiBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqXG4gKiBmbiggdmFsdWUgKVxuICpcbiAqIEB2YWx1ZSBbRGF0ZV1cbiAqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYSBkYXRlIHRvIHBhcnRzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gYGZvcm1hdGBcbiAqIGFuZCB0aGUgZGVmYXVsdC9pbnN0YW5jZVxuICogbG9jYWxlLlxuICovXG5HbG9iYWxpemUuZGF0ZVRvUGFydHNGb3JtYXR0ZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5kYXRlVG9QYXJ0c0Zvcm1hdHRlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgYXJncywgY2xkciwgbnVtYmVyRm9ybWF0dGVycywgcGFkLCBwYXR0ZXJuLCBwcm9wZXJ0aWVzLCByZXR1cm5Gbixcblx0XHR0aW1lWm9uZTtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXCJvcHRpb25zXCIgKTtcblxuXHRjbGRyID0gdGhpcy5jbGRyO1xuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0aWYgKCAhb3B0aW9uc0hhc1N0eWxlKCBvcHRpb25zICkgKSB7XG5cdFx0b3B0aW9ucy5za2VsZXRvbiA9IFwieU1kXCI7XG5cdH1cblxuXHR2YWxpZGF0ZU9wdGlvbnNQcmVzZXQoIG9wdGlvbnMgKTtcblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XG5cblx0dGltZVpvbmUgPSBvcHRpb25zLnRpbWVab25lO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcoIHRpbWVab25lLCBcIm9wdGlvbnMudGltZVpvbmVcIiApO1xuXG5cdGFyZ3MgPSBbIG9wdGlvbnMgXTtcblxuXHRjbGRyLm9uKCBcImdldFwiLCB2YWxpZGF0ZVJlcXVpcmVkQ2xkciApO1xuXHRpZiAoIHRpbWVab25lICkge1xuXHRcdGNsZHIub24oIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRJYW5hKCB0aW1lWm9uZSApICk7XG5cdH1cblx0cGF0dGVybiA9IGRhdGVFeHBhbmRQYXR0ZXJuKCBvcHRpb25zLCBjbGRyICk7XG5cdHZhbGlkYXRlT3B0aW9uc1NrZWxldG9uKCBwYXR0ZXJuLCBvcHRpb25zLnNrZWxldG9uICk7XG5cdHByb3BlcnRpZXMgPSBkYXRlRm9ybWF0UHJvcGVydGllcyggcGF0dGVybiwgY2xkciwgdGltZVpvbmUgKTtcblx0Y2xkci5vZmYoIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRDbGRyICk7XG5cdGlmICggdGltZVpvbmUgKSB7XG5cdFx0Y2xkci5vZmYoIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRJYW5hKCB0aW1lWm9uZSApICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgbmVlZGVkIG51bWJlciBmb3JtYXR0ZXJzLlxuXHRudW1iZXJGb3JtYXR0ZXJzID0gcHJvcGVydGllcy5udW1iZXJGb3JtYXR0ZXJzO1xuXHRkZWxldGUgcHJvcGVydGllcy5udW1iZXJGb3JtYXR0ZXJzO1xuXHRmb3IgKCBwYWQgaW4gbnVtYmVyRm9ybWF0dGVycyApIHtcblx0XHRudW1iZXJGb3JtYXR0ZXJzWyBwYWQgXSA9IHRoaXMubnVtYmVyRm9ybWF0dGVyKHtcblx0XHRcdHJhdzogbnVtYmVyRm9ybWF0dGVyc1sgcGFkIF1cblx0XHR9KTtcblx0fVxuXG5cdHJldHVybkZuID0gZGF0ZVRvUGFydHNGb3JtYXR0ZXJGbiggbnVtYmVyRm9ybWF0dGVycywgcHJvcGVydGllcyApO1xuXG5cdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBudW1iZXJGb3JtYXR0ZXJzLCBwcm9wZXJ0aWVzIF0gKTtcblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG4vKipcbiAqIC5kYXRlUGFyc2VyKCBvcHRpb25zIClcbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgZGF0ZS9leHBhbmRfcGF0dGVybiBmb3IgbW9yZSBpbmZvLlxuICpcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcGFyc2VzIGEgc3RyaW5nIGRhdGUgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBgZm9ybWF0c2AgYW5kIHRoZVxuICogZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5kYXRlUGFyc2VyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZGF0ZVBhcnNlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgYXJncywgY2xkciwgbnVtYmVyUGFyc2VyLCBwYXJzZVByb3BlcnRpZXMsIHBhdHRlcm4sIHJldHVybkZuLCB0aW1lWm9uZSxcblx0XHR0b2tlbml6ZXJQcm9wZXJ0aWVzO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcIm9wdGlvbnNcIiApO1xuXG5cdGNsZHIgPSB0aGlzLmNsZHI7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRpZiAoICFvcHRpb25zSGFzU3R5bGUoIG9wdGlvbnMgKSApIHtcblx0XHRvcHRpb25zLnNrZWxldG9uID0gXCJ5TWRcIjtcblx0fVxuXG5cdHZhbGlkYXRlT3B0aW9uc1ByZXNldCggb3B0aW9ucyApO1xuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcblxuXHR0aW1lWm9uZSA9IG9wdGlvbnMudGltZVpvbmU7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdGltZVpvbmUsIFwib3B0aW9ucy50aW1lWm9uZVwiICk7XG5cblx0YXJncyA9IFsgb3B0aW9ucyBdO1xuXG5cdGNsZHIub24oIFwiZ2V0XCIsIHZhbGlkYXRlUmVxdWlyZWRDbGRyICk7XG5cdGlmICggdGltZVpvbmUgKSB7XG5cdFx0Y2xkci5vbiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZElhbmEoIHRpbWVab25lICkgKTtcblx0fVxuXHRwYXR0ZXJuID0gZGF0ZUV4cGFuZFBhdHRlcm4oIG9wdGlvbnMsIGNsZHIgKTtcblx0dmFsaWRhdGVPcHRpb25zU2tlbGV0b24oIHBhdHRlcm4sIG9wdGlvbnMuc2tlbGV0b24gKTtcblx0dG9rZW5pemVyUHJvcGVydGllcyA9IGRhdGVUb2tlbml6ZXJQcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyLCB0aW1lWm9uZSApO1xuXHRwYXJzZVByb3BlcnRpZXMgPSBkYXRlUGFyc2VQcm9wZXJ0aWVzKCBjbGRyLCB0aW1lWm9uZSApO1xuXHRjbGRyLm9mZiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZENsZHIgKTtcblx0aWYgKCB0aW1lWm9uZSApIHtcblx0XHRjbGRyLm9mZiggXCJnZXRcIiwgdmFsaWRhdGVSZXF1aXJlZElhbmEoIHRpbWVab25lICkgKTtcblx0fVxuXG5cdG51bWJlclBhcnNlciA9IHRoaXMubnVtYmVyUGFyc2VyKHsgcmF3OiBcIjBcIiB9KTtcblxuXHRyZXR1cm5GbiA9IGRhdGVQYXJzZXJGbiggbnVtYmVyUGFyc2VyLCBwYXJzZVByb3BlcnRpZXMsIHRva2VuaXplclByb3BlcnRpZXMgKTtcblxuXHRydW50aW1lQmluZCggYXJncywgY2xkciwgcmV0dXJuRm4sIFsgbnVtYmVyUGFyc2VyLCBwYXJzZVByb3BlcnRpZXMsIHRva2VuaXplclByb3BlcnRpZXMgXSApO1xuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbi8qKlxuICogLmZvcm1hdERhdGUoIHZhbHVlLCBvcHRpb25zIClcbiAqXG4gKiBAdmFsdWUgW0RhdGVdXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF0gc2VlIGRhdGUvZXhwYW5kX3BhdHRlcm4gZm9yIG1vcmUgaW5mby5cbiAqXG4gKiBGb3JtYXRzIGEgZGF0ZSBvciBudW1iZXIgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBvcHRpb25zIHN0cmluZyBhbmQgdGhlIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUuZm9ybWF0RGF0ZSA9XG5HbG9iYWxpemUucHJvdG90eXBlLmZvcm1hdERhdGUgPSBmdW5jdGlvbiggdmFsdWUsIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlRGF0ZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdHJldHVybiB0aGlzLmRhdGVGb3JtYXR0ZXIoIG9wdGlvbnMgKSggdmFsdWUgKTtcbn07XG5cbi8qKlxuICogLmZvcm1hdERhdGVUb1BhcnRzKCB2YWx1ZSwgb3B0aW9ucyApXG4gKlxuICogQHZhbHVlIFtEYXRlXVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSBkYXRlL2V4cGFuZF9wYXR0ZXJuIGZvciBtb3JlIGluZm8uXG4gKlxuICogRm9ybWF0cyBhIGRhdGUgb3IgbnVtYmVyIHRvIHBhcnRzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgdGhlIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUuZm9ybWF0RGF0ZVRvUGFydHMgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXREYXRlVG9QYXJ0cyA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVEYXRlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0cmV0dXJuIHRoaXMuZGF0ZVRvUGFydHNGb3JtYXR0ZXIoIG9wdGlvbnMgKSggdmFsdWUgKTtcbn07XG5cbi8qKlxuICogLnBhcnNlRGF0ZSggdmFsdWUsIG9wdGlvbnMgKVxuICpcbiAqIEB2YWx1ZSBbU3RyaW5nXVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdIHNlZSBkYXRlL2V4cGFuZF9wYXR0ZXJuIGZvciBtb3JlIGluZm8uXG4gKlxuICogUmV0dXJuIGEgRGF0ZSBpbnN0YW5jZSBvciBudWxsLlxuICovXG5HbG9iYWxpemUucGFyc2VEYXRlID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUucGFyc2VEYXRlID0gZnVuY3Rpb24oIHZhbHVlLCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdHJldHVybiB0aGlzLmRhdGVQYXJzZXIoIG9wdGlvbnMgKSggdmFsdWUgKTtcbn07XG5cbnJldHVybiBHbG9iYWxpemU7XG5cblxuXG5cbn0pKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL2RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9kYXRlLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qKiogSU1QT1JUUyBGUk9NIGltcG9ydHMtbG9hZGVyICoqKi9cbnZhciBkZWZpbmUgPSBmYWxzZTtcblxuLyoqXG4gKiBHbG9iYWxpemUgdjEuMy4wXG4gKlxuICogaHR0cDovL2dpdGh1Yi5jb20vanF1ZXJ5L2dsb2JhbGl6ZVxuICpcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTA3LTAzVDIxOjM3WlxuICovXG4vKiFcbiAqIEdsb2JhbGl6ZSB2MS4zLjAgMjAxNy0wNy0wM1QyMTozN1ogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xuICovXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XG5cblx0Ly8gVU1EIHJldHVybkV4cG9ydHNcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXG5cdFx0XHRcImNsZHJcIixcblx0XHRcdFwiLi4vZ2xvYmFsaXplXCIsXG5cdFx0XHRcImNsZHIvZXZlbnRcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBOb2RlLCBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCJjbGRyanNcIiApLCByZXF1aXJlKCBcIi4uL2dsb2JhbGl6ZVwiICkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEV4dGVuZCBnbG9iYWxcblx0XHRmYWN0b3J5KCByb290LkNsZHIsIHJvb3QuR2xvYmFsaXplICk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24oIENsZHIsIEdsb2JhbGl6ZSApIHtcblxudmFyIGFsd2F5c0FycmF5ID0gR2xvYmFsaXplLl9hbHdheXNBcnJheSxcblx0Y3JlYXRlRXJyb3IgPSBHbG9iYWxpemUuX2NyZWF0ZUVycm9yLFxuXHRpc1BsYWluT2JqZWN0ID0gR2xvYmFsaXplLl9pc1BsYWluT2JqZWN0LFxuXHRydW50aW1lQmluZCA9IEdsb2JhbGl6ZS5fcnVudGltZUJpbmQsXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVEZWZhdWx0TG9jYWxlLFxuXHR2YWxpZGF0ZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3Q7XG52YXIgTWVzc2FnZUZvcm1hdDtcbi8qIGpzaGludCBpZ25vcmU6c3RhcnQgKi9cbk1lc3NhZ2VGb3JtYXQgPSAoZnVuY3Rpb24oKSB7XG5NZXNzYWdlRm9ybWF0Ll9wYXJzZSA9IChmdW5jdGlvbigpIHtcblxuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuOC4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gICAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gICAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIHRoaXMuZm91bmQgICAgPSBmb3VuZDtcbiAgICB0aGlzLm9mZnNldCAgID0gb2Zmc2V0O1xuICAgIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG5cbiAgICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xuICB9XG5cbiAgcGVnJHN1YmNsYXNzKFN5bnRheEVycm9yLCBFcnJvcik7XG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDoge30sXG5cbiAgICAgICAgcGVnJEZBSUxFRCA9IHt9LFxuXG4gICAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IHN0YXJ0OiBwZWckcGFyc2VzdGFydCB9LFxuICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gID0gcGVnJHBhcnNlc3RhcnQsXG5cbiAgICAgICAgcGVnJGMwID0gW10sXG4gICAgICAgIHBlZyRjMSA9IGZ1bmN0aW9uKHN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6ICdtZXNzYWdlRm9ybWF0UGF0dGVybicsIHN0YXRlbWVudHM6IHN0IH07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzIgPSBwZWckRkFJTEVELFxuICAgICAgICBwZWckYzMgPSBcIntcIixcbiAgICAgICAgcGVnJGM0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwie1wiLCBkZXNjcmlwdGlvbjogXCJcXFwie1xcXCJcIiB9LFxuICAgICAgICBwZWckYzUgPSBudWxsLFxuICAgICAgICBwZWckYzYgPSBcIixcIixcbiAgICAgICAgcGVnJGM3ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLFxcXCJcIiB9LFxuICAgICAgICBwZWckYzggPSBcIn1cIixcbiAgICAgICAgcGVnJGM5ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwifVwiLCBkZXNjcmlwdGlvbjogXCJcXFwifVxcXCJcIiB9LFxuICAgICAgICBwZWckYzEwID0gZnVuY3Rpb24oYXJnSWR4LCBlZm10KSB7XG4gICAgICAgICAgICAgIHZhciByZXMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJtZXNzYWdlRm9ybWF0RWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50SW5kZXg6IGFyZ0lkeFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoZWZtdCAmJiBlZm10Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlcy5lbGVtZW50Rm9ybWF0ID0gZWZtdFsxXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMub3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxMSA9IFwicGx1cmFsXCIsXG4gICAgICAgIHBlZyRjMTIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJwbHVyYWxcIiwgZGVzY3JpcHRpb246IFwiXFxcInBsdXJhbFxcXCJcIiB9LFxuICAgICAgICBwZWckYzEzID0gZnVuY3Rpb24odCwgcykge1xuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVsZW1lbnRGb3JtYXRcIiwga2V5OiB0LCB2YWw6IHMgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTQgPSBcInNlbGVjdG9yZGluYWxcIixcbiAgICAgICAgcGVnJGMxNSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInNlbGVjdG9yZGluYWxcIiwgZGVzY3JpcHRpb246IFwiXFxcInNlbGVjdG9yZGluYWxcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxNiA9IFwic2VsZWN0XCIsXG4gICAgICAgIHBlZyRjMTcgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJzZWxlY3RcIiwgZGVzY3JpcHRpb246IFwiXFxcInNlbGVjdFxcXCJcIiB9LFxuICAgICAgICBwZWckYzE4ID0gZnVuY3Rpb24odCwgcCkge1xuICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcImVsZW1lbnRGb3JtYXRcIiwga2V5OiB0LCB2YWw6IHAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTkgPSBmdW5jdGlvbihvcCwgcGYpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJwbHVyYWxGb3JtYXRQYXR0ZXJuXCIsIHBsdXJhbEZvcm1zOiBwZiwgb2Zmc2V0OiBvcCB8fCAwIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzIwID0gXCJvZmZzZXRcIixcbiAgICAgICAgcGVnJGMyMSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIm9mZnNldFwiLCBkZXNjcmlwdGlvbjogXCJcXFwib2Zmc2V0XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMjIgPSBcIjpcIixcbiAgICAgICAgcGVnJGMyMyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjpcIiwgZGVzY3JpcHRpb246IFwiXFxcIjpcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMyNCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7IH0sXG4gICAgICAgIHBlZyRjMjUgPSBmdW5jdGlvbihrLCBtZnApIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHsga2V5OiBrLCB2YWw6IG1mcCB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMyNiA9IGZ1bmN0aW9uKGkpIHsgcmV0dXJuIGk7IH0sXG4gICAgICAgIHBlZyRjMjcgPSBcIj1cIixcbiAgICAgICAgcGVnJGMyOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj1cIiwgZGVzY3JpcHRpb246IFwiXFxcIj1cXFwiXCIgfSxcbiAgICAgICAgcGVnJGMyOSA9IGZ1bmN0aW9uKHBmKSB7IHJldHVybiB7IHR5cGU6IFwic2VsZWN0Rm9ybWF0UGF0dGVyblwiLCBwbHVyYWxGb3JtczogcGYgfTsgfSxcbiAgICAgICAgcGVnJGMzMCA9IGZ1bmN0aW9uKHApIHsgcmV0dXJuIHA7IH0sXG4gICAgICAgIHBlZyRjMzEgPSBcIiNcIixcbiAgICAgICAgcGVnJGMzMiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiNcIiwgZGVzY3JpcHRpb246IFwiXFxcIiNcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzMyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4ge3R5cGU6ICdvY3RvdGhvcnBlJ307IH0sXG4gICAgICAgIHBlZyRjMzQgPSBmdW5jdGlvbihzKSB7IHJldHVybiB7IHR5cGU6IFwic3RyaW5nXCIsIHZhbDogcy5qb2luKCcnKSB9OyB9LFxuICAgICAgICBwZWckYzM1ID0geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBcImlkZW50aWZpZXJcIiB9LFxuICAgICAgICBwZWckYzM2ID0gL15bMC05YS16QS1aJF9dLyxcbiAgICAgICAgcGVnJGMzNyA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC05YS16QS1aJF9dXCIsIGRlc2NyaXB0aW9uOiBcIlswLTlhLXpBLVokX11cIiB9LFxuICAgICAgICBwZWckYzM4ID0gL15bXiBcXHRcXG5cXHIsLis9e31dLyxcbiAgICAgICAgcGVnJGMzOSA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXiBcXFxcdFxcXFxuXFxcXHIsLis9e31dXCIsIGRlc2NyaXB0aW9uOiBcIlteIFxcXFx0XFxcXG5cXFxcciwuKz17fV1cIiB9LFxuICAgICAgICBwZWckYzQwID0gZnVuY3Rpb24ocykgeyByZXR1cm4gczsgfSxcbiAgICAgICAgcGVnJGM0MSA9IGZ1bmN0aW9uKGNoYXJzKSB7IHJldHVybiBjaGFycy5qb2luKCcnKTsgfSxcbiAgICAgICAgcGVnJGM0MiA9IC9eW157fSNcXFxcXFwwLVxceDFGfyBcXHRcXG5cXHJdLyxcbiAgICAgICAgcGVnJGM0MyA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXnt9I1xcXFxcXFxcXFxcXDAtXFxcXHgxRn8gXFxcXHRcXFxcblxcXFxyXVwiLCBkZXNjcmlwdGlvbjogXCJbXnt9I1xcXFxcXFxcXFxcXDAtXFxcXHgxRn8gXFxcXHRcXFxcblxcXFxyXVwiIH0sXG4gICAgICAgIHBlZyRjNDQgPSBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9LFxuICAgICAgICBwZWckYzQ1ID0gXCJcXFxcXFxcXFwiLFxuICAgICAgICBwZWckYzQ2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcXFxcXFxcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFxcXFxcXFxcXFxcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0NyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJcXFxcXCI7IH0sXG4gICAgICAgIHBlZyRjNDggPSBcIlxcXFwjXCIsXG4gICAgICAgIHBlZyRjNDkgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcI1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFwjXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNTAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwiI1wiOyB9LFxuICAgICAgICBwZWckYzUxID0gXCJcXFxce1wiLFxuICAgICAgICBwZWckYzUyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcXHtcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFxce1xcXCJcIiB9LFxuICAgICAgICBwZWckYzUzID0gZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcdTAwN0JcIjsgfSxcbiAgICAgICAgcGVnJGM1NCA9IFwiXFxcXH1cIixcbiAgICAgICAgcGVnJGM1NSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFx9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXH1cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJcXHUwMDdEXCI7IH0sXG4gICAgICAgIHBlZyRjNTcgPSBcIlxcXFx1XCIsXG4gICAgICAgIHBlZyRjNTggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcdVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFx1XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNTkgPSBmdW5jdGlvbihoMSwgaDIsIGgzLCBoNCkge1xuICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChcIjB4XCIgKyBoMSArIGgyICsgaDMgKyBoNCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGM2MCA9IC9eWzAtOV0vLFxuICAgICAgICBwZWckYzYxID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTldXCIsIGRlc2NyaXB0aW9uOiBcIlswLTldXCIgfSxcbiAgICAgICAgcGVnJGM2MiA9IGZ1bmN0aW9uKGRzKSB7XG4gICAgICAgICAgICAvL3RoZSBudW1iZXIgbWlnaHQgc3RhcnQgd2l0aCAwIGJ1dCBtdXN0IG5vdCBiZSBpbnRlcnByZXRlZCBhcyBhbiBvY3RhbCBudW1iZXJcbiAgICAgICAgICAgIC8vSGVuY2UsIHRoZSBiYXNlIGlzIHBhc3NlZCB0byBwYXJzZUludCBleHBsaWNpdGVseVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KChkcy5qb2luKCcnKSksIDEwKTtcbiAgICAgICAgICB9LFxuICAgICAgICBwZWckYzYzID0gL15bMC05YS1mQS1GXS8sXG4gICAgICAgIHBlZyRjNjQgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWzAtOWEtZkEtRl1cIiwgZGVzY3JpcHRpb246IFwiWzAtOWEtZkEtRl1cIiB9LFxuICAgICAgICBwZWckYzY1ID0geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBcIndoaXRlc3BhY2VcIiB9LFxuICAgICAgICBwZWckYzY2ID0gZnVuY3Rpb24odykgeyByZXR1cm4gdy5qb2luKCcnKTsgfSxcbiAgICAgICAgcGVnJGM2NyA9IC9eWyBcXHRcXG5cXHJdLyxcbiAgICAgICAgcGVnJGM2OCA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIFxcXFx0XFxcXG5cXFxccl1cIiwgZGVzY3JpcHRpb246IFwiWyBcXFxcdFxcXFxuXFxcXHJdXCIgfSxcblxuICAgICAgICBwZWckY3VyclBvcyAgICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyAgICAgID0gMCxcbiAgICAgICAgcGVnJGNhY2hlZFBvcyAgICAgICAgPSAwLFxuICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH0sXG4gICAgICAgIHBlZyRtYXhGYWlsUG9zICAgICAgID0gMCxcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSxcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICAgIHBlZyRyZXN1bHQ7XG5cbiAgICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgICB9XG5cbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5saW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbigpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgW3sgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfV0sXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgbnVsbCwgcGVnJHJlcG9ydGVkUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHAsIGNoO1xuXG4gICAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHtcbiAgICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmICghZGV0YWlscy5zZWVuQ1IpIHsgZGV0YWlscy5saW5lKys7IH1cbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwZWckY2FjaGVkUG9zICE9PSBwb3MpIHtcbiAgICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgPiBwb3MpIHtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcbiAgICAgICAgcGVnJGNhY2hlZFBvcyA9IHBvcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlZyRjYWNoZWRQb3NEZXRhaWxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICAgIGV4cGVjdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIGlmIChhLmRlc2NyaXB0aW9uIDwgYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYS5kZXNjcmlwdGlvbiA+IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgIGV4cGVjdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICAgICAgZXhwZWN0ZWREZXNjLCBmb3VuZERlc2MsIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXhwZWN0ZWREZXNjc1tpXSA9IGV4cGVjdGVkW2ldLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0ZWREZXNjID0gZXhwZWN0ZWQubGVuZ3RoID4gMVxuICAgICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICAgKyBleHBlY3RlZERlc2NzW2V4cGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgOiBleHBlY3RlZERlc2NzWzBdO1xuXG4gICAgICAgIGZvdW5kRGVzYyA9IGZvdW5kID8gXCJcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuXG4gICAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWREZXNjICsgXCIgYnV0IFwiICsgZm91bmREZXNjICsgXCIgZm91bmQuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcyksXG4gICAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcblxuICAgICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgcG9zLFxuICAgICAgICBwb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIHBvc0RldGFpbHMuY29sdW1uXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXN0YXJ0KCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBzMCA9IHBlZyRwYXJzZW1lc3NhZ2VGb3JtYXRQYXR0ZXJuKCk7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtZXNzYWdlRm9ybWF0UGF0dGVybigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIHMyID0gcGVnJHBhcnNlbWVzc2FnZUZvcm1hdEVsZW1lbnQoKTtcbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZXN0cmluZygpO1xuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZW9jdG90aG9ycGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZW1lc3NhZ2VGb3JtYXRFbGVtZW50KCk7XG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlc3RyaW5nKCk7XG4gICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRwYXJzZW9jdG90aG9ycGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzEoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW1lc3NhZ2VGb3JtYXRFbGVtZW50KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjMpIHtcbiAgICAgICAgczEgPSBwZWckYzM7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZWlkKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRjNjtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VlbGVtZW50Rm9ybWF0KCk7XG4gICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM1ID0gW3M1LCBzNl07XG4gICAgICAgICAgICAgICAgczQgPSBzNTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM0O1xuICAgICAgICAgICAgICAgIHM0ID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHM0O1xuICAgICAgICAgICAgICBzNCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRjNTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjUpIHtcbiAgICAgICAgICAgICAgICAgIHM2ID0gcGVnJGM4O1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzkpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTAoczMsIHM0KTtcbiAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VlbGVtZW50Rm9ybWF0KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDYpID09PSBwZWckYzExKSB7XG4gICAgICAgICAgczIgPSBwZWckYzExO1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckYzY7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzNiA9IHBlZyRwYXJzZXBsdXJhbEZvcm1hdFBhdHRlcm4oKTtcbiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTMoczIsIHM2KTtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxMykgPT09IHBlZyRjMTQpIHtcbiAgICAgICAgICAgIHMyID0gcGVnJGMxNDtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTUpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgICAgICAgIHM0ID0gcGVnJGM2O1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VwbHVyYWxGb3JtYXRQYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMxMyhzMiwgczYpO1xuICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNikgPT09IHBlZyRjMTYpIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckYzE2O1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSA2O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTcpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDQpIHtcbiAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJGM2O1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VzZWxlY3RGb3JtYXRQYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChzNyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTMoczIsIHM2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VpZCgpO1xuICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMyA9IFtdO1xuICAgICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlYXJnU3R5bGVQYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlYXJnU3R5bGVQYXR0ZXJuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTgoczIsIHMzKTtcbiAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VwbHVyYWxGb3JtYXRQYXR0ZXJuKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VvZmZzZXRQYXR0ZXJuKCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckYzU7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBbXTtcbiAgICAgICAgczMgPSBwZWckcGFyc2VwbHVyYWxGb3JtKCk7XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgICBzMyA9IHBlZyRwYXJzZXBsdXJhbEZvcm0oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzE5KHMxLCBzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW9mZnNldFBhdHRlcm4oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3O1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNikgPT09IHBlZyRjMjApIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMjA7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIxKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OCkge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRjMjI7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyMyk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VkaWdpdHMoKTtcbiAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlXygpO1xuICAgICAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjQoczYpO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VwbHVyYWxGb3JtKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNywgczg7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZXBsdXJhbEtleSgpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTIzKSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJGMzO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VtZXNzYWdlRm9ybWF0UGF0dGVybigpO1xuICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRjODtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOSk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjUoczIsIHM2KTtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlcGx1cmFsS2V5KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZWlkKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMyNihzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjEpIHtcbiAgICAgICAgICBzMSA9IHBlZyRjMjc7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI4KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlZGlnaXRzKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMyNChzMik7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXNlbGVjdEZvcm1hdFBhdHRlcm4oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gW107XG4gICAgICBzMiA9IHBlZyRwYXJzZXNlbGVjdEZvcm0oKTtcbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMS5wdXNoKHMyKTtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZXNlbGVjdEZvcm0oKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckYzI7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMyOShzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc2VsZWN0Rm9ybSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1LCBzNiwgczcsIHM4O1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VfKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VpZCgpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTIzKSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJGMzO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VtZXNzYWdlRm9ybWF0UGF0dGVybigpO1xuICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgczcgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzOCA9IHBlZyRjODtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHM4ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOSk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoczggIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMjUoczIsIHM2KTtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlYXJnU3R5bGVQYXR0ZXJuKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZV8oKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ0KSB7XG4gICAgICAgICAgczIgPSBwZWckYzY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWlkKCk7XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczUgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGMzMChzNCk7XG4gICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW9jdG90aG9ycGUoKSB7XG4gICAgICB2YXIgczAsIHMxO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNSkge1xuICAgICAgICBzMSA9IHBlZyRjMzE7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzMik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzMzKCk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc3RyaW5nKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2VjaGFycygpO1xuICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNld2hpdGVzcGFjZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlY2hhcnMoKTtcbiAgICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyID0gcGVnJHBhcnNld2hpdGVzcGFjZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckYzI7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMzNChzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlaWQoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczY7XG5cbiAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlXygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIGlmIChwZWckYzM2LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM3KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM1ID0gW107XG4gICAgICAgICAgaWYgKHBlZyRjMzgudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgczYgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczYgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM5KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM1LnB1c2goczYpO1xuICAgICAgICAgICAgaWYgKHBlZyRjMzgudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICBzNiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzOSk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IFtzNCwgczVdO1xuICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gaW5wdXQuc3Vic3RyaW5nKHMyLCBwZWckY3VyclBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgczIgPSBzMztcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VfKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGM0MChzMik7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzUpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VjaGFycygpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIHMyID0gcGVnJHBhcnNlY2hhcigpO1xuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlY2hhcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRjMjtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzQxKHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VjaGFyKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAocGVnJGM0Mi50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQzKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjNDQoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM0NSkge1xuICAgICAgICAgIHMxID0gcGVnJGM0NTtcbiAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDYpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzQ3KCk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM0OCkge1xuICAgICAgICAgICAgczEgPSBwZWckYzQ4O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ5KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzUwKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjNTEpIHtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzUxO1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTIpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGM1MygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM1NCkge1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM1NDtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTUpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczEgPSBwZWckYzU2KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGM1Nykge1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzU3O1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU4KTsgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHMyID0gcGVnJHBhcnNlaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRwYXJzZWhleERpZ2l0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczEgPSBwZWckYzU5KHMyLCBzMywgczQsIHM1KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VkaWdpdHMoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gW107XG4gICAgICBpZiAocGVnJGM2MC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYxKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHdoaWxlIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICAgIGlmIChwZWckYzYwLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2MSk7IH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJGMyO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjNjIoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWhleERpZ2l0KCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGM2My50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY0KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlXygpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2V3aGl0ZXNwYWNlKCk7XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIHMyID0gcGVnJHBhcnNld2hpdGVzcGFjZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjNjYoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcbiAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY1KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNld2hpdGVzcGFjZSgpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKHBlZyRjNjcudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2OCk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwZWckcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBwZWckZmFpbCh7IHR5cGU6IFwiZW5kXCIsIGRlc2NyaXB0aW9uOiBcImVuZCBvZiBpbnB1dFwiIH0pO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obnVsbCwgcGVnJG1heEZhaWxFeHBlY3RlZCwgcGVnJG1heEZhaWxQb3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgU3ludGF4RXJyb3I6IFN5bnRheEVycm9yLFxuICAgIHBhcnNlOiAgICAgICBwYXJzZVxuICB9O1xufSgpKS5wYXJzZTtcblxuXG4vKiogQGZpbGUgbWVzc2FnZWZvcm1hdC5qcyAtIElDVSBQbHVyYWxGb3JtYXQgKyBTZWxlY3RGb3JtYXQgZm9yIEphdmFTY3JpcHRcbiAqICBAYXV0aG9yIEFsZXggU2V4dG9uIC0gQFNsZXhBeHRvblxuICogIEB2ZXJzaW9uIDAuMy4wLTFcbiAqICBAY29weXJpZ2h0IDIwMTItMjAxNSBBbGV4IFNleHRvbiwgRWVtZWxpIEFybywgYW5kIENvbnRyaWJ1dG9yc1xuICogIEBsaWNlbnNlIFRvIHVzZSBvciBmb3JrLCBNSVQuIFRvIGNvbnRyaWJ1dGUgYmFjaywgRG9qbyBDTEEgICovXG5cblxuLyoqIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHF1b3RpbmcgYW4gT2JqZWN0J3Mga2V5IHZhbHVlIGlmZiByZXF1aXJlZFxuICogIEBwcml2YXRlICAqL1xuZnVuY3Rpb24gcHJvcG5hbWUoa2V5LCBvYmopIHtcbiAgaWYgKC9eW0EtWl8kXVswLTlBLVpfJF0qJC9pLnRlc3Qoa2V5KSkge1xuICAgIHJldHVybiBvYmogPyBvYmogKyAnLicgKyBrZXkgOiBrZXk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGprZXkgPSBKU09OLnN0cmluZ2lmeShrZXkpO1xuICAgIHJldHVybiBvYmogPyBvYmogKyAnWycgKyBqa2V5ICsgJ10nIDogamtleTtcbiAgfVxufTtcblxuXG4vKiogQ3JlYXRlIGEgbmV3IG1lc3NhZ2UgZm9ybWF0dGVyXG4gKlxuICogIEBjbGFzc1xuICogIEBnbG9iYWxcbiAqICBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gW2xvY2FsZT1cImVuXCJdIC0gVGhlIGxvY2FsZSB0byB1c2UsIHdpdGggZmFsbGJhY2tzXG4gKiAgQHBhcmFtIHtmdW5jdGlvbn0gW3BsdXJhbEZ1bmNdIC0gT3B0aW9uYWwgY3VzdG9tIHBsdXJhbGl6YXRpb24gZnVuY3Rpb25cbiAqICBAcGFyYW0ge2Z1bmN0aW9uW119IFtmb3JtYXR0ZXJzXSAtIE9wdGlvbmFsIGN1c3RvbSBmb3JtYXR0aW5nIGZ1bmN0aW9ucyAgKi9cbmZ1bmN0aW9uIE1lc3NhZ2VGb3JtYXQobG9jYWxlLCBwbHVyYWxGdW5jLCBmb3JtYXR0ZXJzKSB7XG4gIHRoaXMubGMgPSBbbG9jYWxlXTsgIFxuICB0aGlzLnJ1bnRpbWUucGx1cmFsRnVuY3MgPSB7fTtcbiAgdGhpcy5ydW50aW1lLnBsdXJhbEZ1bmNzW3RoaXMubGNbMF1dID0gcGx1cmFsRnVuYztcbiAgdGhpcy5ydW50aW1lLmZtdCA9IHt9O1xuICBpZiAoZm9ybWF0dGVycykgZm9yICh2YXIgZiBpbiBmb3JtYXR0ZXJzKSB7XG4gICAgdGhpcy5ydW50aW1lLmZtdFtmXSA9IGZvcm1hdHRlcnNbZl07XG4gIH1cbn1cblxuXG5cblxuLyoqIFBhcnNlIGFuIGlucHV0IHN0cmluZyB0byBpdHMgQVNUXG4gKlxuICogIFByZWNvbXBpbGVkIGZyb20gYGxpYi9tZXNzYWdlZm9ybWF0LXBhcnNlci5wZWdqc2AgYnlcbiAqICB7QGxpbmsgaHR0cDovL3BlZ2pzLm9yZy8gUEVHLmpzfS4gSW5jbHVkZWQgaW4gTWVzc2FnZUZvcm1hdCBvYmplY3RcbiAqICB0byBlbmFibGUgdGVzdGluZy5cbiAqXG4gKiAgQHByaXZhdGUgICovXG5cblxuXG4vKiogUGx1cmFsaXphdGlvbiBmdW5jdGlvbnMgZnJvbVxuICogIHtAbGluayBodHRwOi8vZ2l0aHViLmNvbS9lZW1lbGkvbWFrZS1wbHVyYWwuanMgbWFrZS1wbHVyYWx9XG4gKlxuICogIEBtZW1iZXJvZiBNZXNzYWdlRm9ybWF0XG4gKiAgQHR5cGUgT2JqZWN0LjxzdHJpbmcsZnVuY3Rpb24+ICAqL1xuTWVzc2FnZUZvcm1hdC5wbHVyYWxzID0ge307XG5cblxuLyoqIERlZmF1bHQgbnVtYmVyIGZvcm1hdHRpbmcgZnVuY3Rpb25zIGluIHRoZSBzdHlsZSBvZiBJQ1Unc1xuICogIHtAbGluayBodHRwOi8vaWN1LXByb2plY3Qub3JnL2FwaXJlZi9pY3U0ai9jb20vaWJtL2ljdS90ZXh0L01lc3NhZ2VGb3JtYXQuaHRtbCBzaW1wbGVBcmcgc3ludGF4fVxuICogIGltcGxlbWVudGVkIHVzaW5nIHRoZVxuICogIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9JbnRsIEludGx9XG4gKiAgb2JqZWN0IGRlZmluZWQgYnkgRUNNQS00MDIuXG4gKlxuICogICoqTm90ZSoqOiBJbnRsIGlzIG5vdCBkZWZpbmVkIGluIGRlZmF1bHQgTm9kZSB1bnRpbCAwLjExLjE1IC8gMC4xMi4wLCBzb1xuICogIGVhcmxpZXIgdmVyc2lvbnMgcmVxdWlyZSBhIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9pbnRsIHBvbHlmaWxsfS5cbiAqICBUaGVyZWZvcmUge0BsaW5rIE1lc3NhZ2VGb3JtYXQud2l0aEludGxTdXBwb3J0fSBuZWVkcyB0byBiZSB0cnVlIGZvciB0aGVzZVxuICogIGZ1bmN0aW9ucyB0byBiZSBhdmFpbGFibGUgZm9yIGluY2x1c2lvbiBpbiB0aGUgb3V0cHV0LlxuICpcbiAqICBAc2VlIE1lc3NhZ2VGb3JtYXQjc2V0SW50bFN1cHBvcnRcbiAqXG4gKiAgQG5hbWVzcGFjZVxuICogIEBtZW1iZXJvZiBNZXNzYWdlRm9ybWF0XG4gKiAgQHByb3BlcnR5IHtmdW5jdGlvbn0gbnVtYmVyIC0gUmVwcmVzZW50IGEgbnVtYmVyIGFzIGFuIGludGVnZXIsIHBlcmNlbnQgb3IgY3VycmVuY3kgdmFsdWVcbiAqICBAcHJvcGVydHkge2Z1bmN0aW9ufSBkYXRlIC0gUmVwcmVzZW50IGEgZGF0ZSBhcyBhIGZ1bGwvbG9uZy9kZWZhdWx0L3Nob3J0IHN0cmluZ1xuICogIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IHRpbWUgLSBSZXByZXNlbnQgYSB0aW1lIGFzIGEgZnVsbC9sb25nL2RlZmF1bHQvc2hvcnQgc3RyaW5nXG4gKlxuICogIEBleGFtcGxlXG4gKiAgPiB2YXIgTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ21lc3NhZ2Vmb3JtYXQnKTtcbiAqICA+IHZhciBtZiA9IChuZXcgTWVzc2FnZUZvcm1hdCgnZW4nKSkuc2V0SW50bFN1cHBvcnQodHJ1ZSk7XG4gKiAgPiBtZi5jdXJyZW5jeSA9ICdFVVInO1xuICogID4gdmFyIG1mdW5jID0gbWYuY29tcGlsZShcIlRoZSB0b3RhbCBpcyB7VixudW1iZXIsY3VycmVuY3l9LlwiKTtcbiAqICA+IG1mdW5jKHtWOjUuNX0pXG4gKiAgXCJUaGUgdG90YWwgaXMg4oKsNS41MC5cIlxuICpcbiAqICBAZXhhbXBsZVxuICogID4gdmFyIE1lc3NhZ2VGb3JtYXQgPSByZXF1aXJlKCdtZXNzYWdlZm9ybWF0Jyk7XG4gKiAgPiB2YXIgbWYgPSBuZXcgTWVzc2FnZUZvcm1hdCgnZW4nLCBudWxsLCB7bnVtYmVyOiBNZXNzYWdlRm9ybWF0Lm51bWJlcn0pO1xuICogID4gbWYuY3VycmVuY3kgPSAnRVVSJztcbiAqICA+IHZhciBtZnVuYyA9IG1mLmNvbXBpbGUoXCJUaGUgdG90YWwgaXMge1YsbnVtYmVyLGN1cnJlbmN5fS5cIik7XG4gKiAgPiBtZnVuYyh7Vjo1LjV9KVxuICogIFwiVGhlIHRvdGFsIGlzIOKCrDUuNTAuXCIgICovXG5NZXNzYWdlRm9ybWF0LmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqIEVuYWJsZSBvciBkaXNhYmxlIHN1cHBvcnQgZm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlcnMsIHdoaWNoIHJlcXVpcmUgdGhlXG4gKiAgYEludGxgIG9iamVjdC4gTm90ZSB0aGF0IHRoaXMgY2FuJ3QgYmUgYXV0b2RldGVjdGVkLCBhcyB0aGUgZW52aXJvbm1lbnRcbiAqICBpbiB3aGljaCB0aGUgZm9ybWF0dGVkIHRleHQgaXMgY29tcGlsZWQgaW50byBKYXZhc2NyaXB0IGZ1bmN0aW9ucyBpcyBub3RcbiAqICBuZWNlc3NhcmlseSB0aGUgc2FtZSBlbnZpcm9ubWVudCBpbiB3aGljaCB0aGV5IHdpbGwgZ2V0IGV4ZWN1dGVkLlxuICpcbiAqICBAc2VlIE1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVyc1xuICpcbiAqICBAbWVtYmVyb2YgTWVzc2FnZUZvcm1hdFxuICogIEBwYXJhbSB7Ym9vbGVhbn0gW2VuYWJsZT10cnVlXVxuICogIEByZXR1cm5zIHtPYmplY3R9IFRoZSBNZXNzYWdlRm9ybWF0IGluc3RhbmNlLCB0byBhbGxvdyBmb3IgY2hhaW5pbmdcbiAqICBAZXhhbXBsZVxuICogID4gdmFyIEludGwgPSByZXF1aXJlKCdpbnRsJyk7XG4gKiAgPiB2YXIgTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ21lc3NhZ2Vmb3JtYXQnKTtcbiAqICA+IHZhciBtZiA9IChuZXcgTWVzc2FnZUZvcm1hdCgnZW4nKSkuc2V0SW50bFN1cHBvcnQodHJ1ZSk7XG4gKiAgPiBtZi5jdXJyZW5jeSA9ICdFVVInO1xuICogID4gbWYuY29tcGlsZShcIlRoZSB0b3RhbCBpcyB7VixudW1iZXIsY3VycmVuY3l9LlwiKSh7Vjo1LjV9KTtcbiAqICBcIlRoZSB0b3RhbCBpcyDigqw1LjUwLlwiICAqL1xuXG5cblxuLyoqIEEgc2V0IG9mIHV0aWxpdHkgZnVuY3Rpb25zIHRoYXQgYXJlIGNhbGxlZCBieSB0aGUgY29tcGlsZWQgSmF2YXNjcmlwdFxuICogIGZ1bmN0aW9ucywgdGhlc2UgYXJlIGluY2x1ZGVkIGxvY2FsbHkgaW4gdGhlIG91dHB1dCBvZiB7QGxpbmtcbiAqICBNZXNzYWdlRm9ybWF0I2NvbXBpbGUgY29tcGlsZSgpfS5cbiAqXG4gKiAgQG5hbWVzcGFjZVxuICogIEBtZW1iZXJvZiBNZXNzYWdlRm9ybWF0ICAqL1xuTWVzc2FnZUZvcm1hdC5wcm90b3R5cGUucnVudGltZSA9IHtcblxuICAvKiogVXRpbGl0eSBmdW5jdGlvbiBmb3IgYCNgIGluIHBsdXJhbCBydWxlc1xuICAgKlxuICAgKiAgQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIG9wZXJhdGUgb25cbiAgICogIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0PTBdIC0gQW4gb3B0aW9uYWwgb2Zmc2V0LCBzZXQgYnkgdGhlIHN1cnJvdW5kaW5nIGNvbnRleHQgICovXG4gIG51bWJlcjogZnVuY3Rpb24odmFsdWUsIG9mZnNldCkge1xuICAgIGlmIChpc05hTih2YWx1ZSkpIHRocm93IG5ldyBFcnJvcihcIidcIiArIHZhbHVlICsgXCInIGlzbid0IGEgbnVtYmVyLlwiKTtcbiAgICByZXR1cm4gdmFsdWUgLSAob2Zmc2V0IHx8IDApO1xuICB9LFxuXG4gIC8qKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBge04sIHBsdXJhbHxzZWxlY3RvcmRpbmFsLCAuLi59YFxuICAgKlxuICAgKiAgQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIGtleSB0byB1c2UgdG8gZmluZCBhIHBsdXJhbGl6YXRpb24gcnVsZVxuICAgKiAgQHBhcmFtIHtudW1iZXJ9IG9mZnNldCAtIEFuIG9mZnNldCB0byBhcHBseSB0byBgdmFsdWVgXG4gICAqICBAcGFyYW0ge2Z1bmN0aW9ufSBsY2Z1bmMgLSBBIGxvY2FsZSBmdW5jdGlvbiBmcm9tIGBwbHVyYWxGdW5jc2BcbiAgICogIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gZGF0YSAtIFRoZSBvYmplY3QgZnJvbSB3aGljaCByZXN1bHRzIGFyZSBsb29rZWQgdXBcbiAgICogIEBwYXJhbSB7P2Jvb2xlYW59IGlzT3JkaW5hbCAtIElmIHRydWUsIHVzZSBvcmRpbmFsIHJhdGhlciB0aGFuIGNhcmRpbmFsIHJ1bGVzXG4gICAqICBAcmV0dXJucyB7c3RyaW5nfSBUaGUgcmVzdWx0IG9mIHRoZSBwbHVyYWxpemF0aW9uICAqL1xuICBwbHVyYWw6IGZ1bmN0aW9uKHZhbHVlLCBvZmZzZXQsIGxjZnVuYywgZGF0YSwgaXNPcmRpbmFsKSB7XG4gICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgdmFsdWUpKSByZXR1cm4gZGF0YVt2YWx1ZV0oKTtcbiAgICBpZiAob2Zmc2V0KSB2YWx1ZSAtPSBvZmZzZXQ7XG4gICAgdmFyIGtleSA9IGxjZnVuYyh2YWx1ZSwgaXNPcmRpbmFsKTtcbiAgICBpZiAoa2V5IGluIGRhdGEpIHJldHVybiBkYXRhW2tleV0oKTtcbiAgICByZXR1cm4gZGF0YS5vdGhlcigpO1xuICB9LFxuXG4gIC8qKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciBge04sIHNlbGVjdCwgLi4ufWBcbiAgICpcbiAgICogIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBrZXkgdG8gdXNlIHRvIGZpbmQgYSBzZWxlY3Rpb25cbiAgICogIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsc3RyaW5nPn0gZGF0YSAtIFRoZSBvYmplY3QgZnJvbSB3aGljaCByZXN1bHRzIGFyZSBsb29rZWQgdXBcbiAgICogIEByZXR1cm5zIHtzdHJpbmd9IFRoZSByZXN1bHQgb2YgdGhlIHNlbGVjdCBzdGF0ZW1lbnQgICovXG4gIHNlbGVjdDogZnVuY3Rpb24odmFsdWUsIGRhdGEpIHtcbiAgICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCB2YWx1ZSkpIHJldHVybiBkYXRhW3ZhbHVlXSgpO1xuICAgIHJldHVybiBkYXRhLm90aGVyKClcbiAgfSxcblxuICAvKiogUGx1cmFsaXphdGlvbiBmdW5jdGlvbnMgaW5jbHVkZWQgaW4gY29tcGlsZWQgb3V0cHV0XG4gICAqICBAaW5zdGFuY2VcbiAgICogIEB0eXBlIE9iamVjdC48c3RyaW5nLGZ1bmN0aW9uPiAgKi9cbiAgcGx1cmFsRnVuY3M6IHt9LFxuXG4gIC8qKiBDdXN0b20gZm9ybWF0dGluZyBmdW5jdGlvbnMgY2FsbGVkIGJ5IGB7dmFyLCBmblssIGFyZ3NdKn1gIHN5bnRheFxuICAgKlxuICAgKiAgRm9yIGV4YW1wbGVzLCBzZWUge0BsaW5rIE1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVyc31cbiAgICpcbiAgICogIEBpbnN0YW5jZVxuICAgKiAgQHNlZSBNZXNzYWdlRm9ybWF0LmZvcm1hdHRlcnNcbiAgICogIEB0eXBlIE9iamVjdC48c3RyaW5nLGZ1bmN0aW9uPiAgKi9cbiAgZm10OiB7fSxcblxuICAvKiogQ3VzdG9tIHN0cmluZ2lmaWVyIHRvIGNsZWFuIHVwIGJyb3dzZXIgaW5jb25zaXN0ZW5jaWVzXG4gICAqICBAaW5zdGFuY2UgICovXG4gIHRvU3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9zdHJpbmdpZnkgPSBmdW5jdGlvbihvLCBsZXZlbCkge1xuICAgICAgaWYgKHR5cGVvZiBvICE9ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBmdW5jU3RyID0gby50b1N0cmluZygpLnJlcGxhY2UoL14oZnVuY3Rpb24gKVxcdyovLCAnJDEnKTtcbiAgICAgICAgdmFyIGluZGVudCA9IC8oWyBcXHRdKilcXFMuKiQvLmV4ZWMoZnVuY1N0cik7XG4gICAgICAgIHJldHVybiBpbmRlbnQgPyBmdW5jU3RyLnJlcGxhY2UobmV3IFJlZ0V4cCgnXicgKyBpbmRlbnRbMV0sICdtZycpLCAnJykgOiBmdW5jU3RyO1xuICAgICAgfVxuICAgICAgdmFyIHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgaW4gbykgaWYgKGkgIT0gJ3RvU3RyaW5nJykge1xuICAgICAgICBpZiAobGV2ZWwgPT0gMCkgcy5wdXNoKCd2YXIgJyArIGkgKyAnID0gJyArIF9zdHJpbmdpZnkob1tpXSwgbGV2ZWwgKyAxKSArICc7XFxuJyk7XG4gICAgICAgIGVsc2Ugcy5wdXNoKHByb3BuYW1lKGkpICsgJzogJyArIF9zdHJpbmdpZnkob1tpXSwgbGV2ZWwgKyAxKSk7XG4gICAgICB9XG4gICAgICBpZiAobGV2ZWwgPT0gMCkgcmV0dXJuIHMuam9pbignJyk7XG4gICAgICBpZiAocy5sZW5ndGggPT0gMCkgcmV0dXJuICd7fSc7XG4gICAgICB2YXIgaW5kZW50ID0gJyAgJzsgd2hpbGUgKC0tbGV2ZWwpIGluZGVudCArPSAnICAnO1xuICAgICAgcmV0dXJuICd7XFxuJyArIHMuam9pbignLFxcbicpLnJlcGxhY2UoL14vZ20sIGluZGVudCkgKyAnXFxufSc7XG4gICAgfTtcbiAgICByZXR1cm4gX3N0cmluZ2lmeSh0aGlzLCAwKTtcbiAgfVxufTtcblxuXG4vKiogUmVjdXJzaXZlbHkgbWFwIGFuIEFTVCB0byBpdHMgcmVzdWx0aW5nIHN0cmluZ1xuICpcbiAqICBAbWVtYmVyb2YgTWVzc2FnZUZvcm1hdFxuICpcbiAqICBAcGFyYW0gYXN0IC0gdGhlIEFzdCBub2RlIGZvciB3aGljaCB0aGUgSlMgY29kZSBzaG91bGQgYmUgZ2VuZXJhdGVkXG4gKlxuICogIEBwcml2YXRlICAqL1xuTWVzc2FnZUZvcm1hdC5wcm90b3R5cGUuX3ByZWNvbXBpbGUgPSBmdW5jdGlvbihhc3QsIGRhdGEpIHtcbiAgZGF0YSA9IGRhdGEgfHwgeyBrZXlzOiB7fSwgb2Zmc2V0OiB7fSB9O1xuICB2YXIgciA9IFtdLCBpLCB0bXAsIGFyZ3MgPSBbXTtcblxuICBzd2l0Y2ggKCBhc3QudHlwZSApIHtcbiAgICBjYXNlICdtZXNzYWdlRm9ybWF0UGF0dGVybic6XG4gICAgICBmb3IgKCBpID0gMDsgaSA8IGFzdC5zdGF0ZW1lbnRzLmxlbmd0aDsgKytpICkge1xuICAgICAgICByLnB1c2godGhpcy5fcHJlY29tcGlsZSggYXN0LnN0YXRlbWVudHNbaV0sIGRhdGEgKSk7XG4gICAgICB9XG4gICAgICB0bXAgPSByLmpvaW4oJyArICcpIHx8ICdcIlwiJztcbiAgICAgIHJldHVybiBkYXRhLnBmX2NvdW50ID8gdG1wIDogJ2Z1bmN0aW9uKGQpIHsgcmV0dXJuICcgKyB0bXAgKyAnOyB9JztcblxuICAgIGNhc2UgJ21lc3NhZ2VGb3JtYXRFbGVtZW50JzpcbiAgICAgIGRhdGEucGZfY291bnQgPSBkYXRhLnBmX2NvdW50IHx8IDA7XG4gICAgICBpZiAoIGFzdC5vdXRwdXQgKSB7XG4gICAgICAgIHJldHVybiBwcm9wbmFtZShhc3QuYXJndW1lbnRJbmRleCwgJ2QnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBkYXRhLmtleXNbZGF0YS5wZl9jb3VudF0gPSBhc3QuYXJndW1lbnRJbmRleDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ByZWNvbXBpbGUoIGFzdC5lbGVtZW50Rm9ybWF0LCBkYXRhICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gJyc7XG5cbiAgICBjYXNlICdlbGVtZW50Rm9ybWF0JzpcbiAgICAgIGFyZ3MgPSBbIHByb3BuYW1lKGRhdGEua2V5c1tkYXRhLnBmX2NvdW50XSwgJ2QnKSBdO1xuICAgICAgc3dpdGNoIChhc3Qua2V5KSB7XG4gICAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgICAgYXJncy5wdXNoKHRoaXMuX3ByZWNvbXBpbGUoYXN0LnZhbCwgZGF0YSkpO1xuICAgICAgICAgIHJldHVybiAnc2VsZWN0KCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICAgIGNhc2UgJ3NlbGVjdG9yZGluYWwnOlxuICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbIDAsIHByb3BuYW1lKHRoaXMubGNbMF0sICdwbHVyYWxGdW5jcycpLCB0aGlzLl9wcmVjb21waWxlKGFzdC52YWwsIGRhdGEpLCAxIF0pO1xuICAgICAgICAgIHJldHVybiAncGx1cmFsKCcgKyBhcmdzLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICAgIGNhc2UgJ3BsdXJhbCc6XG4gICAgICAgICAgZGF0YS5vZmZzZXRbZGF0YS5wZl9jb3VudCB8fCAwXSA9IGFzdC52YWwub2Zmc2V0IHx8IDA7XG4gICAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFsgZGF0YS5vZmZzZXRbZGF0YS5wZl9jb3VudF0gfHwgMCwgcHJvcG5hbWUodGhpcy5sY1swXSwgJ3BsdXJhbEZ1bmNzJyksIHRoaXMuX3ByZWNvbXBpbGUoYXN0LnZhbCwgZGF0YSkgXSk7XG4gICAgICAgICAgcmV0dXJuICdwbHVyYWwoJyArIGFyZ3Muam9pbignLCAnKSArICcpJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAodGhpcy53aXRoSW50bFN1cHBvcnQgJiYgIShhc3Qua2V5IGluIHRoaXMucnVudGltZS5mbXQpICYmIChhc3Qua2V5IGluIE1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVycykpIHtcbiAgICAgICAgICAgIHRtcCA9IE1lc3NhZ2VGb3JtYXQuZm9ybWF0dGVyc1thc3Qua2V5XTtcbiAgICAgICAgICAgIHRoaXMucnVudGltZS5mbXRbYXN0LmtleV0gPSAodHlwZW9mIHRtcCh0aGlzKSA9PSAnZnVuY3Rpb24nKSA/IHRtcCh0aGlzKSA6IHRtcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJncy5wdXNoKEpTT04uc3RyaW5naWZ5KHRoaXMubGMpKTtcbiAgICAgICAgICBpZiAoYXN0LnZhbCAmJiBhc3QudmFsLmxlbmd0aCkgYXJncy5wdXNoKEpTT04uc3RyaW5naWZ5KGFzdC52YWwubGVuZ3RoID09IDEgPyBhc3QudmFsWzBdIDogYXN0LnZhbCkpO1xuICAgICAgICAgIHJldHVybiAnZm10LicgKyBhc3Qua2V5ICsgJygnICsgYXJncy5qb2luKCcsICcpICsgJyknO1xuICAgICAgfVxuXG4gICAgY2FzZSAncGx1cmFsRm9ybWF0UGF0dGVybic6XG4gICAgY2FzZSAnc2VsZWN0Rm9ybWF0UGF0dGVybic6XG4gICAgICBkYXRhLnBmX2NvdW50ID0gZGF0YS5wZl9jb3VudCB8fCAwO1xuICAgICAgaWYgKGFzdC50eXBlID09ICdzZWxlY3RGb3JtYXRQYXR0ZXJuJykgZGF0YS5vZmZzZXRbZGF0YS5wZl9jb3VudF0gPSAwO1xuICAgICAgdmFyIG5lZWRPdGhlciA9IHRydWU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYXN0LnBsdXJhbEZvcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBrZXkgPSBhc3QucGx1cmFsRm9ybXNbaV0ua2V5O1xuICAgICAgICBpZiAoa2V5ID09PSAnb3RoZXInKSBuZWVkT3RoZXIgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGFfY29weSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xuICAgICAgICBkYXRhX2NvcHkucGZfY291bnQrKztcbiAgICAgICAgci5wdXNoKHByb3BuYW1lKGtleSkgKyAnOiBmdW5jdGlvbigpIHsgcmV0dXJuICcgKyB0aGlzLl9wcmVjb21waWxlKGFzdC5wbHVyYWxGb3Jtc1tpXS52YWwsIGRhdGFfY29weSkgKyAnO30nKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkT3RoZXIpIHRocm93IG5ldyBFcnJvcihcIk5vICdvdGhlcicgZm9ybSBmb3VuZCBpbiBcIiArIGFzdC50eXBlICsgXCIgXCIgKyBkYXRhLnBmX2NvdW50KTtcbiAgICAgIHJldHVybiAneyAnICsgci5qb2luKCcsICcpICsgJyB9JztcblxuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXN0LnZhbCB8fCBcIlwiKTtcblxuICAgIGNhc2UgJ29jdG90aG9ycGUnOlxuICAgICAgaWYgKCFkYXRhLnBmX2NvdW50KSByZXR1cm4gJ1wiI1wiJztcbiAgICAgIGFyZ3MgPSBbIHByb3BuYW1lKGRhdGEua2V5c1tkYXRhLnBmX2NvdW50LTFdLCAnZCcpIF07XG4gICAgICBpZiAoZGF0YS5vZmZzZXRbZGF0YS5wZl9jb3VudC0xXSkgYXJncy5wdXNoKGRhdGEub2Zmc2V0W2RhdGEucGZfY291bnQtMV0pO1xuICAgICAgcmV0dXJuICdudW1iZXIoJyArIGFyZ3Muam9pbignLCAnKSArICcpJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoICdCYWQgQVNUIHR5cGU6ICcgKyBhc3QudHlwZSApO1xuICB9XG59O1xuXG4vKiogQ29tcGlsZSBtZXNzYWdlcyBpbnRvIGFuIGV4ZWN1dGFibGUgZnVuY3Rpb24gd2l0aCBjbGVhbiBzdHJpbmdcbiAqICByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiAgSWYgYG1lc3NhZ2VzYCBpcyBhIHNpbmdsZSBzdHJpbmcgaW5jbHVkaW5nIElDVSBNZXNzYWdlRm9ybWF0IGRlY2xhcmF0aW9ucyxcbiAqICBgb3B0YCBpcyBpZ25vcmVkIGFuZCB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gdGFrZXMgYSBzaW5nbGUgT2JqZWN0IHBhcmFtZXRlclxuICogIGBkYCByZXByZXNlbnRpbmcgZWFjaCBvZiB0aGUgaW5wdXQncyBkZWZpbmVkIHZhcmlhYmxlcy4gVGhlIHJldHVybmVkXG4gKiAgZnVuY3Rpb24gd2lsbCBiZSBkZWZpbmVkIGluIGEgbG9jYWwgc2NvcGUgdGhhdCBpbmNsdWRlcyBhbGwgdGhlIHJlcXVpcmVkXG4gKiAgcnVudGltZSB2YXJpYWJsZXMuXG4gKlxuICogIElmIGBtZXNzYWdlc2AgaXMgYSBtYXAgb2Yga2V5cyB0byBzdHJpbmdzLCBvciBhIG1hcCBvZiBuYW1lc3BhY2Uga2V5cyB0b1xuICogIHN1Y2gga2V5L3N0cmluZyBtYXBzLCB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gd2lsbCBmaWxsIHRoZSBzcGVjaWZpZWQgZ2xvYmFsXG4gKiAgd2l0aCBqYXZhc2NyaXB0IGZ1bmN0aW9ucyBtYXRjaGluZyB0aGUgc3RydWN0dXJlIG9mIHRoZSBpbnB1dC4gSW4gc3VjaCB1c2UsXG4gKiAgdGhlIG91dHB1dCBvZiBgY29tcGlsZSgpYCBpcyBleHBlY3RlZCB0byBiZSBzZXJpYWxpemVkIHVzaW5nIGAudG9TdHJpbmcoKWAsXG4gKiAgYW5kIHdpbGwgaW5jbHVkZSBkZWZpbml0aW9ucyBvZiB0aGUgcnVudGltZSBmdW5jdGlvbnMuIElmIGBvcHQuZ2xvYmFsYCBpc1xuICogIG51bGwsIGNhbGxpbmcgdGhlIG91dHB1dCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgb2JqZWN0IGl0c2VsZi5cbiAqXG4gKiAgVG9nZXRoZXIsIHRoZSBpbnB1dCBwYXJhbWV0ZXJzIHNob3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nIHBhdHRlcm5zOlxuICogIGBgYGpzXG4gKiAgbWVzc2FnZXMgPSBcInN0cmluZ1wiIHx8IHsga2V5MDogXCJzdHJpbmcwXCIsIGtleTE6IFwic3RyaW5nMVwiLCAuLi4gfSB8fCB7XG4gKiAgICBuczA6IHsga2V5MDogXCJzdHJpbmcwXCIsIGtleTE6IFwic3RyaW5nMVwiLCAuLi4gIH0sXG4gKiAgICBuczE6IHsga2V5MDogXCJzdHJpbmcwXCIsIGtleTE6IFwic3RyaW5nMVwiLCAuLi4gIH0sXG4gKiAgICAuLi5cbiAqICB9XG4gKlxuICogIG9wdCA9IG51bGwgfHwge1xuICogICAgbG9jYWxlOiBudWxsIHx8IHtcbiAqICAgICAgbnMwOiBcImxjMFwiIHx8IFsgXCJsYzBcIiwgLi4uIF0sXG4gKiAgICAgIG5zMTogXCJsYzFcIiB8fCBbIFwibGMxXCIsIC4uLiBdLFxuICogICAgICAuLi5cbiAqICAgIH0sXG4gKiAgICBnbG9iYWw6IG51bGwgfHwgXCJtb2R1bGUuZXhwb3J0c1wiIHx8IFwiZXhwb3J0c1wiIHx8IFwiaTE4blwiIHx8IC4uLlxuICogIH1cbiAqICBgYGBcbiAqXG4gKiAgQG1lbWJlcm9mIE1lc3NhZ2VGb3JtYXRcbiAqICBAcGFyYW0ge3N0cmluZ3xPYmplY3R9XG4gKiAgICAgIG1lc3NhZ2VzIC0gVGhlIGlucHV0IG1lc3NhZ2UocykgdG8gYmUgY29tcGlsZWQsIGluIElDVSBNZXNzYWdlRm9ybWF0XG4gKiAgQHBhcmFtIHtPYmplY3R9IFtvcHQ9e31dIC0gT3B0aW9ucyBjb250cm9sbGluZyBvdXRwdXQgZm9yIG5vbi1zaW1wbGUgaW50cHV0XG4gKiAgQHBhcmFtIHtPYmplY3R9IFtvcHQubG9jYWxlXSAtIFRoZSBsb2NhbGVzIHRvIHVzZSBmb3IgdGhlIG1lc3NhZ2VzLCB3aXRoIGFcbiAqICAgICAgc3RydWN0dXJlIG1hdGNoaW5nIHRoYXQgb2YgYG1lc3NhZ2VzYFxuICogIEBwYXJhbSB7c3RyaW5nfSBbb3B0Lmdsb2JhbD1cIlwiXSAtIFRoZSBnbG9iYWwgdmFyaWFibGUgdGhhdCB0aGUgb3V0cHV0XG4gKiAgICAgIGZ1bmN0aW9uIHNob3VsZCB1c2UsIG9yIGEgbnVsbCBzdHJpbmcgZm9yIG5vbmUuIFwiZXhwb3J0c1wiIGFuZFxuICogICAgICBcIm1vZHVsZS5leHBvcnRzXCIgYXJlIHJlY29nbmlzZWQgYXMgc3BlY2lhbCBjYXNlcy5cbiAqICBAcmV0dXJucyB7ZnVuY3Rpb259IFRoZSBmaXJzdCBtYXRjaCBmb3VuZCBmb3IgdGhlIGdpdmVuIGxvY2FsZShzKVxuICpcbiAqICBAZXhhbXBsZVxuICogPiB2YXIgTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ21lc3NhZ2Vmb3JtYXQnKSxcbiAqIC4uLiAgIG1mID0gbmV3IE1lc3NhZ2VGb3JtYXQoJ2VuJyksXG4gKiAuLi4gICBtZnVuYzAgPSBtZi5jb21waWxlKCdBIHtUWVBFfSBleGFtcGxlLicpO1xuICogPiBtZnVuYzAoe1RZUEU6J3NpbXBsZSd9KVxuICogJ0Egc2ltcGxlIGV4YW1wbGUuJ1xuICogPiBtZnVuYzAudG9TdHJpbmcoKVxuICogJ2Z1bmN0aW9uIChkKSB7IHJldHVybiBcIkEgXCIgKyBkLlRZUEUgKyBcIiBleGFtcGxlLlwiOyB9J1xuICpcbiAqICBAZXhhbXBsZVxuICogPiB2YXIgbXNnU2V0ID0geyBhOiAnQSB7VFlQRX0gZXhhbXBsZS4nLFxuICogLi4uICAgICAgICAgICAgICBiOiAnVGhpcyBoYXMge0NPVU5ULCBwbHVyYWwsIG9uZXtvbmUgbWVtYmVyfSBvdGhlcnsjIG1lbWJlcnN9fS4nIH0sXG4gKiAuLi4gICBtZnVuY1NldCA9IG1mLmNvbXBpbGUobXNnU2V0KTtcbiAqID4gbWZ1bmNTZXQoKS5hKHtUWVBFOidtb3JlIGNvbXBsZXgnfSlcbiAqICdBIG1vcmUgY29tcGxleCBleGFtcGxlLidcbiAqID4gbWZ1bmNTZXQoKS5iKHtDT1VOVDoyfSlcbiAqICdUaGlzIGhhcyAyIG1lbWJlcnMuJ1xuICpcbiAqID4gY29uc29sZS5sb2cobWZ1bmNTZXQudG9TdHJpbmcoKSlcbiAqIGZ1bmN0aW9uIGFub255bW91cygpIHtcbiAqIHZhciBudW1iZXIgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCkge1xuICogICBpZiAoaXNOYU4odmFsdWUpKSB0aHJvdyBuZXcgRXJyb3IoXCInXCIgKyB2YWx1ZSArIFwiJyBpc24ndCBhIG51bWJlci5cIik7XG4gKiAgIHJldHVybiB2YWx1ZSAtIChvZmZzZXQgfHwgMCk7XG4gKiB9O1xuICogdmFyIHBsdXJhbCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBsY2Z1bmMsIGRhdGEsIGlzT3JkaW5hbCkge1xuICogICBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCB2YWx1ZSkpIHJldHVybiBkYXRhW3ZhbHVlXSgpO1xuICogICBpZiAob2Zmc2V0KSB2YWx1ZSAtPSBvZmZzZXQ7XG4gKiAgIHZhciBrZXkgPSBsY2Z1bmModmFsdWUsIGlzT3JkaW5hbCk7XG4gKiAgIGlmIChrZXkgaW4gZGF0YSkgcmV0dXJuIGRhdGFba2V5XSgpO1xuICogICByZXR1cm4gZGF0YS5vdGhlcigpO1xuICogfTtcbiAqIHZhciBzZWxlY3QgPSBmdW5jdGlvbiAodmFsdWUsIGRhdGEpIHtcbiAqICAgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgdmFsdWUpKSByZXR1cm4gZGF0YVt2YWx1ZV0oKTtcbiAqICAgcmV0dXJuIGRhdGEub3RoZXIoKVxuICogfTtcbiAqIHZhciBwbHVyYWxGdW5jcyA9IHtcbiAqICAgZW46IGZ1bmN0aW9uIChuLCBvcmQpIHtcbiAqICAgICB2YXIgcyA9IFN0cmluZyhuKS5zcGxpdCgnLicpLCB2MCA9ICFzWzFdLCB0MCA9IE51bWJlcihzWzBdKSA9PSBuLFxuICogICAgICAgICBuMTAgPSB0MCAmJiBzWzBdLnNsaWNlKC0xKSwgbjEwMCA9IHQwICYmIHNbMF0uc2xpY2UoLTIpO1xuICogICAgIGlmIChvcmQpIHJldHVybiAobjEwID09IDEgJiYgbjEwMCAhPSAxMSkgPyAnb25lJ1xuICogICAgICAgICA6IChuMTAgPT0gMiAmJiBuMTAwICE9IDEyKSA/ICd0d28nXG4gKiAgICAgICAgIDogKG4xMCA9PSAzICYmIG4xMDAgIT0gMTMpID8gJ2ZldydcbiAqICAgICAgICAgOiAnb3RoZXInO1xuICogICAgIHJldHVybiAobiA9PSAxICYmIHYwKSA/ICdvbmUnIDogJ290aGVyJztcbiAqICAgfVxuICogfTtcbiAqIHZhciBmbXQgPSB7fTtcbiAqXG4gKiByZXR1cm4ge1xuICogICBhOiBmdW5jdGlvbihkKSB7IHJldHVybiBcIkEgXCIgKyBkLlRZUEUgKyBcIiBleGFtcGxlLlwiOyB9LFxuICogICBiOiBmdW5jdGlvbihkKSB7IHJldHVybiBcIlRoaXMgaGFzIFwiICsgcGx1cmFsKGQuQ09VTlQsIDAsIHBsdXJhbEZ1bmNzLmVuLCB7IG9uZTogZnVuY3Rpb24oKSB7IHJldHVybiBcIm9uZSBtZW1iZXJcIjt9LCBvdGhlcjogZnVuY3Rpb24oKSB7IHJldHVybiBudW1iZXIoZC5DT1VOVCkrXCIgbWVtYmVyc1wiO30gfSkgKyBcIi5cIjsgfVxuICogfVxuICogfVxuICpcbiAqICBAZXhhbXBsZVxuICogPiBtZi5ydW50aW1lLnBsdXJhbEZ1bmNzLmZpID0gTWVzc2FnZUZvcm1hdC5wbHVyYWxzLmZpO1xuICogPiB2YXIgbXVsdGlTZXQgPSB7IGVuOiB7IGE6ICdBIHtUWVBFfSBleGFtcGxlLicsXG4gKiAuLi4gICAgICAgICAgICAgICAgICAgICAgYjogJ1RoaXMgaXMgdGhlIHtDT1VOVCwgc2VsZWN0b3JkaW5hbCwgb25leyNzdH0gdHdveyNuZH0gZmV3eyNyZH0gb3RoZXJ7I3RofX0gZXhhbXBsZS4nIH0sXG4gKiAuLi4gICAgICAgICAgICAgICAgZmk6IHsgYTogJ3tUWVBFfSBlc2ltZXJra2kuJyxcbiAqIC4uLiAgICAgICAgICAgICAgICAgICAgICBiOiAnVMOkbcOkIG9uIHtDT1VOVCwgc2VsZWN0b3JkaW5hbCwgb3RoZXJ7Iy59fSBlc2ltZXJra2kuJyB9IH0sXG4gKiAuLi4gICBtdWx0aVNldExvY2FsZXMgPSB7IGVuOiAnZW4nLCBmaTogJ2ZpJyB9LFxuICogLi4uICAgbWZ1bmNTZXQgPSBtZi5jb21waWxlKG11bHRpU2V0LCB7IGxvY2FsZTogbXVsdGlTZXRMb2NhbGVzLCBnbG9iYWw6ICdpMThuJyB9KTtcbiAqID4gbWZ1bmNTZXQodGhpcyk7XG4gKiA+IGkxOG4uZW4uYih7Q09VTlQ6M30pXG4gKiAnVGhpcyBpcyB0aGUgM3JkIGV4YW1wbGUuJ1xuICogPiBpMThuLmZpLmIoe0NPVU5UOjN9KVxuICogJ1TDpG3DpCBvbiAzLiBlc2ltZXJra2kuJyAgKi9cbk1lc3NhZ2VGb3JtYXQucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoIG1lc3NhZ2VzLCBvcHQgKSB7XG4gIHZhciByID0ge30sIGxjMCA9IHRoaXMubGMsXG4gICAgICBjb21waWxlTXNnID0gZnVuY3Rpb24oc2VsZiwgbXNnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGFzdCA9IE1lc3NhZ2VGb3JtYXQuX3BhcnNlKG1zZyk7XG4gICAgICAgICAgcmV0dXJuIHNlbGYuX3ByZWNvbXBpbGUoYXN0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoYXN0ID8gJ1ByZWNvbXBpbGVyJyA6ICdQYXJzZXInKSArICcgZXJyb3I6ICcgKyBlLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RyaW5naWZ5ID0gZnVuY3Rpb24ociwgbGV2ZWwpIHtcbiAgICAgICAgaWYgKCFsZXZlbCkgbGV2ZWwgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHIgIT0gJ29iamVjdCcpIHJldHVybiByO1xuICAgICAgICB2YXIgbyA9IFtdLCBpbmRlbnQgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZXZlbDsgKytpKSBpbmRlbnQgKz0gJyAgJztcbiAgICAgICAgZm9yICh2YXIgayBpbiByKSBvLnB1c2goJ1xcbicgKyBpbmRlbnQgKyAnICAnICsgcHJvcG5hbWUoaykgKyAnOiAnICsgc3RyaW5naWZ5KHJba10sIGxldmVsICsgMSkpO1xuICAgICAgICByZXR1cm4gJ3snICsgby5qb2luKCcsJykgKyAnXFxuJyArIGluZGVudCArICd9JztcbiAgICAgIH07XG5cbiAgaWYgKHR5cGVvZiBtZXNzYWdlcyA9PSAnc3RyaW5nJykge1xuICAgIHZhciBmID0gbmV3IEZ1bmN0aW9uKFxuICAgICAgICAnbnVtYmVyLCBwbHVyYWwsIHNlbGVjdCwgcGx1cmFsRnVuY3MsIGZtdCcsXG4gICAgICAgICdyZXR1cm4gJyArIGNvbXBpbGVNc2codGhpcywgbWVzc2FnZXMpKTtcbiAgICByZXR1cm4gZih0aGlzLnJ1bnRpbWUubnVtYmVyLCB0aGlzLnJ1bnRpbWUucGx1cmFsLCB0aGlzLnJ1bnRpbWUuc2VsZWN0LFxuICAgICAgICB0aGlzLnJ1bnRpbWUucGx1cmFsRnVuY3MsIHRoaXMucnVudGltZS5mbXQpO1xuICB9XG5cbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIGZvciAodmFyIG5zIGluIG1lc3NhZ2VzKSB7XG4gICAgaWYgKG9wdC5sb2NhbGUpIHRoaXMubGMgPSBvcHQubG9jYWxlW25zXSAmJiBbXS5jb25jYXQob3B0LmxvY2FsZVtuc10pIHx8IGxjMDtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2VzW25zXSA9PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHsgcltuc10gPSBjb21waWxlTXNnKHRoaXMsIG1lc3NhZ2VzW25zXSk7IH1cbiAgICAgIGNhdGNoIChlKSB7IGUubWVzc2FnZSA9IGUubWVzc2FnZS5yZXBsYWNlKCc6JywgJyB3aXRoIGAnICsgbnMgKyAnYDonKTsgdGhyb3cgZTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICByW25zXSA9IHt9O1xuICAgICAgZm9yICh2YXIga2V5IGluIG1lc3NhZ2VzW25zXSkge1xuICAgICAgICB0cnkgeyByW25zXVtrZXldID0gY29tcGlsZU1zZyh0aGlzLCBtZXNzYWdlc1tuc11ba2V5XSk7IH1cbiAgICAgICAgY2F0Y2ggKGUpIHsgZS5tZXNzYWdlID0gZS5tZXNzYWdlLnJlcGxhY2UoJzonLCAnIHdpdGggYCcgKyBrZXkgKyAnYCBpbiBgJyArIG5zICsgJ2A6Jyk7IHRocm93IGU7IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0aGlzLmxjID0gbGMwO1xuICB2YXIgcyA9IHRoaXMucnVudGltZS50b1N0cmluZygpICsgJ1xcbic7XG4gIHN3aXRjaCAob3B0Lmdsb2JhbCB8fCAnJykge1xuICAgIGNhc2UgJ2V4cG9ydHMnOlxuICAgICAgdmFyIG8gPSBbXTtcbiAgICAgIGZvciAodmFyIGsgaW4gcikgby5wdXNoKHByb3BuYW1lKGssICdleHBvcnRzJykgKyAnID0gJyArIHN0cmluZ2lmeShyW2tdKSk7XG4gICAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKHMgKyBvLmpvaW4oJztcXG4nKSk7XG4gICAgY2FzZSAnbW9kdWxlLmV4cG9ydHMnOlxuICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihzICsgJ21vZHVsZS5leHBvcnRzID0gJyArIHN0cmluZ2lmeShyKSk7XG4gICAgY2FzZSAnJzpcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24ocyArICdyZXR1cm4gJyArIHN0cmluZ2lmeShyKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ0cnLCBzICsgcHJvcG5hbWUob3B0Lmdsb2JhbCwgJ0cnKSArICcgPSAnICsgc3RyaW5naWZ5KHIpKTtcbiAgfVxufTtcblxuXG5yZXR1cm4gTWVzc2FnZUZvcm1hdDtcbn0oKSk7XG4vKiBqc2hpbnQgaWdub3JlOmVuZCAqL1xuXG5cbnZhciBjcmVhdGVFcnJvclBsdXJhbE1vZHVsZVByZXNlbmNlID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBjcmVhdGVFcnJvciggXCJFX01JU1NJTkdfUExVUkFMX01PRFVMRVwiLCBcIlBsdXJhbCBtb2R1bGUgbm90IGxvYWRlZC5cIiApO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlTWVzc2FnZUJ1bmRsZSA9IGZ1bmN0aW9uKCBjbGRyICkge1xuXHR2YWxpZGF0ZShcblx0XHRcIkVfTUlTU0lOR19NRVNTQUdFX0JVTkRMRVwiLFxuXHRcdFwiTWlzc2luZyBtZXNzYWdlIGJ1bmRsZSBmb3IgbG9jYWxlIGB7bG9jYWxlfWAuXCIsXG5cdFx0Y2xkci5hdHRyaWJ1dGVzLmJ1bmRsZSAmJiBjbGRyLmdldCggXCJnbG9iYWxpemUtbWVzc2FnZXMve2J1bmRsZX1cIiApICE9PSB1bmRlZmluZWQsXG5cdFx0e1xuXHRcdFx0bG9jYWxlOiBjbGRyLmxvY2FsZVxuXHRcdH1cblx0KTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZU1lc3NhZ2VQcmVzZW5jZSA9IGZ1bmN0aW9uKCBwYXRoLCB2YWx1ZSApIHtcblx0cGF0aCA9IHBhdGguam9pbiggXCIvXCIgKTtcblx0dmFsaWRhdGUoIFwiRV9NSVNTSU5HX01FU1NBR0VcIiwgXCJNaXNzaW5nIHJlcXVpcmVkIG1lc3NhZ2UgY29udGVudCBge3BhdGh9YC5cIixcblx0XHR2YWx1ZSAhPT0gdW5kZWZpbmVkLCB7IHBhdGg6IHBhdGggfSApO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlTWVzc2FnZVR5cGUgPSBmdW5jdGlvbiggcGF0aCwgdmFsdWUgKSB7XG5cdHBhdGggPSBwYXRoLmpvaW4oIFwiL1wiICk7XG5cdHZhbGlkYXRlKFxuXHRcdFwiRV9JTlZBTElEX01FU1NBR0VcIixcblx0XHRcIkludmFsaWQgbWVzc2FnZSBjb250ZW50IGB7cGF0aH1gLiB7ZXhwZWN0ZWR9IGV4cGVjdGVkLlwiLFxuXHRcdHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIixcblx0XHR7XG5cdFx0XHRleHBlY3RlZDogXCJhIHN0cmluZ1wiLFxuXHRcdFx0cGF0aDogcGF0aFxuXHRcdH1cblx0KTtcbn07XG5cblxuXG5cbnZhciB2YWxpZGF0ZVBhcmFtZXRlclR5cGVNZXNzYWdlVmFyaWFibGVzID0gZnVuY3Rpb24oIHZhbHVlLCBuYW1lICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUoXG5cdFx0dmFsdWUsXG5cdFx0bmFtZSxcblx0XHR2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGlzUGxhaW5PYmplY3QoIHZhbHVlICkgfHwgQXJyYXkuaXNBcnJheSggdmFsdWUgKSxcblx0XHRcIkFycmF5IG9yIFBsYWluIE9iamVjdFwiXG5cdCk7XG59O1xuXG5cblxuXG52YXIgbWVzc2FnZUZvcm1hdHRlckZuID0gZnVuY3Rpb24oIGZvcm1hdHRlciApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIG1lc3NhZ2VGb3JtYXR0ZXIoIHZhcmlhYmxlcyApIHtcblx0XHRpZiAoIHR5cGVvZiB2YXJpYWJsZXMgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhcmlhYmxlcyA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHZhcmlhYmxlcyA9IFtdLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMCApO1xuXHRcdH1cblx0XHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVNZXNzYWdlVmFyaWFibGVzKCB2YXJpYWJsZXMsIFwidmFyaWFibGVzXCIgKTtcblx0XHRyZXR1cm4gZm9ybWF0dGVyKCB2YXJpYWJsZXMgKTtcblx0fTtcbn07XG5cblxuXG5cbnZhciBtZXNzYWdlRm9ybWF0dGVyUnVudGltZUJpbmQgPSBmdW5jdGlvbiggY2xkciwgbWVzc2FnZWZvcm1hdHRlciApIHtcblx0dmFyIGxvY2FsZSA9IGNsZHIubG9jYWxlLFxuXHRcdG9yaWdUb1N0cmluZyA9IG1lc3NhZ2Vmb3JtYXR0ZXIudG9TdHJpbmc7XG5cblx0bWVzc2FnZWZvcm1hdHRlci50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdOYW1lcywgYXJnVmFsdWVzLCBvdXRwdXQsXG5cdFx0XHRhcmdzID0ge307XG5cblx0XHQvLyBQcm9wZXJseSBhZGp1c3QgU2xleEF4dG9uL21lc3NhZ2Vmb3JtYXQuanMgY29tcGlsZWQgdmFyaWFibGVzIHdpdGggR2xvYmFsaXplIHZhcmlhYmxlczpcblx0XHRvdXRwdXQgPSBvcmlnVG9TdHJpbmcuY2FsbCggbWVzc2FnZWZvcm1hdHRlciApO1xuXG5cdFx0aWYgKCAvbnVtYmVyXFwoLy50ZXN0KCBvdXRwdXQgKSApIHtcblx0XHRcdGFyZ3MubnVtYmVyID0gXCJtZXNzYWdlRm9ybWF0Lm51bWJlclwiO1xuXHRcdH1cblxuXHRcdGlmICggL3BsdXJhbFxcKC8udGVzdCggb3V0cHV0ICkgKSB7XG5cdFx0XHRhcmdzLnBsdXJhbCA9IFwibWVzc2FnZUZvcm1hdC5wbHVyYWxcIjtcblx0XHR9XG5cblx0XHRpZiAoIC9zZWxlY3RcXCgvLnRlc3QoIG91dHB1dCApICkge1xuXHRcdFx0YXJncy5zZWxlY3QgPSBcIm1lc3NhZ2VGb3JtYXQuc2VsZWN0XCI7XG5cdFx0fVxuXG5cdFx0b3V0cHV0LnJlcGxhY2UoIC9wbHVyYWxGdW5jcyhcXFsoW15cXF1dKylcXF18XFwuKFthLXpBLVpdKykpLywgZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0YXJncy5wbHVyYWxGdW5jcyA9IFwie1wiICtcblx0XHRcdFx0XCJcXFwiXCIgKyBsb2NhbGUgKyBcIlxcXCI6IEdsb2JhbGl6ZShcXFwiXCIgKyBsb2NhbGUgKyBcIlxcXCIpLnBsdXJhbEdlbmVyYXRvcigpXCIgK1xuXHRcdFx0XHRcIn1cIjtcblx0XHRcdHJldHVybiBtYXRjaDtcblx0XHR9KTtcblxuXHRcdGFyZ05hbWVzID0gT2JqZWN0LmtleXMoIGFyZ3MgKS5qb2luKCBcIiwgXCIgKTtcblx0XHRhcmdWYWx1ZXMgPSBPYmplY3Qua2V5cyggYXJncyApLm1hcChmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuIGFyZ3NbIGtleSBdO1xuXHRcdH0pLmpvaW4oIFwiLCBcIiApO1xuXG5cdFx0cmV0dXJuIFwiKGZ1bmN0aW9uKCBcIiArIGFyZ05hbWVzICsgXCIgKSB7XFxuXCIgK1xuXHRcdFx0XCIgIHJldHVybiBcIiArIG91dHB1dCArIFwiXFxuXCIgK1xuXHRcdFx0XCJ9KShcIiArIGFyZ1ZhbHVlcyArIFwiKVwiO1xuXHR9O1xuXG5cdHJldHVybiBtZXNzYWdlZm9ybWF0dGVyO1xufTtcblxuXG5cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogLmxvYWRNZXNzYWdlcygganNvbiApXG4gKlxuICogQGpzb24gW0pTT05dXG4gKlxuICogTG9hZCB0cmFuc2xhdGlvbiBkYXRhLlxuICovXG5HbG9iYWxpemUubG9hZE1lc3NhZ2VzID0gZnVuY3Rpb24oIGpzb24gKSB7XG5cdHZhciBsb2NhbGUsXG5cdFx0Y3VzdG9tRGF0YSA9IHtcblx0XHRcdFwiZ2xvYmFsaXplLW1lc3NhZ2VzXCI6IGpzb24sXG5cdFx0XHRcIm1haW5cIjoge31cblx0XHR9O1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIGpzb24sIFwianNvblwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBqc29uLCBcImpzb25cIiApO1xuXG5cdC8vIFNldCBhdmFpbGFibGUgYnVuZGxlcyBieSBwb3B1bGF0aW5nIGN1c3RvbURhdGEgbWFpbiBkYXRhc2V0LlxuXHRmb3IgKCBsb2NhbGUgaW4ganNvbiApIHtcblx0XHRpZiAoIGpzb24uaGFzT3duUHJvcGVydHkoIGxvY2FsZSApICkge1xuXHRcdFx0Y3VzdG9tRGF0YS5tYWluWyBsb2NhbGUgXSA9IHt9O1xuXHRcdH1cblx0fVxuXG5cdENsZHIubG9hZCggY3VzdG9tRGF0YSApO1xufTtcblxuLyoqXG4gKiAubWVzc2FnZUZvcm1hdHRlciggcGF0aCApXG4gKlxuICogQHBhdGggW1N0cmluZyBvciBBcnJheV1cbiAqXG4gKiBGb3JtYXQgYSBtZXNzYWdlIGdpdmVuIGl0cyBwYXRoLlxuICovXG5HbG9iYWxpemUubWVzc2FnZUZvcm1hdHRlciA9XG5HbG9iYWxpemUucHJvdG90eXBlLm1lc3NhZ2VGb3JtYXR0ZXIgPSBmdW5jdGlvbiggcGF0aCApIHtcblx0dmFyIGNsZHIsIGZvcm1hdHRlciwgbWVzc2FnZSwgcGx1cmFsR2VuZXJhdG9yLCByZXR1cm5Gbixcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAwICk7XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggcGF0aCwgXCJwYXRoXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKCBwYXRoLCBcInBhdGhcIiwgdHlwZW9mIHBhdGggPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSggcGF0aCApLFxuXHRcdFwiYSBTdHJpbmcgbm9yIGFuIEFycmF5XCIgKTtcblxuXHRwYXRoID0gYWx3YXlzQXJyYXkoIHBhdGggKTtcblx0Y2xkciA9IHRoaXMuY2xkcjtcblxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcblx0dmFsaWRhdGVNZXNzYWdlQnVuZGxlKCBjbGRyICk7XG5cblx0bWVzc2FnZSA9IGNsZHIuZ2V0KCBbIFwiZ2xvYmFsaXplLW1lc3NhZ2VzL3tidW5kbGV9XCIgXS5jb25jYXQoIHBhdGggKSApO1xuXHR2YWxpZGF0ZU1lc3NhZ2VQcmVzZW5jZSggcGF0aCwgbWVzc2FnZSApO1xuXG5cdC8vIElmIG1lc3NhZ2UgaXMgYW4gQXJyYXksIGNvbmNhdGVuYXRlIGl0LlxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG1lc3NhZ2UgKSApIHtcblx0XHRtZXNzYWdlID0gbWVzc2FnZS5qb2luKCBcIiBcIiApO1xuXHR9XG5cdHZhbGlkYXRlTWVzc2FnZVR5cGUoIHBhdGgsIG1lc3NhZ2UgKTtcblxuXHQvLyBJcyBwbHVyYWwgbW9kdWxlIHByZXNlbnQ/IFllcywgdXNlIGl0cyBnZW5lcmF0b3IuIE5vcGUsIHVzZSBhbiBlcnJvciBnZW5lcmF0b3IuXG5cdHBsdXJhbEdlbmVyYXRvciA9IHRoaXMucGx1cmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHRoaXMucGx1cmFsR2VuZXJhdG9yKCkgOlxuXHRcdGNyZWF0ZUVycm9yUGx1cmFsTW9kdWxlUHJlc2VuY2U7XG5cblx0Zm9ybWF0dGVyID0gbmV3IE1lc3NhZ2VGb3JtYXQoIGNsZHIubG9jYWxlLCBwbHVyYWxHZW5lcmF0b3IgKS5jb21waWxlKCBtZXNzYWdlICk7XG5cblx0cmV0dXJuRm4gPSBtZXNzYWdlRm9ybWF0dGVyRm4oIGZvcm1hdHRlciApO1xuXG5cdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5Gbixcblx0XHRbIG1lc3NhZ2VGb3JtYXR0ZXJSdW50aW1lQmluZCggY2xkciwgZm9ybWF0dGVyICksIHBsdXJhbEdlbmVyYXRvciBdICk7XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxuLyoqXG4gKiAuZm9ybWF0TWVzc2FnZSggcGF0aCBbLCB2YXJpYWJsZXNdIClcbiAqXG4gKiBAcGF0aCBbU3RyaW5nIG9yIEFycmF5XVxuICpcbiAqIEB2YXJpYWJsZXMgW051bWJlciwgU3RyaW5nLCBBcnJheSBvciBPYmplY3RdXG4gKlxuICogRm9ybWF0IGEgbWVzc2FnZSBnaXZlbiBpdHMgcGF0aC5cbiAqL1xuR2xvYmFsaXplLmZvcm1hdE1lc3NhZ2UgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXRNZXNzYWdlID0gZnVuY3Rpb24oIHBhdGggLyogLCB2YXJpYWJsZXMgKi8gKSB7XG5cdHJldHVybiB0aGlzLm1lc3NhZ2VGb3JtYXR0ZXIoIHBhdGggKS5hcHBseSgge30sIHNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApICk7XG59O1xuXG5yZXR1cm4gR2xvYmFsaXplO1xuXG5cblxuXG59KSk7XG5cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L2dsb2JhbGl6ZS9tZXNzYWdlLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvbWVzc2FnZS5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgZGVmaW5lID0gZmFsc2U7XG5cbi8qKlxuICogR2xvYmFsaXplIHYxLjMuMFxuICpcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wNy0wM1QyMTozN1pcbiAqL1xuLyohXG4gKiBHbG9iYWxpemUgdjEuMy4wIDIwMTctMDctMDNUMjE6MzdaIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2dpdC5pby9UcmRRYndcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXG5cdC8vIFVNRCByZXR1cm5FeHBvcnRzXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1xuXHRcdFx0XCJjbGRyXCIsXG5cdFx0XHRcIi4uL2dsb2JhbGl6ZVwiLFxuXHRcdFx0XCJjbGRyL2V2ZW50XCIsXG5cdFx0XHRcImNsZHIvc3VwcGxlbWVudGFsXCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gTm9kZSwgQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiY2xkcmpzXCIgKSwgcmVxdWlyZSggXCIuLi9nbG9iYWxpemVcIiApICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBHbG9iYWxcblx0XHRmYWN0b3J5KCByb290LkNsZHIsIHJvb3QuR2xvYmFsaXplICk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24oIENsZHIsIEdsb2JhbGl6ZSApIHtcblxudmFyIGNyZWF0ZUVycm9yID0gR2xvYmFsaXplLl9jcmVhdGVFcnJvcixcblx0cmVnZXhwRXNjYXBlID0gR2xvYmFsaXplLl9yZWdleHBFc2NhcGUsXG5cdHJ1bnRpbWVCaW5kID0gR2xvYmFsaXplLl9ydW50aW1lQmluZCxcblx0c3RyaW5nUGFkID0gR2xvYmFsaXplLl9zdHJpbmdQYWQsXG5cdHZhbGlkYXRlQ2xkciA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVDbGRyLFxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlRGVmYXVsdExvY2FsZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGUsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0ID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdDtcblxuXG52YXIgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUgPSBmdW5jdGlvbiggZmVhdHVyZSApIHtcblx0cmV0dXJuIGNyZWF0ZUVycm9yKCBcIkVfVU5TVVBQT1JURURcIiwgXCJVbnN1cHBvcnRlZCB7ZmVhdHVyZX0uXCIsIHtcblx0XHRmZWF0dXJlOiBmZWF0dXJlXG5cdH0pO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxuXHRcdHZhbHVlLFxuXHRcdG5hbWUsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIsXG5cdFx0XCJOdW1iZXJcIlxuXHQpO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxuXHRcdHZhbHVlLFxuXHRcdG5hbWUsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIsXG5cdFx0XCJhIHN0cmluZ1wiXG5cdCk7XG59O1xuXG5cblxuXG4vKipcbiAqIGdvdXBpbmdTZXBhcmF0b3IoIG51bWJlciwgcHJpbWFyeUdyb3VwaW5nU2l6ZSwgc2Vjb25kYXJ5R3JvdXBpbmdTaXplIClcbiAqXG4gKiBAbnVtYmVyIFtOdW1iZXJdLlxuICpcbiAqIEBwcmltYXJ5R3JvdXBpbmdTaXplIFtOdW1iZXJdXG4gKlxuICogQHNlY29uZGFyeUdyb3VwaW5nU2l6ZSBbTnVtYmVyXVxuICpcbiAqIFJldHVybiB0aGUgZm9ybWF0dGVkIG51bWJlciB3aXRoIGdyb3VwIHNlcGFyYXRvci5cbiAqL1xudmFyIG51bWJlckZvcm1hdEdyb3VwaW5nU2VwYXJhdG9yID0gZnVuY3Rpb24oIG51bWJlciwgcHJpbWFyeUdyb3VwaW5nU2l6ZSwgc2Vjb25kYXJ5R3JvdXBpbmdTaXplICkge1xuXHR2YXIgaW5kZXgsXG5cdFx0Y3VycmVudEdyb3VwaW5nU2l6ZSA9IHByaW1hcnlHcm91cGluZ1NpemUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRzZXAgPSBcIixcIixcblx0XHRzd2l0Y2hUb1NlY29uZGFyeSA9IHNlY29uZGFyeUdyb3VwaW5nU2l6ZSA/IHRydWUgOiBmYWxzZTtcblxuXHRudW1iZXIgPSBTdHJpbmcoIG51bWJlciApLnNwbGl0KCBcIi5cIiApO1xuXHRpbmRleCA9IG51bWJlclsgMCBdLmxlbmd0aDtcblxuXHR3aGlsZSAoIGluZGV4ID4gY3VycmVudEdyb3VwaW5nU2l6ZSApIHtcblx0XHRyZXQgPSBudW1iZXJbIDAgXS5zbGljZSggaW5kZXggLSBjdXJyZW50R3JvdXBpbmdTaXplLCBpbmRleCApICtcblx0XHRcdCggcmV0Lmxlbmd0aCA/IHNlcCA6IFwiXCIgKSArIHJldDtcblx0XHRpbmRleCAtPSBjdXJyZW50R3JvdXBpbmdTaXplO1xuXHRcdGlmICggc3dpdGNoVG9TZWNvbmRhcnkgKSB7XG5cdFx0XHRjdXJyZW50R3JvdXBpbmdTaXplID0gc2Vjb25kYXJ5R3JvdXBpbmdTaXplO1xuXHRcdFx0c3dpdGNoVG9TZWNvbmRhcnkgPSBmYWxzZTtcblx0XHR9XG5cdH1cblxuXHRudW1iZXJbIDAgXSA9IG51bWJlclsgMCBdLnNsaWNlKCAwLCBpbmRleCApICsgKCByZXQubGVuZ3RoID8gc2VwIDogXCJcIiApICsgcmV0O1xuXHRyZXR1cm4gbnVtYmVyLmpvaW4oIFwiLlwiICk7XG59O1xuXG5cblxuXG4vKipcbiAqIGludGVnZXJGcmFjdGlvbkRpZ2l0cyggbnVtYmVyLCBtaW5pbXVtSW50ZWdlckRpZ2l0cywgbWluaW11bUZyYWN0aW9uRGlnaXRzLFxuICogbWF4aW11bUZyYWN0aW9uRGlnaXRzLCByb3VuZCwgcm91bmRJbmNyZW1lbnQgKVxuICpcbiAqIEBudW1iZXIgW051bWJlcl1cbiAqXG4gKiBAbWluaW11bUludGVnZXJEaWdpdHMgW051bWJlcl1cbiAqXG4gKiBAbWluaW11bUZyYWN0aW9uRGlnaXRzIFtOdW1iZXJdXG4gKlxuICogQG1heGltdW1GcmFjdGlvbkRpZ2l0cyBbTnVtYmVyXVxuICpcbiAqIEByb3VuZCBbRnVuY3Rpb25dXG4gKlxuICogQHJvdW5kSW5jcmVtZW50IFtGdW5jdGlvbl1cbiAqXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBpbnRlZ2VyIGFuZCBmcmFjdGlvbiBkaWdpdHMuXG4gKi9cbnZhciBudW1iZXJGb3JtYXRJbnRlZ2VyRnJhY3Rpb25EaWdpdHMgPSBmdW5jdGlvbiggbnVtYmVyLCBtaW5pbXVtSW50ZWdlckRpZ2l0cywgbWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIHJvdW5kLFxuXHRyb3VuZEluY3JlbWVudCApIHtcblxuXHQvLyBGcmFjdGlvblxuXHRpZiAoIG1heGltdW1GcmFjdGlvbkRpZ2l0cyApIHtcblxuXHRcdC8vIFJvdW5kaW5nXG5cdFx0aWYgKCByb3VuZEluY3JlbWVudCApIHtcblx0XHRcdG51bWJlciA9IHJvdW5kKCBudW1iZXIsIHJvdW5kSW5jcmVtZW50ICk7XG5cblx0XHQvLyBNYXhpbXVtIGZyYWN0aW9uIGRpZ2l0c1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRudW1iZXIgPSByb3VuZCggbnVtYmVyLCB7IGV4cG9uZW50OiAtbWF4aW11bUZyYWN0aW9uRGlnaXRzIH0gKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblx0XHRudW1iZXIgPSByb3VuZCggbnVtYmVyICk7XG5cdH1cblxuXHRudW1iZXIgPSBTdHJpbmcoIG51bWJlciApO1xuXG5cdC8vIE1heGltdW0gaW50ZWdlciBkaWdpdHMgKHBvc3Qgc3RyaW5nIHBoYXNlKVxuXHRpZiAoIG1heGltdW1GcmFjdGlvbkRpZ2l0cyAmJiAvZS0vLnRlc3QoIG51bWJlciApICkge1xuXG5cdFx0Ly8gVXNlIHRvRml4ZWQoIG1heGltdW1GcmFjdGlvbkRpZ2l0cyApIHRvIG1ha2Ugc3VyZSBzbWFsbCBudW1iZXJzIGxpa2UgMWUtNyBhcmVcblx0XHQvLyBkaXNwbGF5ZWQgdXNpbmcgcGxhaW4gZGlnaXRzIGluc3RlYWQgb2Ygc2NpZW50aWZpYyBub3RhdGlvbi5cblx0XHQvLyAxOiBSZW1vdmUgbGVhZGluZyBkZWNpbWFsIHplcm9zLlxuXHRcdC8vIDI6IFJlbW92ZSBsZWFkaW5nIGRlY2ltYWwgc2VwYXJhdG9yLlxuXHRcdC8vIE5vdGU6IFN0cmluZygpIGlzIHN0aWxsIHByZWZlcnJlZCBzbyBpdCBkb2Vzbid0IG1lc3MgdXAgd2l0aCBhIG51bWJlciBwcmVjaXNpb25cblx0XHQvLyB1bm5lY2Vzc2FyaWx5LCBlLmcuLCAoMTIzNDU2Nzg5LjEyMykudG9GaXhlZCgxMCkgPT09IFwiMTIzNDU2Nzg5LjEyMjk5OTk5NTlcIixcblx0XHQvLyBTdHJpbmcoMTIzNDU2Nzg5LjEyMykgPT09IFwiMTIzNDU2Nzg5LjEyM1wiLlxuXHRcdG51bWJlciA9ICggK251bWJlciApLnRvRml4ZWQoIG1heGltdW1GcmFjdGlvbkRpZ2l0cyApXG5cdFx0XHQucmVwbGFjZSggLzArJC8sIFwiXCIgKSAvKiAxICovXG5cdFx0XHQucmVwbGFjZSggL1xcLiQvLCBcIlwiICkgLyogMiAqLztcblx0fVxuXG5cdC8vIE1pbmltdW0gZnJhY3Rpb24gZGlnaXRzIChwb3N0IHN0cmluZyBwaGFzZSlcblx0aWYgKCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgKSB7XG5cdFx0bnVtYmVyID0gbnVtYmVyLnNwbGl0KCBcIi5cIiApO1xuXHRcdG51bWJlclsgMSBdID0gc3RyaW5nUGFkKCBudW1iZXJbIDEgXSB8fCBcIlwiLCBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIHRydWUgKTtcblx0XHRudW1iZXIgPSBudW1iZXIuam9pbiggXCIuXCIgKTtcblx0fVxuXG5cdC8vIE1pbmltdW0gaW50ZWdlciBkaWdpdHNcblx0aWYgKCBtaW5pbXVtSW50ZWdlckRpZ2l0cyApIHtcblx0XHRudW1iZXIgPSBudW1iZXIuc3BsaXQoIFwiLlwiICk7XG5cdFx0bnVtYmVyWyAwIF0gPSBzdHJpbmdQYWQoIG51bWJlclsgMCBdLCBtaW5pbXVtSW50ZWdlckRpZ2l0cyApO1xuXHRcdG51bWJlciA9IG51bWJlci5qb2luKCBcIi5cIiApO1xuXHR9XG5cblx0cmV0dXJuIG51bWJlcjtcbn07XG5cblxuXG5cbi8qKlxuICogdG9QcmVjaXNpb24oIG51bWJlciwgcHJlY2lzaW9uLCByb3VuZCApXG4gKlxuICogQG51bWJlciAoTnVtYmVyKVxuICpcbiAqIEBwcmVjaXNpb24gKE51bWJlcikgc2lnbmlmaWNhbnQgZmlndXJlcyBwcmVjaXNpb24gKG5vdCBkZWNpbWFsIHByZWNpc2lvbikuXG4gKlxuICogQHJvdW5kIChGdW5jdGlvbilcbiAqXG4gKiBSZXR1cm4gbnVtYmVyLnRvUHJlY2lzaW9uKCBwcmVjaXNpb24gKSB1c2luZyB0aGUgZ2l2ZW4gcm91bmQgZnVuY3Rpb24uXG4gKi9cbnZhciBudW1iZXJUb1ByZWNpc2lvbiA9IGZ1bmN0aW9uKCBudW1iZXIsIHByZWNpc2lvbiwgcm91bmQgKSB7XG5cdHZhciByb3VuZE9yZGVyO1xuXG5cdC8vIEdldCBudW1iZXIgYXQgdHdvIGV4dHJhIHNpZ25pZmljYW50IGZpZ3VyZSBwcmVjaXNpb24uXG5cdG51bWJlciA9IG51bWJlci50b1ByZWNpc2lvbiggcHJlY2lzaW9uICsgMiApO1xuXG5cdC8vIFRoZW4sIHJvdW5kIGl0IHRvIHRoZSByZXF1aXJlZCBzaWduaWZpY2FudCBmaWd1cmUgcHJlY2lzaW9uLlxuXHRyb3VuZE9yZGVyID0gTWF0aC5jZWlsKCBNYXRoLmxvZyggTWF0aC5hYnMoIG51bWJlciApICkgLyBNYXRoLmxvZyggMTAgKSApO1xuXHRyb3VuZE9yZGVyIC09IHByZWNpc2lvbjtcblxuXHRyZXR1cm4gcm91bmQoIG51bWJlciwgeyBleHBvbmVudDogcm91bmRPcmRlciB9ICk7XG59O1xuXG5cblxuXG4vKipcbiAqIHRvUHJlY2lzaW9uKCBudW1iZXIsIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzLCByb3VuZCApXG4gKlxuICogQG51bWJlciBbTnVtYmVyXVxuICpcbiAqIEBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgW051bWJlcl1cbiAqXG4gKiBAbWF4aW11bVNpZ25pZmljYW50RGlnaXRzIFtOdW1iZXJdXG4gKlxuICogQHJvdW5kIFtGdW5jdGlvbl1cbiAqXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBzaWduaWZpY2FudCBkaWdpdHMgbnVtYmVyLlxuICovXG52YXIgbnVtYmVyRm9ybWF0U2lnbmlmaWNhbnREaWdpdHMgPSBmdW5jdGlvbiggbnVtYmVyLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cywgcm91bmQgKSB7XG5cdHZhciBhdE1pbmltdW0sIGF0TWF4aW11bTtcblxuXHQvLyBTYW5pdHkgY2hlY2suXG5cdGlmICggbWluaW11bVNpZ25pZmljYW50RGlnaXRzID4gbWF4aW11bVNpZ25pZmljYW50RGlnaXRzICkge1xuXHRcdG1heGltdW1TaWduaWZpY2FudERpZ2l0cyA9IG1pbmltdW1TaWduaWZpY2FudERpZ2l0cztcblx0fVxuXG5cdGF0TWluaW11bSA9IG51bWJlclRvUHJlY2lzaW9uKCBudW1iZXIsIG1pbmltdW1TaWduaWZpY2FudERpZ2l0cywgcm91bmQgKTtcblx0YXRNYXhpbXVtID0gbnVtYmVyVG9QcmVjaXNpb24oIG51bWJlciwgbWF4aW11bVNpZ25pZmljYW50RGlnaXRzLCByb3VuZCApO1xuXG5cdC8vIFVzZSBhdE1heGltdW0gb25seSBpZiBpdCBoYXMgbW9yZSBzaWduaWZpY2FudCBkaWdpdHMgdGhhbiBhdE1pbmltdW0uXG5cdG51bWJlciA9ICthdE1pbmltdW0gPT09ICthdE1heGltdW0gPyBhdE1pbmltdW0gOiBhdE1heGltdW07XG5cblx0Ly8gRXhwYW5kIGludGVnZXIgbnVtYmVycywgZWcuIDEyM2U1IHRvIDEyMzAwLlxuXHRudW1iZXIgPSAoICtudW1iZXIgKS50b1N0cmluZyggMTAgKTtcblxuXHRpZiAoICggL2UvICkudGVzdCggbnVtYmVyICkgKSB7XG5cdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0ZmVhdHVyZTogXCJpbnRlZ2VycyBvdXQgb2YgKDFlMjEsIDFlLTcpXCJcblx0XHR9KTtcblx0fVxuXG5cdC8vIEFkZCB0cmFpbGluZyB6ZXJvcyBpZiBuZWNlc3NhcnkuXG5cdGlmICggbWluaW11bVNpZ25pZmljYW50RGlnaXRzIC0gbnVtYmVyLnJlcGxhY2UoIC9eMCt8XFwuL2csIFwiXCIgKS5sZW5ndGggPiAwICkge1xuXHRcdG51bWJlciA9IG51bWJlci5zcGxpdCggXCIuXCIgKTtcblx0XHRudW1iZXJbIDEgXSA9IHN0cmluZ1BhZCggbnVtYmVyWyAxIF0gfHwgXCJcIiwgbWluaW11bVNpZ25pZmljYW50RGlnaXRzIC0gbnVtYmVyWyAwIF0ucmVwbGFjZSggL14wKy8sIFwiXCIgKS5sZW5ndGgsIHRydWUgKTtcblx0XHRudW1iZXIgPSBudW1iZXIuam9pbiggXCIuXCIgKTtcblx0fVxuXG5cdHJldHVybiBudW1iZXI7XG59O1xuXG5cblxuXG4vKipcbiAqIHJlbW92ZUxpdGVyYWxRdW90ZXMoIHN0cmluZyApXG4gKlxuICogUmV0dXJuOlxuICogLSBgYCBpZiBpbnB1dCBzdHJpbmcgaXMgYCcnYC5cbiAqIC0gYG8nY2xvY2tgIGlmIGlucHV0IHN0cmluZyBpcyBgJ28nJ2Nsb2NrJ2AuXG4gKiAtIGBmb29gIGlmIGlucHV0IHN0cmluZyBpcyBgZm9vYCwgaS5lLiwgcmV0dXJuIHRoZSBzYW1lIHZhbHVlIGluIGNhc2UgaXQgaXNuJ3QgYSBzaW5nbGUtcXVvdGVkXG4gKiAgIHN0cmluZy5cbiAqL1xudmFyIHJlbW92ZUxpdGVyYWxRdW90ZXMgPSBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRpZiAoIHN0cmluZ1sgMCBdICsgc3RyaW5nWyBzdHJpbmcubGVuZ3RoIC0gMSBdICE9PSBcIicnXCIgKSB7XG5cdFx0cmV0dXJuIHN0cmluZztcblx0fVxuXHRpZiAoIHN0cmluZyA9PT0gXCInJ1wiICkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggLycnL2csIFwiJ1wiICkuc2xpY2UoIDEsIC0xICk7XG59O1xuXG5cblxuXG4vKipcbiAqIGZvcm1hdCggbnVtYmVyLCBwcm9wZXJ0aWVzIClcbiAqXG4gKiBAbnVtYmVyIFtOdW1iZXJdLlxuICpcbiAqIEBwcm9wZXJ0aWVzIFtPYmplY3RdIE91dHB1dCBvZiBudW1iZXIvZm9ybWF0LXByb3BlcnRpZXMuXG4gKlxuICogUmV0dXJuIHRoZSBmb3JtYXR0ZWQgbnVtYmVyLlxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LW51bWJlcnMuaHRtbFxuICovXG52YXIgbnVtYmVyRm9ybWF0ID0gZnVuY3Rpb24oIG51bWJlciwgcHJvcGVydGllcyApIHtcblx0dmFyIGluZmluaXR5U3ltYm9sLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cywgbWluaW11bUZyYWN0aW9uRGlnaXRzLFxuXHRtaW5pbXVtSW50ZWdlckRpZ2l0cywgbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBuYW5TeW1ib2wsIG51RGlnaXRzTWFwLCBwYWRkaW5nLCBwcmVmaXgsXG5cdHByaW1hcnlHcm91cGluZ1NpemUsIHBhdHRlcm4sIHJldCwgcm91bmQsIHJvdW5kSW5jcmVtZW50LCBzZWNvbmRhcnlHcm91cGluZ1NpemUsIHN1ZmZpeCxcblx0c3ltYm9sTWFwO1xuXG5cdHBhZGRpbmcgPSBwcm9wZXJ0aWVzWyAxIF07XG5cdG1pbmltdW1JbnRlZ2VyRGlnaXRzID0gcHJvcGVydGllc1sgMiBdO1xuXHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBwcm9wZXJ0aWVzWyAzIF07XG5cdG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IHByb3BlcnRpZXNbIDQgXTtcblx0bWluaW11bVNpZ25pZmljYW50RGlnaXRzID0gcHJvcGVydGllc1sgNSBdO1xuXHRtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBwcm9wZXJ0aWVzWyA2IF07XG5cdHJvdW5kSW5jcmVtZW50ID0gcHJvcGVydGllc1sgNyBdO1xuXHRwcmltYXJ5R3JvdXBpbmdTaXplID0gcHJvcGVydGllc1sgOCBdO1xuXHRzZWNvbmRhcnlHcm91cGluZ1NpemUgPSBwcm9wZXJ0aWVzWyA5IF07XG5cdHJvdW5kID0gcHJvcGVydGllc1sgMTUgXTtcblx0aW5maW5pdHlTeW1ib2wgPSBwcm9wZXJ0aWVzWyAxNiBdO1xuXHRuYW5TeW1ib2wgPSBwcm9wZXJ0aWVzWyAxNyBdO1xuXHRzeW1ib2xNYXAgPSBwcm9wZXJ0aWVzWyAxOCBdO1xuXHRudURpZ2l0c01hcCA9IHByb3BlcnRpZXNbIDE5IF07XG5cblx0Ly8gTmFOXG5cdGlmICggaXNOYU4oIG51bWJlciApICkge1xuXHRcdHJldHVybiBuYW5TeW1ib2w7XG5cdH1cblxuXHRpZiAoIG51bWJlciA8IDAgKSB7XG5cdFx0cGF0dGVybiA9IHByb3BlcnRpZXNbIDEyIF07XG5cdFx0cHJlZml4ID0gcHJvcGVydGllc1sgMTMgXTtcblx0XHRzdWZmaXggPSBwcm9wZXJ0aWVzWyAxNCBdO1xuXHR9IGVsc2Uge1xuXHRcdHBhdHRlcm4gPSBwcm9wZXJ0aWVzWyAxMSBdO1xuXHRcdHByZWZpeCA9IHByb3BlcnRpZXNbIDAgXTtcblx0XHRzdWZmaXggPSBwcm9wZXJ0aWVzWyAxMCBdO1xuXHR9XG5cblx0Ly8gSW5maW5pdHlcblx0aWYgKCAhaXNGaW5pdGUoIG51bWJlciApICkge1xuXHRcdHJldHVybiBwcmVmaXggKyBpbmZpbml0eVN5bWJvbCArIHN1ZmZpeDtcblx0fVxuXG5cdHJldCA9IHByZWZpeDtcblxuXHQvLyBQZXJjZW50XG5cdGlmICggcGF0dGVybi5pbmRleE9mKCBcIiVcIiApICE9PSAtMSApIHtcblx0XHRudW1iZXIgKj0gMTAwO1xuXG5cdC8vIFBlciBtaWxsZVxuXHR9IGVsc2UgaWYgKCBwYXR0ZXJuLmluZGV4T2YoIFwiXFx1MjAzMFwiICkgIT09IC0xICkge1xuXHRcdG51bWJlciAqPSAxMDAwO1xuXHR9XG5cblx0Ly8gU2lnbmlmaWNhbnQgZGlnaXQgZm9ybWF0XG5cdGlmICggIWlzTmFOKCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgKiBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgKSApIHtcblx0XHRudW1iZXIgPSBudW1iZXJGb3JtYXRTaWduaWZpY2FudERpZ2l0cyggbnVtYmVyLCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsXG5cdFx0XHRtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsIHJvdW5kICk7XG5cblx0Ly8gSW50ZWdlciBhbmQgZnJhY3Rpb25hbCBmb3JtYXRcblx0fSBlbHNlIHtcblx0XHRudW1iZXIgPSBudW1iZXJGb3JtYXRJbnRlZ2VyRnJhY3Rpb25EaWdpdHMoIG51bWJlciwgbWluaW11bUludGVnZXJEaWdpdHMsXG5cdFx0XHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1GcmFjdGlvbkRpZ2l0cywgcm91bmQsIHJvdW5kSW5jcmVtZW50ICk7XG5cdH1cblxuXHQvLyBSZW1vdmUgdGhlIHBvc3NpYmxlIG51bWJlciBtaW51cyBzaWduXG5cdG51bWJlciA9IG51bWJlci5yZXBsYWNlKCAvXi0vLCBcIlwiICk7XG5cblx0Ly8gR3JvdXBpbmcgc2VwYXJhdG9yc1xuXHRpZiAoIHByaW1hcnlHcm91cGluZ1NpemUgKSB7XG5cdFx0bnVtYmVyID0gbnVtYmVyRm9ybWF0R3JvdXBpbmdTZXBhcmF0b3IoIG51bWJlciwgcHJpbWFyeUdyb3VwaW5nU2l6ZSxcblx0XHRcdHNlY29uZGFyeUdyb3VwaW5nU2l6ZSApO1xuXHR9XG5cblx0cmV0ICs9IG51bWJlcjtcblxuXHQvLyBTY2llbnRpZmljIG5vdGF0aW9uXG5cdC8vIFRPRE8gaW1wbGVtZW50IGhlcmVcblxuXHQvLyBQYWRkaW5nLycoW14nXXwnJykrJ3wnJ3xbLixcXC0rRSVcXHUyMDMwXS9nXG5cdC8vIFRPRE8gaW1wbGVtZW50IGhlcmVcblxuXHRyZXQgKz0gc3VmZml4O1xuXG5cdHJldHVybiByZXQucmVwbGFjZSggLygnKFteJ118JycpKyd8JycpfC4vZywgZnVuY3Rpb24oIGNoYXJhY3RlciwgbGl0ZXJhbCApIHtcblxuXHRcdC8vIExpdGVyYWxzXG5cdFx0aWYgKCBsaXRlcmFsICkge1xuXHRcdFx0cmV0dXJuIHJlbW92ZUxpdGVyYWxRdW90ZXMoIGxpdGVyYWwgKTtcblx0XHR9XG5cblx0XHQvLyBTeW1ib2xzXG5cdFx0Y2hhcmFjdGVyID0gY2hhcmFjdGVyLnJlcGxhY2UoIC9bLixcXC0rRSVcXHUyMDMwXS8sIGZ1bmN0aW9uKCBzeW1ib2wgKSB7XG5cdFx0XHRyZXR1cm4gc3ltYm9sTWFwWyBzeW1ib2wgXTtcblx0XHR9KTtcblxuXHRcdC8vIE51bWJlcmluZyBzeXN0ZW1cblx0XHRpZiAoIG51RGlnaXRzTWFwICkge1xuXHRcdFx0Y2hhcmFjdGVyID0gY2hhcmFjdGVyLnJlcGxhY2UoIC9bMC05XS8sIGZ1bmN0aW9uKCBkaWdpdCApIHtcblx0XHRcdFx0cmV0dXJuIG51RGlnaXRzTWFwWyArZGlnaXQgXTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiBjaGFyYWN0ZXI7XG5cdH0pO1xufTtcblxuXG5cblxudmFyIG51bWJlckZvcm1hdHRlckZuID0gZnVuY3Rpb24oIHByb3BlcnRpZXMgKSB7XG5cdHJldHVybiBmdW5jdGlvbiBudW1iZXJGb3JtYXR0ZXIoIHZhbHVlICkge1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRcdHJldHVybiBudW1iZXJGb3JtYXQoIHZhbHVlLCBwcm9wZXJ0aWVzICk7XG5cdH07XG59O1xuXG5cblxuXG4vKipcbiAqIE51bWJlcmluZ1N5c3RlbSggY2xkciApXG4gKlxuICogLSBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LW51bWJlcnMuaHRtbCNvdGhlck51bWJlcmluZ1N5c3RlbXNcbiAqIC0gaHR0cDovL2NsZHIudW5pY29kZS5vcmcvaW5kZXgvYmNwNDctZXh0ZW5zaW9uXG4gKiAtIGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1LyN1X0V4dGVuc2lvblxuICovXG52YXIgbnVtYmVyTnVtYmVyaW5nU3lzdGVtID0gZnVuY3Rpb24oIGNsZHIgKSB7XG5cdHZhciBudSA9IGNsZHIuYXR0cmlidXRlc1sgXCJ1LW51XCIgXTtcblxuXHRpZiAoIG51ICkge1xuXHRcdGlmICggbnUgPT09IFwidHJhZGl0aW9cIiApIHtcblx0XHRcdG51ID0gXCJ0cmFkaXRpb25hbFwiO1xuXHRcdH1cblx0XHRpZiAoIFsgXCJuYXRpdmVcIiwgXCJ0cmFkaXRpb25hbFwiLCBcImZpbmFuY2VcIiBdLmluZGV4T2YoIG51ICkgIT09IC0xICkge1xuXG5cdFx0XHQvLyBVbmljb2RlIGxvY2FsZSBleHRlbnNpb24gYHUtbnVgIGlzIHNldCB1c2luZyBlaXRoZXIgKG5hdGl2ZSwgdHJhZGl0aW9uYWwgb3Jcblx0XHRcdC8vIGZpbmFuY2UpLiBTbywgbG9va3VwIHRoZSByZXNwZWN0aXZlIGxvY2FsZSdzIG51bWJlcmluZ1N5c3RlbSBhbmQgcmV0dXJuIGl0LlxuXHRcdFx0cmV0dXJuIGNsZHIubWFpbihbIFwibnVtYmVycy9vdGhlck51bWJlcmluZ1N5c3RlbXNcIiwgbnUgXSk7XG5cdFx0fVxuXG5cdFx0Ly8gVW5pY29kZSBsb2NhbGUgZXh0ZW5zaW9uIGB1LW51YCBpcyBzZXQgd2l0aCBhbiBleHBsaWNpdCBudW1iZXJpbmdTeXN0ZW0uIFJldHVybiBpdC5cblx0XHRyZXR1cm4gbnU7XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGRlZmF1bHQgbnVtYmVyaW5nU3lzdGVtLlxuXHRyZXR1cm4gY2xkci5tYWluKCBcIm51bWJlcnMvZGVmYXVsdE51bWJlcmluZ1N5c3RlbVwiICk7XG59O1xuXG5cblxuXG4vKipcbiAqIG51TWFwKCBjbGRyIClcbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogUmV0dXJuIGRpZ2l0cyBtYXAgaWYgbnVtYmVyaW5nIHN5c3RlbSBpcyBkaWZmZXJlbnQgdGhhbiBgbGF0bmAuXG4gKi9cbnZhciBudW1iZXJOdW1iZXJpbmdTeXN0ZW1EaWdpdHNNYXAgPSBmdW5jdGlvbiggY2xkciApIHtcblx0dmFyIGF1eCxcblx0XHRudSA9IG51bWJlck51bWJlcmluZ1N5c3RlbSggY2xkciApO1xuXG5cdGlmICggbnUgPT09IFwibGF0blwiICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGF1eCA9IGNsZHIuc3VwcGxlbWVudGFsKFsgXCJudW1iZXJpbmdTeXN0ZW1zXCIsIG51IF0pO1xuXG5cdGlmICggYXV4Ll90eXBlICE9PSBcIm51bWVyaWNcIiApIHtcblx0XHR0aHJvdyBjcmVhdGVFcnJvclVuc3VwcG9ydGVkRmVhdHVyZSggXCJgXCIgKyBhdXguX3R5cGUgKyBcImAgbnVtYmVyaW5nIHN5c3RlbVwiICk7XG5cdH1cblxuXHRyZXR1cm4gYXV4Ll9kaWdpdHM7XG59O1xuXG5cblxuXG4vKipcbiAqIEVCTkYgcmVwcmVzZW50YXRpb246XG4gKlxuICogbnVtYmVyX3BhdHRlcm5fcmUgPSAgICAgICAgcHJlZml4P1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFkZGluZz9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIChpbnRlZ2VyX2ZyYWN0aW9uX3BhdHRlcm4gfCBzaWduaWZpY2FudF9wYXR0ZXJuKVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NpZW50aWZpY19ub3RhdGlvbj9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1ZmZpeD9cbiAqXG4gKiBwcmVmaXggPSAgICAgICAgICAgICAgICAgICBub25fbnVtYmVyX3N0dWZmXG4gKlxuICogcGFkZGluZyA9ICAgICAgICAgICAgICAgICAgXCIqXCIgcmVnZXhwKC4pXG4gKlxuICogaW50ZWdlcl9mcmFjdGlvbl9wYXR0ZXJuID0gaW50ZWdlcl9wYXR0ZXJuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcmFjdGlvbl9wYXR0ZXJuP1xuICpcbiAqIGludGVnZXJfcGF0dGVybiA9ICAgICAgICAgIHJlZ2V4cChbIyxdKlswLF0qMCspXG4gKlxuICogZnJhY3Rpb25fcGF0dGVybiA9ICAgICAgICAgXCIuXCIgcmVnZXhwKDAqWzAtOV0qIyopXG4gKlxuICogc2lnbmlmaWNhbnRfcGF0dGVybiA9ICAgICAgcmVnZXhwKFsjLF0qQCsjKilcbiAqXG4gKiBzY2llbnRpZmljX25vdGF0aW9uID0gICAgICByZWdleHAoRVxcKz8wKylcbiAqXG4gKiBzdWZmaXggPSAgICAgICAgICAgICAgICAgICBub25fbnVtYmVyX3N0dWZmXG4gKlxuICogbm9uX251bWJlcl9zdHVmZiA9ICAgICAgICAgcmVnZXhwKCgnW14nXSsnfCcnfFteKiNAMCwuRV0pKilcbiAqXG4gKlxuICogUmVnZXhwIGdyb3VwczpcbiAqXG4gKiAgMDogbnVtYmVyX3BhdHRlcm5fcmVcbiAqICAxOiBwcmVmaXhcbiAqICAyOiAtXG4gKiAgMzogLVxuICogIDQ6IHBhZGRpbmdcbiAqICA1OiAoaW50ZWdlcl9mcmFjdGlvbl9wYXR0ZXJuIHwgc2lnbmlmaWNhbnRfcGF0dGVybilcbiAqICA2OiBpbnRlZ2VyX2ZyYWN0aW9uX3BhdHRlcm5cbiAqICA3OiBpbnRlZ2VyX3BhdHRlcm5cbiAqICA4OiBmcmFjdGlvbl9wYXR0ZXJuXG4gKiAgOTogc2lnbmlmaWNhbnRfcGF0dGVyblxuICogMTA6IHNjaWVudGlmaWNfbm90YXRpb25cbiAqIDExOiBzdWZmaXhcbiAqIDEyOiAtXG4gKi9cbnZhciBudW1iZXJQYXR0ZXJuUmUgPSAoIC9eKCgnKFteJ118JycpKid8W14qI0AwLC5FXSkqKShcXCouKT8oKChbIyxdKlswLF0qMCspKFxcLjAqWzAtOV0qIyopPyl8KFsjLF0qQCsjKikpKEVcXCs/MCspPygoJ1teJ10rJ3wnJ3xbXiojQDAsLkVdKSopJC8gKTtcblxuXG5cblxuLyoqXG4gKiBmb3JtYXQoIG51bWJlciwgcGF0dGVybiApXG4gKlxuICogQG51bWJlciBbTnVtYmVyXS5cbiAqXG4gKiBAcGF0dGVybiBbU3RyaW5nXSByYXcgcGF0dGVybiBmb3IgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm4gdGhlIGZvcm1hdHRlZCBudW1iZXIuXG4gKiByZWY6IGh0dHA6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM1L3RyMzUtbnVtYmVycy5odG1sXG4gKi9cbnZhciBudW1iZXJQYXR0ZXJuUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBwYXR0ZXJuICkge1xuXHR2YXIgYXV4MSwgYXV4MiwgZnJhY3Rpb25QYXR0ZXJuLCBpbnRlZ2VyRnJhY3Rpb25PclNpZ25pZmljYW50UGF0dGVybiwgaW50ZWdlclBhdHRlcm4sXG5cdFx0bWF4aW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyxcblx0XHRtaW5pbXVtSW50ZWdlckRpZ2l0cywgbWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBwYWRkaW5nLCBwcmVmaXgsIHByaW1hcnlHcm91cGluZ1NpemUsXG5cdFx0cm91bmRJbmNyZW1lbnQsIHNjaWVudGlmaWNOb3RhdGlvbiwgc2Vjb25kYXJ5R3JvdXBpbmdTaXplLCBzaWduaWZpY2FudFBhdHRlcm4sIHN1ZmZpeDtcblxuXHRwYXR0ZXJuID0gcGF0dGVybi5tYXRjaCggbnVtYmVyUGF0dGVyblJlICk7XG5cdGlmICggIXBhdHRlcm4gKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBcIkludmFsaWQgcGF0dGVybjogXCIgKyBwYXR0ZXJuICk7XG5cdH1cblxuXHRwcmVmaXggPSBwYXR0ZXJuWyAxIF07XG5cdHBhZGRpbmcgPSBwYXR0ZXJuWyA0IF07XG5cdGludGVnZXJGcmFjdGlvbk9yU2lnbmlmaWNhbnRQYXR0ZXJuID0gcGF0dGVyblsgNSBdO1xuXHRzaWduaWZpY2FudFBhdHRlcm4gPSBwYXR0ZXJuWyA5IF07XG5cdHNjaWVudGlmaWNOb3RhdGlvbiA9IHBhdHRlcm5bIDEwIF07XG5cdHN1ZmZpeCA9IHBhdHRlcm5bIDExIF07XG5cblx0Ly8gU2lnbmlmaWNhbnQgZGlnaXQgZm9ybWF0XG5cdGlmICggc2lnbmlmaWNhbnRQYXR0ZXJuICkge1xuXHRcdHNpZ25pZmljYW50UGF0dGVybi5yZXBsYWNlKCAvKEArKSgjKikvLCBmdW5jdGlvbiggbWF0Y2gsIG1pbmltdW1TaWduaWZpY2FudERpZ2l0c01hdGNoLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHNNYXRjaCApIHtcblx0XHRcdG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyA9IG1pbmltdW1TaWduaWZpY2FudERpZ2l0c01hdGNoLmxlbmd0aDtcblx0XHRcdG1heGltdW1TaWduaWZpY2FudERpZ2l0cyA9IG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyArXG5cdFx0XHRcdG1heGltdW1TaWduaWZpY2FudERpZ2l0c01hdGNoLmxlbmd0aDtcblx0XHR9KTtcblxuXHQvLyBJbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIGZvcm1hdFxuXHR9IGVsc2Uge1xuXHRcdGZyYWN0aW9uUGF0dGVybiA9IHBhdHRlcm5bIDggXTtcblx0XHRpbnRlZ2VyUGF0dGVybiA9IHBhdHRlcm5bIDcgXTtcblxuXHRcdGlmICggZnJhY3Rpb25QYXR0ZXJuICkge1xuXG5cdFx0XHQvLyBNaW5pbXVtIGZyYWN0aW9uIGRpZ2l0cywgYW5kIHJvdW5kaW5nLlxuXHRcdFx0ZnJhY3Rpb25QYXR0ZXJuLnJlcGxhY2UoIC9bMC05XSsvLCBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRcdG1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IG1hdGNoO1xuXHRcdFx0fSk7XG5cdFx0XHRpZiAoIG1pbmltdW1GcmFjdGlvbkRpZ2l0cyApIHtcblx0XHRcdFx0cm91bmRJbmNyZW1lbnQgPSArKCBcIjAuXCIgKyBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgKTtcblx0XHRcdFx0bWluaW11bUZyYWN0aW9uRGlnaXRzID0gbWluaW11bUZyYWN0aW9uRGlnaXRzLmxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG1pbmltdW1GcmFjdGlvbkRpZ2l0cyA9IDA7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1heGltdW0gZnJhY3Rpb24gZGlnaXRzXG5cdFx0XHQvLyAxOiBpZ25vcmUgZGVjaW1hbCBjaGFyYWN0ZXJcblx0XHRcdG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IGZyYWN0aW9uUGF0dGVybi5sZW5ndGggLSAxIC8qIDEgKi87XG5cdFx0fVxuXG5cdFx0Ly8gTWluaW11bSBpbnRlZ2VyIGRpZ2l0c1xuXHRcdGludGVnZXJQYXR0ZXJuLnJlcGxhY2UoIC8wKyQvLCBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtaW5pbXVtSW50ZWdlckRpZ2l0cyA9IG1hdGNoLmxlbmd0aDtcblx0XHR9KTtcblx0fVxuXG5cdC8vIFNjaWVudGlmaWMgbm90YXRpb25cblx0aWYgKCBzY2llbnRpZmljTm90YXRpb24gKSB7XG5cdFx0dGhyb3cgY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmUoe1xuXHRcdFx0ZmVhdHVyZTogXCJzY2llbnRpZmljIG5vdGF0aW9uIChub3QgaW1wbGVtZW50ZWQpXCJcblx0XHR9KTtcblx0fVxuXG5cdC8vIFBhZGRpbmdcblx0aWYgKCBwYWRkaW5nICkge1xuXHRcdHRocm93IGNyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlKHtcblx0XHRcdGZlYXR1cmU6IFwicGFkZGluZyAobm90IGltcGxlbWVudGVkKVwiXG5cdFx0fSk7XG5cdH1cblxuXHQvLyBHcm91cGluZ1xuXHRpZiAoICggYXV4MSA9IGludGVnZXJGcmFjdGlvbk9yU2lnbmlmaWNhbnRQYXR0ZXJuLmxhc3RJbmRleE9mKCBcIixcIiApICkgIT09IC0xICkge1xuXG5cdFx0Ly8gUHJpbWFyeSBncm91cGluZyBzaXplIGlzIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZSBsYXN0IGdyb3VwIHNlcGFyYXRvciBhbmQgdGhlIGVuZCBvZlxuXHRcdC8vIHRoZSBpbnRlZ2VyIChvciB0aGUgZW5kIG9mIHRoZSBzaWduaWZpY2FudCBwYXR0ZXJuKS5cblx0XHRhdXgyID0gaW50ZWdlckZyYWN0aW9uT3JTaWduaWZpY2FudFBhdHRlcm4uc3BsaXQoIFwiLlwiIClbIDAgXTtcblx0XHRwcmltYXJ5R3JvdXBpbmdTaXplID0gYXV4Mi5sZW5ndGggLSBhdXgxIC0gMTtcblxuXHRcdC8vIFNlY29uZGFyeSBncm91cGluZyBzaXplIGlzIHRoZSBpbnRlcnZhbCBiZXR3ZWVuIHRoZSBsYXN0IHR3byBncm91cCBzZXBhcmF0b3JzLlxuXHRcdGlmICggKCBhdXgyID0gaW50ZWdlckZyYWN0aW9uT3JTaWduaWZpY2FudFBhdHRlcm4ubGFzdEluZGV4T2YoIFwiLFwiLCBhdXgxIC0gMSApICkgIT09IC0xICkge1xuXHRcdFx0c2Vjb25kYXJ5R3JvdXBpbmdTaXplID0gYXV4MSAtIDEgLSBhdXgyO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybjpcblx0Ly8gIDA6IEBwcmVmaXggU3RyaW5nXG5cdC8vICAxOiBAcGFkZGluZyBBcnJheSBbIDxjaGFyYWN0ZXI+LCA8Y291bnQ+IF0gVE9ET1xuXHQvLyAgMjogQG1pbmltdW1JbnRlZ2VyRGlnaXRzIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIE51bWJlciB2YWx1ZSBpbmRpY2F0aW5nIHRoZSBtaW5pbXVtIGludGVnZXJcblx0Ly8gICAgICAgIGRpZ2l0cyB0byBiZSB1c2VkLiBOdW1iZXJzIHdpbGwgYmUgcGFkZGVkIHdpdGggbGVhZGluZyB6ZXJvZXMgaWYgbmVjZXNzYXJ5LlxuXHQvLyAgMzogQG1pbmltdW1GcmFjdGlvbkRpZ2l0cyBhbmRcblx0Ly8gIDQ6IEBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgYXJlIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyIE51bWJlciB2YWx1ZXMgaW5kaWNhdGluZyB0aGUgbWluaW11bSBhbmRcblx0Ly8gICAgICAgIG1heGltdW0gZnJhY3Rpb24gZGlnaXRzIHRvIGJlIHVzZWQuIE51bWJlcnMgd2lsbCBiZSByb3VuZGVkIG9yIHBhZGRlZCB3aXRoIHRyYWlsaW5nXG5cdC8vICAgICAgICB6ZXJvZXMgaWYgbmVjZXNzYXJ5LlxuXHQvLyAgNTogQG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyBhbmRcblx0Ly8gIDY6IEBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgYXJlIHBvc2l0aXZlIGludGVnZXIgTnVtYmVyIHZhbHVlcyBpbmRpY2F0aW5nIHRoZSBtaW5pbXVtIGFuZFxuXHQvLyAgICAgICAgbWF4aW11bSBmcmFjdGlvbiBkaWdpdHMgdG8gYmUgc2hvd24uIEVpdGhlciBub25lIG9yIGJvdGggb2YgdGhlc2UgcHJvcGVydGllcyBhcmVcblx0Ly8gICAgICAgIHByZXNlbnQ7IGlmIHRoZXkgYXJlLCB0aGV5IG92ZXJyaWRlIG1pbmltdW0gYW5kIG1heGltdW0gaW50ZWdlciBhbmQgZnJhY3Rpb24gZGlnaXRzXG5cdC8vICAgICAgICDigJMgdGhlIGZvcm1hdHRlciB1c2VzIGhvd2V2ZXIgbWFueSBpbnRlZ2VyIGFuZCBmcmFjdGlvbiBkaWdpdHMgYXJlIHJlcXVpcmVkIHRvIGRpc3BsYXlcblx0Ly8gICAgICAgIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cy5cblx0Ly8gIDc6IEByb3VuZEluY3JlbWVudCBEZWNpbWFsIHJvdW5kIGluY3JlbWVudCBvciBudWxsXG5cdC8vICA4OiBAcHJpbWFyeUdyb3VwaW5nU2l6ZVxuXHQvLyAgOTogQHNlY29uZGFyeUdyb3VwaW5nU2l6ZVxuXHQvLyAxMDogQHN1ZmZpeCBTdHJpbmdcblx0cmV0dXJuIFtcblx0XHRwcmVmaXgsXG5cdFx0cGFkZGluZyxcblx0XHRtaW5pbXVtSW50ZWdlckRpZ2l0cyxcblx0XHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMsXG5cdFx0bWF4aW11bUZyYWN0aW9uRGlnaXRzLFxuXHRcdG1pbmltdW1TaWduaWZpY2FudERpZ2l0cyxcblx0XHRtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsXG5cdFx0cm91bmRJbmNyZW1lbnQsXG5cdFx0cHJpbWFyeUdyb3VwaW5nU2l6ZSxcblx0XHRzZWNvbmRhcnlHcm91cGluZ1NpemUsXG5cdFx0c3VmZml4XG5cdF07XG59O1xuXG5cblxuXG4vKipcbiAqIFN5bWJvbCggbmFtZSwgY2xkciApXG4gKlxuICogQG5hbWUgW1N0cmluZ10gU3ltYm9sIG5hbWUuXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIFJldHVybiB0aGUgbG9jYWxpemVkIHN5bWJvbCBnaXZlbiBpdHMgbmFtZS5cbiAqL1xudmFyIG51bWJlclN5bWJvbCA9IGZ1bmN0aW9uKCBuYW1lLCBjbGRyICkge1xuXHRyZXR1cm4gY2xkci5tYWluKFtcblx0XHRcIm51bWJlcnMvc3ltYm9scy1udW1iZXJTeXN0ZW0tXCIgKyBudW1iZXJOdW1iZXJpbmdTeXN0ZW0oIGNsZHIgKSxcblx0XHRuYW1lXG5cdF0pO1xufTtcblxuXG5cblxudmFyIG51bWJlclN5bWJvbE5hbWUgPSB7XG5cdFwiLlwiOiBcImRlY2ltYWxcIixcblx0XCIsXCI6IFwiZ3JvdXBcIixcblx0XCIlXCI6IFwicGVyY2VudFNpZ25cIixcblx0XCIrXCI6IFwicGx1c1NpZ25cIixcblx0XCItXCI6IFwibWludXNTaWduXCIsXG5cdFwiRVwiOiBcImV4cG9uZW50aWFsXCIsXG5cdFwiXFx1MjAzMFwiOiBcInBlck1pbGxlXCJcbn07XG5cblxuXG5cbi8qKlxuICogc3ltYm9sTWFwKCBjbGRyIClcbiAqXG4gKiBAY2xkciBbQ2xkciBpbnN0YW5jZV0uXG4gKlxuICogUmV0dXJuIHRoZSAobG9jYWxpemVkIHN5bWJvbCwgcGF0dGVybiBzeW1ib2wpIGtleSB2YWx1ZSBwYWlyLCBlZy4ge1xuICogICBcIi5cIjogXCLZq1wiLFxuICogICBcIixcIjogXCLZrFwiLFxuICogICBcIiVcIjogXCLZqlwiLFxuICogICAuLi5cbiAqIH07XG4gKi9cbnZhciBudW1iZXJTeW1ib2xNYXAgPSBmdW5jdGlvbiggY2xkciApIHtcblx0dmFyIHN5bWJvbCxcblx0XHRzeW1ib2xNYXAgPSB7fTtcblxuXHRmb3IgKCBzeW1ib2wgaW4gbnVtYmVyU3ltYm9sTmFtZSApIHtcblx0XHRzeW1ib2xNYXBbIHN5bWJvbCBdID0gbnVtYmVyU3ltYm9sKCBudW1iZXJTeW1ib2xOYW1lWyBzeW1ib2wgXSwgY2xkciApO1xuXHR9XG5cblx0cmV0dXJuIHN5bWJvbE1hcDtcbn07XG5cblxuXG5cbnZhciBudW1iZXJUcnVuY2F0ZSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcblx0XHRyZXR1cm4gTmFOO1xuXHR9XG5cdHJldHVybiBNYXRoWyB2YWx1ZSA8IDAgPyBcImNlaWxcIiA6IFwiZmxvb3JcIiBdKCB2YWx1ZSApO1xufTtcblxuXG5cblxuLyoqXG4gKiByb3VuZCggbWV0aG9kIClcbiAqXG4gKiBAbWV0aG9kIFtTdHJpbmddIHdpdGggZWl0aGVyIFwicm91bmRcIiwgXCJjZWlsXCIsIFwiZmxvb3JcIiwgb3IgXCJ0cnVuY2F0ZVwiLlxuICpcbiAqIFJldHVybiBmdW5jdGlvbiggdmFsdWUsIGluY3JlbWVudE9yRXhwICk6XG4gKlxuICogICBAdmFsdWUgW051bWJlcl0gZWcuIDEyMy40NS5cbiAqXG4gKiAgIEBpbmNyZW1lbnRPckV4cCBbTnVtYmVyXSBvcHRpb25hbCwgZWcuIDAuMTsgb3JcbiAqICAgICBbT2JqZWN0XSBFaXRoZXIgeyBpbmNyZW1lbnQ6IDx2YWx1ZT4gfSBvciB7IGV4cG9uZW50OiA8dmFsdWU+IH1cbiAqXG4gKiAgIFJldHVybiB0aGUgcm91bmRlZCBudW1iZXIsIGVnOlxuICogICAtIHJvdW5kKCBcInJvdW5kXCIgKSggMTIzLjQ1ICk6IDEyMztcbiAqICAgLSByb3VuZCggXCJjZWlsXCIgKSggMTIzLjQ1ICk6IDEyNDtcbiAqICAgLSByb3VuZCggXCJmbG9vclwiICkoIDEyMy40NSApOiAxMjM7XG4gKiAgIC0gcm91bmQoIFwidHJ1bmNhdGVcIiApKCAxMjMuNDUgKTogMTIzO1xuICogICAtIHJvdW5kKCBcInJvdW5kXCIgKSggMTIzLjQ1LCAwLjEgKTogMTIzLjU7XG4gKiAgIC0gcm91bmQoIFwicm91bmRcIiApKCAxMjMuNDUsIDEwICk6IDEyMDtcbiAqXG4gKiAgIEJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL01hdGgvcm91bmRcbiAqICAgUmVmOiAjMzc2XG4gKi9cbnZhciBudW1iZXJSb3VuZCA9IGZ1bmN0aW9uKCBtZXRob2QgKSB7XG5cdG1ldGhvZCA9IG1ldGhvZCB8fCBcInJvdW5kXCI7XG5cdG1ldGhvZCA9IG1ldGhvZCA9PT0gXCJ0cnVuY2F0ZVwiID8gbnVtYmVyVHJ1bmNhdGUgOiBNYXRoWyBtZXRob2QgXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlLCBpbmNyZW1lbnRPckV4cCApIHtcblx0XHR2YXIgZXhwLCBpbmNyZW1lbnQ7XG5cblx0XHR2YWx1ZSA9ICt2YWx1ZTtcblxuXHRcdC8vIElmIHRoZSB2YWx1ZSBpcyBub3QgYSBudW1iZXIsIHJldHVybiBOYU4uXG5cdFx0aWYgKCBpc05hTiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiBOYU47XG5cdFx0fVxuXG5cdFx0Ly8gRXhwb25lbnQgZ2l2ZW4uXG5cdFx0aWYgKCB0eXBlb2YgaW5jcmVtZW50T3JFeHAgPT09IFwib2JqZWN0XCIgJiYgaW5jcmVtZW50T3JFeHAuZXhwb25lbnQgKSB7XG5cdFx0XHRleHAgPSAraW5jcmVtZW50T3JFeHAuZXhwb25lbnQ7XG5cdFx0XHRpbmNyZW1lbnQgPSAxO1xuXG5cdFx0XHRpZiAoIGV4cCA9PT0gMCApIHtcblx0XHRcdFx0cmV0dXJuIG1ldGhvZCggdmFsdWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGV4cCBpcyBub3QgYW4gaW50ZWdlciwgcmV0dXJuIE5hTi5cblx0XHRcdGlmICggISggdHlwZW9mIGV4cCA9PT0gXCJudW1iZXJcIiAmJiBleHAgJSAxID09PSAwICkgKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9XG5cblx0XHQvLyBJbmNyZW1lbnQgZ2l2ZW4uXG5cdFx0fSBlbHNlIHtcblx0XHRcdGluY3JlbWVudCA9ICtpbmNyZW1lbnRPckV4cCB8fCAxO1xuXG5cdFx0XHRpZiAoIGluY3JlbWVudCA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIG1ldGhvZCggdmFsdWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhlIGluY3JlbWVudCBpcyBub3QgYSBudW1iZXIsIHJldHVybiBOYU4uXG5cdFx0XHRpZiAoIGlzTmFOKCBpbmNyZW1lbnQgKSApIHtcblx0XHRcdFx0cmV0dXJuIE5hTjtcblx0XHRcdH1cblxuXHRcdFx0aW5jcmVtZW50ID0gaW5jcmVtZW50LnRvRXhwb25lbnRpYWwoKS5zcGxpdCggXCJlXCIgKTtcblx0XHRcdGV4cCA9ICtpbmNyZW1lbnRbIDEgXTtcblx0XHRcdGluY3JlbWVudCA9ICtpbmNyZW1lbnRbIDAgXTtcblx0XHR9XG5cblx0XHQvLyBTaGlmdCAmIFJvdW5kXG5cdFx0dmFsdWUgPSB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCBcImVcIiApO1xuXHRcdHZhbHVlWyAwIF0gPSArdmFsdWVbIDAgXSAvIGluY3JlbWVudDtcblx0XHR2YWx1ZVsgMSBdID0gdmFsdWVbIDEgXSA/ICggK3ZhbHVlWyAxIF0gLSBleHAgKSA6IC1leHA7XG5cdFx0dmFsdWUgPSBtZXRob2QoICsoIHZhbHVlWyAwIF0gKyBcImVcIiArIHZhbHVlWyAxIF0gKSApO1xuXG5cdFx0Ly8gU2hpZnQgYmFja1xuXHRcdHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKS5zcGxpdCggXCJlXCIgKTtcblx0XHR2YWx1ZVsgMCBdID0gK3ZhbHVlWyAwIF0gKiBpbmNyZW1lbnQ7XG5cdFx0dmFsdWVbIDEgXSA9IHZhbHVlWyAxIF0gPyAoICt2YWx1ZVsgMSBdICsgZXhwICkgOiBleHA7XG5cdFx0cmV0dXJuICsoIHZhbHVlWyAwIF0gKyBcImVcIiArIHZhbHVlWyAxIF0gKTtcblx0fTtcbn07XG5cblxuXG5cbi8qKlxuICogZm9ybWF0UHJvcGVydGllcyggcGF0dGVybiwgY2xkciBbLCBvcHRpb25zXSApXG4gKlxuICogQHBhdHRlcm4gW1N0cmluZ10gcmF3IHBhdHRlcm4gZm9yIG51bWJlcnMuXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdOlxuICogLSBtaW5pbXVtSW50ZWdlckRpZ2l0cyBbTnVtYmVyXVxuICogLSBtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIG1heGltdW1GcmFjdGlvbkRpZ2l0cyBbTnVtYmVyXVxuICogLSBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIG1heGltdW1TaWduaWZpY2FudERpZ2l0cyBbTnVtYmVyXVxuICogLSByb3VuZCBbU3RyaW5nXSBcImNlaWxcIiwgXCJmbG9vclwiLCBcInJvdW5kXCIgKGRlZmF1bHQpLCBvciBcInRydW5jYXRlXCIuXG4gKiAtIHVzZUdyb3VwaW5nIFtCb29sZWFuXSBkZWZhdWx0IHRydWUuXG4gKlxuICogUmV0dXJuIHRoZSBwcm9jZXNzZWQgcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgdXNlZCBpbiBudW1iZXIvZm9ybWF0LlxuICogcmVmOiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LW51bWJlcnMuaHRtbFxuICovXG52YXIgbnVtYmVyRm9ybWF0UHJvcGVydGllcyA9IGZ1bmN0aW9uKCBwYXR0ZXJuLCBjbGRyLCBvcHRpb25zICkge1xuXHR2YXIgbmVnYXRpdmVQYXR0ZXJuLCBuZWdhdGl2ZVByZWZpeCwgbmVnYXRpdmVQcm9wZXJ0aWVzLCBuZWdhdGl2ZVN1ZmZpeCwgcG9zaXRpdmVQYXR0ZXJuLFxuXHRcdHJvdW5kRm4sIHByb3BlcnRpZXM7XG5cblx0ZnVuY3Rpb24gZ2V0T3B0aW9ucyggYXR0cmlidXRlLCBwcm9wZXJ0eUluZGV4ICkge1xuXHRcdGlmICggYXR0cmlidXRlIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRwcm9wZXJ0aWVzWyBwcm9wZXJ0eUluZGV4IF0gPSBvcHRpb25zWyBhdHRyaWJ1dGUgXTtcblx0XHR9XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0cGF0dGVybiA9IHBhdHRlcm4uc3BsaXQoIFwiO1wiICk7XG5cblx0cG9zaXRpdmVQYXR0ZXJuID0gcGF0dGVyblsgMCBdO1xuXG5cdG5lZ2F0aXZlUGF0dGVybiA9IHBhdHRlcm5bIDEgXSB8fCBcIi1cIiArIHBvc2l0aXZlUGF0dGVybjtcblx0bmVnYXRpdmVQcm9wZXJ0aWVzID0gbnVtYmVyUGF0dGVyblByb3BlcnRpZXMoIG5lZ2F0aXZlUGF0dGVybiApO1xuXHRuZWdhdGl2ZVByZWZpeCA9IG5lZ2F0aXZlUHJvcGVydGllc1sgMCBdO1xuXHRuZWdhdGl2ZVN1ZmZpeCA9IG5lZ2F0aXZlUHJvcGVydGllc1sgMTAgXTtcblxuXHQvLyBIYXZlIHJ1bnRpbWUgY29kZSB0byByZWZlciB0byBudW1iZXJSb3VuZCgpIGluc3RlYWQgb2YgaW5jbHVkaW5nIGl0IGV4cGxpY2l0bHkuXG5cdHJvdW5kRm4gPSBudW1iZXJSb3VuZCggb3B0aW9ucy5yb3VuZCApO1xuXHRyb3VuZEZuLmdlbmVyYXRvclN0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcIm51bWJlclJvdW5kKFwiICsgKCBvcHRpb25zLnJvdW5kID8gXCJcXFwiXCIgKyBvcHRpb25zLnJvdW5kICsgXCJcXFwiXCIgOiBcIlwiICkgKyBcIilcIjtcblx0fTtcblxuXHRwcm9wZXJ0aWVzID0gbnVtYmVyUGF0dGVyblByb3BlcnRpZXMoIHBvc2l0aXZlUGF0dGVybiApLmNvbmNhdChbXG5cdFx0cG9zaXRpdmVQYXR0ZXJuLFxuXHRcdG5lZ2F0aXZlUHJlZml4ICsgcG9zaXRpdmVQYXR0ZXJuICsgbmVnYXRpdmVTdWZmaXgsXG5cdFx0bmVnYXRpdmVQcmVmaXgsXG5cdFx0bmVnYXRpdmVTdWZmaXgsXG5cdFx0cm91bmRGbixcblx0XHRudW1iZXJTeW1ib2woIFwiaW5maW5pdHlcIiwgY2xkciApLFxuXHRcdG51bWJlclN5bWJvbCggXCJuYW5cIiwgY2xkciApLFxuXHRcdG51bWJlclN5bWJvbE1hcCggY2xkciApLFxuXHRcdG51bWJlck51bWJlcmluZ1N5c3RlbURpZ2l0c01hcCggY2xkciApXG5cdF0pO1xuXG5cdGdldE9wdGlvbnMoIFwibWluaW11bUludGVnZXJEaWdpdHNcIiwgMiApO1xuXHRnZXRPcHRpb25zKCBcIm1pbmltdW1GcmFjdGlvbkRpZ2l0c1wiLCAzICk7XG5cdGdldE9wdGlvbnMoIFwibWF4aW11bUZyYWN0aW9uRGlnaXRzXCIsIDQgKTtcblx0Z2V0T3B0aW9ucyggXCJtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHNcIiwgNSApO1xuXHRnZXRPcHRpb25zKCBcIm1heGltdW1TaWduaWZpY2FudERpZ2l0c1wiLCA2ICk7XG5cblx0Ly8gR3JvdXBpbmcgc2VwYXJhdG9yc1xuXHRpZiAoIG9wdGlvbnMudXNlR3JvdXBpbmcgPT09IGZhbHNlICkge1xuXHRcdHByb3BlcnRpZXNbIDggXSA9IG51bGw7XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgbnVtYmVyIG9mIGRpZ2l0cyBpZiBvbmx5IG9uZSBvZiBlaXRoZXIgbWluaW11bUZyYWN0aW9uRGlnaXRzIG9yXG5cdC8vIG1heGltdW1GcmFjdGlvbkRpZ2l0cyBpcyBwYXNzZWQgaW4gYXMgYW4gb3B0aW9uXG5cdGlmICggXCJtaW5pbXVtRnJhY3Rpb25EaWdpdHNcIiBpbiBvcHRpb25zICYmICEoIFwibWF4aW11bUZyYWN0aW9uRGlnaXRzXCIgaW4gb3B0aW9ucyApICkge1xuXG5cdFx0Ly8gbWF4aW11bUZyYWN0aW9uRGlnaXRzID0gTWF0aC5tYXgoIG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgbWF4aW11bUZyYWN0aW9uRGlnaXRzICk7XG5cdFx0cHJvcGVydGllc1sgNCBdID0gTWF0aC5tYXgoIHByb3BlcnRpZXNbIDMgXSwgcHJvcGVydGllc1sgNCBdICk7XG5cdH0gZWxzZSBpZiAoICEoIFwibWluaW11bUZyYWN0aW9uRGlnaXRzXCIgaW4gb3B0aW9ucyApICYmXG5cdFx0XHRcIm1heGltdW1GcmFjdGlvbkRpZ2l0c1wiIGluIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBtaW5pbXVtRnJhY3Rpb25EaWdpdHMgPSBNYXRoLm1pbiggbWluaW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMgKTtcblx0XHRwcm9wZXJ0aWVzWyAzIF0gPSBNYXRoLm1pbiggcHJvcGVydGllc1sgMyBdLCBwcm9wZXJ0aWVzWyA0IF0gKTtcblx0fVxuXG5cdC8vIFJldHVybjpcblx0Ly8gMC0xMDogc2VlIG51bWJlci9wYXR0ZXJuLXByb3BlcnRpZXMuXG5cdC8vIDExOiBAcG9zaXRpdmVQYXR0ZXJuIFtTdHJpbmddIFBvc2l0aXZlIHBhdHRlcm4uXG5cdC8vIDEyOiBAbmVnYXRpdmVQYXR0ZXJuIFtTdHJpbmddIE5lZ2F0aXZlIHBhdHRlcm4uXG5cdC8vIDEzOiBAbmVnYXRpdmVQcmVmaXggW1N0cmluZ10gTmVnYXRpdmUgcHJlZml4LlxuXHQvLyAxNDogQG5lZ2F0aXZlU3VmZml4IFtTdHJpbmddIE5lZ2F0aXZlIHN1ZmZpeC5cblx0Ly8gMTU6IEByb3VuZCBbRnVuY3Rpb25dIFJvdW5kIGZ1bmN0aW9uLlxuXHQvLyAxNjogQGluZmluaXR5U3ltYm9sIFtTdHJpbmddIEluZmluaXR5IHN5bWJvbC5cblx0Ly8gMTc6IEBuYW5TeW1ib2wgW1N0cmluZ10gTmFOIHN5bWJvbC5cblx0Ly8gMTg6IEBzeW1ib2xNYXAgW09iamVjdF0gQSBidW5jaCBvZiBvdGhlciBzeW1ib2xzLlxuXHQvLyAxOTogQG51RGlnaXRzTWFwIFtBcnJheV0gRGlnaXRzIG1hcCBpZiBudW1iZXJpbmcgc3lzdGVtIGlzIGRpZmZlcmVudCB0aGFuIGBsYXRuYC5cblx0cmV0dXJuIHByb3BlcnRpZXM7XG59O1xuXG5cblxuXG4vKipcbiAqIEdlbmVyYXRlZCBieTpcbiAqXG4gKiB2YXIgcmVnZW5lcmF0ZSA9IHJlcXVpcmUoIFwicmVnZW5lcmF0ZVwiICk7XG4gKiB2YXIgZm9ybWF0U3ltYm9scyA9IHJlcXVpcmUoICogXCJ1bmljb2RlLTguMC4wL0dlbmVyYWxfQ2F0ZWdvcnkvRm9ybWF0L3N5bWJvbHNcIiApO1xuICogcmVnZW5lcmF0ZSgpLmFkZCggZm9ybWF0U3ltYm9scyApLnRvU3RyaW5nKCk7XG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvcmVnZW5lcmF0ZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvdW5pY29kZS04LjAuMFxuICovXG52YXIgcmVnZXhwQ2ZHID0gL1tcXHhBRFxcdTA2MDAtXFx1MDYwNVxcdTA2MUNcXHUwNkREXFx1MDcwRlxcdTE4MEVcXHUyMDBCLVxcdTIwMEZcXHUyMDJBLVxcdTIwMkVcXHUyMDYwLVxcdTIwNjRcXHUyMDY2LVxcdTIwNkZcXHVGRUZGXFx1RkZGOS1cXHVGRkZCXXxcXHVEODA0XFx1RENCRHxcXHVEODJGW1xcdURDQTAtXFx1RENBM118XFx1RDgzNFtcXHVERDczLVxcdUREN0FdfFxcdURCNDBbXFx1REMwMVxcdURDMjAtXFx1REM3Rl0vZztcblxuXG5cblxuLyoqXG4gKiBHZW5lcmF0ZWQgYnk6XG4gKlxuICogdmFyIHJlZ2VuZXJhdGUgPSByZXF1aXJlKCBcInJlZ2VuZXJhdGVcIiApO1xuICogdmFyIGRhc2hTeW1ib2xzID0gcmVxdWlyZSggKiBcInVuaWNvZGUtOC4wLjAvR2VuZXJhbF9DYXRlZ29yeS9EYXNoX1B1bmN0dWF0aW9uL3N5bWJvbHNcIiApO1xuICogcmVnZW5lcmF0ZSgpLmFkZCggZGFzaFN5bWJvbHMgKS50b1N0cmluZygpO1xuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3JlZ2VuZXJhdGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3VuaWNvZGUtOC4wLjBcbiAqXG4gKiBOT1RFOiBJbiBhZGRpdGlvbiB0byBbOmRhc2g6XSwgIHRoZSBiZWxvdyBpbmNsdWRlcyBNSU5VUyBTSUdOIFUrMjIxMi5cbiAqL1xudmFyIHJlZ2V4cERhc2hHID0gL1tcXC1cXHUwNThBXFx1MDVCRVxcdTE0MDBcXHUxODA2XFx1MjAxMC1cXHUyMDE1XFx1MkUxN1xcdTJFMUFcXHUyRTNBXFx1MkUzQlxcdTJFNDBcXHUzMDFDXFx1MzAzMFxcdTMwQTBcXHVGRTMxXFx1RkUzMlxcdUZFNThcXHVGRTYzXFx1RkYwRFxcdTIyMTJdL2c7XG5cblxuXG5cbi8qKlxuICogR2VuZXJhdGVkIGJ5OlxuICpcbiAqIHZhciByZWdlbmVyYXRlID0gcmVxdWlyZSggXCJyZWdlbmVyYXRlXCIgKTtcbiAqIHZhciBzcGFjZVNlcGFyYXRvclN5bWJvbHMgPSByZXF1aXJlKCBcInVuaWNvZGUtOC4wLjAvR2VuZXJhbF9DYXRlZ29yeS9TcGFjZV9TZXBhcmF0b3Ivc3ltYm9sc1wiICk7XG4gKiByZWdlbmVyYXRlKCkuYWRkKCBzcGFjZVNlcGFyYXRvclN5bWJvbHMgKS50b1N0cmluZygpO1xuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3JlZ2VuZXJhdGVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRoaWFzYnluZW5zL3VuaWNvZGUtOC4wLjBcbiAqL1xudmFyIHJlZ2V4cFpzRyA9IC9bIFxceEEwXFx1MTY4MFxcdTIwMDAtXFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMF0vZztcblxuXG5cblxuLyoqXG4gKiBMb29zZSBNYXRjaGluZzpcbiAqIC0gSWdub3JlIGFsbCBmb3JtYXQgY2hhcmFjdGVycywgd2hpY2ggaW5jbHVkZXMgUkxNLCBMUk0gb3IgQUxNIHVzZWQgdG8gY29udHJvbCBCSURJXG4gKiAgIGZvcm1hdHRpbmcuXG4gKiAtIE1hcCBhbGwgY2hhcmFjdGVycyBpbiBbOlpzOl0gdG8gVSswMDIwIFNQQUNFO1xuICogLSBNYXAgYWxsIGNoYXJhY3RlcnMgaW4gWzpEYXNoOl0gdG8gVSswMDJEIEhZUEhFTi1NSU5VUztcbiAqL1xudmFyIGxvb3NlTWF0Y2hpbmcgPSBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdHJldHVybiB2YWx1ZVxuXHRcdC5yZXBsYWNlKCByZWdleHBDZkcsIFwiXCIgKVxuXHRcdC5yZXBsYWNlKCByZWdleHBEYXNoRywgXCItXCIgKVxuXHRcdC5yZXBsYWNlKCByZWdleHBac0csIFwiIFwiICk7XG59O1xuXG5cblxuXG4vKipcbiAqIHBhcnNlKCB2YWx1ZSwgcHJvcGVydGllcyApXG4gKlxuICogQHZhbHVlIFtTdHJpbmddLlxuICpcbiAqIEBwcm9wZXJ0aWVzIFtPYmplY3RdIFBhcnNlciBwcm9wZXJ0aWVzIGlzIGEgcmVkdWNlZCBwcmUtcHJvY2Vzc2VkIGNsZHJcbiAqIGRhdGEgc2V0IHJldHVybmVkIGJ5IG51bWJlclBhcnNlclByb3BlcnRpZXMoKS5cbiAqXG4gKiBSZXR1cm4gdGhlIHBhcnNlZCBOdW1iZXIgKGluY2x1ZGluZyBJbmZpbml0eSkgb3IgTmFOIHdoZW4gdmFsdWUgaXMgaW52YWxpZC5cbiAqIHJlZjogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS1udW1iZXJzLmh0bWxcbiAqL1xudmFyIG51bWJlclBhcnNlID0gZnVuY3Rpb24oIHZhbHVlLCBwcm9wZXJ0aWVzICkge1xuXHR2YXIgZ3JhbW1hciwgaW52ZXJ0ZWROdURpZ2l0c01hcCwgaW52ZXJ0ZWRTeW1ib2xNYXAsIG5lZ2F0aXZlLCBudW1iZXIsIHByZWZpeCwgcHJlZml4TlN1ZmZpeCxcblx0XHRzdWZmaXgsIHRva2VuaXplciwgdmFsaWQ7XG5cblx0Ly8gR3JhbW1hcjpcblx0Ly8gLSBWYWx1ZSA8PSAgICAgICAgICAgTmFOIHwgUG9zaXRpdmVOdW1iZXIgfCBOZWdhdGl2ZU51bWJlclxuXHQvLyAtIFBvc2l0aXZlTnVtYmVyIDw9ICBQb3NpdGl2ZVByZWZpeCBOdW1iZXJPckluZiBQb3NpdGl2ZVN1Zml4XG5cdC8vIC0gTmVnYXRpdmVOdW1iZXIgPD0gIE5lZ2F0aXZlUHJlZml4IE51bWJlck9ySW5mXG5cdC8vIC0gTnVtYmVyT3JJbmYgPD0gICAgIE51bWJlciB8IEluZlxuXHRncmFtbWFyID0gW1xuXHRcdFsgXCJuYW5cIiBdLFxuXHRcdFsgXCJwcmVmaXhcIiwgXCJpbmZpbml0eVwiLCBcInN1ZmZpeFwiIF0sXG5cdFx0WyBcInByZWZpeFwiLCBcIm51bWJlclwiLCBcInN1ZmZpeFwiIF0sXG5cdFx0WyBcIm5lZ2F0aXZlUHJlZml4XCIsIFwiaW5maW5pdHlcIiwgXCJuZWdhdGl2ZVN1ZmZpeFwiIF0sXG5cdFx0WyBcIm5lZ2F0aXZlUHJlZml4XCIsIFwibnVtYmVyXCIsIFwibmVnYXRpdmVTdWZmaXhcIiBdXG5cdF07XG5cblx0aW52ZXJ0ZWRTeW1ib2xNYXAgPSBwcm9wZXJ0aWVzWyAwIF07XG5cdGludmVydGVkTnVEaWdpdHNNYXAgPSBwcm9wZXJ0aWVzWyAxIF0gfHwge307XG5cdHRva2VuaXplciA9IHByb3BlcnRpZXNbIDIgXTtcblxuXHR2YWx1ZSA9IGxvb3NlTWF0Y2hpbmcoIHZhbHVlICk7XG5cblx0ZnVuY3Rpb24gcGFyc2UoIHR5cGUgKSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBsZXhlbWUgKSB7XG5cblx0XHRcdC8vIFJldmVyc2UgbG9jYWxpemVkIHN5bWJvbHMgYW5kIG51bWJlcmluZyBzeXN0ZW0uXG5cdFx0XHRsZXhlbWUgPSBsZXhlbWUuc3BsaXQoIFwiXCIgKS5tYXAoZnVuY3Rpb24oIGNoYXJhY3RlciApIHtcblx0XHRcdFx0cmV0dXJuIGludmVydGVkU3ltYm9sTWFwWyBjaGFyYWN0ZXIgXSB8fFxuXHRcdFx0XHRcdGludmVydGVkTnVEaWdpdHNNYXBbIGNoYXJhY3RlciBdIHx8XG5cdFx0XHRcdFx0Y2hhcmFjdGVyO1xuXHRcdFx0fSkuam9pbiggXCJcIiApO1xuXG5cdFx0XHRzd2l0Y2ggKCB0eXBlICkge1xuXHRcdFx0XHRjYXNlIFwiaW5maW5pdHlcIjpcblx0XHRcdFx0XHRudW1iZXIgPSBJbmZpbml0eTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlIFwibmFuXCI6XG5cdFx0XHRcdFx0bnVtYmVyID0gTmFOO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJudW1iZXJcIjpcblxuXHRcdFx0XHRcdC8vIFJlbW92ZSBncm91cGluZyBzZXBhcmF0b3JzLlxuXHRcdFx0XHRcdGxleGVtZSA9IGxleGVtZS5yZXBsYWNlKCAvLC9nLCBcIlwiICk7XG5cblx0XHRcdFx0XHRudW1iZXIgPSArbGV4ZW1lO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJwcmVmaXhcIjpcblx0XHRcdFx0Y2FzZSBcIm5lZ2F0aXZlUHJlZml4XCI6XG5cdFx0XHRcdFx0cHJlZml4ID0gbGV4ZW1lO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgXCJzdWZmaXhcIjpcblx0XHRcdFx0XHRzdWZmaXggPSBsZXhlbWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdFx0Y2FzZSBcIm5lZ2F0aXZlU3VmZml4XCI6XG5cdFx0XHRcdFx0c3VmZml4ID0gbGV4ZW1lO1xuXHRcdFx0XHRcdG5lZ2F0aXZlID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHQvLyBUaGlzIHNob3VsZCBuZXZlciBiZSByZWFjaGVkLlxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJJbnRlcm5hbCBlcnJvclwiICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gXCJcIjtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gdG9rZW5pemVOUGFyc2UoIF92YWx1ZSwgZ3JhbW1hciApIHtcblx0XHRyZXR1cm4gZ3JhbW1hci5zb21lKGZ1bmN0aW9uKCBzdGF0ZW1lbnQgKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSBfdmFsdWU7XG5cblx0XHRcdC8vIFRoZSB3aG9sZSBncmFtbWFyIHN0YXRlbWVudCBzaG91bGQgYmUgdXNlZCAoaS5lLiwgLmV2ZXJ5KCkgcmV0dXJuIHRydWUpIGFuZCB2YWx1ZSBiZVxuXHRcdFx0Ly8gZW50aXJlbHkgY29uc3VtZWQgKGkuZS4sICF2YWx1ZS5sZW5ndGgpLlxuXHRcdFx0cmV0dXJuIHN0YXRlbWVudC5ldmVyeShmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0aWYgKCB2YWx1ZS5tYXRjaCggdG9rZW5pemVyWyB0eXBlIF0gKSA9PT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDb25zdW1lIGFuZCBwYXJzZSBpdC5cblx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5yZXBsYWNlKCB0b2tlbml6ZXJbIHR5cGUgXSwgcGFyc2UoIHR5cGUgKSApO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0pICYmICF2YWx1ZS5sZW5ndGg7XG5cdFx0fSk7XG5cdH1cblxuXHR2YWxpZCA9IHRva2VuaXplTlBhcnNlKCB2YWx1ZSwgZ3JhbW1hciApO1xuXG5cdC8vIE5hTlxuXHRpZiAoICF2YWxpZCB8fCBpc05hTiggbnVtYmVyICkgKSB7XG5cdFx0cmV0dXJuIE5hTjtcblx0fVxuXG5cdHByZWZpeE5TdWZmaXggPSBcIlwiICsgcHJlZml4ICsgc3VmZml4O1xuXG5cdC8vIFBlcmNlbnRcblx0aWYgKCBwcmVmaXhOU3VmZml4LmluZGV4T2YoIFwiJVwiICkgIT09IC0xICkge1xuXHRcdG51bWJlciAvPSAxMDA7XG5cblx0Ly8gUGVyIG1pbGxlXG5cdH0gZWxzZSBpZiAoIHByZWZpeE5TdWZmaXguaW5kZXhPZiggXCJcXHUyMDMwXCIgKSAhPT0gLTEgKSB7XG5cdFx0bnVtYmVyIC89IDEwMDA7XG5cdH1cblxuXHQvLyBOZWdhdGl2ZSBudW1iZXJcblx0aWYgKCBuZWdhdGl2ZSApIHtcblx0XHRudW1iZXIgKj0gLTE7XG5cdH1cblxuXHRyZXR1cm4gbnVtYmVyO1xufTtcblxuXG5cblxudmFyIG51bWJlclBhcnNlckZuID0gZnVuY3Rpb24oIHByb3BlcnRpZXMgKSB7XG5cdHJldHVybiBmdW5jdGlvbiBudW1iZXJQYXJzZXIoIHZhbHVlICkge1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRcdHJldHVybiBudW1iZXJQYXJzZSggdmFsdWUsIHByb3BlcnRpZXMgKTtcblx0fTtcblxufTtcblxuXG5cblxuLyoqXG4gKiBzeW1ib2xNYXAoIGNsZHIgKVxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBSZXR1cm4gdGhlIChsb2NhbGl6ZWQgc3ltYm9sLCBwYXR0ZXJuIHN5bWJvbCkga2V5IHZhbHVlIHBhaXIsIGVnLiB7XG4gKiAgIFwi2atcIjogXCIuXCIsXG4gKiAgIFwi2axcIjogXCIsXCIsXG4gKiAgIFwi2apcIjogXCIlXCIsXG4gKiAgIC4uLlxuICogfTtcbiAqL1xudmFyIG51bWJlclN5bWJvbEludmVydGVkTWFwID0gZnVuY3Rpb24oIGNsZHIgKSB7XG5cdHZhciBzeW1ib2wsXG5cdFx0c3ltYm9sTWFwID0ge307XG5cblx0Zm9yICggc3ltYm9sIGluIG51bWJlclN5bWJvbE5hbWUgKSB7XG5cdFx0c3ltYm9sTWFwWyBudW1iZXJTeW1ib2woIG51bWJlclN5bWJvbE5hbWVbIHN5bWJvbCBdLCBjbGRyICkgXSA9IHN5bWJvbDtcblx0fVxuXG5cdHJldHVybiBzeW1ib2xNYXA7XG59O1xuXG5cblxuXG4vKipcbiAqIG9iamVjdE1hcCggb2JqZWN0LCBmbilcbiAqXG4gKiAtIG9iamVjdFxuICpcbiAqIC0gZm4oIHBhaXIgKSA9PiBwYWlyXG4gKi9cbnZhciBvYmplY3RNYXAgPSBmdW5jdGlvbiggb2JqZWN0LCBmbiApIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKCBvYmplY3QgKS5tYXAoZnVuY3Rpb24oIGtleSApIHtcblx0XHRyZXR1cm4gZm4oWyBrZXksIG9iamVjdFsga2V5IF0gXSk7XG5cdH0pLnJlZHVjZShmdW5jdGlvbiggb2JqZWN0LCBwYWlyICkge1xuXHRcdG9iamVjdFsgcGFpclsgMCBdIF0gPSBwYWlyWyAxIF07XG5cdFx0cmV0dXJuIG9iamVjdDtcblx0fSwge30pO1xufTtcblxuXG5cblxuLyoqXG4gKiBwYXJzZVByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIgKVxuICpcbiAqIEBwYXR0ZXJuIFtTdHJpbmddIHJhdyBwYXR0ZXJuIGZvciBudW1iZXJzLlxuICpcbiAqIEBjbGRyIFtDbGRyIGluc3RhbmNlXS5cbiAqXG4gKiBSZXR1cm4gcGFyc2VyIHByb3BlcnRpZXMsIHVzZWQgdG8gZmVlZCBwYXJzZXIgZnVuY3Rpb24uXG4gKlxuICogVE9ETzpcbiAqIC0gU2NpZW50aWZpY19ub3RhdGlvbjtcbiAqIC0gUGFkZGluZztcbiAqL1xudmFyIG51bWJlclBhcnNlUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBwYXR0ZXJuLCBjbGRyLCBvcHRpb25zICkge1xuXHR2YXIgYXV4LCBkZWNpbWFsU3ltYm9sUmUsIGRpZ2l0c1JlLCBncm91cGluZ1NlcGFyYXRvclJlLCBpbmZpbml0eVN5bWJvbCwgaW52ZXJ0ZWROdURpZ2l0c01hcCxcblx0XHRpbnZlcnRlZFN5bWJvbE1hcCwgbWF4aW11bUZyYWN0aW9uRGlnaXRzLCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMsXG5cdFx0bWluaW11bVNpZ25pZmljYW50RGlnaXRzLCBuYW5TeW1ib2wsIG5lZ2F0aXZlUHJlZml4LCBuZWdhdGl2ZVN1ZmZpeCwgbnVEaWdpdHNNYXAsXG5cdFx0bnVtYmVyVG9rZW5pemVyLCBwcmVmaXgsIHByaW1hcnlHcm91cGluZ1NpemUsIHNlY29uZGFyeUdyb3VwaW5nU2l6ZSwgc3VmZml4LCBzeW1ib2xNYXAsXG5cdFx0Zm9ybWF0UHJvcGVydGllcyA9IG51bWJlckZvcm1hdFByb3BlcnRpZXMoIHBhdHRlcm4sIGNsZHIsIG9wdGlvbnMgKTtcblxuXHRwcmVmaXggPSBsb29zZU1hdGNoaW5nKCBmb3JtYXRQcm9wZXJ0aWVzWyAwIF0gKTtcblx0bWF4aW11bUZyYWN0aW9uRGlnaXRzID0gZm9ybWF0UHJvcGVydGllc1sgNCBdO1xuXHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBmb3JtYXRQcm9wZXJ0aWVzWyA1IF07XG5cdG1heGltdW1TaWduaWZpY2FudERpZ2l0cyA9IGZvcm1hdFByb3BlcnRpZXNbIDYgXTtcblx0cHJpbWFyeUdyb3VwaW5nU2l6ZSA9IGZvcm1hdFByb3BlcnRpZXNbIDggXTtcblx0c2Vjb25kYXJ5R3JvdXBpbmdTaXplID0gZm9ybWF0UHJvcGVydGllc1sgOSBdO1xuXHRzdWZmaXggPSBsb29zZU1hdGNoaW5nKCBmb3JtYXRQcm9wZXJ0aWVzWyAxMCBdICk7XG5cdG5lZ2F0aXZlUHJlZml4ID0gbG9vc2VNYXRjaGluZyggZm9ybWF0UHJvcGVydGllc1sgMTMgXSApO1xuXHRuZWdhdGl2ZVN1ZmZpeCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDE0IF0gKTtcblx0aW5maW5pdHlTeW1ib2wgPSBsb29zZU1hdGNoaW5nKCBmb3JtYXRQcm9wZXJ0aWVzWyAxNiBdICk7XG5cdG5hblN5bWJvbCA9IGxvb3NlTWF0Y2hpbmcoIGZvcm1hdFByb3BlcnRpZXNbIDE3IF0gKTtcblx0c3ltYm9sTWFwID0gb2JqZWN0TWFwKCBmb3JtYXRQcm9wZXJ0aWVzWyAxOCBdLCBmdW5jdGlvbiggcGFpciApIHtcblx0XHRyZXR1cm4gWyBwYWlyWyAwIF0sIGxvb3NlTWF0Y2hpbmcoIHBhaXJbIDEgXSApIF07XG5cdH0pO1xuXHRudURpZ2l0c01hcCA9IGZvcm1hdFByb3BlcnRpZXNbIDE5IF07XG5cblx0aW52ZXJ0ZWRTeW1ib2xNYXAgPSBvYmplY3RNYXAoIG51bWJlclN5bWJvbEludmVydGVkTWFwKCBjbGRyICksIGZ1bmN0aW9uKCBwYWlyICkge1xuXHRcdHJldHVybiBbIGxvb3NlTWF0Y2hpbmcoIHBhaXJbIDAgXSApLCBwYWlyWyAxIF0gXTtcblx0fSk7XG5cblx0ZGlnaXRzUmUgPSBudURpZ2l0c01hcCA/IFwiW1wiICsgbnVEaWdpdHNNYXAgKyBcIl1cIiA6IFwiXFxcXGRcIjtcblx0Z3JvdXBpbmdTZXBhcmF0b3JSZSA9IHJlZ2V4cEVzY2FwZSggc3ltYm9sTWFwWyBcIixcIiBdICk7XG5cdGRlY2ltYWxTeW1ib2xSZSA9IHJlZ2V4cEVzY2FwZSggc3ltYm9sTWFwWyBcIi5cIiBdICk7XG5cblx0aWYgKCBudURpZ2l0c01hcCApIHtcblx0XHRpbnZlcnRlZE51RGlnaXRzTWFwID0gbnVEaWdpdHNNYXAuc3BsaXQoIFwiXCIgKS5yZWR1Y2UoZnVuY3Rpb24oIG9iamVjdCwgbG9jYWxpemVkRGlnaXQsIGkgKSB7XG5cdFx0XHRvYmplY3RbIGxvY2FsaXplZERpZ2l0IF0gPSBTdHJpbmcoIGkgKTtcblx0XHRcdHJldHVybiBvYmplY3Q7XG5cdFx0fSwge30gKTtcblx0fVxuXG5cdGF1eCA9IFsgcHJlZml4LCBzdWZmaXgsIG5lZ2F0aXZlUHJlZml4LCBuZWdhdGl2ZVN1ZmZpeCBdLm1hcChmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoIC8oJyhbXiddfCcnKSsnfCcnKXwuL2csIGZ1bmN0aW9uKCBjaGFyYWN0ZXIsIGxpdGVyYWwgKSB7XG5cblx0XHRcdC8vIExpdGVyYWxzXG5cdFx0XHRpZiAoIGxpdGVyYWwgKSB7XG5cdFx0XHRcdHJldHVybiByZW1vdmVMaXRlcmFsUXVvdGVzKCBsaXRlcmFsICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN5bWJvbHNcblx0XHRcdGNoYXJhY3RlciA9IGNoYXJhY3Rlci5yZXBsYWNlKCAvW1xcLStFJVxcdTIwMzBdLywgZnVuY3Rpb24oIHN5bWJvbCApIHtcblx0XHRcdFx0cmV0dXJuIHN5bWJvbE1hcFsgc3ltYm9sIF07XG5cdFx0XHR9KTtcblxuXHRcdFx0cmV0dXJuIGNoYXJhY3Rlcjtcblx0XHR9KTtcblx0fSk7XG5cblx0cHJlZml4ID0gYXV4WyAwIF07XG5cdHN1ZmZpeCA9IGF1eFsgMSBdO1xuXHRuZWdhdGl2ZVByZWZpeCA9IGF1eFsgMiBdO1xuXHRuZWdhdGl2ZVN1ZmZpeCA9IGF1eFsgMyBdO1xuXG5cdC8vIE51bWJlclxuXHQvL1xuXHQvLyBudW1iZXJfcmUgPSAgICAgICAgICAgICAgICAgICAgICAgaW50ZWdlciBmcmFjdGlvbj9cblx0Ly9cblx0Ly8gaW50ZWdlciA9ICAgICAgICAgICAgICAgICAgICAgICAgIGRpZ2l0cyB8IGRpZ2l0c191c2luZ19ncm91cGluZ19zZXBhcmF0b3JzXG5cdC8vXG5cdC8vIGZyYWN0aW9uID0gICAgICAgICAgICAgICAgICAgICAgICByZWdleHAoKC5cXGQrKT8pXG5cdC8vXG5cdC8vIGRpZ2l0cyA9ICAgICAgICAgICAgICAgICAgICAgICAgICByZWdleHAoXFxkKylcblx0Ly9cblx0Ly8gZGlnaXRzX3dfZ3JvdXBpbmdfc2VwYXJhdG9ycyA9ICAgIGRpZ2l0c193XzFfZ3JvdXBpbmdfc2VwYXJhdG9ycyB8XG5cdC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaWdpdHNfd18yX2dyb3VwaW5nX3NlcGFyYXRvcnNcblx0Ly9cblx0Ly8gZGlnaXRzX3dfMV9ncm91cGluZ19zZXBhcmF0b3JzID0gIHJlZ2V4cChcXGR7MSwzfSgsXFxkezN9KSspXG5cdC8vXG5cdC8vIGRpZ2l0c193XzJfZ3JvdXBpbmdfc2VwYXJhdG9ycyA9ICByZWdleHAoXFxkezEsMn0oKCxcXGR7Mn0pKigsXFxkezN9KSkpXG5cblx0Ly8gSW50ZWdlciBwYXJ0XG5cdG51bWJlclRva2VuaXplciA9IGRpZ2l0c1JlICsgXCIrXCI7XG5cblx0Ly8gR3JvdXBpbmcgc2VwYXJhdG9yc1xuXHRpZiAoIHByaW1hcnlHcm91cGluZ1NpemUgKSB7XG5cdFx0aWYgKCBzZWNvbmRhcnlHcm91cGluZ1NpemUgKSB7XG5cdFx0XHRhdXggPSBkaWdpdHNSZSArIFwiezEsXCIgKyBzZWNvbmRhcnlHcm91cGluZ1NpemUgKyBcIn0oKFwiICsgZ3JvdXBpbmdTZXBhcmF0b3JSZSArXG5cdFx0XHRcdGRpZ2l0c1JlICsgXCJ7XCIgKyBzZWNvbmRhcnlHcm91cGluZ1NpemUgKyBcIn0pKihcIiArIGdyb3VwaW5nU2VwYXJhdG9yUmUgK1xuXHRcdFx0XHRkaWdpdHNSZSArIFwie1wiICsgcHJpbWFyeUdyb3VwaW5nU2l6ZSArIFwifSkpXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGF1eCA9IGRpZ2l0c1JlICsgXCJ7MSxcIiArIHByaW1hcnlHcm91cGluZ1NpemUgKyBcIn0oXCIgKyBncm91cGluZ1NlcGFyYXRvclJlICtcblx0XHRcdFx0ZGlnaXRzUmUgKyBcIntcIiArIHByaW1hcnlHcm91cGluZ1NpemUgKyBcIn0pK1wiO1xuXHRcdH1cblx0XHRudW1iZXJUb2tlbml6ZXIgPSBcIihcIiArIGF1eCArIFwifFwiICsgbnVtYmVyVG9rZW5pemVyICsgXCIpXCI7XG5cdH1cblxuXHQvLyBGcmFjdGlvbiBwYXJ0PyBPbmx5IGluY2x1ZGVkIGlmIDEgb3IgMi5cblx0Ly8gMTogVXNpbmcgc2lnbmlmaWNhbnQgZGlnaXQgZm9ybWF0LlxuXHQvLyAyOiBVc2luZyBpbnRlZ2VyIGFuZCBmcmFjdGlvbmFsIGZvcm1hdCAmJiBpdCBoYXMgYSBtYXhpbXVtRnJhY3Rpb25EaWdpdHMuXG5cdGlmICggIWlzTmFOKCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgKiBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgKSB8fCAvKiAxICovXG5cdFx0XHRcdG1heGltdW1GcmFjdGlvbkRpZ2l0cyAvKiAyICovICkge1xuXG5cdFx0Ly8gMTogSGFuZGxlIHRyYWlsaW5nIGRlY2ltYWwgc2VwYXJhdG9yLCBlLmcuLCBgXCIxLlwiID0+IGAxYGAuXG5cdFx0YXV4ID0gZGVjaW1hbFN5bWJvbFJlICsgZGlnaXRzUmUgKyBcIitcIjtcblx0XHRudW1iZXJUb2tlbml6ZXIgPSBudW1iZXJUb2tlbml6ZXIgKyBcIihcIiArIGF1eCArIFwifFwiICsgZGVjaW1hbFN5bWJvbFJlIC8qIDEgKi8gKyBcIik/XCIgK1xuXG5cdFx0XHQvLyBIYW5kbGUgbm9uLXBhZGRlZCBkZWNpbWFscywgZS5nLiwgYFwiLjEyXCJgID0+IGAwLjEyYCBieSBtYWtpbmcgdGhlIGludGVnZXIgcGFydFxuXHRcdFx0Ly8gb3B0aW9uYWwuXG5cdFx0XHRcInwoXCIgKyBudW1iZXJUb2tlbml6ZXIgKyBcIik/XCIgKyBhdXg7XG5cblx0XHRudW1iZXJUb2tlbml6ZXIgPSBcIihcIiArIG51bWJlclRva2VuaXplciArIFwiKVwiO1xuXHR9XG5cblx0Ly8gMDogQGludmVydGVkU3ltYm9sTWFwIFtPYmplY3RdIEludmVydGVkIHN5bWJvbCBtYXAuXG5cdC8vIDE6IEBpbnZlcnRlZE51RGlnaXRzTWFwIFtPYmplY3RdIEludmVydGVkIGRpZ2l0cyBtYXAgaWYgbnVtYmVyaW5nIHN5c3RlbSBpcyBkaWZmZXJlbnQgdGhhblxuXHQvLyAgICBgbGF0bmAuXG5cdC8vIDI6IEB0b2tlbml6ZXIgW09iamVjdF0gVG9rZW5pemVyIG1hcCwgdXNlZCBieSBwYXJzZXIgdG8gY29uc3VtZSBpbnB1dC5cblx0cmV0dXJuIFtcblx0XHRpbnZlcnRlZFN5bWJvbE1hcCxcblx0XHRpbnZlcnRlZE51RGlnaXRzTWFwLFxuXHRcdHtcblx0XHRcdGluZmluaXR5OiBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggaW5maW5pdHlTeW1ib2wgKSApLFxuXHRcdFx0bmFuOiAgbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIG5hblN5bWJvbCApICksXG5cdFx0XHRuZWdhdGl2ZVByZWZpeDogbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIG5lZ2F0aXZlUHJlZml4ICkgKSxcblx0XHRcdG5lZ2F0aXZlU3VmZml4OiBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggbmVnYXRpdmVTdWZmaXggKSApLFxuXHRcdFx0bnVtYmVyOiBuZXcgUmVnRXhwKCBcIl5cIiArIG51bWJlclRva2VuaXplciApLFxuXHRcdFx0cHJlZml4OiBuZXcgUmVnRXhwKCBcIl5cIiArIHJlZ2V4cEVzY2FwZSggcHJlZml4ICkgKSxcblx0XHRcdHN1ZmZpeDogbmV3IFJlZ0V4cCggXCJeXCIgKyByZWdleHBFc2NhcGUoIHN1ZmZpeCApIClcblx0XHR9XG5cdF07XG5cbn07XG5cblxuXG5cbi8qKlxuICogUGF0dGVybiggc3R5bGUgKVxuICpcbiAqIEBzdHlsZSBbU3RyaW5nXSBcImRlY2ltYWxcIiAoZGVmYXVsdCkgb3IgXCJwZXJjZW50XCIuXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICovXG52YXIgbnVtYmVyUGF0dGVybiA9IGZ1bmN0aW9uKCBzdHlsZSwgY2xkciApIHtcblx0aWYgKCBzdHlsZSAhPT0gXCJkZWNpbWFsXCIgJiYgc3R5bGUgIT09IFwicGVyY2VudFwiICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggXCJJbnZhbGlkIHN0eWxlXCIgKTtcblx0fVxuXG5cdHJldHVybiBjbGRyLm1haW4oW1xuXHRcdFwibnVtYmVyc1wiLFxuXHRcdHN0eWxlICsgXCJGb3JtYXRzLW51bWJlclN5c3RlbS1cIiArIG51bWJlck51bWJlcmluZ1N5c3RlbSggY2xkciApLFxuXHRcdFwic3RhbmRhcmRcIlxuXHRdKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGlnaXRzKCBwcm9wZXJ0aWVzICkge1xuXHR2YXIgbWluaW11bUludGVnZXJEaWdpdHMgPSBwcm9wZXJ0aWVzWyAyIF0sXG5cdFx0bWluaW11bUZyYWN0aW9uRGlnaXRzID0gcHJvcGVydGllc1sgMyBdLFxuXHRcdG1heGltdW1GcmFjdGlvbkRpZ2l0cyA9IHByb3BlcnRpZXNbIDQgXSxcblx0XHRtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgPSBwcm9wZXJ0aWVzWyA1IF0sXG5cdFx0bWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gcHJvcGVydGllc1sgNiBdO1xuXG5cdC8vIFZhbGlkYXRlIHNpZ25pZmljYW50IGRpZ2l0IGZvcm1hdCBwcm9wZXJ0aWVzXG5cdGlmICggIWlzTmFOKCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMgKiBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgKSApIHtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlKCBtaW5pbXVtU2lnbmlmaWNhbnREaWdpdHMsIFwibWluaW11bVNpZ25pZmljYW50RGlnaXRzXCIsIDEsIDIxICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJSYW5nZSggbWF4aW11bVNpZ25pZmljYW50RGlnaXRzLCBcIm1heGltdW1TaWduaWZpY2FudERpZ2l0c1wiLFxuXHRcdFx0bWluaW11bVNpZ25pZmljYW50RGlnaXRzLCAyMSApO1xuXG5cdH0gZWxzZSBpZiAoICFpc05hTiggbWluaW11bVNpZ25pZmljYW50RGlnaXRzICkgfHwgIWlzTmFOKCBtYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMgKSApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIFwiTmVpdGhlciBvciBib3RoIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHNpZ25pZmljYW50IGRpZ2l0cyBtdXN0IGJlIFwiICtcblx0XHRcdFwicHJlc2VudFwiICk7XG5cblx0Ly8gVmFsaWRhdGUgaW50ZWdlciBhbmQgZnJhY3Rpb25hbCBmb3JtYXRcblx0fSBlbHNlIHtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlKCBtaW5pbXVtSW50ZWdlckRpZ2l0cywgXCJtaW5pbXVtSW50ZWdlckRpZ2l0c1wiLCAxLCAyMSApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUmFuZ2UoIG1pbmltdW1GcmFjdGlvbkRpZ2l0cywgXCJtaW5pbXVtRnJhY3Rpb25EaWdpdHNcIiwgMCwgMjAgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclJhbmdlKCBtYXhpbXVtRnJhY3Rpb25EaWdpdHMsIFwibWF4aW11bUZyYWN0aW9uRGlnaXRzXCIsXG5cdFx0XHRtaW5pbXVtRnJhY3Rpb25EaWdpdHMsIDIwICk7XG5cdH1cbn1cblxuLyoqXG4gKiAubnVtYmVyRm9ybWF0dGVyKCBbb3B0aW9uc10gKVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdOlxuICogLSBzdHlsZTogW1N0cmluZ10gXCJkZWNpbWFsXCIgKGRlZmF1bHQpIG9yIFwicGVyY2VudFwiLlxuICogLSBzZWUgYWxzbyBudW1iZXIvZm9ybWF0IG9wdGlvbnMuXG4gKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBmb3JtYXRzIGEgbnVtYmVyIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gb3B0aW9ucyBhbmQgZGVmYXVsdC9pbnN0YW5jZVxuICogbG9jYWxlLlxuICovXG5HbG9iYWxpemUubnVtYmVyRm9ybWF0dGVyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUubnVtYmVyRm9ybWF0dGVyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBhcmdzLCBjbGRyLCBwYXR0ZXJuLCBwcm9wZXJ0aWVzLCByZXR1cm5GbjtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCggb3B0aW9ucywgXCJvcHRpb25zXCIgKTtcblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0Y2xkciA9IHRoaXMuY2xkcjtcblxuXHRhcmdzID0gWyBvcHRpb25zIF07XG5cblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XG5cblx0Y2xkci5vbiggXCJnZXRcIiwgdmFsaWRhdGVDbGRyICk7XG5cblx0aWYgKCBvcHRpb25zLnJhdyApIHtcblx0XHRwYXR0ZXJuID0gb3B0aW9ucy5yYXc7XG5cdH0gZWxzZSB7XG5cdFx0cGF0dGVybiA9IG51bWJlclBhdHRlcm4oIG9wdGlvbnMuc3R5bGUgfHwgXCJkZWNpbWFsXCIsIGNsZHIgKTtcblx0fVxuXG5cdHByb3BlcnRpZXMgPSBudW1iZXJGb3JtYXRQcm9wZXJ0aWVzKCBwYXR0ZXJuLCBjbGRyLCBvcHRpb25zICk7XG5cblx0Y2xkci5vZmYoIFwiZ2V0XCIsIHZhbGlkYXRlQ2xkciApO1xuXG5cdHZhbGlkYXRlRGlnaXRzKCBwcm9wZXJ0aWVzICk7XG5cblx0cmV0dXJuRm4gPSBudW1iZXJGb3JtYXR0ZXJGbiggcHJvcGVydGllcyApO1xuXG5cdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBwcm9wZXJ0aWVzIF0gKTtcblxuXHRyZXR1cm4gcmV0dXJuRm47XG59O1xuXG4vKipcbiAqIC5udW1iZXJQYXJzZXIoIFtvcHRpb25zXSApXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF06XG4gKiAtIHN0eWxlOiBbU3RyaW5nXSBcImRlY2ltYWxcIiAoZGVmYXVsdCkgb3IgXCJwZXJjZW50XCIuXG4gKlxuICogUmV0dXJuIHRoZSBudW1iZXIgcGFyc2VyIGFjY29yZGluZyB0byB0aGUgZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5udW1iZXJQYXJzZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5udW1iZXJQYXJzZXIgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGFyZ3MsIGNsZHIsIHBhdHRlcm4sIHByb3BlcnRpZXMsIHJldHVybkZuO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcIm9wdGlvbnNcIiApO1xuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRjbGRyID0gdGhpcy5jbGRyO1xuXG5cdGFyZ3MgPSBbIG9wdGlvbnMgXTtcblxuXHR2YWxpZGF0ZURlZmF1bHRMb2NhbGUoIGNsZHIgKTtcblxuXHRjbGRyLm9uKCBcImdldFwiLCB2YWxpZGF0ZUNsZHIgKTtcblxuXHRpZiAoIG9wdGlvbnMucmF3ICkge1xuXHRcdHBhdHRlcm4gPSBvcHRpb25zLnJhdztcblx0fSBlbHNlIHtcblx0XHRwYXR0ZXJuID0gbnVtYmVyUGF0dGVybiggb3B0aW9ucy5zdHlsZSB8fCBcImRlY2ltYWxcIiwgY2xkciApO1xuXHR9XG5cblx0cHJvcGVydGllcyA9IG51bWJlclBhcnNlUHJvcGVydGllcyggcGF0dGVybiwgY2xkciwgb3B0aW9ucyApO1xuXG5cdGNsZHIub2ZmKCBcImdldFwiLCB2YWxpZGF0ZUNsZHIgKTtcblxuXHRyZXR1cm5GbiA9IG51bWJlclBhcnNlckZuKCBwcm9wZXJ0aWVzICk7XG5cblx0cnVudGltZUJpbmQoIGFyZ3MsIGNsZHIsIHJldHVybkZuLCBbIHByb3BlcnRpZXMgXSApO1xuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbi8qKlxuICogLmZvcm1hdE51bWJlciggdmFsdWUgWywgb3B0aW9uc10gKVxuICpcbiAqIEB2YWx1ZSBbTnVtYmVyXSBudW1iZXIgdG8gYmUgZm9ybWF0dGVkLlxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdOiBzZWUgbnVtYmVyL2Zvcm1hdC1wcm9wZXJ0aWVzLlxuICpcbiAqIEZvcm1hdCBhIG51bWJlciBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIG9wdGlvbnMgYW5kIGRlZmF1bHQvaW5zdGFuY2UgbG9jYWxlLlxuICovXG5HbG9iYWxpemUuZm9ybWF0TnVtYmVyID1cbkdsb2JhbGl6ZS5wcm90b3R5cGUuZm9ybWF0TnVtYmVyID0gZnVuY3Rpb24oIHZhbHVlLCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdHJldHVybiB0aGlzLm51bWJlckZvcm1hdHRlciggb3B0aW9ucyApKCB2YWx1ZSApO1xufTtcblxuLyoqXG4gKiAucGFyc2VOdW1iZXIoIHZhbHVlIFssIG9wdGlvbnNdIClcbiAqXG4gKiBAdmFsdWUgW1N0cmluZ11cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XTogU2VlIG51bWJlclBhcnNlcigpLlxuICpcbiAqIFJldHVybiB0aGUgcGFyc2VkIE51bWJlciAoaW5jbHVkaW5nIEluZmluaXR5KSBvciBOYU4gd2hlbiB2YWx1ZSBpcyBpbnZhbGlkLlxuICovXG5HbG9iYWxpemUucGFyc2VOdW1iZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5wYXJzZU51bWJlciA9IGZ1bmN0aW9uKCB2YWx1ZSwgb3B0aW9ucyApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRyZXR1cm4gdGhpcy5udW1iZXJQYXJzZXIoIG9wdGlvbnMgKSggdmFsdWUgKTtcbn07XG5cbi8qKlxuICogT3B0aW1pemF0aW9uIHRvIGF2b2lkIGR1cGxpY2F0aW5nIHNvbWUgaW50ZXJuYWwgZnVuY3Rpb25zIGFjcm9zcyBtb2R1bGVzLlxuICovXG5HbG9iYWxpemUuX2NyZWF0ZUVycm9yVW5zdXBwb3J0ZWRGZWF0dXJlID0gY3JlYXRlRXJyb3JVbnN1cHBvcnRlZEZlYXR1cmU7XG5HbG9iYWxpemUuX251bWJlck51bWJlcmluZ1N5c3RlbSA9IG51bWJlck51bWJlcmluZ1N5c3RlbTtcbkdsb2JhbGl6ZS5fbnVtYmVyTnVtYmVyaW5nU3lzdGVtRGlnaXRzTWFwID0gbnVtYmVyTnVtYmVyaW5nU3lzdGVtRGlnaXRzTWFwO1xuR2xvYmFsaXplLl9udW1iZXJQYXR0ZXJuID0gbnVtYmVyUGF0dGVybjtcbkdsb2JhbGl6ZS5fbnVtYmVyU3ltYm9sID0gbnVtYmVyU3ltYm9sO1xuR2xvYmFsaXplLl9sb29zZU1hdGNoaW5nID0gbG9vc2VNYXRjaGluZztcbkdsb2JhbGl6ZS5fcmVtb3ZlTGl0ZXJhbFF1b3RlcyA9IHJlbW92ZUxpdGVyYWxRdW90ZXM7XG5HbG9iYWxpemUuX3N0cmluZ1BhZCA9IHN0cmluZ1BhZDtcbkdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyID0gdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyO1xuR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcgPSB2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmc7XG5cbnJldHVybiBHbG9iYWxpemU7XG5cblxuXG5cbn0pKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL251bWJlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL251bWJlci5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgZGVmaW5lID0gZmFsc2U7XG5cbi8qKlxuICogR2xvYmFsaXplIHYxLjMuMFxuICpcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcbiAqXG4gKiBDb3B5cmlnaHQgalF1ZXJ5IEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wNy0wM1QyMTozN1pcbiAqL1xuLyohXG4gKiBHbG9iYWxpemUgdjEuMy4wIDIwMTctMDctMDNUMjE6MzdaIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2dpdC5pby9UcmRRYndcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXG5cdC8vIFVNRCByZXR1cm5FeHBvcnRzXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1xuXHRcdFx0XCJjbGRyXCIsXG5cdFx0XHRcIi4uL2dsb2JhbGl6ZVwiLFxuXHRcdFx0XCJjbGRyL2V2ZW50XCIsXG5cdFx0XHRcImNsZHIvc3VwcGxlbWVudGFsXCJcblx0XHRdLCBmYWN0b3J5ICk7XG5cdH0gZWxzZSBpZiAoIHR5cGVvZiBleHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gTm9kZSwgQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoIHJlcXVpcmUoIFwiY2xkcmpzXCIgKSwgcmVxdWlyZSggXCIuLi9nbG9iYWxpemVcIiApICk7XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBHbG9iYWxcblx0XHRmYWN0b3J5KCByb290LkNsZHIsIHJvb3QuR2xvYmFsaXplICk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24oIENsZHIsIEdsb2JhbGl6ZSApIHtcblxudmFyIHJ1bnRpbWVCaW5kID0gR2xvYmFsaXplLl9ydW50aW1lQmluZCxcblx0dmFsaWRhdGVDbGRyID0gR2xvYmFsaXplLl92YWxpZGF0ZUNsZHIsXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVEZWZhdWx0TG9jYWxlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGUgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZSxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0O1xudmFyIE1ha2VQbHVyYWw7XG4vKiBqc2hpbnQgaWdub3JlOnN0YXJ0ICovXG5NYWtlUGx1cmFsID0gKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgX3RvQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7IHJldHVybiBBcnJheS5pc0FycmF5KGFycikgPyBhcnIgOiBBcnJheS5mcm9tKGFycik7IH07XG5cbnZhciBfdG9Db25zdW1hYmxlQXJyYXkgPSBmdW5jdGlvbiAoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfTtcblxudmFyIF9jbGFzc0NhbGxDaGVjayA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uJyk7IH0gfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IChmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoJ3ZhbHVlJyBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSkoKTtcblxuXG4vKipcbiAqIG1ha2UtcGx1cmFsLmpzIC0tIGh0dHBzOi8vZ2l0aHViLmNvbS9lZW1lbGkvbWFrZS1wbHVyYWwuanMvXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxNSBieSBFZW1lbGkgQXJvIDxlZW1lbGlAZ21haWwuY29tPlxuICpcbiAqIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxuICogcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLCBwcm92aWRlZCB0aGF0IHRoZSBhYm92ZVxuICogY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBhcHBlYXIgaW4gYWxsIGNvcGllcy5cbiAqXG4gKiBUaGUgc29mdHdhcmUgaXMgcHJvdmlkZWQgXCJhcyBpc1wiIGFuZCB0aGUgYXV0aG9yIGRpc2NsYWltcyBhbGwgd2FycmFudGllc1xuICogd2l0aCByZWdhcmQgdG8gdGhpcyBzb2Z0d2FyZSBpbmNsdWRpbmcgYWxsIGltcGxpZWQgd2FycmFudGllcyBvZlxuICogbWVyY2hhbnRhYmlsaXR5IGFuZCBmaXRuZXNzLiBJbiBubyBldmVudCBzaGFsbCB0aGUgYXV0aG9yIGJlIGxpYWJsZSBmb3JcbiAqIGFueSBzcGVjaWFsLCBkaXJlY3QsIGluZGlyZWN0LCBvciBjb25zZXF1ZW50aWFsIGRhbWFnZXMgb3IgYW55IGRhbWFnZXNcbiAqIHdoYXRzb2V2ZXIgcmVzdWx0aW5nIGZyb20gbG9zcyBvZiB1c2UsIGRhdGEgb3IgcHJvZml0cywgd2hldGhlciBpbiBhblxuICogYWN0aW9uIG9mIGNvbnRyYWN0LCBuZWdsaWdlbmNlIG9yIG90aGVyIHRvcnRpb3VzIGFjdGlvbiwgYXJpc2luZyBvdXQgb2ZcbiAqIG9yIGluIGNvbm5lY3Rpb24gd2l0aCB0aGUgdXNlIG9yIHBlcmZvcm1hbmNlIG9mIHRoaXMgc29mdHdhcmUuXG4gKi9cblxudmFyIFBhcnNlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFyc2VyKCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGFyc2VyKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUGFyc2VyLCBbe1xuICAgICAgICBrZXk6ICdwYXJzZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShjb25kKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoY29uZCA9PT0gJ2kgPSAwIG9yIG4gPSAxJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbiA+PSAwICYmIG4gPD0gMSc7XG4gICAgICAgICAgICB9aWYgKGNvbmQgPT09ICdpID0gMCwxJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbiA+PSAwICYmIG4gPCAyJztcbiAgICAgICAgICAgIH1pZiAoY29uZCA9PT0gJ2kgPSAxIGFuZCB2ID0gMCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnYwID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ24gPT0gMSAmJiB2MCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29uZC5yZXBsYWNlKC8oW3R2XSkgKCE/KT0gMC9nLCBmdW5jdGlvbiAobSwgc3ltLCBub3RlcSkge1xuICAgICAgICAgICAgICAgIHZhciBzbiA9IHN5bSArICcwJztcbiAgICAgICAgICAgICAgICBfdGhpc1tzbl0gPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBub3RlcSA/ICchJyArIHNuIDogc247XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC9cXGJbZmludHZdXFxiL2csIGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgX3RoaXNbbV0gPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBtO1xuICAgICAgICAgICAgfSkucmVwbGFjZSgvKFtmaW5dKSAlICgxMCspL2csIGZ1bmN0aW9uIChtLCBzeW0sIG51bSkge1xuICAgICAgICAgICAgICAgIHZhciBzbiA9IHN5bSArIG51bTtcbiAgICAgICAgICAgICAgICBfdGhpc1tzbl0gPSAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBzbjtcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoL24xMCsgPSAwL2csICd0MCAmJiAkJicpLnJlcGxhY2UoLyhcXHcrICghPyk9ICkoWzAtOS5dKyxbMC05LixdKykvZywgZnVuY3Rpb24gKG0sIHNlLCBub3RlcSwgeCkge1xuICAgICAgICAgICAgICAgIGlmIChtID09PSAnbiA9IDAsMScpIHJldHVybiAnKG4gPT0gMCB8fCBuID09IDEpJztcbiAgICAgICAgICAgICAgICBpZiAobm90ZXEpIHJldHVybiBzZSArIHguc3BsaXQoJywnKS5qb2luKCcgJiYgJyArIHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJygnICsgc2UgKyB4LnNwbGl0KCcsJykuam9pbignIHx8ICcgKyBzZSkgKyAnKSc7XG4gICAgICAgICAgICB9KS5yZXBsYWNlKC8oXFx3KykgKCE/KT0gKFswLTldKylcXC5cXC4oWzAtOV0rKS9nLCBmdW5jdGlvbiAobSwgc3ltLCBub3RlcSwgeDAsIHgxKSB7XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlcih4MCkgKyAxID09PSBOdW1iZXIoeDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3RlcSkgcmV0dXJuICcnICsgc3ltICsgJyAhPSAnICsgeDAgKyAnICYmICcgKyBzeW0gKyAnICE9ICcgKyB4MTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcoJyArIHN5bSArICcgPT0gJyArIHgwICsgJyB8fCAnICsgc3ltICsgJyA9PSAnICsgeDEgKyAnKSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub3RlcSkgcmV0dXJuICcoJyArIHN5bSArICcgPCAnICsgeDAgKyAnIHx8ICcgKyBzeW0gKyAnID4gJyArIHgxICsgJyknO1xuICAgICAgICAgICAgICAgIGlmIChzeW0gPT09ICduJykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy50MCA9IDE7cmV0dXJuICcodDAgJiYgbiA+PSAnICsgeDAgKyAnICYmIG4gPD0gJyArIHgxICsgJyknO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gJygnICsgc3ltICsgJyA+PSAnICsgeDAgKyAnICYmICcgKyBzeW0gKyAnIDw9ICcgKyB4MSArICcpJztcbiAgICAgICAgICAgIH0pLnJlcGxhY2UoLyBhbmQgL2csICcgJiYgJykucmVwbGFjZSgvIG9yIC9nLCAnIHx8ICcpLnJlcGxhY2UoLyA9IC9nLCAnID09ICcpO1xuICAgICAgICB9XG4gICAgfSwge1xuICAgICAgICBrZXk6ICd2YXJzJyxcbiAgICAgICAgdmFsdWU6IChmdW5jdGlvbiAoX3ZhcnMpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIHZhcnMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF92YXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhcnMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF92YXJzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gdmFycztcbiAgICAgICAgfSkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZhcnMgPSBbXTtcbiAgICAgICAgICAgIGlmICh0aGlzLmkpIHZhcnMucHVzaCgnaSA9IHNbMF0nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmYgfHwgdGhpcy52KSB2YXJzLnB1c2goJ2YgPSBzWzFdIHx8IFxcJ1xcJycpO1xuICAgICAgICAgICAgaWYgKHRoaXMudCkgdmFycy5wdXNoKCd0ID0gKHNbMV0gfHwgXFwnXFwnKS5yZXBsYWNlKC8wKyQvLCBcXCdcXCcpJyk7XG4gICAgICAgICAgICBpZiAodGhpcy52KSB2YXJzLnB1c2goJ3YgPSBmLmxlbmd0aCcpO1xuICAgICAgICAgICAgaWYgKHRoaXMudjApIHZhcnMucHVzaCgndjAgPSAhc1sxXScpO1xuICAgICAgICAgICAgaWYgKHRoaXMudDAgfHwgdGhpcy5uMTAgfHwgdGhpcy5uMTAwKSB2YXJzLnB1c2goJ3QwID0gTnVtYmVyKHNbMF0pID09IG4nKTtcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gdGhpcykge1xuICAgICAgICAgICAgICAgIGlmICgvXi4xMCskLy50ZXN0KGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBrMCA9IGtbMF0gPT09ICduJyA/ICd0MCAmJiBzWzBdJyA6IGtbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhcnMucHVzaCgnJyArIGsgKyAnID0gJyArIGswICsgJy5zbGljZSgtJyArIGsuc3Vic3RyKDIpLmxlbmd0aCArICcpJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfWlmICghdmFycy5sZW5ndGgpIHJldHVybiAnJztcbiAgICAgICAgICAgIHJldHVybiAndmFyICcgKyBbJ3MgPSBTdHJpbmcobikuc3BsaXQoXFwnLlxcJyknXS5jb25jYXQodmFycykuam9pbignLCAnKTtcbiAgICAgICAgfSlcbiAgICB9XSk7XG5cbiAgICByZXR1cm4gUGFyc2VyO1xufSkoKTtcblxuXG5cbnZhciBNYWtlUGx1cmFsID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYWtlUGx1cmFsKGxjKSB7XG4gICAgICAgIHZhciBfcmVmID0gYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyBNYWtlUGx1cmFsIDogYXJndW1lbnRzWzFdO1xuXG4gICAgICAgIHZhciBjYXJkaW5hbHMgPSBfcmVmLmNhcmRpbmFscztcbiAgICAgICAgdmFyIG9yZGluYWxzID0gX3JlZi5vcmRpbmFscztcblxuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFrZVBsdXJhbCk7XG5cbiAgICAgICAgaWYgKCFjYXJkaW5hbHMgJiYgIW9yZGluYWxzKSB0aHJvdyBuZXcgRXJyb3IoJ0F0IGxlYXN0IG9uZSB0eXBlIG9mIHBsdXJhbCBpcyByZXF1aXJlZCcpO1xuICAgICAgICB0aGlzLmxjID0gbGM7XG4gICAgICAgIHRoaXMuY2F0ZWdvcmllcyA9IHsgY2FyZGluYWw6IFtdLCBvcmRpbmFsOiBbXSB9O1xuICAgICAgICB0aGlzLnBhcnNlciA9IG5ldyBQYXJzZXIoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZm4gPSB0aGlzLmJ1aWxkRnVuY3Rpb24oY2FyZGluYWxzLCBvcmRpbmFscyk7XG4gICAgICAgIHRoaXMuZm4uX29iaiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZm4uY2F0ZWdvcmllcyA9IHRoaXMuY2F0ZWdvcmllcztcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZm4udG9TdHJpbmcgPSB0aGlzLmZuVG9TdHJpbmcuYmluZCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm47XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKE1ha2VQbHVyYWwsIFt7XG4gICAgICAgIGtleTogJ2NvbXBpbGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZSh0eXBlLCByZXEpIHtcbiAgICAgICAgICAgIHZhciBjYXNlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJ1bGVzID0gTWFrZVBsdXJhbC5ydWxlc1t0eXBlXVt0aGlzLmxjXTtcbiAgICAgICAgICAgIGlmICghcnVsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVxKSB0aHJvdyBuZXcgRXJyb3IoJ0xvY2FsZSBcIicgKyB0aGlzLmxjICsgJ1wiICcgKyB0eXBlICsgJyBydWxlcyBub3QgZm91bmQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhdGVnb3JpZXNbdHlwZV0gPSBbJ290aGVyJ107XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXCdvdGhlclxcJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciByIGluIHJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9ydWxlcyRyJHRyaW0kc3BsaXQgPSBydWxlc1tyXS50cmltKCkuc3BsaXQoL1xccypAXFx3Ki8pO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9ydWxlcyRyJHRyaW0kc3BsaXQyID0gX3RvQXJyYXkoX3J1bGVzJHIkdHJpbSRzcGxpdCk7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29uZCA9IF9ydWxlcyRyJHRyaW0kc3BsaXQyWzBdO1xuICAgICAgICAgICAgICAgIHZhciBleGFtcGxlcyA9IF9ydWxlcyRyJHRyaW0kc3BsaXQyLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIHZhciBjYXQgPSByLnJlcGxhY2UoJ3BsdXJhbFJ1bGUtY291bnQtJywgJycpO1xuICAgICAgICAgICAgICAgIGlmIChjb25kKSBjYXNlcy5wdXNoKFt0aGlzLnBhcnNlci5wYXJzZShjb25kKSwgY2F0XSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhdGVnb3JpZXNbdHlwZV0gPSBjYXNlcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY1sxXTtcbiAgICAgICAgICAgIH0pLmNvbmNhdCgnb3RoZXInKTtcbiAgICAgICAgICAgIGlmIChjYXNlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJygnICsgY2FzZXNbMF1bMF0gKyAnKSA/IFxcJycgKyBjYXNlc1swXVsxXSArICdcXCcgOiBcXCdvdGhlclxcJyc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNhc2VzLm1hcChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJygnICsgY1swXSArICcpID8gXFwnJyArIGNbMV0gKyAnXFwnJztcbiAgICAgICAgICAgICAgICB9KSksIFsnXFwnb3RoZXJcXCcnXSkuam9pbignXFxuICAgICAgOiAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnYnVpbGRGdW5jdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBidWlsZEZ1bmN0aW9uKGNhcmRpbmFscywgb3JkaW5hbHMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgICB2YXIgY29tcGlsZSA9IGZ1bmN0aW9uIGNvbXBpbGUoYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjID8gKGNbMV0gPyAncmV0dXJuICcgOiAnaWYgKG9yZCkgcmV0dXJuICcpICsgX3RoaXMzLmNvbXBpbGUuYXBwbHkoX3RoaXMzLCBfdG9Db25zdW1hYmxlQXJyYXkoYykpIDogJyc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGZvbGQgPSB7IHZhcnM6IGZ1bmN0aW9uIHZhcnMoc3RyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoJyAgJyArIHN0ciArICc7JykucmVwbGFjZSgvKC57MSw3OH0pKCx8JCkgPy9nLCAnJDEkMlxcbiAgICAgICcpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29uZDogZnVuY3Rpb24gY29uZChzdHIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgnICAnICsgc3RyICsgJzsnKS5yZXBsYWNlKC8oLnsxLDc4fSkgKFxcfFxcfCB8JCkgPy9nbSwgJyQxXFxuICAgICAgICAgICQyJyk7XG4gICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgIGNvbmQgPSBbb3JkaW5hbHMgJiYgWydvcmRpbmFsJywgIWNhcmRpbmFsc10sIGNhcmRpbmFscyAmJiBbJ2NhcmRpbmFsJywgdHJ1ZV1dLm1hcChjb21waWxlKS5tYXAoZm9sZC5jb25kKSxcbiAgICAgICAgICAgICAgICBib2R5ID0gW2ZvbGQudmFycyh0aGlzLnBhcnNlci52YXJzKCkpXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGNvbmQpKS5qb2luKCdcXG4nKS5yZXBsYWNlKC9cXHMrJC9nbSwgJycpLnJlcGxhY2UoL15bXFxzO10qW1xcclxcbl0rL2dtLCAnJyksXG4gICAgICAgICAgICAgICAgYXJncyA9IG9yZGluYWxzICYmIGNhcmRpbmFscyA/ICduLCBvcmQnIDogJ24nO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGdW5jdGlvbihhcmdzLCBib2R5KTtcbiAgICAgICAgfVxuICAgIH0sIHtcbiAgICAgICAga2V5OiAnZm5Ub1N0cmluZycsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBmblRvU3RyaW5nKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzLmZuKS5yZXBsYWNlKC9eZnVuY3Rpb24oIFxcdyspPy8sIG5hbWUgPyAnZnVuY3Rpb24gJyArIG5hbWUgOiAnZnVuY3Rpb24nKS5yZXBsYWNlKCdcXG4vKiovJywgJycpO1xuICAgICAgICB9XG4gICAgfV0sIFt7XG4gICAgICAgIGtleTogJ2xvYWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZCgpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXJncy5mb3JFYWNoKGZ1bmN0aW9uIChjbGRyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBjbGRyICYmIGNsZHIuc3VwcGxlbWVudGFsIHx8IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgZG9lcyBub3QgYXBwZWFyIHRvIGJlIENMRFIgZGF0YScpO1xuICAgICAgICAgICAgICAgIE1ha2VQbHVyYWwucnVsZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhcmRpbmFsOiBkYXRhWydwbHVyYWxzLXR5cGUtY2FyZGluYWwnXSB8fCBNYWtlUGx1cmFsLnJ1bGVzLmNhcmRpbmFsLFxuICAgICAgICAgICAgICAgICAgICBvcmRpbmFsOiBkYXRhWydwbHVyYWxzLXR5cGUtb3JkaW5hbCddIHx8IE1ha2VQbHVyYWwucnVsZXMub3JkaW5hbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBNYWtlUGx1cmFsO1xuICAgICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE1ha2VQbHVyYWw7XG59KSgpO1xuXG5cblxuTWFrZVBsdXJhbC5jYXJkaW5hbHMgPSB0cnVlO1xuTWFrZVBsdXJhbC5vcmRpbmFscyA9IGZhbHNlO1xuTWFrZVBsdXJhbC5ydWxlcyA9IHsgY2FyZGluYWw6IHt9LCBvcmRpbmFsOiB7fSB9O1xuXG5cbnJldHVybiBNYWtlUGx1cmFsO1xufSgpKTtcbi8qIGpzaGludCBpZ25vcmU6ZW5kICovXG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciA9IGZ1bmN0aW9uKCB2YWx1ZSwgbmFtZSApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlKFxuXHRcdHZhbHVlLFxuXHRcdG5hbWUsXG5cdFx0dmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIsXG5cdFx0XCJOdW1iZXJcIlxuXHQpO1xufTtcblxuXG5cblxudmFyIHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsdXJhbFR5cGUgPSBmdW5jdGlvbiggdmFsdWUsIG5hbWUgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZShcblx0XHR2YWx1ZSxcblx0XHRuYW1lLFxuXHRcdHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IFwiY2FyZGluYWxcIiB8fCB2YWx1ZSA9PT0gXCJvcmRpbmFsXCIsXG5cdFx0XCJTdHJpbmcgXFxcImNhcmRpbmFsXFxcIiBvciBcXFwib3JkaW5hbFxcXCJcIlxuXHQpO1xufTtcblxuXG5cblxudmFyIHBsdXJhbEdlbmVyYXRvckZuID0gZnVuY3Rpb24oIHBsdXJhbCApIHtcblx0cmV0dXJuIGZ1bmN0aW9uIHBsdXJhbEdlbmVyYXRvciggdmFsdWUgKSB7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdFx0cmV0dXJuIHBsdXJhbCggdmFsdWUgKTtcblx0fTtcbn07XG5cblxuXG5cbi8qKlxuICogLnBsdXJhbCggdmFsdWUgKVxuICpcbiAqIEB2YWx1ZSBbTnVtYmVyXVxuICpcbiAqIFJldHVybiB0aGUgY29ycmVzcG9uZGluZyBmb3JtICh6ZXJvIHwgb25lIHwgdHdvIHwgZmV3IHwgbWFueSB8IG90aGVyKSBvZiBhXG4gKiB2YWx1ZSBnaXZlbiBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5wbHVyYWwgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5wbHVyYWwgPSBmdW5jdGlvbiggdmFsdWUsIG9wdGlvbnMgKSB7XG5cdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHJldHVybiB0aGlzLnBsdXJhbEdlbmVyYXRvciggb3B0aW9ucyApKCB2YWx1ZSApO1xufTtcblxuLyoqXG4gKiAucGx1cmFsR2VuZXJhdG9yKCBbb3B0aW9uc10gKVxuICpcbiAqIFJldHVybiBhIHBsdXJhbCBmdW5jdGlvbiAob2YgdGhlIGZvcm0gYmVsb3cpLlxuICpcbiAqIGZuKCB2YWx1ZSApXG4gKlxuICogQHZhbHVlIFtOdW1iZXJdXG4gKlxuICogUmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIGZvcm0gKHplcm8gfCBvbmUgfCB0d28gfCBmZXcgfCBtYW55IHwgb3RoZXIpIG9mIGEgdmFsdWUgZ2l2ZW4gdGhlXG4gKiBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLnBsdXJhbEdlbmVyYXRvciA9XG5HbG9iYWxpemUucHJvdG90eXBlLnBsdXJhbEdlbmVyYXRvciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgYXJncywgY2xkciwgaXNPcmRpbmFsLCBwbHVyYWwsIHJldHVybkZuLCB0eXBlO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcIm9wdGlvbnNcIiApO1xuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRjbGRyID0gdGhpcy5jbGRyO1xuXG5cdGFyZ3MgPSBbIG9wdGlvbnMgXTtcblx0dHlwZSA9IG9wdGlvbnMudHlwZSB8fCBcImNhcmRpbmFsXCI7XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGx1cmFsVHlwZSggb3B0aW9ucy50eXBlLCBcIm9wdGlvbnMudHlwZVwiICk7XG5cblx0dmFsaWRhdGVEZWZhdWx0TG9jYWxlKCBjbGRyICk7XG5cblx0aXNPcmRpbmFsID0gdHlwZSA9PT0gXCJvcmRpbmFsXCI7XG5cblx0Y2xkci5vbiggXCJnZXRcIiwgdmFsaWRhdGVDbGRyICk7XG5cdGNsZHIuc3VwcGxlbWVudGFsKFsgXCJwbHVyYWxzLXR5cGUtXCIgKyB0eXBlLCBcIntsYW5ndWFnZX1cIiBdKTtcblx0Y2xkci5vZmYoIFwiZ2V0XCIsIHZhbGlkYXRlQ2xkciApO1xuXG5cdE1ha2VQbHVyYWwucnVsZXMgPSB7fTtcblx0TWFrZVBsdXJhbC5ydWxlc1sgdHlwZSBdID0gY2xkci5zdXBwbGVtZW50YWwoIFwicGx1cmFscy10eXBlLVwiICsgdHlwZSApO1xuXG5cdHBsdXJhbCA9IG5ldyBNYWtlUGx1cmFsKCBjbGRyLmF0dHJpYnV0ZXMubGFuZ3VhZ2UsIHtcblx0XHRcIm9yZGluYWxzXCI6IGlzT3JkaW5hbCxcblx0XHRcImNhcmRpbmFsc1wiOiAhaXNPcmRpbmFsXG5cdH0pO1xuXG5cdHJldHVybkZuID0gcGx1cmFsR2VuZXJhdG9yRm4oIHBsdXJhbCApO1xuXG5cdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBwbHVyYWwgXSApO1xuXG5cdHJldHVybiByZXR1cm5Gbjtcbn07XG5cbnJldHVybiBHbG9iYWxpemU7XG5cblxuXG5cbn0pKTtcblxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3BsdXJhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3BsdXJhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKioqIElNUE9SVFMgRlJPTSBpbXBvcnRzLWxvYWRlciAqKiovXG52YXIgZGVmaW5lID0gZmFsc2U7XG5cbi8qKlxuICogR2xvYmFsaXplIHYxLjMuMFxuICpcbiAqIGh0dHA6Ly9naXRodWIuY29tL2pxdWVyeS9nbG9iYWxpemVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMCwgMjAxNCBqUXVlcnkgRm91bmRhdGlvbiwgSW5jLiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHA6Ly9qcXVlcnkub3JnL2xpY2Vuc2VcbiAqXG4gKiBEYXRlOiAyMDE3LTA3LTAzVDIxOjM3WlxuICovXG4vKiFcbiAqIEdsb2JhbGl6ZSB2MS4zLjAgMjAxNy0wNy0wM1QyMTozN1ogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vZ2l0LmlvL1RyZFFid1xuICovXG4oZnVuY3Rpb24oIHJvb3QsIGZhY3RvcnkgKSB7XG5cblx0Ly8gVU1EIHJldHVybkV4cG9ydHNcblx0aWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblxuXHRcdC8vIEFNRFxuXHRcdGRlZmluZShbXG5cdFx0XHRcImNsZHJcIixcblx0XHRcdFwiLi4vZ2xvYmFsaXplXCIsXG5cdFx0XHRcIi4vbnVtYmVyXCIsXG5cdFx0XHRcIi4vcGx1cmFsXCIsXG5cdFx0XHRcImNsZHIvZXZlbnRcIixcblx0XHRcdFwiY2xkci9zdXBwbGVtZW50YWxcIlxuXHRcdF0sIGZhY3RvcnkgKTtcblx0fSBlbHNlIGlmICggdHlwZW9mIGV4cG9ydHMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyBOb2RlLCBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSggcmVxdWlyZSggXCJjbGRyanNcIiApLCByZXF1aXJlKCBcIi4uL2dsb2JhbGl6ZVwiICkgKTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIEV4dGVuZCBnbG9iYWxcblx0XHRmYWN0b3J5KCByb290LkNsZHIsIHJvb3QuR2xvYmFsaXplICk7XG5cdH1cbn0odGhpcywgZnVuY3Rpb24oIENsZHIsIEdsb2JhbGl6ZSApIHtcblxudmFyIGZvcm1hdE1lc3NhZ2UgPSBHbG9iYWxpemUuX2Zvcm1hdE1lc3NhZ2UsXG5cdHJ1bnRpbWVCaW5kID0gR2xvYmFsaXplLl9ydW50aW1lQmluZCxcblx0dmFsaWRhdGVDbGRyID0gR2xvYmFsaXplLl92YWxpZGF0ZUNsZHIsXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVEZWZhdWx0TG9jYWxlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZyxcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXI7XG5cblxuLyoqXG4gKiBmb3JtYXQoIHZhbHVlLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApXG4gKlxuICogQHZhbHVlIFtOdW1iZXJdIFRoZSBudW1iZXIgdG8gZm9ybWF0XG4gKlxuICogQG51bWJlckZvcm1hdHRlciBbU3RyaW5nXSBBIG51bWJlckZvcm1hdHRlciBmcm9tIEdsb2JhbGl6ZS5udW1iZXJGb3JtYXR0ZXJcbiAqXG4gKiBAcGx1cmFsR2VuZXJhdG9yIFtTdHJpbmddIEEgcGx1cmFsR2VuZXJhdG9yIGZyb20gR2xvYmFsaXplLnBsdXJhbEdlbmVyYXRvclxuICpcbiAqIEBwcm9wZXJ0aWVzIFtPYmplY3RdIGNvbnRhaW5pbmcgcmVsYXRpdmUgdGltZSBwbHVyYWwgbWVzc2FnZS5cbiAqXG4gKiBGb3JtYXQgcmVsYXRpdmUgdGltZS5cbiAqL1xudmFyIHJlbGF0aXZlVGltZUZvcm1hdCA9IGZ1bmN0aW9uKCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKSB7XG5cblx0dmFyIHJlbGF0aXZlVGltZSxcblx0XHRtZXNzYWdlID0gcHJvcGVydGllc1sgXCJyZWxhdGl2ZS10eXBlLVwiICsgdmFsdWUgXTtcblxuXHRpZiAoIG1lc3NhZ2UgKSB7XG5cdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdH1cblxuXHRyZWxhdGl2ZVRpbWUgPSB2YWx1ZSA8PSAwID8gcHJvcGVydGllc1sgXCJyZWxhdGl2ZVRpbWUtdHlwZS1wYXN0XCIgXVxuXHRcdDogcHJvcGVydGllc1sgXCJyZWxhdGl2ZVRpbWUtdHlwZS1mdXR1cmVcIiBdO1xuXG5cdHZhbHVlID0gTWF0aC5hYnMoIHZhbHVlICk7XG5cblx0bWVzc2FnZSA9IHJlbGF0aXZlVGltZVsgXCJyZWxhdGl2ZVRpbWVQYXR0ZXJuLWNvdW50LVwiICsgcGx1cmFsR2VuZXJhdG9yKCB2YWx1ZSApIF07XG5cdHJldHVybiBmb3JtYXRNZXNzYWdlKCBtZXNzYWdlLCBbIG51bWJlckZvcm1hdHRlciggdmFsdWUgKSBdICk7XG59O1xuXG5cblxuXG52YXIgcmVsYXRpdmVUaW1lRm9ybWF0dGVyRm4gPSBmdW5jdGlvbiggbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKSB7XG5cdHJldHVybiBmdW5jdGlvbiByZWxhdGl2ZVRpbWVGb3JtYXR0ZXIoIHZhbHVlICkge1xuXHRcdHZhbGlkYXRlUGFyYW1ldGVyUHJlc2VuY2UoIHZhbHVlLCBcInZhbHVlXCIgKTtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRcdHJldHVybiByZWxhdGl2ZVRpbWVGb3JtYXQoIHZhbHVlLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApO1xuXHR9O1xuXG59O1xuXG5cblxuXG4vKipcbiAqIHByb3BlcnRpZXMoIHVuaXQsIGNsZHIsIG9wdGlvbnMgKVxuICpcbiAqIEB1bml0IFtTdHJpbmddIGVnLiBcImRheVwiLCBcIndlZWtcIiwgXCJtb250aFwiLCBldGMuXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdXG4gKiAtIGZvcm06IFtTdHJpbmddIGVnLiBcInNob3J0XCIgb3IgXCJuYXJyb3dcIi4gT3IgZmFsc3kgZm9yIGRlZmF1bHQgbG9uZyBmb3JtLlxuICpcbiAqIFJldHVybiByZWxhdGl2ZSB0aW1lIHByb3BlcnRpZXMuXG4gKi9cbnZhciByZWxhdGl2ZVRpbWVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIHVuaXQsIGNsZHIsIG9wdGlvbnMgKSB7XG5cblx0dmFyIGZvcm0gPSBvcHRpb25zLmZvcm0sXG5cdFx0cmF3LCBwcm9wZXJ0aWVzLCBrZXksIG1hdGNoO1xuXG5cdGlmICggZm9ybSApIHtcblx0XHR1bml0ID0gdW5pdCArIFwiLVwiICsgZm9ybTtcblx0fVxuXG5cdHJhdyA9IGNsZHIubWFpbiggWyBcImRhdGVzXCIsIFwiZmllbGRzXCIsIHVuaXQgXSApO1xuXHRwcm9wZXJ0aWVzID0ge1xuXHRcdFwicmVsYXRpdmVUaW1lLXR5cGUtZnV0dXJlXCI6IHJhd1sgXCJyZWxhdGl2ZVRpbWUtdHlwZS1mdXR1cmVcIiBdLFxuXHRcdFwicmVsYXRpdmVUaW1lLXR5cGUtcGFzdFwiOiByYXdbIFwicmVsYXRpdmVUaW1lLXR5cGUtcGFzdFwiIF1cblx0fTtcblx0Zm9yICgga2V5IGluIHJhdyApIHtcblx0XHRpZiAoIHJhdy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRtYXRjaCA9IC9yZWxhdGl2ZS10eXBlLSgtP1swLTldKykvLmV4ZWMoIGtleSApO1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0cHJvcGVydGllc1sga2V5IF0gPSByYXdbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBwcm9wZXJ0aWVzO1xufTtcblxuXG5cblxuLyoqXG4gKiAuZm9ybWF0UmVsYXRpdmVUaW1lKCB2YWx1ZSwgdW5pdCBbLCBvcHRpb25zXSApXG4gKlxuICogQHZhbHVlIFtOdW1iZXJdIFRoZSBudW1iZXIgb2YgdW5pdCB0byBmb3JtYXQuXG4gKlxuICogQHVuaXQgW1N0cmluZ10gc2VlIC5yZWxhdGl2ZVRpbWVGb3JtYXR0ZXIoKSBmb3IgZGV0YWlscy5cbiAqXG4gKiBAb3B0aW9ucyBbT2JqZWN0XSBzZWUgLnJlbGF0aXZlVGltZUZvcm1hdHRlcigpIGZvciBkZXRhaWxzLlxuICpcbiAqIEZvcm1hdHMgYSByZWxhdGl2ZSB0aW1lIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gdW5pdCwgb3B0aW9ucywgYW5kIHRoZSBkZWZhdWx0L2luc3RhbmNlIGxvY2FsZS5cbiAqL1xuR2xvYmFsaXplLmZvcm1hdFJlbGF0aXZlVGltZSA9XG5HbG9iYWxpemUucHJvdG90eXBlLmZvcm1hdFJlbGF0aXZlVGltZSA9IGZ1bmN0aW9uKCB2YWx1ZSwgdW5pdCwgb3B0aW9ucyApIHtcblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdmFsdWUsIFwidmFsdWVcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVOdW1iZXIoIHZhbHVlLCBcInZhbHVlXCIgKTtcblxuXHRyZXR1cm4gdGhpcy5yZWxhdGl2ZVRpbWVGb3JtYXR0ZXIoIHVuaXQsIG9wdGlvbnMgKSggdmFsdWUgKTtcbn07XG5cbi8qKlxuICogLnJlbGF0aXZlVGltZUZvcm1hdHRlciggdW5pdCBbLCBvcHRpb25zIF0pXG4gKlxuICogQHVuaXQgW1N0cmluZ10gU3RyaW5nIHZhbHVlIGluZGljYXRpbmcgdGhlIHVuaXQgdG8gYmUgZm9ybWF0dGVkLiBlZy4gXCJkYXlcIiwgXCJ3ZWVrXCIsIFwibW9udGhcIiwgZXRjLlxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdXG4gKiAtIGZvcm06IFtTdHJpbmddIGVnLiBcInNob3J0XCIgb3IgXCJuYXJyb3dcIi4gT3IgZmFsc3kgZm9yIGRlZmF1bHQgbG9uZyBmb3JtLlxuICpcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGZvcm1hdHMgYSByZWxhdGl2ZSB0aW1lIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gdW5pdCwgb3B0aW9ucywgYW5kIHRoZVxuICogZGVmYXVsdC9pbnN0YW5jZSBsb2NhbGUuXG4gKi9cbkdsb2JhbGl6ZS5yZWxhdGl2ZVRpbWVGb3JtYXR0ZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5yZWxhdGl2ZVRpbWVGb3JtYXR0ZXIgPSBmdW5jdGlvbiggdW5pdCwgb3B0aW9ucyApIHtcblx0dmFyIGFyZ3MsIGNsZHIsIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCBwcm9wZXJ0aWVzLCByZXR1cm5GbjtcblxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB1bml0LCBcInVuaXRcIiApO1xuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcoIHVuaXQsIFwidW5pdFwiICk7XG5cblx0Y2xkciA9IHRoaXMuY2xkcjtcblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0YXJncyA9IFsgdW5pdCwgb3B0aW9ucyBdO1xuXG5cdHZhbGlkYXRlRGVmYXVsdExvY2FsZSggY2xkciApO1xuXG5cdGNsZHIub24oIFwiZ2V0XCIsIHZhbGlkYXRlQ2xkciApO1xuXHRwcm9wZXJ0aWVzID0gcmVsYXRpdmVUaW1lUHJvcGVydGllcyggdW5pdCwgY2xkciwgb3B0aW9ucyApO1xuXHRjbGRyLm9mZiggXCJnZXRcIiwgdmFsaWRhdGVDbGRyICk7XG5cblx0bnVtYmVyRm9ybWF0dGVyID0gdGhpcy5udW1iZXJGb3JtYXR0ZXIoIG9wdGlvbnMgKTtcblx0cGx1cmFsR2VuZXJhdG9yID0gdGhpcy5wbHVyYWxHZW5lcmF0b3IoKTtcblxuXHRyZXR1cm5GbiA9IHJlbGF0aXZlVGltZUZvcm1hdHRlckZuKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyApO1xuXG5cdHJ1bnRpbWVCaW5kKCBhcmdzLCBjbGRyLCByZXR1cm5GbiwgWyBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyBdICk7XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxucmV0dXJuIEdsb2JhbGl6ZTtcblxuXG5cblxufSkpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvcmVsYXRpdmUtdGltZS5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3JlbGF0aXZlLXRpbWUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGRlZmluZSA9IGZhbHNlO1xuXG4vKipcbiAqIEdsb2JhbGl6ZSB2MS4zLjBcbiAqXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXG4gKlxuICogQ29weXJpZ2h0IDIwMTAsIDIwMTQgalF1ZXJ5IEZvdW5kYXRpb24sIEluYy4gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXG4gKlxuICogRGF0ZTogMjAxNy0wNy0wM1QyMTozN1pcbiAqL1xuLyohXG4gKiBHbG9iYWxpemUgdjEuMy4wIDIwMTctMDctMDNUMjE6MzdaIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2dpdC5pby9UcmRRYndcbiAqL1xuKGZ1bmN0aW9uKCByb290LCBmYWN0b3J5ICkge1xuXG5cdC8vIFVNRCByZXR1cm5FeHBvcnRzXG5cdGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cblx0XHQvLyBBTURcblx0XHRkZWZpbmUoW1xuXHRcdFx0XCJjbGRyXCIsXG5cdFx0XHRcIi4uL2dsb2JhbGl6ZVwiLFxuXHRcdFx0XCIuL251bWJlclwiLFxuXHRcdFx0XCIuL3BsdXJhbFwiXG5cdFx0XSwgZmFjdG9yeSApO1xuXHR9IGVsc2UgaWYgKCB0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIE5vZGUsIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCByZXF1aXJlKCBcImNsZHJqc1wiICksIHJlcXVpcmUoIFwiLi4vZ2xvYmFsaXplXCIgKSApO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gRXh0ZW5kIGdsb2JhbFxuXHRcdGZhY3RvcnkoIHJvb3QuQ2xkciwgcm9vdC5HbG9iYWxpemUgKTtcblx0fVxufSh0aGlzLCBmdW5jdGlvbiggQ2xkciwgR2xvYmFsaXplICkge1xuXG52YXIgZm9ybWF0TWVzc2FnZSA9IEdsb2JhbGl6ZS5fZm9ybWF0TWVzc2FnZSxcblx0cnVudGltZUJpbmQgPSBHbG9iYWxpemUuX3J1bnRpbWVCaW5kLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlID0gR2xvYmFsaXplLl92YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVQbGFpbk9iamVjdCA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlUGxhaW5PYmplY3QsXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciA9IEdsb2JhbGl6ZS5fdmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyLFxuXHR2YWxpZGF0ZVBhcmFtZXRlclR5cGVTdHJpbmcgPSBHbG9iYWxpemUuX3ZhbGlkYXRlUGFyYW1ldGVyVHlwZVN0cmluZztcblxuXG4vKipcbiAqIGZvcm1hdCggdmFsdWUsIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCB1bml0UHJvcGVyaWVzIClcbiAqXG4gKiBAdmFsdWUgW051bWJlcl1cbiAqXG4gKiBAbnVtYmVyRm9ybWF0dGVyIFtPYmplY3RdOiBBIG51bWJlckZvcm1hdHRlciBmcm9tIEdsb2JhbGl6ZS5udW1iZXJGb3JtYXR0ZXIuXG4gKlxuICogQHBsdXJhbEdlbmVyYXRvciBbT2JqZWN0XTogQSBwbHVyYWxHZW5lcmF0b3IgZnJvbSBHbG9iYWxpemUucGx1cmFsR2VuZXJhdG9yLlxuICpcbiAqIEB1bml0UHJvcGVyaWVzIFtPYmplY3RdOiBsb2NhbGl6ZWQgdW5pdCBkYXRhIGZyb20gY2xkci5cbiAqXG4gKiBGb3JtYXQgdW5pdHMgc3VjaCBhcyBzZWNvbmRzLCBtaW51dGVzLCBkYXlzLCB3ZWVrcywgZXRjLlxuICpcbiAqIE9CUzpcbiAqXG4gKiBVbml0IFNlcXVlbmNlcyBhcmUgbm90IGltcGxlbWVudGVkLlxuICogaHR0cDovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzUvdHIzNS0zNS90cjM1LWdlbmVyYWwuaHRtbCNVbml0X1NlcXVlbmNlc1xuICpcbiAqIER1cmF0aW9uIFVuaXQgKGZvciBjb21wb3NlZCB0aW1lIHVuaXQgZHVyYXRpb25zKSBpcyBub3QgaW1wbGVtZW50ZWQuXG4gKiBodHRwOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzNS90cjM1LTM1L3RyMzUtZ2VuZXJhbC5odG1sI2R1cmF0aW9uVW5pdFxuICovXG52YXIgdW5pdEZvcm1hdCA9IGZ1bmN0aW9uKCB2YWx1ZSwgbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHVuaXRQcm9wZXJ0aWVzICkge1xuXHR2YXIgY29tcG91bmRVbml0UGF0dGVybiA9IHVuaXRQcm9wZXJ0aWVzLmNvbXBvdW5kVW5pdFBhdHRlcm4sIGRpdmlkZW5kLCBkaXZpZGVuZFByb3BlcnRpZXMsXG5cdFx0Zm9ybWF0dGVkVmFsdWUsIGRpdmlzb3IsIGRpdmlzb3JQcm9wZXJ0aWVzLCBtZXNzYWdlLCBwbHVyYWxWYWx1ZTtcblxuXHR1bml0UHJvcGVydGllcyA9IHVuaXRQcm9wZXJ0aWVzLnVuaXRQcm9wZXJ0aWVzO1xuXHRmb3JtYXR0ZWRWYWx1ZSA9IG51bWJlckZvcm1hdHRlciggdmFsdWUgKTtcblx0cGx1cmFsVmFsdWUgPSBwbHVyYWxHZW5lcmF0b3IoIHZhbHVlICk7XG5cblx0Ly8gY29tcHV0ZWQgY29tcG91bmQgdW5pdCwgZWcuIFwibWVnYWJ5dGUtcGVyLXNlY29uZFwiLlxuXHRpZiAoIHVuaXRQcm9wZXJ0aWVzIGluc3RhbmNlb2YgQXJyYXkgKSB7XG5cdFx0ZGl2aWRlbmRQcm9wZXJ0aWVzID0gdW5pdFByb3BlcnRpZXNbIDAgXTtcblx0XHRkaXZpc29yUHJvcGVydGllcyA9IHVuaXRQcm9wZXJ0aWVzWyAxIF07XG5cblx0XHRkaXZpZGVuZCA9IGZvcm1hdE1lc3NhZ2UoIGRpdmlkZW5kUHJvcGVydGllc1sgcGx1cmFsVmFsdWUgXSwgWyB2YWx1ZSBdICk7XG5cdFx0ZGl2aXNvciA9IGZvcm1hdE1lc3NhZ2UoIGRpdmlzb3JQcm9wZXJ0aWVzLm9uZSwgWyBcIlwiIF0gKS50cmltKCk7XG5cblx0XHRyZXR1cm4gZm9ybWF0TWVzc2FnZSggY29tcG91bmRVbml0UGF0dGVybiwgWyBkaXZpZGVuZCwgZGl2aXNvciBdICk7XG5cdH1cblxuXHRtZXNzYWdlID0gdW5pdFByb3BlcnRpZXNbIHBsdXJhbFZhbHVlIF07XG5cblx0cmV0dXJuIGZvcm1hdE1lc3NhZ2UoIG1lc3NhZ2UsIFsgZm9ybWF0dGVkVmFsdWUgXSApO1xufTtcblxuXG5cblxudmFyIHVuaXRGb3JtYXR0ZXJGbiA9IGZ1bmN0aW9uKCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgdW5pdFByb3BlcnRpZXMgKSB7XG5cdHJldHVybiBmdW5jdGlvbiB1bml0Rm9ybWF0dGVyKCB2YWx1ZSApIHtcblx0XHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdFx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlTnVtYmVyKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cblx0XHRyZXR1cm4gdW5pdEZvcm1hdCggdmFsdWUsIG51bWJlckZvcm1hdHRlciwgcGx1cmFsR2VuZXJhdG9yLCB1bml0UHJvcGVydGllcyApO1xuXHR9O1xuXG59O1xuXG5cblxuXG4vKipcbiAqIGNhdGVnb3JpZXMoKVxuICpcbiAqIFJldHVybiBhbGwgdW5pdCBjYXRlZ29yaWVzLlxuICovXG52YXIgdW5pdENhdGVnb3JpZXMgPSBbIFwiYWNjZWxlcmF0aW9uXCIsIFwiYW5nbGVcIiwgXCJhcmVhXCIsIFwiZGlnaXRhbFwiLCBcImR1cmF0aW9uXCIsIFwibGVuZ3RoXCIsIFwibWFzc1wiLCBcInBvd2VyXCIsXG5cInByZXNzdXJlXCIsIFwic3BlZWRcIiwgXCJ0ZW1wZXJhdHVyZVwiLCBcInZvbHVtZVwiIF07XG5cblxuXG5cbmZ1bmN0aW9uIHN0cmlwUGx1cmFsR2FyYmFnZSggZGF0YSApIHtcblx0dmFyIGF1eCwgcGx1cmFsQ291bnQ7XG5cblx0aWYgKCBkYXRhICkge1xuXHRcdGF1eCA9IHt9O1xuXHRcdGZvciAoIHBsdXJhbENvdW50IGluIGRhdGEgKSB7XG5cdFx0XHRhdXhbIHBsdXJhbENvdW50LnJlcGxhY2UoIC91bml0UGF0dGVybi1jb3VudC0vLCBcIlwiICkgXSA9IGRhdGFbIHBsdXJhbENvdW50IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGF1eDtcbn1cblxuLyoqXG4gKiBnZXQoIHVuaXQsIGZvcm0sIGNsZHIgKVxuICpcbiAqIEB1bml0IFtTdHJpbmddIFRoZSBmdWxsIHR5cGUtdW5pdCBuYW1lIChlZy4gZHVyYXRpb24tc2Vjb25kKSwgb3IgdGhlIHNob3J0IHVuaXQgbmFtZVxuICogKGVnLiBzZWNvbmQpLlxuICpcbiAqIEBmb3JtIFtTdHJpbmddIEEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGZvcm0gb2YgdGhlIHVuaXQgcmVwcmVzZW50YXRpb24gKGVnLiBsb25nLFxuICogc2hvcnQsIG5hcnJvdykuXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICpcbiAqIFJldHVybiB0aGUgcGx1cmFsIG1hcCBvZiBhIHVuaXQsIGVnOiBcInNlY29uZFwiXG4gKiB7IFwib25lXCI6IFwiezB9IHNlY29uZFwiLFxuICogICBcIm90aGVyXCI6IFwiezB9IHNlY29uZHNcIiB9XG4gKiB9XG4gKlxuICogT3IgdGhlIEFycmF5IG9mIHBsdXJhbCBtYXBzIG9mIGEgY29tcG91bmQtdW5pdCwgZWc6IFwiZm9vdC1wZXItc2Vjb25kXCJcbiAqIFsgeyBcIm9uZVwiOiBcInswfSBmb290XCIsXG4gKiAgICAgXCJvdGhlclwiOiBcInswfSBmZWV0XCIgfSxcbiAqICAgeyBcIm9uZVwiOiBcInswfSBzZWNvbmRcIixcbiAqICAgICBcIm90aGVyXCI6IFwiezB9IHNlY29uZHNcIiB9IF1cbiAqXG4gKiBVc2VzIHRoZSBwcmVjb21wdXRlZCBmb3JtIG9mIGEgY29tcG91bmQtdW5pdCBpZiBhdmFpbGFibGUsIGVnOiBcIm1pbGUtcGVyLWhvdXJcIlxuICogeyBcImRpc3BsYXlOYW1lXCI6IFwibWlsZXMgcGVyIGhvdXJcIixcbiAqICAgIFwidW5pdFBhdHRlcm4tY291bnQtb25lXCI6IFwiezB9IG1pbGUgcGVyIGhvdXJcIixcbiAqICAgIFwidW5pdFBhdHRlcm4tY291bnQtb3RoZXJcIjogXCJ7MH0gbWlsZXMgcGVyIGhvdXJcIlxuICogfSxcbiAqXG4gKiBBbHNvIHN1cHBvcnRzIFwiL1wiIGluc3RlYWQgb2YgXCItcGVyLVwiLCBlZy4gXCJmb290L3NlY29uZFwiLCB1c2luZyB0aGUgcHJlY29tcHV0ZWQgZm9ybSBpZlxuICogYXZhaWxhYmxlLlxuICpcbiAqIE9yIHRoZSBBcnJheSBvZiBwbHVyYWwgbWFwcyBvZiBhIGNvbXBvdW5kLXVuaXQsIGVnOiBcImZvb3QtcGVyLXNlY29uZFwiXG4gKiBbIHsgXCJvbmVcIjogXCJ7MH0gZm9vdFwiLFxuICogICAgIFwib3RoZXJcIjogXCJ7MH0gZmVldFwiIH0sXG4gKiAgIHsgXCJvbmVcIjogXCJ7MH0gc2Vjb25kXCIsXG4gKiAgICAgXCJvdGhlclwiOiBcInswfSBzZWNvbmRzXCIgfSBdXG4gKlxuICogT3IgdW5kZWZpbmVkIGluIGNhc2UgdGhlIHVuaXQgKG9yIGEgdW5pdCBvZiB0aGUgY29tcG91bmQtdW5pdCkgZG9lc24ndCBleGlzdC5cbiAqL1xudmFyIGdldCA9IGZ1bmN0aW9uKCB1bml0LCBmb3JtLCBjbGRyICkge1xuXHR2YXIgcmV0O1xuXG5cdC8vIEVuc3VyZSB0aGF0IHdlIGdldCB0aGUgJ3ByZWNvbXB1dGVkJyBmb3JtLCBpZiBwcmVzZW50LlxuXHR1bml0ID0gdW5pdC5yZXBsYWNlKCAvXFwvLywgXCItcGVyLVwiICk7XG5cblx0Ly8gR2V0IHVuaXQgb3IgPGNhdGVnb3J5Pi11bml0IChlZy4gXCJkdXJhdGlvbi1zZWNvbmRcIikuXG5cdFsgXCJcIiBdLmNvbmNhdCggdW5pdENhdGVnb3JpZXMgKS5zb21lKGZ1bmN0aW9uKCBjYXRlZ29yeSApIHtcblx0XHRyZXR1cm4gcmV0ID0gY2xkci5tYWluKFtcblx0XHRcdFwidW5pdHNcIixcblx0XHRcdGZvcm0sXG5cdFx0XHRjYXRlZ29yeS5sZW5ndGggPyBjYXRlZ29yeSArIFwiLVwiICsgdW5pdCA6IHVuaXRcblx0XHRdKTtcblx0fSk7XG5cblx0Ly8gUmVuYW1lIGtleXMgcy91bml0UGF0dGVybi1jb3VudC0vL2cuXG5cdHJldCA9IHN0cmlwUGx1cmFsR2FyYmFnZSggcmV0ICk7XG5cblx0Ly8gQ29tcG91bmQgVW5pdCwgZWcuIFwiZm9vdC1wZXItc2Vjb25kXCIgb3IgXCJmb290L3NlY29uZFwiLlxuXHRpZiAoICFyZXQgJiYgKCAvLXBlci0vICkudGVzdCggdW5pdCApICkge1xuXG5cdFx0Ly8gXCJTb21lIHVuaXRzIGFscmVhZHkgaGF2ZSAncHJlY29tcHV0ZWQnIGZvcm1zLCBzdWNoIGFzIGtpbG9tZXRlci1wZXItaG91cjtcblx0XHQvLyB3aGVyZSBzdWNoIHVuaXRzIGV4aXN0LCB0aGV5IHNob3VsZCBiZSB1c2VkIGluIHByZWZlcmVuY2VcIiBVVFMjMzUuXG5cdFx0Ly8gTm90ZSB0aGF0IHByZWNvbXB1dGVkIGZvcm0gaGFzIGFscmVhZHkgYmVlbiBoYW5kbGVkIGFib3ZlICghcmV0KS5cblxuXHRcdC8vIEdldCBib3RoIHJlY3Vyc2l2ZWx5LlxuXHRcdHVuaXQgPSB1bml0LnNwbGl0KCBcIi1wZXItXCIgKTtcblx0XHRyZXQgPSB1bml0Lm1hcChmdW5jdGlvbiggdW5pdCApIHtcblx0XHRcdHJldHVybiBnZXQoIHVuaXQsIGZvcm0sIGNsZHIgKTtcblx0XHR9KTtcblx0XHRpZiAoICFyZXRbIDAgXSB8fCAhcmV0WyAxIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cbnZhciB1bml0R2V0ID0gZ2V0O1xuXG5cblxuXG4vKipcbiAqIHByb3BlcnRpZXMoIHVuaXQsIGZvcm0sIGNsZHIgKVxuICpcbiAqIEB1bml0IFtTdHJpbmddIFRoZSBmdWxsIHR5cGUtdW5pdCBuYW1lIChlZy4gZHVyYXRpb24tc2Vjb25kKSwgb3IgdGhlIHNob3J0IHVuaXQgbmFtZVxuICogKGVnLiBzZWNvbmQpLlxuICpcbiAqIEBmb3JtIFtTdHJpbmddIEEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGZvcm0gb2YgdGhlIHVuaXQgcmVwcmVzZW50YXRpb24gKGVnLiBsb25nLFxuICogc2hvcnQsIG5hcnJvdykuXG4gKlxuICogQGNsZHIgW0NsZHIgaW5zdGFuY2VdLlxuICovXG52YXIgdW5pdFByb3BlcnRpZXMgPSBmdW5jdGlvbiggdW5pdCwgZm9ybSwgY2xkciApIHtcblx0dmFyIGNvbXBvdW5kVW5pdFBhdHRlcm4sIHVuaXRQcm9wZXJ0aWVzO1xuXG5cdGNvbXBvdW5kVW5pdFBhdHRlcm4gPSBjbGRyLm1haW4oIFsgXCJ1bml0c1wiLCBmb3JtLCBcInBlci9jb21wb3VuZFVuaXRQYXR0ZXJuXCIgXSApO1xuXHR1bml0UHJvcGVydGllcyA9IHVuaXRHZXQoIHVuaXQsIGZvcm0sIGNsZHIgKTtcblxuXHRyZXR1cm4ge1xuXHRcdGNvbXBvdW5kVW5pdFBhdHRlcm46IGNvbXBvdW5kVW5pdFBhdHRlcm4sXG5cdFx0dW5pdFByb3BlcnRpZXM6IHVuaXRQcm9wZXJ0aWVzXG5cdH07XG59O1xuXG5cblxuXG4vKipcbiAqIEdsb2JhbGl6ZS5mb3JtYXRVbml0KCB2YWx1ZSwgdW5pdCwgb3B0aW9ucyApXG4gKlxuICogQHZhbHVlIFtOdW1iZXJdXG4gKlxuICogQHVuaXQgW1N0cmluZ106IFRoZSB1bml0IChlLmcgXCJzZWNvbmRcIiwgXCJkYXlcIiwgXCJ5ZWFyXCIpXG4gKlxuICogQG9wdGlvbnMgW09iamVjdF1cbiAqIC0gZm9ybTogW1N0cmluZ10gXCJsb25nXCIsIFwic2hvcnRcIiAoZGVmYXVsdCksIG9yIFwibmFycm93XCIuXG4gKlxuICogRm9ybWF0IHVuaXRzIHN1Y2ggYXMgc2Vjb25kcywgbWludXRlcywgZGF5cywgd2Vla3MsIGV0Yy5cbiAqL1xuR2xvYmFsaXplLmZvcm1hdFVuaXQgPVxuR2xvYmFsaXplLnByb3RvdHlwZS5mb3JtYXRVbml0ID0gZnVuY3Rpb24oIHZhbHVlLCB1bml0LCBvcHRpb25zICkge1xuXHR2YWxpZGF0ZVBhcmFtZXRlclByZXNlbmNlKCB2YWx1ZSwgXCJ2YWx1ZVwiICk7XG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZU51bWJlciggdmFsdWUsIFwidmFsdWVcIiApO1xuXG5cdHJldHVybiB0aGlzLnVuaXRGb3JtYXR0ZXIoIHVuaXQsIG9wdGlvbnMgKSggdmFsdWUgKTtcbn07XG5cbi8qKlxuICogR2xvYmFsaXplLnVuaXRGb3JtYXR0ZXIoIHVuaXQsIG9wdGlvbnMgKVxuICpcbiAqIEB1bml0IFtTdHJpbmddOiBUaGUgdW5pdCAoZS5nIFwic2Vjb25kXCIsIFwiZGF5XCIsIFwieWVhclwiKVxuICpcbiAqIEBvcHRpb25zIFtPYmplY3RdXG4gKiAtIGZvcm06IFtTdHJpbmddIFwibG9uZ1wiLCBcInNob3J0XCIgKGRlZmF1bHQpLCBvciBcIm5hcnJvd1wiLlxuICpcbiAqIC0gbnVtYmVyRm9ybWF0dGVyOiBbRnVuY3Rpb25dIGEgbnVtYmVyIGZvcm1hdHRlciBmdW5jdGlvbi4gRGVmYXVsdHMgdG8gR2xvYmFsaXplXG4gKiAgIGAubnVtYmVyRm9ybWF0dGVyKClgIGZvciB0aGUgY3VycmVudCBsb2NhbGUgdXNpbmcgdGhlIGRlZmF1bHQgb3B0aW9ucy5cbiAqL1xuR2xvYmFsaXplLnVuaXRGb3JtYXR0ZXIgPVxuR2xvYmFsaXplLnByb3RvdHlwZS51bml0Rm9ybWF0dGVyID0gZnVuY3Rpb24oIHVuaXQsIG9wdGlvbnMgKSB7XG5cdHZhciBhcmdzLCBmb3JtLCBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcmV0dXJuRm4sIHByb3BlcnRpZXM7XG5cblx0dmFsaWRhdGVQYXJhbWV0ZXJQcmVzZW5jZSggdW5pdCwgXCJ1bml0XCIgKTtcblx0dmFsaWRhdGVQYXJhbWV0ZXJUeXBlU3RyaW5nKCB1bml0LCBcInVuaXRcIiApO1xuXG5cdHZhbGlkYXRlUGFyYW1ldGVyVHlwZVBsYWluT2JqZWN0KCBvcHRpb25zLCBcIm9wdGlvbnNcIiApO1xuXG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdGFyZ3MgPSBbIHVuaXQsIG9wdGlvbnMgXTtcblx0Zm9ybSA9IG9wdGlvbnMuZm9ybSB8fCBcImxvbmdcIjtcblx0cHJvcGVydGllcyA9IHVuaXRQcm9wZXJ0aWVzKCB1bml0LCBmb3JtLCB0aGlzLmNsZHIgKTtcblxuXHRudW1iZXJGb3JtYXR0ZXIgPSBvcHRpb25zLm51bWJlckZvcm1hdHRlciB8fCB0aGlzLm51bWJlckZvcm1hdHRlcigpO1xuXHRwbHVyYWxHZW5lcmF0b3IgPSB0aGlzLnBsdXJhbEdlbmVyYXRvcigpO1xuXHRyZXR1cm5GbiA9IHVuaXRGb3JtYXR0ZXJGbiggbnVtYmVyRm9ybWF0dGVyLCBwbHVyYWxHZW5lcmF0b3IsIHByb3BlcnRpZXMgKTtcblxuXHRydW50aW1lQmluZCggYXJncywgdGhpcy5jbGRyLCByZXR1cm5GbiwgWyBudW1iZXJGb3JtYXR0ZXIsIHBsdXJhbEdlbmVyYXRvciwgcHJvcGVydGllcyBdICk7XG5cblx0cmV0dXJuIHJldHVybkZuO1xufTtcblxucmV0dXJuIEdsb2JhbGl6ZTtcblxuXG5cblxufSkpO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9nbG9iYWxpemUvdW5pdC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvZ2xvYmFsaXplL2Rpc3QvZ2xvYmFsaXplL3VuaXQuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLyoqKiBJTVBPUlRTIEZST00gaW1wb3J0cy1sb2FkZXIgKioqL1xudmFyIGRlZmluZSA9IGZhbHNlO1xuXG4vKiFcbiAqIEdsb2JhbGl6ZSB2MS4zLjBcbiAqXG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qcXVlcnkvZ2xvYmFsaXplXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTctMDctMDNUMjE6MzdaXG4gKi9cblxuLy8gQ29yZVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCBcIi4vZ2xvYmFsaXplXCIgKTtcblxuLy8gRXh0ZW50IGNvcmUgd2l0aCB0aGUgZm9sbG93aW5nIG1vZHVsZXNcbnJlcXVpcmUoIFwiLi9nbG9iYWxpemUvbWVzc2FnZVwiICk7XG5yZXF1aXJlKCBcIi4vZ2xvYmFsaXplL251bWJlclwiICk7XG5yZXF1aXJlKCBcIi4vZ2xvYmFsaXplL3BsdXJhbFwiICk7XG5cbi8vIExvYWQgYWZ0ZXIgZ2xvYmFsaXplL251bWJlclxucmVxdWlyZSggXCIuL2dsb2JhbGl6ZS9jdXJyZW5jeVwiICk7XG5yZXF1aXJlKCBcIi4vZ2xvYmFsaXplL2RhdGVcIiApO1xuXG4vLyBMb2FkIGFmdGVyIGdsb2JhbGl6ZS9udW1iZXIgYW5kIGdsb2JhbGl6ZS9wbHVyYWxcbnJlcXVpcmUoIFwiLi9nbG9iYWxpemUvcmVsYXRpdmUtdGltZVwiICk7XG5yZXF1aXJlKCBcIi4vZ2xvYmFsaXplL3VuaXRcIiApO1xuXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9nbG9iYWxpemUvZGlzdC9ub2RlLW1haW4uanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2dsb2JhbGl6ZS9kaXN0L25vZGUtbWFpbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbihmdW5jdGlvbih3aW5kb3csIGRvY3VtZW50KSB7XG4ndXNlIHN0cmljdCc7XG5cblxuLy8gRXhpdHMgZWFybHkgaWYgYWxsIEludGVyc2VjdGlvbk9ic2VydmVyIGFuZCBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5XG4vLyBmZWF0dXJlcyBhcmUgbmF0aXZlbHkgc3VwcG9ydGVkLlxuaWYgKCdJbnRlcnNlY3Rpb25PYnNlcnZlcicgaW4gd2luZG93ICYmXG4gICAgJ0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnknIGluIHdpbmRvdyAmJlxuICAgICdpbnRlcnNlY3Rpb25SYXRpbycgaW4gd2luZG93LkludGVyc2VjdGlvbk9ic2VydmVyRW50cnkucHJvdG90eXBlKSB7XG5cbiAgLy8gTWluaW1hbCBwb2x5ZmlsbCBmb3IgRWRnZSAxNSdzIGxhY2sgb2YgYGlzSW50ZXJzZWN0aW5nYFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0ludGVyc2VjdGlvbk9ic2VydmVyL2lzc3Vlcy8yMTFcbiAgaWYgKCEoJ2lzSW50ZXJzZWN0aW5nJyBpbiB3aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeS5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5LnByb3RvdHlwZSxcbiAgICAgICdpc0ludGVyc2VjdGluZycsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb25SYXRpbyA+IDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuO1xufVxuXG5cbi8qKlxuICogQW4gSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgcmVnaXN0cnkuIFRoaXMgcmVnaXN0cnkgZXhpc3RzIHRvIGhvbGQgYSBzdHJvbmdcbiAqIHJlZmVyZW5jZSB0byBJbnRlcnNlY3Rpb25PYnNlcnZlciBpbnN0YW5jZXMgY3VycmVudGx5IG9ic2VydmVyaW5nIGEgdGFyZ2V0XG4gKiBlbGVtZW50LiBXaXRob3V0IHRoaXMgcmVnaXN0cnksIGluc3RhbmNlcyB3aXRob3V0IGFub3RoZXIgcmVmZXJlbmNlIG1heSBiZVxuICogZ2FyYmFnZSBjb2xsZWN0ZWQuXG4gKi9cbnZhciByZWdpc3RyeSA9IFtdO1xuXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZ2xvYmFsIEludGVyc2VjdGlvbk9ic2VydmVyRW50cnkgY29uc3RydWN0b3IuXG4gKiBodHRwczovL3dpY2cuZ2l0aHViLmlvL0ludGVyc2VjdGlvbk9ic2VydmVyLyNpbnRlcnNlY3Rpb24tb2JzZXJ2ZXItZW50cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBlbnRyeSBBIGRpY3Rpb25hcnkgb2YgaW5zdGFuY2UgcHJvcGVydGllcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KGVudHJ5KSB7XG4gIHRoaXMudGltZSA9IGVudHJ5LnRpbWU7XG4gIHRoaXMudGFyZ2V0ID0gZW50cnkudGFyZ2V0O1xuICB0aGlzLnJvb3RCb3VuZHMgPSBlbnRyeS5yb290Qm91bmRzO1xuICB0aGlzLmJvdW5kaW5nQ2xpZW50UmVjdCA9IGVudHJ5LmJvdW5kaW5nQ2xpZW50UmVjdDtcbiAgdGhpcy5pbnRlcnNlY3Rpb25SZWN0ID0gZW50cnkuaW50ZXJzZWN0aW9uUmVjdCB8fCBnZXRFbXB0eVJlY3QoKTtcbiAgdGhpcy5pc0ludGVyc2VjdGluZyA9ICEhZW50cnkuaW50ZXJzZWN0aW9uUmVjdDtcblxuICAvLyBDYWxjdWxhdGVzIHRoZSBpbnRlcnNlY3Rpb24gcmF0aW8uXG4gIHZhciB0YXJnZXRSZWN0ID0gdGhpcy5ib3VuZGluZ0NsaWVudFJlY3Q7XG4gIHZhciB0YXJnZXRBcmVhID0gdGFyZ2V0UmVjdC53aWR0aCAqIHRhcmdldFJlY3QuaGVpZ2h0O1xuICB2YXIgaW50ZXJzZWN0aW9uUmVjdCA9IHRoaXMuaW50ZXJzZWN0aW9uUmVjdDtcbiAgdmFyIGludGVyc2VjdGlvbkFyZWEgPSBpbnRlcnNlY3Rpb25SZWN0LndpZHRoICogaW50ZXJzZWN0aW9uUmVjdC5oZWlnaHQ7XG5cbiAgLy8gU2V0cyBpbnRlcnNlY3Rpb24gcmF0aW8uXG4gIGlmICh0YXJnZXRBcmVhKSB7XG4gICAgdGhpcy5pbnRlcnNlY3Rpb25SYXRpbyA9IGludGVyc2VjdGlvbkFyZWEgLyB0YXJnZXRBcmVhO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIGFyZWEgaXMgemVybyBhbmQgaXMgaW50ZXJzZWN0aW5nLCBzZXRzIHRvIDEsIG90aGVyd2lzZSB0byAwXG4gICAgdGhpcy5pbnRlcnNlY3Rpb25SYXRpbyA9IHRoaXMuaXNJbnRlcnNlY3RpbmcgPyAxIDogMDtcbiAgfVxufVxuXG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgZ2xvYmFsIEludGVyc2VjdGlvbk9ic2VydmVyIGNvbnN0cnVjdG9yLlxuICogaHR0cHM6Ly93aWNnLmdpdGh1Yi5pby9JbnRlcnNlY3Rpb25PYnNlcnZlci8jaW50ZXJzZWN0aW9uLW9ic2VydmVyLWludGVyZmFjZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgaW50ZXJzZWN0aW9uXG4gKiAgICAgY2hhbmdlcyBoYXZlIHF1ZXVlZC4gVGhlIGZ1bmN0aW9uIGlzIG5vdCBpbnZva2VkIGlmIHRoZSBxdWV1ZSBoYXNcbiAqICAgICBiZWVuIGVtcHRpZWQgYnkgY2FsbGluZyB0aGUgYHRha2VSZWNvcmRzYCBtZXRob2QuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdF9vcHRpb25zIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBJbnRlcnNlY3Rpb25PYnNlcnZlcihjYWxsYmFjaywgb3B0X29wdGlvbnMpIHtcblxuICB2YXIgb3B0aW9ucyA9IG9wdF9vcHRpb25zIHx8IHt9O1xuXG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5yb290ICYmIG9wdGlvbnMucm9vdC5ub2RlVHlwZSAhPSAxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyb290IG11c3QgYmUgYW4gRWxlbWVudCcpO1xuICB9XG5cbiAgLy8gQmluZHMgYW5kIHRocm90dGxlcyBgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zYC5cbiAgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zID0gdGhyb3R0bGUoXG4gICAgICB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMuYmluZCh0aGlzKSwgdGhpcy5USFJPVFRMRV9USU1FT1VUKTtcblxuICAvLyBQcml2YXRlIHByb3BlcnRpZXMuXG4gIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2s7XG4gIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICB0aGlzLl9xdWV1ZWRFbnRyaWVzID0gW107XG4gIHRoaXMuX3Jvb3RNYXJnaW5WYWx1ZXMgPSB0aGlzLl9wYXJzZVJvb3RNYXJnaW4ob3B0aW9ucy5yb290TWFyZ2luKTtcblxuICAvLyBQdWJsaWMgcHJvcGVydGllcy5cbiAgdGhpcy50aHJlc2hvbGRzID0gdGhpcy5faW5pdFRocmVzaG9sZHMob3B0aW9ucy50aHJlc2hvbGQpO1xuICB0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3QgfHwgbnVsbDtcbiAgdGhpcy5yb290TWFyZ2luID0gdGhpcy5fcm9vdE1hcmdpblZhbHVlcy5tYXAoZnVuY3Rpb24obWFyZ2luKSB7XG4gICAgcmV0dXJuIG1hcmdpbi52YWx1ZSArIG1hcmdpbi51bml0O1xuICB9KS5qb2luKCcgJyk7XG59XG5cblxuLyoqXG4gKiBUaGUgbWluaW11bSBpbnRlcnZhbCB3aXRoaW4gd2hpY2ggdGhlIGRvY3VtZW50IHdpbGwgYmUgY2hlY2tlZCBmb3JcbiAqIGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuVEhST1RUTEVfVElNRU9VVCA9IDEwMDtcblxuXG4vKipcbiAqIFRoZSBmcmVxdWVuY3kgaW4gd2hpY2ggdGhlIHBvbHlmaWxsIHBvbGxzIGZvciBpbnRlcnNlY3Rpb24gY2hhbmdlcy5cbiAqIHRoaXMgY2FuIGJlIHVwZGF0ZWQgb24gYSBwZXIgaW5zdGFuY2UgYmFzaXMgYW5kIG11c3QgYmUgc2V0IHByaW9yIHRvXG4gKiBjYWxsaW5nIGBvYnNlcnZlYCBvbiB0aGUgZmlyc3QgdGFyZ2V0LlxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuUE9MTF9JTlRFUlZBTCA9IG51bGw7XG5cblxuLyoqXG4gKiBTdGFydHMgb2JzZXJ2aW5nIGEgdGFyZ2V0IGVsZW1lbnQgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzIGJhc2VkIG9uXG4gKiB0aGUgdGhyZXNob2xkcyB2YWx1ZXMuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCBUaGUgRE9NIGVsZW1lbnQgdG8gb2JzZXJ2ZS5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLm9ic2VydmUgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgLy8gSWYgdGhlIHRhcmdldCBpcyBhbHJlYWR5IGJlaW5nIG9ic2VydmVkLCBkbyBub3RoaW5nLlxuICBpZiAodGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzLnNvbWUoZnVuY3Rpb24oaXRlbSkge1xuICAgIHJldHVybiBpdGVtLmVsZW1lbnQgPT0gdGFyZ2V0O1xuICB9KSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghKHRhcmdldCAmJiB0YXJnZXQubm9kZVR5cGUgPT0gMSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldCBtdXN0IGJlIGFuIEVsZW1lbnQnKTtcbiAgfVxuXG4gIHRoaXMuX3JlZ2lzdGVySW5zdGFuY2UoKTtcbiAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzLnB1c2goe2VsZW1lbnQ6IHRhcmdldCwgZW50cnk6IG51bGx9KTtcbiAgdGhpcy5fbW9uaXRvckludGVyc2VjdGlvbnMoKTtcbiAgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zKCk7XG59O1xuXG5cbi8qKlxuICogU3RvcHMgb2JzZXJ2aW5nIGEgdGFyZ2V0IGVsZW1lbnQgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIERPTSBlbGVtZW50IHRvIG9ic2VydmUuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS51bm9ic2VydmUgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgdGhpcy5fb2JzZXJ2YXRpb25UYXJnZXRzID1cbiAgICAgIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cy5maWx0ZXIoZnVuY3Rpb24oaXRlbSkge1xuXG4gICAgcmV0dXJuIGl0ZW0uZWxlbWVudCAhPSB0YXJnZXQ7XG4gIH0pO1xuICBpZiAoIXRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cy5sZW5ndGgpIHtcbiAgICB0aGlzLl91bm1vbml0b3JJbnRlcnNlY3Rpb25zKCk7XG4gICAgdGhpcy5fdW5yZWdpc3Rlckluc3RhbmNlKCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTdG9wcyBvYnNlcnZpbmcgYWxsIHRhcmdldCBlbGVtZW50cyBmb3IgaW50ZXJzZWN0aW9uIGNoYW5nZXMuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX29ic2VydmF0aW9uVGFyZ2V0cyA9IFtdO1xuICB0aGlzLl91bm1vbml0b3JJbnRlcnNlY3Rpb25zKCk7XG4gIHRoaXMuX3VucmVnaXN0ZXJJbnN0YW5jZSgpO1xufTtcblxuXG4vKipcbiAqIFJldHVybnMgYW55IHF1ZXVlIGVudHJpZXMgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlbiByZXBvcnRlZCB0byB0aGVcbiAqIGNhbGxiYWNrIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlXG4gKiBjYWxsYmFjayB0byBvYnRhaW4gdGhlIGFic29sdXRlIG1vc3QgdXAtdG8tZGF0ZSBpbnRlcnNlY3Rpb24gaW5mb3JtYXRpb24uXG4gKiBAcmV0dXJuIHtBcnJheX0gVGhlIGN1cnJlbnRseSBxdWV1ZWQgZW50cmllcy5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLnRha2VSZWNvcmRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZWNvcmRzID0gdGhpcy5fcXVldWVkRW50cmllcy5zbGljZSgpO1xuICB0aGlzLl9xdWV1ZWRFbnRyaWVzID0gW107XG4gIHJldHVybiByZWNvcmRzO1xufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgdGhlIHRocmVzaG9sZCB2YWx1ZSBmcm9tIHRoZSB1c2VyIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZFxuICogcmV0dXJucyBhIHNvcnRlZCBhcnJheSBvZiB1bmlxdWUgdGhyZXNob2xkIHZhbHVlcy4gSWYgYSB2YWx1ZSBpcyBub3RcbiAqIGJldHdlZW4gMCBhbmQgMSBhbmQgZXJyb3IgaXMgdGhyb3duLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8bnVtYmVyPX0gb3B0X3RocmVzaG9sZCBBbiBvcHRpb25hbCB0aHJlc2hvbGQgdmFsdWUgb3JcbiAqICAgICBhIGxpc3Qgb2YgdGhyZXNob2xkIHZhbHVlcywgZGVmYXVsdGluZyB0byBbMF0uXG4gKiBAcmV0dXJuIHtBcnJheX0gQSBzb3J0ZWQgbGlzdCBvZiB1bmlxdWUgYW5kIHZhbGlkIHRocmVzaG9sZCB2YWx1ZXMuXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5faW5pdFRocmVzaG9sZHMgPSBmdW5jdGlvbihvcHRfdGhyZXNob2xkKSB7XG4gIHZhciB0aHJlc2hvbGQgPSBvcHRfdGhyZXNob2xkIHx8IFswXTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KHRocmVzaG9sZCkpIHRocmVzaG9sZCA9IFt0aHJlc2hvbGRdO1xuXG4gIHJldHVybiB0aHJlc2hvbGQuc29ydCgpLmZpbHRlcihmdW5jdGlvbih0LCBpLCBhKSB7XG4gICAgaWYgKHR5cGVvZiB0ICE9ICdudW1iZXInIHx8IGlzTmFOKHQpIHx8IHQgPCAwIHx8IHQgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RocmVzaG9sZCBtdXN0IGJlIGEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSBpbmNsdXNpdmVseScpO1xuICAgIH1cbiAgICByZXR1cm4gdCAhPT0gYVtpIC0gMV07XG4gIH0pO1xufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgdGhlIHJvb3RNYXJnaW4gdmFsdWUgZnJvbSB0aGUgdXNlciBjb25maWd1cmF0aW9uIG9iamVjdFxuICogYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdGhlIGZvdXIgbWFyZ2luIHZhbHVlcyBhcyBhbiBvYmplY3QgY29udGFpbmluZ1xuICogdGhlIHZhbHVlIGFuZCB1bml0IHByb3BlcnRpZXMuIElmIGFueSBvZiB0aGUgdmFsdWVzIGFyZSBub3QgcHJvcGVybHlcbiAqIGZvcm1hdHRlZCBvciB1c2UgYSB1bml0IG90aGVyIHRoYW4gcHggb3IgJSwgYW5kIGVycm9yIGlzIHRocm93bi5cbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdF9yb290TWFyZ2luIEFuIG9wdGlvbmFsIHJvb3RNYXJnaW4gdmFsdWUsXG4gKiAgICAgZGVmYXVsdGluZyB0byAnMHB4Jy5cbiAqIEByZXR1cm4ge0FycmF5PE9iamVjdD59IEFuIGFycmF5IG9mIG1hcmdpbiBvYmplY3RzIHdpdGggdGhlIGtleXNcbiAqICAgICB2YWx1ZSBhbmQgdW5pdC5cbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9wYXJzZVJvb3RNYXJnaW4gPSBmdW5jdGlvbihvcHRfcm9vdE1hcmdpbikge1xuICB2YXIgbWFyZ2luU3RyaW5nID0gb3B0X3Jvb3RNYXJnaW4gfHwgJzBweCc7XG4gIHZhciBtYXJnaW5zID0gbWFyZ2luU3RyaW5nLnNwbGl0KC9cXHMrLykubWFwKGZ1bmN0aW9uKG1hcmdpbikge1xuICAgIHZhciBwYXJ0cyA9IC9eKC0/XFxkKlxcLj9cXGQrKShweHwlKSQvLmV4ZWMobWFyZ2luKTtcbiAgICBpZiAoIXBhcnRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Jvb3RNYXJnaW4gbXVzdCBiZSBzcGVjaWZpZWQgaW4gcGl4ZWxzIG9yIHBlcmNlbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHt2YWx1ZTogcGFyc2VGbG9hdChwYXJ0c1sxXSksIHVuaXQ6IHBhcnRzWzJdfTtcbiAgfSk7XG5cbiAgLy8gSGFuZGxlcyBzaG9ydGhhbmQuXG4gIG1hcmdpbnNbMV0gPSBtYXJnaW5zWzFdIHx8IG1hcmdpbnNbMF07XG4gIG1hcmdpbnNbMl0gPSBtYXJnaW5zWzJdIHx8IG1hcmdpbnNbMF07XG4gIG1hcmdpbnNbM10gPSBtYXJnaW5zWzNdIHx8IG1hcmdpbnNbMV07XG5cbiAgcmV0dXJuIG1hcmdpbnM7XG59O1xuXG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzIGlmIHRoZSBwb2xsaW5nIGlzIG5vdCBhbHJlYWR5XG4gKiBoYXBwZW5pbmcsIGFuZCBpZiB0aGUgcGFnZSdzIHZpc2liaWx0eSBzdGF0ZSBpcyB2aXNpYmxlLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9tb25pdG9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMuX21vbml0b3JpbmdJbnRlcnNlY3Rpb25zKSB7XG4gICAgdGhpcy5fbW9uaXRvcmluZ0ludGVyc2VjdGlvbnMgPSB0cnVlO1xuXG4gICAgLy8gSWYgYSBwb2xsIGludGVydmFsIGlzIHNldCwgdXNlIHBvbGxpbmcgaW5zdGVhZCBvZiBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZXNpemUgYW5kIHNjcm9sbCBldmVudHMgb3IgRE9NIG11dGF0aW9ucy5cbiAgICBpZiAodGhpcy5QT0xMX0lOVEVSVkFMKSB7XG4gICAgICB0aGlzLl9tb25pdG9yaW5nSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgICB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMsIHRoaXMuUE9MTF9JTlRFUlZBTCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWRkRXZlbnQod2luZG93LCAncmVzaXplJywgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zLCB0cnVlKTtcbiAgICAgIGFkZEV2ZW50KGRvY3VtZW50LCAnc2Nyb2xsJywgdGhpcy5fY2hlY2tGb3JJbnRlcnNlY3Rpb25zLCB0cnVlKTtcblxuICAgICAgaWYgKCdNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cpIHtcbiAgICAgICAgdGhpcy5fZG9tT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMpO1xuICAgICAgICB0aGlzLl9kb21PYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LCB7XG4gICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgICAgY2hhcmFjdGVyRGF0YTogdHJ1ZSxcbiAgICAgICAgICBzdWJ0cmVlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFN0b3BzIHBvbGxpbmcgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl91bm1vbml0b3JJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLl9tb25pdG9yaW5nSW50ZXJzZWN0aW9ucykge1xuICAgIHRoaXMuX21vbml0b3JpbmdJbnRlcnNlY3Rpb25zID0gZmFsc2U7XG5cbiAgICBjbGVhckludGVydmFsKHRoaXMuX21vbml0b3JpbmdJbnRlcnZhbCk7XG4gICAgdGhpcy5fbW9uaXRvcmluZ0ludGVydmFsID0gbnVsbDtcblxuICAgIHJlbW92ZUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucywgdHJ1ZSk7XG4gICAgcmVtb3ZlRXZlbnQoZG9jdW1lbnQsICdzY3JvbGwnLCB0aGlzLl9jaGVja0ZvckludGVyc2VjdGlvbnMsIHRydWUpO1xuXG4gICAgaWYgKHRoaXMuX2RvbU9ic2VydmVyKSB7XG4gICAgICB0aGlzLl9kb21PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLl9kb21PYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9XG59O1xuXG5cbi8qKlxuICogU2NhbnMgZWFjaCBvYnNlcnZhdGlvbiB0YXJnZXQgZm9yIGludGVyc2VjdGlvbiBjaGFuZ2VzIGFuZCBhZGRzIHRoZW1cbiAqIHRvIHRoZSBpbnRlcm5hbCBlbnRyaWVzIHF1ZXVlLiBJZiBuZXcgZW50cmllcyBhcmUgZm91bmQsIGl0XG4gKiBzY2hlZHVsZXMgdGhlIGNhbGxiYWNrIHRvIGJlIGludm9rZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX2NoZWNrRm9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcm9vdElzSW5Eb20gPSB0aGlzLl9yb290SXNJbkRvbSgpO1xuICB2YXIgcm9vdFJlY3QgPSByb290SXNJbkRvbSA/IHRoaXMuX2dldFJvb3RSZWN0KCkgOiBnZXRFbXB0eVJlY3QoKTtcblxuICB0aGlzLl9vYnNlcnZhdGlvblRhcmdldHMuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgdmFyIHRhcmdldCA9IGl0ZW0uZWxlbWVudDtcbiAgICB2YXIgdGFyZ2V0UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0YXJnZXQpO1xuICAgIHZhciByb290Q29udGFpbnNUYXJnZXQgPSB0aGlzLl9yb290Q29udGFpbnNUYXJnZXQodGFyZ2V0KTtcbiAgICB2YXIgb2xkRW50cnkgPSBpdGVtLmVudHJ5O1xuICAgIHZhciBpbnRlcnNlY3Rpb25SZWN0ID0gcm9vdElzSW5Eb20gJiYgcm9vdENvbnRhaW5zVGFyZ2V0ICYmXG4gICAgICAgIHRoaXMuX2NvbXB1dGVUYXJnZXRBbmRSb290SW50ZXJzZWN0aW9uKHRhcmdldCwgcm9vdFJlY3QpO1xuXG4gICAgdmFyIG5ld0VudHJ5ID0gaXRlbS5lbnRyeSA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5KHtcbiAgICAgIHRpbWU6IG5vdygpLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICBib3VuZGluZ0NsaWVudFJlY3Q6IHRhcmdldFJlY3QsXG4gICAgICByb290Qm91bmRzOiByb290UmVjdCxcbiAgICAgIGludGVyc2VjdGlvblJlY3Q6IGludGVyc2VjdGlvblJlY3RcbiAgICB9KTtcblxuICAgIGlmICghb2xkRW50cnkpIHtcbiAgICAgIHRoaXMuX3F1ZXVlZEVudHJpZXMucHVzaChuZXdFbnRyeSk7XG4gICAgfSBlbHNlIGlmIChyb290SXNJbkRvbSAmJiByb290Q29udGFpbnNUYXJnZXQpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgZW50cnkgaW50ZXJzZWN0aW9uIHJhdGlvIGhhcyBjcm9zc2VkIGFueSBvZiB0aGVcbiAgICAgIC8vIHRocmVzaG9sZHMsIGFkZCBhIG5ldyBlbnRyeS5cbiAgICAgIGlmICh0aGlzLl9oYXNDcm9zc2VkVGhyZXNob2xkKG9sZEVudHJ5LCBuZXdFbnRyeSkpIHtcbiAgICAgICAgdGhpcy5fcXVldWVkRW50cmllcy5wdXNoKG5ld0VudHJ5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGluIHRoZSBET00gb3IgdGFyZ2V0IGlzIG5vdCBjb250YWluZWQgd2l0aGluXG4gICAgICAvLyByb290IGJ1dCB0aGUgcHJldmlvdXMgZW50cnkgZm9yIHRoaXMgdGFyZ2V0IGhhZCBhbiBpbnRlcnNlY3Rpb24sXG4gICAgICAvLyBhZGQgYSBuZXcgcmVjb3JkIGluZGljYXRpbmcgcmVtb3ZhbC5cbiAgICAgIGlmIChvbGRFbnRyeSAmJiBvbGRFbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICB0aGlzLl9xdWV1ZWRFbnRyaWVzLnB1c2gobmV3RW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwgdGhpcyk7XG5cbiAgaWYgKHRoaXMuX3F1ZXVlZEVudHJpZXMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sodGhpcy50YWtlUmVjb3JkcygpLCB0aGlzKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgYSB0YXJnZXQgYW5kIHJvb3QgcmVjdCBjb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlblxuICogZm9sbG93aW5nIHRoZSBhbGdvcml0aG0gaW4gdGhlIHNwZWMuXG4gKiBUT0RPKHBoaWxpcHdhbHRvbik6IGF0IHRoaXMgdGltZSBjbGlwLXBhdGggaXMgbm90IGNvbnNpZGVyZWQuXG4gKiBodHRwczovL3dpY2cuZ2l0aHViLmlvL0ludGVyc2VjdGlvbk9ic2VydmVyLyNjYWxjdWxhdGUtaW50ZXJzZWN0aW9uLXJlY3QtYWxnb1xuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBET00gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IHJvb3RSZWN0IFRoZSBib3VuZGluZyByZWN0IG9mIHRoZSByb290IGFmdGVyIGJlaW5nXG4gKiAgICAgZXhwYW5kZWQgYnkgdGhlIHJvb3RNYXJnaW4gdmFsdWUuXG4gKiBAcmV0dXJuIHs/T2JqZWN0fSBUaGUgZmluYWwgaW50ZXJzZWN0aW9uIHJlY3Qgb2JqZWN0IG9yIHVuZGVmaW5lZCBpZiBub1xuICogICAgIGludGVyc2VjdGlvbiBpcyBmb3VuZC5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fY29tcHV0ZVRhcmdldEFuZFJvb3RJbnRlcnNlY3Rpb24gPVxuICAgIGZ1bmN0aW9uKHRhcmdldCwgcm9vdFJlY3QpIHtcblxuICAvLyBJZiB0aGUgZWxlbWVudCBpc24ndCBkaXNwbGF5ZWQsIGFuIGludGVyc2VjdGlvbiBjYW4ndCBoYXBwZW4uXG4gIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpLmRpc3BsYXkgPT0gJ25vbmUnKSByZXR1cm47XG5cbiAgdmFyIHRhcmdldFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QodGFyZ2V0KTtcbiAgdmFyIGludGVyc2VjdGlvblJlY3QgPSB0YXJnZXRSZWN0O1xuICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50Tm9kZSh0YXJnZXQpO1xuICB2YXIgYXRSb290ID0gZmFsc2U7XG5cbiAgd2hpbGUgKCFhdFJvb3QpIHtcbiAgICB2YXIgcGFyZW50UmVjdCA9IG51bGw7XG4gICAgdmFyIHBhcmVudENvbXB1dGVkU3R5bGUgPSBwYXJlbnQubm9kZVR5cGUgPT0gMSA/XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCkgOiB7fTtcblxuICAgIC8vIElmIHRoZSBwYXJlbnQgaXNuJ3QgZGlzcGxheWVkLCBhbiBpbnRlcnNlY3Rpb24gY2FuJ3QgaGFwcGVuLlxuICAgIGlmIChwYXJlbnRDb21wdXRlZFN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnKSByZXR1cm47XG5cbiAgICBpZiAocGFyZW50ID09IHRoaXMucm9vdCB8fCBwYXJlbnQgPT0gZG9jdW1lbnQpIHtcbiAgICAgIGF0Um9vdCA9IHRydWU7XG4gICAgICBwYXJlbnRSZWN0ID0gcm9vdFJlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIG5vbi12aXNpYmxlIG92ZXJmbG93LCBhbmQgaXQncyBub3QgdGhlIDxib2R5PlxuICAgICAgLy8gb3IgPGh0bWw+IGVsZW1lbnQsIHVwZGF0ZSB0aGUgaW50ZXJzZWN0aW9uIHJlY3QuXG4gICAgICAvLyBOb3RlOiA8Ym9keT4gYW5kIDxodG1sPiBjYW5ub3QgYmUgY2xpcHBlZCB0byBhIHJlY3QgdGhhdCdzIG5vdCBhbHNvXG4gICAgICAvLyB0aGUgZG9jdW1lbnQgcmVjdCwgc28gbm8gbmVlZCB0byBjb21wdXRlIGEgbmV3IGludGVyc2VjdGlvbi5cbiAgICAgIGlmIChwYXJlbnQgIT0gZG9jdW1lbnQuYm9keSAmJlxuICAgICAgICAgIHBhcmVudCAhPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiZcbiAgICAgICAgICBwYXJlbnRDb21wdXRlZFN0eWxlLm92ZXJmbG93ICE9ICd2aXNpYmxlJykge1xuICAgICAgICBwYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KHBhcmVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgZWl0aGVyIG9mIHRoZSBhYm92ZSBjb25kaXRpb25hbHMgc2V0IGEgbmV3IHBhcmVudFJlY3QsXG4gICAgLy8gY2FsY3VsYXRlIG5ldyBpbnRlcnNlY3Rpb24gZGF0YS5cbiAgICBpZiAocGFyZW50UmVjdCkge1xuICAgICAgaW50ZXJzZWN0aW9uUmVjdCA9IGNvbXB1dGVSZWN0SW50ZXJzZWN0aW9uKHBhcmVudFJlY3QsIGludGVyc2VjdGlvblJlY3QpO1xuXG4gICAgICBpZiAoIWludGVyc2VjdGlvblJlY3QpIGJyZWFrO1xuICAgIH1cbiAgICBwYXJlbnQgPSBnZXRQYXJlbnROb2RlKHBhcmVudCk7XG4gIH1cbiAgcmV0dXJuIGludGVyc2VjdGlvblJlY3Q7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdCByZWN0IGFmdGVyIGJlaW5nIGV4cGFuZGVkIGJ5IHRoZSByb290TWFyZ2luIHZhbHVlLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXhwYW5kZWQgcm9vdCByZWN0LlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9nZXRSb290UmVjdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcm9vdFJlY3Q7XG4gIGlmICh0aGlzLnJvb3QpIHtcbiAgICByb290UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdCh0aGlzLnJvb3QpO1xuICB9IGVsc2Uge1xuICAgIC8vIFVzZSA8aHRtbD4vPGJvZHk+IGluc3RlYWQgb2Ygd2luZG93IHNpbmNlIHNjcm9sbCBiYXJzIGFmZmVjdCBzaXplLlxuICAgIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgICByb290UmVjdCA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogaHRtbC5jbGllbnRXaWR0aCB8fCBib2R5LmNsaWVudFdpZHRoLFxuICAgICAgd2lkdGg6IGh0bWwuY2xpZW50V2lkdGggfHwgYm9keS5jbGllbnRXaWR0aCxcbiAgICAgIGJvdHRvbTogaHRtbC5jbGllbnRIZWlnaHQgfHwgYm9keS5jbGllbnRIZWlnaHQsXG4gICAgICBoZWlnaHQ6IGh0bWwuY2xpZW50SGVpZ2h0IHx8IGJvZHkuY2xpZW50SGVpZ2h0XG4gICAgfTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZXhwYW5kUmVjdEJ5Um9vdE1hcmdpbihyb290UmVjdCk7XG59O1xuXG5cbi8qKlxuICogQWNjZXB0cyBhIHJlY3QgYW5kIGV4cGFuZHMgaXQgYnkgdGhlIHJvb3RNYXJnaW4gdmFsdWUuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdCBUaGUgcmVjdCBvYmplY3QgdG8gZXhwYW5kLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXhwYW5kZWQgcmVjdC5cbiAqIEBwcml2YXRlXG4gKi9cbkludGVyc2VjdGlvbk9ic2VydmVyLnByb3RvdHlwZS5fZXhwYW5kUmVjdEJ5Um9vdE1hcmdpbiA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgdmFyIG1hcmdpbnMgPSB0aGlzLl9yb290TWFyZ2luVmFsdWVzLm1hcChmdW5jdGlvbihtYXJnaW4sIGkpIHtcbiAgICByZXR1cm4gbWFyZ2luLnVuaXQgPT0gJ3B4JyA/IG1hcmdpbi52YWx1ZSA6XG4gICAgICAgIG1hcmdpbi52YWx1ZSAqIChpICUgMiA/IHJlY3Qud2lkdGggOiByZWN0LmhlaWdodCkgLyAxMDA7XG4gIH0pO1xuICB2YXIgbmV3UmVjdCA9IHtcbiAgICB0b3A6IHJlY3QudG9wIC0gbWFyZ2luc1swXSxcbiAgICByaWdodDogcmVjdC5yaWdodCArIG1hcmdpbnNbMV0sXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSArIG1hcmdpbnNbMl0sXG4gICAgbGVmdDogcmVjdC5sZWZ0IC0gbWFyZ2luc1szXVxuICB9O1xuICBuZXdSZWN0LndpZHRoID0gbmV3UmVjdC5yaWdodCAtIG5ld1JlY3QubGVmdDtcbiAgbmV3UmVjdC5oZWlnaHQgPSBuZXdSZWN0LmJvdHRvbSAtIG5ld1JlY3QudG9wO1xuXG4gIHJldHVybiBuZXdSZWN0O1xufTtcblxuXG4vKipcbiAqIEFjY2VwdHMgYW4gb2xkIGFuZCBuZXcgZW50cnkgYW5kIHJldHVybnMgdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgb2YgdGhlXG4gKiB0aHJlc2hvbGQgdmFsdWVzIGhhcyBiZWVuIGNyb3NzZWQuXG4gKiBAcGFyYW0gez9JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5fSBvbGRFbnRyeSBUaGUgcHJldmlvdXMgZW50cnkgZm9yIGFcbiAqICAgIHBhcnRpY3VsYXIgdGFyZ2V0IGVsZW1lbnQgb3IgbnVsbCBpZiBubyBwcmV2aW91cyBlbnRyeSBleGlzdHMuXG4gKiBAcGFyYW0ge0ludGVyc2VjdGlvbk9ic2VydmVyRW50cnl9IG5ld0VudHJ5IFRoZSBjdXJyZW50IGVudHJ5IGZvciBhXG4gKiAgICBwYXJ0aWN1bGFyIHRhcmdldCBlbGVtZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGEgYW55IHRocmVzaG9sZCBoYXMgYmVlbiBjcm9zc2VkLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9oYXNDcm9zc2VkVGhyZXNob2xkID1cbiAgICBmdW5jdGlvbihvbGRFbnRyeSwgbmV3RW50cnkpIHtcblxuICAvLyBUbyBtYWtlIGNvbXBhcmluZyBlYXNpZXIsIGFuIGVudHJ5IHRoYXQgaGFzIGEgcmF0aW8gb2YgMFxuICAvLyBidXQgZG9lcyBub3QgYWN0dWFsbHkgaW50ZXJzZWN0IGlzIGdpdmVuIGEgdmFsdWUgb2YgLTFcbiAgdmFyIG9sZFJhdGlvID0gb2xkRW50cnkgJiYgb2xkRW50cnkuaXNJbnRlcnNlY3RpbmcgP1xuICAgICAgb2xkRW50cnkuaW50ZXJzZWN0aW9uUmF0aW8gfHwgMCA6IC0xO1xuICB2YXIgbmV3UmF0aW8gPSBuZXdFbnRyeS5pc0ludGVyc2VjdGluZyA/XG4gICAgICBuZXdFbnRyeS5pbnRlcnNlY3Rpb25SYXRpbyB8fCAwIDogLTE7XG5cbiAgLy8gSWdub3JlIHVuY2hhbmdlZCByYXRpb3NcbiAgaWYgKG9sZFJhdGlvID09PSBuZXdSYXRpbykgcmV0dXJuO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50aHJlc2hvbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRocmVzaG9sZCA9IHRoaXMudGhyZXNob2xkc1tpXTtcblxuICAgIC8vIFJldHVybiB0cnVlIGlmIGFuIGVudHJ5IG1hdGNoZXMgYSB0aHJlc2hvbGQgb3IgaWYgdGhlIG5ldyByYXRpb1xuICAgIC8vIGFuZCB0aGUgb2xkIHJhdGlvIGFyZSBvbiB0aGUgb3Bwb3NpdGUgc2lkZXMgb2YgYSB0aHJlc2hvbGQuXG4gICAgaWYgKHRocmVzaG9sZCA9PSBvbGRSYXRpbyB8fCB0aHJlc2hvbGQgPT0gbmV3UmF0aW8gfHxcbiAgICAgICAgdGhyZXNob2xkIDwgb2xkUmF0aW8gIT09IHRocmVzaG9sZCA8IG5ld1JhdGlvKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSByb290IGVsZW1lbnQgaXMgYW4gZWxlbWVudCBhbmQgaXMgaW4gdGhlIERPTS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBpcyBhbiBlbGVtZW50IGFuZCBpcyBpbiB0aGUgRE9NLlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9yb290SXNJbkRvbSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gIXRoaXMucm9vdCB8fCBjb250YWluc0RlZXAoZG9jdW1lbnQsIHRoaXMucm9vdCk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiByb290LlxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgVGhlIHRhcmdldCBlbGVtZW50IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgaXMgYSBjaGlsZCBvZiByb290LlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9yb290Q29udGFpbnNUYXJnZXQgPSBmdW5jdGlvbih0YXJnZXQpIHtcbiAgcmV0dXJuIGNvbnRhaW5zRGVlcCh0aGlzLnJvb3QgfHwgZG9jdW1lbnQsIHRhcmdldCk7XG59O1xuXG5cbi8qKlxuICogQWRkcyB0aGUgaW5zdGFuY2UgdG8gdGhlIGdsb2JhbCBJbnRlcnNlY3Rpb25PYnNlcnZlciByZWdpc3RyeSBpZiBpdCBpc24ndFxuICogYWxyZWFkeSBwcmVzZW50LlxuICogQHByaXZhdGVcbiAqL1xuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIucHJvdG90eXBlLl9yZWdpc3Rlckluc3RhbmNlID0gZnVuY3Rpb24oKSB7XG4gIGlmIChyZWdpc3RyeS5pbmRleE9mKHRoaXMpIDwgMCkge1xuICAgIHJlZ2lzdHJ5LnB1c2godGhpcyk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBSZW1vdmVzIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBnbG9iYWwgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgcmVnaXN0cnkuXG4gKiBAcHJpdmF0ZVxuICovXG5JbnRlcnNlY3Rpb25PYnNlcnZlci5wcm90b3R5cGUuX3VucmVnaXN0ZXJJbnN0YW5jZSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaW5kZXggPSByZWdpc3RyeS5pbmRleE9mKHRoaXMpO1xuICBpZiAoaW5kZXggIT0gLTEpIHJlZ2lzdHJ5LnNwbGljZShpbmRleCwgMSk7XG59O1xuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBwZXJmb3JtYW5jZS5ub3coKSBtZXRob2Qgb3IgbnVsbCBpbiBicm93c2Vyc1xuICogdGhhdCBkb24ndCBzdXBwb3J0IHRoZSBBUEkuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBlbGFwc2VkIHRpbWUgc2luY2UgdGhlIHBhZ2Ugd2FzIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gbm93KCkge1xuICByZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlICYmIHBlcmZvcm1hbmNlLm5vdyAmJiBwZXJmb3JtYW5jZS5ub3coKTtcbn1cblxuXG4vKipcbiAqIFRocm90dGxlcyBhIGZ1bmN0aW9uIGFuZCBkZWxheXMgaXRzIGV4ZWN1dGlvbmcsIHNvIGl0J3Mgb25seSBjYWxsZWQgYXQgbW9zdFxuICogb25jZSB3aXRoaW4gYSBnaXZlbiB0aW1lIHBlcmlvZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byB0aHJvdHRsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0IFRoZSBhbW91bnQgb2YgdGltZSB0aGF0IG11c3QgcGFzcyBiZWZvcmUgdGhlXG4gKiAgICAgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBhZ2Fpbi5cbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmbiwgdGltZW91dCkge1xuICB2YXIgdGltZXIgPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGltZXIpIHtcbiAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICB9O1xufVxuXG5cbi8qKlxuICogQWRkcyBhbiBldmVudCBoYW5kbGVyIHRvIGEgRE9NIG5vZGUgZW5zdXJpbmcgY3Jvc3MtYnJvd3NlciBjb21wYXRpYmlsaXR5LlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBET00gbm9kZSB0byBhZGQgdGhlIGV2ZW50IGhhbmRsZXIgdG8uXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZXZlbnQgaGFuZGxlciB0byBhZGQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG9wdF91c2VDYXB0dXJlIE9wdGlvbmFsbHkgYWRkcyB0aGUgZXZlbiB0byB0aGUgY2FwdHVyZVxuICogICAgIHBoYXNlLiBOb3RlOiB0aGlzIG9ubHkgd29ya3MgaW4gbW9kZXJuIGJyb3dzZXJzLlxuICovXG5mdW5jdGlvbiBhZGRFdmVudChub2RlLCBldmVudCwgZm4sIG9wdF91c2VDYXB0dXJlKSB7XG4gIGlmICh0eXBlb2Ygbm9kZS5hZGRFdmVudExpc3RlbmVyID09ICdmdW5jdGlvbicpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBvcHRfdXNlQ2FwdHVyZSB8fCBmYWxzZSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZW9mIG5vZGUuYXR0YWNoRXZlbnQgPT0gJ2Z1bmN0aW9uJykge1xuICAgIG5vZGUuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmbik7XG4gIH1cbn1cblxuXG4vKipcbiAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGV2ZW50IGhhbmRsZXIgZnJvbSBhIERPTSBub2RlLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBET00gbm9kZSB0byByZW1vdmUgdGhlIGV2ZW50IGhhbmRsZXIgZnJvbS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBldmVudCBoYW5kbGVyIHRvIHJlbW92ZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0X3VzZUNhcHR1cmUgSWYgdGhlIGV2ZW50IGhhbmRsZXIgd2FzIGFkZGVkIHdpdGggdGhpc1xuICogICAgIGZsYWcgc2V0IHRvIHRydWUsIGl0IHNob3VsZCBiZSBzZXQgdG8gdHJ1ZSBoZXJlIGluIG9yZGVyIHRvIHJlbW92ZSBpdC5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnQobm9kZSwgZXZlbnQsIGZuLCBvcHRfdXNlQ2FwdHVyZSkge1xuICBpZiAodHlwZW9mIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9PSAnZnVuY3Rpb24nKSB7XG4gICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgb3B0X3VzZUNhcHR1cmUgfHwgZmFsc2UpO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBub2RlLmRldGF0Y2hFdmVudCA9PSAnZnVuY3Rpb24nKSB7XG4gICAgbm9kZS5kZXRhdGNoRXZlbnQoJ29uJyArIGV2ZW50LCBmbik7XG4gIH1cbn1cblxuXG4vKipcbiAqIFJldHVybnMgdGhlIGludGVyc2VjdGlvbiBiZXR3ZWVuIHR3byByZWN0IG9iamVjdHMuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdDEgVGhlIGZpcnN0IHJlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVjdDIgVGhlIHNlY29uZCByZWN0LlxuICogQHJldHVybiB7P09iamVjdH0gVGhlIGludGVyc2VjdGlvbiByZWN0IG9yIHVuZGVmaW5lZCBpZiBubyBpbnRlcnNlY3Rpb25cbiAqICAgICBpcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVJlY3RJbnRlcnNlY3Rpb24ocmVjdDEsIHJlY3QyKSB7XG4gIHZhciB0b3AgPSBNYXRoLm1heChyZWN0MS50b3AsIHJlY3QyLnRvcCk7XG4gIHZhciBib3R0b20gPSBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSk7XG4gIHZhciBsZWZ0ID0gTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCk7XG4gIHZhciByaWdodCA9IE1hdGgubWluKHJlY3QxLnJpZ2h0LCByZWN0Mi5yaWdodCk7XG4gIHZhciB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgdmFyIGhlaWdodCA9IGJvdHRvbSAtIHRvcDtcblxuICByZXR1cm4gKHdpZHRoID49IDAgJiYgaGVpZ2h0ID49IDApICYmIHtcbiAgICB0b3A6IHRvcCxcbiAgICBib3R0b206IGJvdHRvbSxcbiAgICBsZWZ0OiBsZWZ0LFxuICAgIHJpZ2h0OiByaWdodCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cblxuXG4vKipcbiAqIFNoaW1zIHRoZSBuYXRpdmUgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZvciBjb21wYXRpYmlsaXR5IHdpdGggb2xkZXIgSUUuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIFRoZSBlbGVtZW50IHdob3NlIGJvdW5kaW5nIHJlY3QgdG8gZ2V0LlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgKHBvc3NpYmx5IHNoaW1tZWQpIHJlY3Qgb2YgdGhlIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbCkge1xuICB2YXIgcmVjdDtcblxuICB0cnkge1xuICAgIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gSWdub3JlIFdpbmRvd3MgNyBJRTExIFwiVW5zcGVjaWZpZWQgZXJyb3JcIlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9XSUNHL0ludGVyc2VjdGlvbk9ic2VydmVyL3B1bGwvMjA1XG4gIH1cblxuICBpZiAoIXJlY3QpIHJldHVybiBnZXRFbXB0eVJlY3QoKTtcblxuICAvLyBPbGRlciBJRVxuICBpZiAoIShyZWN0LndpZHRoICYmIHJlY3QuaGVpZ2h0KSkge1xuICAgIHJlY3QgPSB7XG4gICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgICBib3R0b206IHJlY3QuYm90dG9tLFxuICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgd2lkdGg6IHJlY3QucmlnaHQgLSByZWN0LmxlZnQsXG4gICAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgICB9O1xuICB9XG4gIHJldHVybiByZWN0O1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBhbiBlbXB0eSByZWN0IG9iamVjdC4gQW4gZW1wdHkgcmVjdCBpcyByZXR1cm5lZCB3aGVuIGFuIGVsZW1lbnRcbiAqIGlzIG5vdCBpbiB0aGUgRE9NLlxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgZW1wdHkgcmVjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0RW1wdHlSZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMCxcbiAgICByaWdodDogMCxcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDBcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIGEgcGFyZW50IGVsZW1lbnQgY29udGFpbnMgYSBjaGlsZCBlbGVtbnQgKGluY2x1ZGluZyBpbnNpZGVcbiAqIHNoYWRvdyBET00pLlxuICogQHBhcmFtIHtOb2RlfSBwYXJlbnQgVGhlIHBhcmVudCBlbGVtZW50LlxuICogQHBhcmFtIHtOb2RlfSBjaGlsZCBUaGUgY2hpbGQgZWxlbWVudC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBhcmVudCBub2RlIGNvbnRhaW5zIHRoZSBjaGlsZCBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc0RlZXAocGFyZW50LCBjaGlsZCkge1xuICB2YXIgbm9kZSA9IGNoaWxkO1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlID09IHBhcmVudCkgcmV0dXJuIHRydWU7XG5cbiAgICBub2RlID0gZ2V0UGFyZW50Tm9kZShub2RlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLyoqXG4gKiBHZXRzIHRoZSBwYXJlbnQgbm9kZSBvZiBhbiBlbGVtZW50IG9yIGl0cyBob3N0IGVsZW1lbnQgaWYgdGhlIHBhcmVudCBub2RlXG4gKiBpcyBhIHNoYWRvdyByb290LlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHdob3NlIHBhcmVudCB0byBnZXQuXG4gKiBAcmV0dXJuIHtOb2RlfG51bGx9IFRoZSBwYXJlbnQgbm9kZSBvciBudWxsIGlmIG5vIHBhcmVudCBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUobm9kZSkge1xuICB2YXIgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuXG4gIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09IDExICYmIHBhcmVudC5ob3N0KSB7XG4gICAgLy8gSWYgdGhlIHBhcmVudCBpcyBhIHNoYWRvdyByb290LCByZXR1cm4gdGhlIGhvc3QgZWxlbWVudC5cbiAgICByZXR1cm4gcGFyZW50Lmhvc3Q7XG4gIH1cbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuXG4vLyBFeHBvc2VzIHRoZSBjb25zdHJ1Y3RvcnMgZ2xvYmFsbHkuXG53aW5kb3cuSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbndpbmRvdy5JbnRlcnNlY3Rpb25PYnNlcnZlckVudHJ5ID0gSW50ZXJzZWN0aW9uT2JzZXJ2ZXJFbnRyeTtcblxufSh3aW5kb3csIGRvY3VtZW50KSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIvaW50ZXJzZWN0aW9uLW9ic2VydmVyLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9pbnRlcnNlY3Rpb24tb2JzZXJ2ZXIvaW50ZXJzZWN0aW9uLW9ic2VydmVyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIi8qIVxyXG4gKiBQRVAgdjAuNC4yIHwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9QRVBcclxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgfCBodHRwOi8vanF1ZXJ5Lm9yZy9saWNlbnNlXHJcbiAqL1xyXG5cclxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcclxuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XHJcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcclxuICAoZ2xvYmFsLlBvaW50ZXJFdmVudHNQb2x5ZmlsbCA9IGZhY3RvcnkoKSk7XHJcbn0odGhpcywgZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgaXMgdGhlIGNvbnN0cnVjdG9yIGZvciBuZXcgUG9pbnRlckV2ZW50cy5cclxuICAgKlxyXG4gICAqIE5ldyBQb2ludGVyIEV2ZW50cyBtdXN0IGJlIGdpdmVuIGEgdHlwZSwgYW5kIGFuIG9wdGlvbmFsIGRpY3Rpb25hcnkgb2ZcclxuICAgKiBpbml0aWFsaXphdGlvbiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogRHVlIHRvIGNlcnRhaW4gcGxhdGZvcm0gcmVxdWlyZW1lbnRzLCBldmVudHMgcmV0dXJuZWQgZnJvbSB0aGUgY29uc3RydWN0b3JcclxuICAgKiBpZGVudGlmeSBhcyBNb3VzZUV2ZW50cy5cclxuICAgKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpblR5cGUgVGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGNyZWF0ZS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW2luRGljdF0gQW4gb3B0aW9uYWwgZGljdGlvbmFyeSBvZiBpbml0aWFsIGV2ZW50IHByb3BlcnRpZXMuXHJcbiAgICogQHJldHVybiB7RXZlbnR9IEEgbmV3IFBvaW50ZXJFdmVudCBvZiB0eXBlIGBpblR5cGVgLCBpbml0aWFsaXplZCB3aXRoIHByb3BlcnRpZXMgZnJvbSBgaW5EaWN0YC5cclxuICAgKi9cclxuICB2YXIgTU9VU0VfUFJPUFMgPSBbXHJcbiAgICAnYnViYmxlcycsXHJcbiAgICAnY2FuY2VsYWJsZScsXHJcbiAgICAndmlldycsXHJcbiAgICAnZGV0YWlsJyxcclxuICAgICdzY3JlZW5YJyxcclxuICAgICdzY3JlZW5ZJyxcclxuICAgICdjbGllbnRYJyxcclxuICAgICdjbGllbnRZJyxcclxuICAgICdjdHJsS2V5JyxcclxuICAgICdhbHRLZXknLFxyXG4gICAgJ3NoaWZ0S2V5JyxcclxuICAgICdtZXRhS2V5JyxcclxuICAgICdidXR0b24nLFxyXG4gICAgJ3JlbGF0ZWRUYXJnZXQnLFxyXG4gICAgJ3BhZ2VYJyxcclxuICAgICdwYWdlWSdcclxuICBdO1xyXG5cclxuICB2YXIgTU9VU0VfREVGQVVMVFMgPSBbXHJcbiAgICBmYWxzZSxcclxuICAgIGZhbHNlLFxyXG4gICAgbnVsbCxcclxuICAgIG51bGwsXHJcbiAgICAwLFxyXG4gICAgMCxcclxuICAgIDAsXHJcbiAgICAwLFxyXG4gICAgZmFsc2UsXHJcbiAgICBmYWxzZSxcclxuICAgIGZhbHNlLFxyXG4gICAgZmFsc2UsXHJcbiAgICAwLFxyXG4gICAgbnVsbCxcclxuICAgIDAsXHJcbiAgICAwXHJcbiAgXTtcclxuXHJcbiAgZnVuY3Rpb24gUG9pbnRlckV2ZW50KGluVHlwZSwgaW5EaWN0KSB7XHJcbiAgICBpbkRpY3QgPSBpbkRpY3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHJcbiAgICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xyXG4gICAgZS5pbml0RXZlbnQoaW5UeXBlLCBpbkRpY3QuYnViYmxlcyB8fCBmYWxzZSwgaW5EaWN0LmNhbmNlbGFibGUgfHwgZmFsc2UpO1xyXG5cclxuICAgIC8vIGRlZmluZSBpbmhlcml0ZWQgTW91c2VFdmVudCBwcm9wZXJ0aWVzXHJcbiAgICAvLyBza2lwIGJ1YmJsZXMgYW5kIGNhbmNlbGFibGUgc2luY2UgdGhleSdyZSBzZXQgYWJvdmUgaW4gaW5pdEV2ZW50KClcclxuICAgIGZvciAodmFyIGkgPSAyLCBwOyBpIDwgTU9VU0VfUFJPUFMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgcCA9IE1PVVNFX1BST1BTW2ldO1xyXG4gICAgICBlW3BdID0gaW5EaWN0W3BdIHx8IE1PVVNFX0RFRkFVTFRTW2ldO1xyXG4gICAgfVxyXG4gICAgZS5idXR0b25zID0gaW5EaWN0LmJ1dHRvbnMgfHwgMDtcclxuXHJcbiAgICAvLyBTcGVjIHJlcXVpcmVzIHRoYXQgcG9pbnRlcnMgd2l0aG91dCBwcmVzc3VyZSBzcGVjaWZpZWQgdXNlIDAuNSBmb3IgZG93blxyXG4gICAgLy8gc3RhdGUgYW5kIDAgZm9yIHVwIHN0YXRlLlxyXG4gICAgdmFyIHByZXNzdXJlID0gMDtcclxuXHJcbiAgICBpZiAoaW5EaWN0LnByZXNzdXJlICYmIGUuYnV0dG9ucykge1xyXG4gICAgICBwcmVzc3VyZSA9IGluRGljdC5wcmVzc3VyZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHByZXNzdXJlID0gZS5idXR0b25zID8gMC41IDogMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBhZGQgeC95IHByb3BlcnRpZXMgYWxpYXNlZCB0byBjbGllbnRYL1lcclxuICAgIGUueCA9IGUuY2xpZW50WDtcclxuICAgIGUueSA9IGUuY2xpZW50WTtcclxuXHJcbiAgICAvLyBkZWZpbmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIFBvaW50ZXJFdmVudCBpbnRlcmZhY2VcclxuICAgIGUucG9pbnRlcklkID0gaW5EaWN0LnBvaW50ZXJJZCB8fCAwO1xyXG4gICAgZS53aWR0aCA9IGluRGljdC53aWR0aCB8fCAwO1xyXG4gICAgZS5oZWlnaHQgPSBpbkRpY3QuaGVpZ2h0IHx8IDA7XHJcbiAgICBlLnByZXNzdXJlID0gcHJlc3N1cmU7XHJcbiAgICBlLnRpbHRYID0gaW5EaWN0LnRpbHRYIHx8IDA7XHJcbiAgICBlLnRpbHRZID0gaW5EaWN0LnRpbHRZIHx8IDA7XHJcbiAgICBlLnBvaW50ZXJUeXBlID0gaW5EaWN0LnBvaW50ZXJUeXBlIHx8ICcnO1xyXG4gICAgZS5od1RpbWVzdGFtcCA9IGluRGljdC5od1RpbWVzdGFtcCB8fCAwO1xyXG4gICAgZS5pc1ByaW1hcnkgPSBpbkRpY3QuaXNQcmltYXJ5IHx8IGZhbHNlO1xyXG4gICAgcmV0dXJuIGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIGEgbWFwIG9mIHBvaW50ZXIgc3RhdGVzXHJcbiAgICovXHJcbiAgdmFyIFVTRV9NQVAgPSB3aW5kb3cuTWFwICYmIHdpbmRvdy5NYXAucHJvdG90eXBlLmZvckVhY2g7XHJcbiAgdmFyIFBvaW50ZXJNYXAgPSBVU0VfTUFQID8gTWFwIDogU3BhcnNlQXJyYXlNYXA7XHJcblxyXG4gIGZ1bmN0aW9uIFNwYXJzZUFycmF5TWFwKCkge1xyXG4gICAgdGhpcy5hcnJheSA9IFtdO1xyXG4gICAgdGhpcy5zaXplID0gMDtcclxuICB9XHJcblxyXG4gIFNwYXJzZUFycmF5TWFwLnByb3RvdHlwZSA9IHtcclxuICAgIHNldDogZnVuY3Rpb24oaywgdikge1xyXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlKGspO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghdGhpcy5oYXMoaykpIHtcclxuICAgICAgICB0aGlzLnNpemUrKztcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmFycmF5W2tdID0gdjtcclxuICAgIH0sXHJcbiAgICBoYXM6IGZ1bmN0aW9uKGspIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlba10gIT09IHVuZGVmaW5lZDtcclxuICAgIH0sXHJcbiAgICBkZWxldGU6IGZ1bmN0aW9uKGspIHtcclxuICAgICAgaWYgKHRoaXMuaGFzKGspKSB7XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuYXJyYXlba107XHJcbiAgICAgICAgdGhpcy5zaXplLS07XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBnZXQ6IGZ1bmN0aW9uKGspIHtcclxuICAgICAgcmV0dXJuIHRoaXMuYXJyYXlba107XHJcbiAgICB9LFxyXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB0aGlzLmFycmF5Lmxlbmd0aCA9IDA7XHJcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIHJldHVybiB2YWx1ZSwga2V5LCBtYXBcclxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmFycmF5LmZvckVhY2goZnVuY3Rpb24odiwgaykge1xyXG4gICAgICAgIGNhbGxiYWNrLmNhbGwodGhpc0FyZywgdiwgaywgdGhpcyk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIHZhciBDTE9ORV9QUk9QUyA9IFtcclxuXHJcbiAgICAvLyBNb3VzZUV2ZW50XHJcbiAgICAnYnViYmxlcycsXHJcbiAgICAnY2FuY2VsYWJsZScsXHJcbiAgICAndmlldycsXHJcbiAgICAnZGV0YWlsJyxcclxuICAgICdzY3JlZW5YJyxcclxuICAgICdzY3JlZW5ZJyxcclxuICAgICdjbGllbnRYJyxcclxuICAgICdjbGllbnRZJyxcclxuICAgICdjdHJsS2V5JyxcclxuICAgICdhbHRLZXknLFxyXG4gICAgJ3NoaWZ0S2V5JyxcclxuICAgICdtZXRhS2V5JyxcclxuICAgICdidXR0b24nLFxyXG4gICAgJ3JlbGF0ZWRUYXJnZXQnLFxyXG5cclxuICAgIC8vIERPTSBMZXZlbCAzXHJcbiAgICAnYnV0dG9ucycsXHJcblxyXG4gICAgLy8gUG9pbnRlckV2ZW50XHJcbiAgICAncG9pbnRlcklkJyxcclxuICAgICd3aWR0aCcsXHJcbiAgICAnaGVpZ2h0JyxcclxuICAgICdwcmVzc3VyZScsXHJcbiAgICAndGlsdFgnLFxyXG4gICAgJ3RpbHRZJyxcclxuICAgICdwb2ludGVyVHlwZScsXHJcbiAgICAnaHdUaW1lc3RhbXAnLFxyXG4gICAgJ2lzUHJpbWFyeScsXHJcblxyXG4gICAgLy8gZXZlbnQgaW5zdGFuY2VcclxuICAgICd0eXBlJyxcclxuICAgICd0YXJnZXQnLFxyXG4gICAgJ2N1cnJlbnRUYXJnZXQnLFxyXG4gICAgJ3doaWNoJyxcclxuICAgICdwYWdlWCcsXHJcbiAgICAncGFnZVknLFxyXG4gICAgJ3RpbWVTdGFtcCdcclxuICBdO1xyXG5cclxuICB2YXIgQ0xPTkVfREVGQVVMVFMgPSBbXHJcblxyXG4gICAgLy8gTW91c2VFdmVudFxyXG4gICAgZmFsc2UsXHJcbiAgICBmYWxzZSxcclxuICAgIG51bGwsXHJcbiAgICBudWxsLFxyXG4gICAgMCxcclxuICAgIDAsXHJcbiAgICAwLFxyXG4gICAgMCxcclxuICAgIGZhbHNlLFxyXG4gICAgZmFsc2UsXHJcbiAgICBmYWxzZSxcclxuICAgIGZhbHNlLFxyXG4gICAgMCxcclxuICAgIG51bGwsXHJcblxyXG4gICAgLy8gRE9NIExldmVsIDNcclxuICAgIDAsXHJcblxyXG4gICAgLy8gUG9pbnRlckV2ZW50XHJcbiAgICAwLFxyXG4gICAgMCxcclxuICAgIDAsXHJcbiAgICAwLFxyXG4gICAgMCxcclxuICAgIDAsXHJcbiAgICAnJyxcclxuICAgIDAsXHJcbiAgICBmYWxzZSxcclxuXHJcbiAgICAvLyBldmVudCBpbnN0YW5jZVxyXG4gICAgJycsXHJcbiAgICBudWxsLFxyXG4gICAgbnVsbCxcclxuICAgIDAsXHJcbiAgICAwLFxyXG4gICAgMCxcclxuICAgIDBcclxuICBdO1xyXG5cclxuICB2YXIgQk9VTkRBUllfRVZFTlRTID0ge1xyXG4gICAgJ3BvaW50ZXJvdmVyJzogMSxcclxuICAgICdwb2ludGVyb3V0JzogMSxcclxuICAgICdwb2ludGVyZW50ZXInOiAxLFxyXG4gICAgJ3BvaW50ZXJsZWF2ZSc6IDFcclxuICB9O1xyXG5cclxuICB2YXIgSEFTX1NWR19JTlNUQU5DRSA9ICh0eXBlb2YgU1ZHRWxlbWVudEluc3RhbmNlICE9PSAndW5kZWZpbmVkJyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgbW9kdWxlIGlzIGZvciBub3JtYWxpemluZyBldmVudHMuIE1vdXNlIGFuZCBUb3VjaCBldmVudHMgd2lsbCBiZVxyXG4gICAqIGNvbGxlY3RlZCBoZXJlLCBhbmQgZmlyZSBQb2ludGVyRXZlbnRzIHRoYXQgaGF2ZSB0aGUgc2FtZSBzZW1hbnRpY3MsIG5vXHJcbiAgICogbWF0dGVyIHRoZSBzb3VyY2UuXHJcbiAgICogRXZlbnRzIGZpcmVkOlxyXG4gICAqICAgLSBwb2ludGVyZG93bjogYSBwb2ludGluZyBpcyBhZGRlZFxyXG4gICAqICAgLSBwb2ludGVydXA6IGEgcG9pbnRlciBpcyByZW1vdmVkXHJcbiAgICogICAtIHBvaW50ZXJtb3ZlOiBhIHBvaW50ZXIgaXMgbW92ZWRcclxuICAgKiAgIC0gcG9pbnRlcm92ZXI6IGEgcG9pbnRlciBjcm9zc2VzIGludG8gYW4gZWxlbWVudFxyXG4gICAqICAgLSBwb2ludGVyb3V0OiBhIHBvaW50ZXIgbGVhdmVzIGFuIGVsZW1lbnRcclxuICAgKiAgIC0gcG9pbnRlcmNhbmNlbDogYSBwb2ludGVyIHdpbGwgbm8gbG9uZ2VyIGdlbmVyYXRlIGV2ZW50c1xyXG4gICAqL1xyXG4gIHZhciBkaXNwYXRjaGVyID0ge1xyXG4gICAgcG9pbnRlcm1hcDogbmV3IFBvaW50ZXJNYXAoKSxcclxuICAgIGV2ZW50TWFwOiBPYmplY3QuY3JlYXRlKG51bGwpLFxyXG4gICAgY2FwdHVyZUluZm86IE9iamVjdC5jcmVhdGUobnVsbCksXHJcblxyXG4gICAgLy8gU2NvcGUgb2JqZWN0cyBmb3IgbmF0aXZlIGV2ZW50cy5cclxuICAgIC8vIFRoaXMgZXhpc3RzIGZvciBlYXNlIG9mIHRlc3RpbmcuXHJcbiAgICBldmVudFNvdXJjZXM6IE9iamVjdC5jcmVhdGUobnVsbCksXHJcbiAgICBldmVudFNvdXJjZUxpc3Q6IFtdLFxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBuZXcgZXZlbnQgc291cmNlIHRoYXQgd2lsbCBnZW5lcmF0ZSBwb2ludGVyIGV2ZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBgaW5Tb3VyY2VgIG11c3QgY29udGFpbiBhbiBhcnJheSBvZiBldmVudCBuYW1lcyBuYW1lZCBgZXZlbnRzYCwgYW5kXHJcbiAgICAgKiBmdW5jdGlvbnMgd2l0aCB0aGUgbmFtZXMgc3BlY2lmaWVkIGluIHRoZSBgZXZlbnRzYCBhcnJheS5cclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgbmFtZSBmb3IgdGhlIGV2ZW50IHNvdXJjZVxyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBBIG5ldyBzb3VyY2Ugb2YgcGxhdGZvcm0gZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICByZWdpc3RlclNvdXJjZTogZnVuY3Rpb24obmFtZSwgc291cmNlKSB7XHJcbiAgICAgIHZhciBzID0gc291cmNlO1xyXG4gICAgICB2YXIgbmV3RXZlbnRzID0gcy5ldmVudHM7XHJcbiAgICAgIGlmIChuZXdFdmVudHMpIHtcclxuICAgICAgICBuZXdFdmVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgICBpZiAoc1tlXSkge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50TWFwW2VdID0gc1tlXS5iaW5kKHMpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRTb3VyY2VzW25hbWVdID0gcztcclxuICAgICAgICB0aGlzLmV2ZW50U291cmNlTGlzdC5wdXNoKHMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuICAgICAgdmFyIGwgPSB0aGlzLmV2ZW50U291cmNlTGlzdC5sZW5ndGg7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBlczsgKGkgPCBsKSAmJiAoZXMgPSB0aGlzLmV2ZW50U291cmNlTGlzdFtpXSk7IGkrKykge1xyXG5cclxuICAgICAgICAvLyBjYWxsIGV2ZW50c291cmNlIHJlZ2lzdGVyXHJcbiAgICAgICAgZXMucmVnaXN0ZXIuY2FsbChlcywgZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHZhciBsID0gdGhpcy5ldmVudFNvdXJjZUxpc3QubGVuZ3RoO1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgZXM7IChpIDwgbCkgJiYgKGVzID0gdGhpcy5ldmVudFNvdXJjZUxpc3RbaV0pOyBpKyspIHtcclxuXHJcbiAgICAgICAgLy8gY2FsbCBldmVudHNvdXJjZSByZWdpc3RlclxyXG4gICAgICAgIGVzLnVucmVnaXN0ZXIuY2FsbChlcywgZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBjb250YWluczogLypzY29wZS5leHRlcm5hbC5jb250YWlucyB8fCAqL2Z1bmN0aW9uKGNvbnRhaW5lciwgY29udGFpbmVkKSB7XHJcbiAgICAgIHRyeSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5jb250YWlucyhjb250YWluZWQpO1xyXG4gICAgICB9IGNhdGNoIChleCkge1xyXG5cclxuICAgICAgICAvLyBtb3N0IGxpa2VseTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8vIEVWRU5UU1xyXG4gICAgZG93bjogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICBpbkV2ZW50LmJ1YmJsZXMgPSB0cnVlO1xyXG4gICAgICB0aGlzLmZpcmVFdmVudCgncG9pbnRlcmRvd24nLCBpbkV2ZW50KTtcclxuICAgIH0sXHJcbiAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIGluRXZlbnQuYnViYmxlcyA9IHRydWU7XHJcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdwb2ludGVybW92ZScsIGluRXZlbnQpO1xyXG4gICAgfSxcclxuICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIGluRXZlbnQuYnViYmxlcyA9IHRydWU7XHJcbiAgICAgIHRoaXMuZmlyZUV2ZW50KCdwb2ludGVydXAnLCBpbkV2ZW50KTtcclxuICAgIH0sXHJcbiAgICBlbnRlcjogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICBpbkV2ZW50LmJ1YmJsZXMgPSBmYWxzZTtcclxuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BvaW50ZXJlbnRlcicsIGluRXZlbnQpO1xyXG4gICAgfSxcclxuICAgIGxlYXZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIGluRXZlbnQuYnViYmxlcyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLmZpcmVFdmVudCgncG9pbnRlcmxlYXZlJywgaW5FdmVudCk7XHJcbiAgICB9LFxyXG4gICAgb3ZlcjogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICBpbkV2ZW50LmJ1YmJsZXMgPSB0cnVlO1xyXG4gICAgICB0aGlzLmZpcmVFdmVudCgncG9pbnRlcm92ZXInLCBpbkV2ZW50KTtcclxuICAgIH0sXHJcbiAgICBvdXQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcclxuICAgICAgaW5FdmVudC5idWJibGVzID0gdHJ1ZTtcclxuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BvaW50ZXJvdXQnLCBpbkV2ZW50KTtcclxuICAgIH0sXHJcbiAgICBjYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcclxuICAgICAgaW5FdmVudC5idWJibGVzID0gdHJ1ZTtcclxuICAgICAgdGhpcy5maXJlRXZlbnQoJ3BvaW50ZXJjYW5jZWwnLCBpbkV2ZW50KTtcclxuICAgIH0sXHJcbiAgICBsZWF2ZU91dDogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdGhpcy5vdXQoZXZlbnQpO1xyXG4gICAgICB0aGlzLnByb3BhZ2F0ZShldmVudCwgdGhpcy5sZWF2ZSwgZmFsc2UpO1xyXG4gICAgfSxcclxuICAgIGVudGVyT3ZlcjogZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgdGhpcy5vdmVyKGV2ZW50KTtcclxuICAgICAgdGhpcy5wcm9wYWdhdGUoZXZlbnQsIHRoaXMuZW50ZXIsIHRydWUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBMSVNURU5FUiBMT0dJQ1xyXG4gICAgZXZlbnRIYW5kbGVyOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcblxyXG4gICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBtdWx0aXBsZSBkaXNwYXRjaCBvZiBwb2ludGVyZXZlbnRzIGZyb21cclxuICAgICAgLy8gcGxhdGZvcm0gZXZlbnRzLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0d28gZWxlbWVudHMgaW4gZGlmZmVyZW50IHNjb3Blc1xyXG4gICAgICAvLyBhcmUgc2V0IHVwIHRvIGNyZWF0ZSBwb2ludGVyIGV2ZW50cywgd2hpY2ggaXMgcmVsZXZhbnQgdG8gU2hhZG93IERPTS5cclxuICAgICAgaWYgKGluRXZlbnQuX2hhbmRsZWRCeVBFKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHZhciB0eXBlID0gaW5FdmVudC50eXBlO1xyXG4gICAgICB2YXIgZm4gPSB0aGlzLmV2ZW50TWFwICYmIHRoaXMuZXZlbnRNYXBbdHlwZV07XHJcbiAgICAgIGlmIChmbikge1xyXG4gICAgICAgIGZuKGluRXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICAgIGluRXZlbnQuX2hhbmRsZWRCeVBFID0gdHJ1ZTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gc2V0IHVwIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgbGlzdGVuOiBmdW5jdGlvbih0YXJnZXQsIGV2ZW50cykge1xyXG4gICAgICBldmVudHMuZm9yRWFjaChmdW5jdGlvbihlKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFdmVudCh0YXJnZXQsIGUpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgdW5saXN0ZW46IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnRzKSB7XHJcbiAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50KHRhcmdldCwgZSk7XHJcbiAgICAgIH0sIHRoaXMpO1xyXG4gICAgfSxcclxuICAgIGFkZEV2ZW50OiAvKnNjb3BlLmV4dGVybmFsLmFkZEV2ZW50IHx8ICovZnVuY3Rpb24odGFyZ2V0LCBldmVudE5hbWUpIHtcclxuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLmJvdW5kSGFuZGxlcik7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlRXZlbnQ6IC8qc2NvcGUuZXh0ZXJuYWwucmVtb3ZlRXZlbnQgfHwgKi9mdW5jdGlvbih0YXJnZXQsIGV2ZW50TmFtZSkge1xyXG4gICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHRoaXMuYm91bmRIYW5kbGVyKTtcclxuICAgIH0sXHJcblxyXG4gICAgLy8gRVZFTlQgQ1JFQVRJT04gQU5EIFRSQUNLSU5HXHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgRXZlbnQgb2YgdHlwZSBgaW5UeXBlYCwgYmFzZWQgb24gdGhlIGluZm9ybWF0aW9uIGluXHJcbiAgICAgKiBgaW5FdmVudGAuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGluVHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgZXZlbnQgdG8gY3JlYXRlXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IEEgcGxhdGZvcm0gZXZlbnQgd2l0aCBhIHRhcmdldFxyXG4gICAgICogQHJldHVybiB7RXZlbnR9IEEgUG9pbnRlckV2ZW50IG9mIHR5cGUgYGluVHlwZWBcclxuICAgICAqL1xyXG4gICAgbWFrZUV2ZW50OiBmdW5jdGlvbihpblR5cGUsIGluRXZlbnQpIHtcclxuXHJcbiAgICAgIC8vIHJlbGF0ZWRUYXJnZXQgbXVzdCBiZSBudWxsIGlmIHBvaW50ZXIgaXMgY2FwdHVyZWRcclxuICAgICAgaWYgKHRoaXMuY2FwdHVyZUluZm9baW5FdmVudC5wb2ludGVySWRdKSB7XHJcbiAgICAgICAgaW5FdmVudC5yZWxhdGVkVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB2YXIgZSA9IG5ldyBQb2ludGVyRXZlbnQoaW5UeXBlLCBpbkV2ZW50KTtcclxuICAgICAgaWYgKGluRXZlbnQucHJldmVudERlZmF1bHQpIHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0ID0gaW5FdmVudC5wcmV2ZW50RGVmYXVsdDtcclxuICAgICAgfVxyXG4gICAgICBlLl90YXJnZXQgPSBlLl90YXJnZXQgfHwgaW5FdmVudC50YXJnZXQ7XHJcbiAgICAgIHJldHVybiBlO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBtYWtlIGFuZCBkaXNwYXRjaCBhbiBldmVudCBpbiBvbmUgY2FsbFxyXG4gICAgZmlyZUV2ZW50OiBmdW5jdGlvbihpblR5cGUsIGluRXZlbnQpIHtcclxuICAgICAgdmFyIGUgPSB0aGlzLm1ha2VFdmVudChpblR5cGUsIGluRXZlbnQpO1xyXG4gICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xyXG4gICAgfSxcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIGluRXZlbnQsIHdpdGggd3JpdGFibGUgcHJvcGVydGllcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBpbkV2ZW50IEFuIGV2ZW50IHRoYXQgY29udGFpbnMgcHJvcGVydGllcyB0byBjb3B5LlxyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBzaGFsbG93IGNvcGllcyBvZiBgaW5FdmVudGAnc1xyXG4gICAgICogICAgcHJvcGVydGllcy5cclxuICAgICAqL1xyXG4gICAgY2xvbmVFdmVudDogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICB2YXIgZXZlbnRDb3B5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuICAgICAgdmFyIHA7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ0xPTkVfUFJPUFMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBwID0gQ0xPTkVfUFJPUFNbaV07XHJcbiAgICAgICAgZXZlbnRDb3B5W3BdID0gaW5FdmVudFtwXSB8fCBDTE9ORV9ERUZBVUxUU1tpXTtcclxuXHJcbiAgICAgICAgLy8gV29yayBhcm91bmQgU1ZHSW5zdGFuY2VFbGVtZW50IHNoYWRvdyB0cmVlXHJcbiAgICAgICAgLy8gUmV0dXJuIHRoZSA8dXNlPiBlbGVtZW50IHRoYXQgaXMgcmVwcmVzZW50ZWQgYnkgdGhlIGluc3RhbmNlIGZvciBTYWZhcmksIENocm9tZSwgSUUuXHJcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmVoYXZpb3IgaW1wbGVtZW50ZWQgYnkgRmlyZWZveC5cclxuICAgICAgICBpZiAoSEFTX1NWR19JTlNUQU5DRSAmJiAocCA9PT0gJ3RhcmdldCcgfHwgcCA9PT0gJ3JlbGF0ZWRUYXJnZXQnKSkge1xyXG4gICAgICAgICAgaWYgKGV2ZW50Q29weVtwXSBpbnN0YW5jZW9mIFNWR0VsZW1lbnRJbnN0YW5jZSkge1xyXG4gICAgICAgICAgICBldmVudENvcHlbcF0gPSBldmVudENvcHlbcF0uY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBrZWVwIHRoZSBzZW1hbnRpY3Mgb2YgcHJldmVudERlZmF1bHRcclxuICAgICAgaWYgKGluRXZlbnQucHJldmVudERlZmF1bHQpIHtcclxuICAgICAgICBldmVudENvcHkucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgIGluRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBldmVudENvcHk7XHJcbiAgICB9LFxyXG4gICAgZ2V0VGFyZ2V0OiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIHZhciBjYXB0dXJlID0gdGhpcy5jYXB0dXJlSW5mb1tpbkV2ZW50LnBvaW50ZXJJZF07XHJcbiAgICAgIGlmICghY2FwdHVyZSkge1xyXG4gICAgICAgIHJldHVybiBpbkV2ZW50Ll90YXJnZXQ7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGluRXZlbnQuX3RhcmdldCA9PT0gY2FwdHVyZSB8fCAhKGluRXZlbnQudHlwZSBpbiBCT1VOREFSWV9FVkVOVFMpKSB7XHJcbiAgICAgICAgcmV0dXJuIGNhcHR1cmU7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBwcm9wYWdhdGU6IGZ1bmN0aW9uKGV2ZW50LCBmbiwgcHJvcGFnYXRlRG93bikge1xyXG4gICAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICB2YXIgdGFyZ2V0cyA9IFtdO1xyXG4gICAgICB3aGlsZSAoIXRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSAmJiB0YXJnZXQgIT09IGRvY3VtZW50KSB7XHJcbiAgICAgICAgdGFyZ2V0cy5wdXNoKHRhcmdldCk7XHJcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LnBhcmVudE5vZGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHByb3BhZ2F0ZURvd24pIHtcclxuICAgICAgICB0YXJnZXRzLnJldmVyc2UoKTtcclxuICAgICAgfVxyXG4gICAgICB0YXJnZXRzLmZvckVhY2goZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgICAgZXZlbnQudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xyXG4gICAgICB9LCB0aGlzKTtcclxuICAgIH0sXHJcbiAgICBzZXRDYXB0dXJlOiBmdW5jdGlvbihpblBvaW50ZXJJZCwgaW5UYXJnZXQpIHtcclxuICAgICAgaWYgKHRoaXMuY2FwdHVyZUluZm9baW5Qb2ludGVySWRdKSB7XHJcbiAgICAgICAgdGhpcy5yZWxlYXNlQ2FwdHVyZShpblBvaW50ZXJJZCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jYXB0dXJlSW5mb1tpblBvaW50ZXJJZF0gPSBpblRhcmdldDtcclxuICAgICAgdmFyIGUgPSBuZXcgUG9pbnRlckV2ZW50KCdnb3Rwb2ludGVyY2FwdHVyZScpO1xyXG4gICAgICBlLnBvaW50ZXJJZCA9IGluUG9pbnRlcklkO1xyXG4gICAgICB0aGlzLmltcGxpY2l0UmVsZWFzZSA9IHRoaXMucmVsZWFzZUNhcHR1cmUuYmluZCh0aGlzLCBpblBvaW50ZXJJZCk7XHJcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuaW1wbGljaXRSZWxlYXNlKTtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuaW1wbGljaXRSZWxlYXNlKTtcclxuICAgICAgZS5fdGFyZ2V0ID0gaW5UYXJnZXQ7XHJcbiAgICAgIHRoaXMuYXN5bmNEaXNwYXRjaEV2ZW50KGUpO1xyXG4gICAgfSxcclxuICAgIHJlbGVhc2VDYXB0dXJlOiBmdW5jdGlvbihpblBvaW50ZXJJZCkge1xyXG4gICAgICB2YXIgdCA9IHRoaXMuY2FwdHVyZUluZm9baW5Qb2ludGVySWRdO1xyXG4gICAgICBpZiAodCkge1xyXG4gICAgICAgIHZhciBlID0gbmV3IFBvaW50ZXJFdmVudCgnbG9zdHBvaW50ZXJjYXB0dXJlJyk7XHJcbiAgICAgICAgZS5wb2ludGVySWQgPSBpblBvaW50ZXJJZDtcclxuICAgICAgICB0aGlzLmNhcHR1cmVJbmZvW2luUG9pbnRlcklkXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCB0aGlzLmltcGxpY2l0UmVsZWFzZSk7XHJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuaW1wbGljaXRSZWxlYXNlKTtcclxuICAgICAgICBlLl90YXJnZXQgPSB0O1xyXG4gICAgICAgIHRoaXMuYXN5bmNEaXNwYXRjaEV2ZW50KGUpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgLyoqXHJcbiAgICAgKiBEaXNwYXRjaGVzIHRoZSBldmVudCB0byBpdHMgdGFyZ2V0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgVGhlIGV2ZW50IHRvIGJlIGRpc3BhdGNoZWQuXHJcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBUcnVlIGlmIGFuIGV2ZW50IGhhbmRsZXIgcmV0dXJucyB0cnVlLCBmYWxzZSBvdGhlcndpc2UuXHJcbiAgICAgKi9cclxuICAgIGRpc3BhdGNoRXZlbnQ6IC8qc2NvcGUuZXh0ZXJuYWwuZGlzcGF0Y2hFdmVudCB8fCAqL2Z1bmN0aW9uKGluRXZlbnQpIHtcclxuICAgICAgdmFyIHQgPSB0aGlzLmdldFRhcmdldChpbkV2ZW50KTtcclxuICAgICAgaWYgKHQpIHtcclxuICAgICAgICByZXR1cm4gdC5kaXNwYXRjaEV2ZW50KGluRXZlbnQpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgYXN5bmNEaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmRpc3BhdGNoRXZlbnQuYmluZCh0aGlzLCBpbkV2ZW50KSk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBkaXNwYXRjaGVyLmJvdW5kSGFuZGxlciA9IGRpc3BhdGNoZXIuZXZlbnRIYW5kbGVyLmJpbmQoZGlzcGF0Y2hlcik7XHJcblxyXG4gIHZhciB0YXJnZXRpbmcgPSB7XHJcbiAgICBzaGFkb3c6IGZ1bmN0aW9uKGluRWwpIHtcclxuICAgICAgaWYgKGluRWwpIHtcclxuICAgICAgICByZXR1cm4gaW5FbC5zaGFkb3dSb290IHx8IGluRWwud2Via2l0U2hhZG93Um9vdDtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNhblRhcmdldDogZnVuY3Rpb24oc2hhZG93KSB7XHJcbiAgICAgIHJldHVybiBzaGFkb3cgJiYgQm9vbGVhbihzaGFkb3cuZWxlbWVudEZyb21Qb2ludCk7XHJcbiAgICB9LFxyXG4gICAgdGFyZ2V0aW5nU2hhZG93OiBmdW5jdGlvbihpbkVsKSB7XHJcbiAgICAgIHZhciBzID0gdGhpcy5zaGFkb3coaW5FbCk7XHJcbiAgICAgIGlmICh0aGlzLmNhblRhcmdldChzKSkge1xyXG4gICAgICAgIHJldHVybiBzO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgb2xkZXJTaGFkb3c6IGZ1bmN0aW9uKHNoYWRvdykge1xyXG4gICAgICB2YXIgb3MgPSBzaGFkb3cub2xkZXJTaGFkb3dSb290O1xyXG4gICAgICBpZiAoIW9zKSB7XHJcbiAgICAgICAgdmFyIHNlID0gc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ3NoYWRvdycpO1xyXG4gICAgICAgIGlmIChzZSkge1xyXG4gICAgICAgICAgb3MgPSBzZS5vbGRlclNoYWRvd1Jvb3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBvcztcclxuICAgIH0sXHJcbiAgICBhbGxTaGFkb3dzOiBmdW5jdGlvbihlbGVtZW50KSB7XHJcbiAgICAgIHZhciBzaGFkb3dzID0gW107XHJcbiAgICAgIHZhciBzID0gdGhpcy5zaGFkb3coZWxlbWVudCk7XHJcbiAgICAgIHdoaWxlIChzKSB7XHJcbiAgICAgICAgc2hhZG93cy5wdXNoKHMpO1xyXG4gICAgICAgIHMgPSB0aGlzLm9sZGVyU2hhZG93KHMpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBzaGFkb3dzO1xyXG4gICAgfSxcclxuICAgIHNlYXJjaFJvb3Q6IGZ1bmN0aW9uKGluUm9vdCwgeCwgeSkge1xyXG4gICAgICBpZiAoaW5Sb290KSB7XHJcbiAgICAgICAgdmFyIHQgPSBpblJvb3QuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcclxuICAgICAgICB2YXIgc3QsIHNyO1xyXG5cclxuICAgICAgICAvLyBpcyBlbGVtZW50IGEgc2hhZG93IGhvc3Q/XHJcbiAgICAgICAgc3IgPSB0aGlzLnRhcmdldGluZ1NoYWRvdyh0KTtcclxuICAgICAgICB3aGlsZSAoc3IpIHtcclxuXHJcbiAgICAgICAgICAvLyBmaW5kIHRoZSB0aGUgZWxlbWVudCBpbnNpZGUgdGhlIHNoYWRvdyByb290XHJcbiAgICAgICAgICBzdCA9IHNyLmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XHJcbiAgICAgICAgICBpZiAoIXN0KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBjaGVjayBmb3Igb2xkZXIgc2hhZG93c1xyXG4gICAgICAgICAgICBzciA9IHRoaXMub2xkZXJTaGFkb3coc3IpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIHNoYWRvd2VkIGVsZW1lbnQgbWF5IGNvbnRhaW4gYSBzaGFkb3cgcm9vdFxyXG4gICAgICAgICAgICB2YXIgc3NyID0gdGhpcy50YXJnZXRpbmdTaGFkb3coc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hSb290KHNzciwgeCwgeSkgfHwgc3Q7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBsaWdodCBkb20gZWxlbWVudCBpcyB0aGUgdGFyZ2V0XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBvd25lcjogZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICB2YXIgcyA9IGVsZW1lbnQ7XHJcblxyXG4gICAgICAvLyB3YWxrIHVwIHVudGlsIHlvdSBoaXQgdGhlIHNoYWRvdyByb290IG9yIGRvY3VtZW50XHJcbiAgICAgIHdoaWxlIChzLnBhcmVudE5vZGUpIHtcclxuICAgICAgICBzID0gcy5wYXJlbnROb2RlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB0aGUgb3duZXIgZWxlbWVudCBpcyBleHBlY3RlZCB0byBiZSBhIERvY3VtZW50IG9yIFNoYWRvd1Jvb3RcclxuICAgICAgaWYgKHMubm9kZVR5cGUgIT09IE5vZGUuRE9DVU1FTlRfTk9ERSAmJiBzLm5vZGVUeXBlICE9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcclxuICAgICAgICBzID0gZG9jdW1lbnQ7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHM7XHJcbiAgICB9LFxyXG4gICAgZmluZFRhcmdldDogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WDtcclxuICAgICAgdmFyIHkgPSBpbkV2ZW50LmNsaWVudFk7XHJcblxyXG4gICAgICAvLyBpZiB0aGUgbGlzdGVuZXIgaXMgaW4gdGhlIHNoYWRvdyByb290LCBpdCBpcyBtdWNoIGZhc3RlciB0byBzdGFydCB0aGVyZVxyXG4gICAgICB2YXIgcyA9IHRoaXMub3duZXIoaW5FdmVudC50YXJnZXQpO1xyXG5cclxuICAgICAgLy8gaWYgeCwgeSBpcyBub3QgaW4gdGhpcyByb290LCBmYWxsIGJhY2sgdG8gZG9jdW1lbnQgc2VhcmNoXHJcbiAgICAgIGlmICghcy5lbGVtZW50RnJvbVBvaW50KHgsIHkpKSB7XHJcbiAgICAgICAgcyA9IGRvY3VtZW50O1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnNlYXJjaFJvb3QocywgeCwgeSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmZvckVhY2gpO1xyXG4gIHZhciBtYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUubWFwKTtcclxuICB2YXIgdG9BcnJheSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLnNsaWNlKTtcclxuICB2YXIgZmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsLmJpbmQoQXJyYXkucHJvdG90eXBlLmZpbHRlcik7XHJcbiAgdmFyIE1PID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgfHwgd2luZG93LldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XHJcbiAgdmFyIFNFTEVDVE9SID0gJ1t0b3VjaC1hY3Rpb25dJztcclxuICB2YXIgT0JTRVJWRVJfSU5JVCA9IHtcclxuICAgIHN1YnRyZWU6IHRydWUsXHJcbiAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICBhdHRyaWJ1dGVzOiB0cnVlLFxyXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXHJcbiAgICBhdHRyaWJ1dGVGaWx0ZXI6IFsndG91Y2gtYWN0aW9uJ11cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBJbnN0YWxsZXIoYWRkLCByZW1vdmUsIGNoYW5nZWQsIGJpbmRlcikge1xyXG4gICAgdGhpcy5hZGRDYWxsYmFjayA9IGFkZC5iaW5kKGJpbmRlcik7XHJcbiAgICB0aGlzLnJlbW92ZUNhbGxiYWNrID0gcmVtb3ZlLmJpbmQoYmluZGVyKTtcclxuICAgIHRoaXMuY2hhbmdlZENhbGxiYWNrID0gY2hhbmdlZC5iaW5kKGJpbmRlcik7XHJcbiAgICBpZiAoTU8pIHtcclxuICAgICAgdGhpcy5vYnNlcnZlciA9IG5ldyBNTyh0aGlzLm11dGF0aW9uV2F0Y2hlci5iaW5kKHRoaXMpKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIEluc3RhbGxlci5wcm90b3R5cGUgPSB7XHJcbiAgICB3YXRjaFN1YnRyZWU6IGZ1bmN0aW9uKHRhcmdldCkge1xyXG5cclxuICAgICAgLy8gT25seSB3YXRjaCBzY29wZXMgdGhhdCBjYW4gdGFyZ2V0IGZpbmQsIGFzIHRoZXNlIGFyZSB0b3AtbGV2ZWwuXHJcbiAgICAgIC8vIE90aGVyd2lzZSB3ZSBjYW4gc2VlIGR1cGxpY2F0ZSBhZGRpdGlvbnMgYW5kIHJlbW92YWxzIHRoYXQgYWRkIG5vaXNlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUT0RPKGRmcmVlZG1hbik6IEZvciBzb21lIGluc3RhbmNlcyB3aXRoIFNoYWRvd0RPTVBvbHlmaWxsLCB3ZSBjYW4gc2VlXHJcbiAgICAgIC8vIGEgcmVtb3ZhbCB3aXRob3V0IGFuIGluc2VydGlvbiB3aGVuIGEgbm9kZSBpcyByZWRpc3RyaWJ1dGVkIGFtb25nXHJcbiAgICAgIC8vIHNoYWRvd3MuIFNpbmNlIGl0IGFsbCBlbmRzIHVwIGNvcnJlY3QgaW4gdGhlIGRvY3VtZW50LCB3YXRjaGluZyBvbmx5XHJcbiAgICAgIC8vIHRoZSBkb2N1bWVudCB3aWxsIHlpZWxkIHRoZSBjb3JyZWN0IG11dGF0aW9ucyB0byB3YXRjaC5cclxuICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIgJiYgdGFyZ2V0aW5nLmNhblRhcmdldCh0YXJnZXQpKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlci5vYnNlcnZlKHRhcmdldCwgT0JTRVJWRVJfSU5JVCk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBlbmFibGVPblN1YnRyZWU6IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgICB0aGlzLndhdGNoU3VidHJlZSh0YXJnZXQpO1xyXG4gICAgICBpZiAodGFyZ2V0ID09PSBkb2N1bWVudCAmJiBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YWxsT25Mb2FkKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5pbnN0YWxsTmV3U3VidHJlZSh0YXJnZXQpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgaW5zdGFsbE5ld1N1YnRyZWU6IGZ1bmN0aW9uKHRhcmdldCkge1xyXG4gICAgICBmb3JFYWNoKHRoaXMuZmluZEVsZW1lbnRzKHRhcmdldCksIHRoaXMuYWRkRWxlbWVudCwgdGhpcyk7XHJcbiAgICB9LFxyXG4gICAgZmluZEVsZW1lbnRzOiBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgaWYgKHRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlRWxlbWVudDogZnVuY3Rpb24oZWwpIHtcclxuICAgICAgdGhpcy5yZW1vdmVDYWxsYmFjayhlbCk7XHJcbiAgICB9LFxyXG4gICAgYWRkRWxlbWVudDogZnVuY3Rpb24oZWwpIHtcclxuICAgICAgdGhpcy5hZGRDYWxsYmFjayhlbCk7XHJcbiAgICB9LFxyXG4gICAgZWxlbWVudENoYW5nZWQ6IGZ1bmN0aW9uKGVsLCBvbGRWYWx1ZSkge1xyXG4gICAgICB0aGlzLmNoYW5nZWRDYWxsYmFjayhlbCwgb2xkVmFsdWUpO1xyXG4gICAgfSxcclxuICAgIGNvbmNhdExpc3RzOiBmdW5jdGlvbihhY2N1bSwgbGlzdCkge1xyXG4gICAgICByZXR1cm4gYWNjdW0uY29uY2F0KHRvQXJyYXkobGlzdCkpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyByZWdpc3RlciBhbGwgdG91Y2gtYWN0aW9uID0gbm9uZSBub2RlcyBvbiBkb2N1bWVudCBsb2FkXHJcbiAgICBpbnN0YWxsT25Mb2FkOiBmdW5jdGlvbigpIHtcclxuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XHJcbiAgICAgICAgICB0aGlzLmluc3RhbGxOZXdTdWJ0cmVlKGRvY3VtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0uYmluZCh0aGlzKSk7XHJcbiAgICB9LFxyXG4gICAgaXNFbGVtZW50OiBmdW5jdGlvbihuKSB7XHJcbiAgICAgIHJldHVybiBuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERTtcclxuICAgIH0sXHJcbiAgICBmbGF0dGVuTXV0YXRpb25UcmVlOiBmdW5jdGlvbihpbk5vZGVzKSB7XHJcblxyXG4gICAgICAvLyBmaW5kIGNoaWxkcmVuIHdpdGggdG91Y2gtYWN0aW9uXHJcbiAgICAgIHZhciB0cmVlID0gbWFwKGluTm9kZXMsIHRoaXMuZmluZEVsZW1lbnRzLCB0aGlzKTtcclxuXHJcbiAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYWRkZWQgbm9kZXMgYXJlIGFjY291bnRlZCBmb3JcclxuICAgICAgdHJlZS5wdXNoKGZpbHRlcihpbk5vZGVzLCB0aGlzLmlzRWxlbWVudCkpO1xyXG5cclxuICAgICAgLy8gZmxhdHRlbiB0aGUgbGlzdFxyXG4gICAgICByZXR1cm4gdHJlZS5yZWR1Y2UodGhpcy5jb25jYXRMaXN0cywgW10pO1xyXG4gICAgfSxcclxuICAgIG11dGF0aW9uV2F0Y2hlcjogZnVuY3Rpb24obXV0YXRpb25zKSB7XHJcbiAgICAgIG11dGF0aW9ucy5mb3JFYWNoKHRoaXMubXV0YXRpb25IYW5kbGVyLCB0aGlzKTtcclxuICAgIH0sXHJcbiAgICBtdXRhdGlvbkhhbmRsZXI6IGZ1bmN0aW9uKG0pIHtcclxuICAgICAgaWYgKG0udHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcclxuICAgICAgICB2YXIgYWRkZWQgPSB0aGlzLmZsYXR0ZW5NdXRhdGlvblRyZWUobS5hZGRlZE5vZGVzKTtcclxuICAgICAgICBhZGRlZC5mb3JFYWNoKHRoaXMuYWRkRWxlbWVudCwgdGhpcyk7XHJcbiAgICAgICAgdmFyIHJlbW92ZWQgPSB0aGlzLmZsYXR0ZW5NdXRhdGlvblRyZWUobS5yZW1vdmVkTm9kZXMpO1xyXG4gICAgICAgIHJlbW92ZWQuZm9yRWFjaCh0aGlzLnJlbW92ZUVsZW1lbnQsIHRoaXMpO1xyXG4gICAgICB9IGVsc2UgaWYgKG0udHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50Q2hhbmdlZChtLnRhcmdldCwgbS5vbGRWYWx1ZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBzaGFkb3dTZWxlY3Rvcih2KSB7XHJcbiAgICByZXR1cm4gJ2JvZHkgL3NoYWRvdy1kZWVwLyAnICsgc2VsZWN0b3Iodik7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHNlbGVjdG9yKHYpIHtcclxuICAgIHJldHVybiAnW3RvdWNoLWFjdGlvbj1cIicgKyB2ICsgJ1wiXSc7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJ1bGUodikge1xyXG4gICAgcmV0dXJuICd7IC1tcy10b3VjaC1hY3Rpb246ICcgKyB2ICsgJzsgdG91Y2gtYWN0aW9uOiAnICsgdiArICc7IH0nO1xyXG4gIH1cclxuICB2YXIgYXR0cmliMmNzcyA9IFtcclxuICAgICdub25lJyxcclxuICAgICdhdXRvJyxcclxuICAgICdwYW4teCcsXHJcbiAgICAncGFuLXknLFxyXG4gICAge1xyXG4gICAgICBydWxlOiAncGFuLXggcGFuLXknLFxyXG4gICAgICBzZWxlY3RvcnM6IFtcclxuICAgICAgICAncGFuLXggcGFuLXknLFxyXG4gICAgICAgICdwYW4teSBwYW4teCdcclxuICAgICAgXVxyXG4gICAgfVxyXG4gIF07XHJcbiAgdmFyIHN0eWxlcyA9ICcnO1xyXG5cclxuICAvLyBvbmx5IGluc3RhbGwgc3R5bGVzaGVldCBpZiB0aGUgYnJvd3NlciBoYXMgdG91Y2ggYWN0aW9uIHN1cHBvcnRcclxuICB2YXIgaGFzTmF0aXZlUEUgPSB3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudDtcclxuXHJcbiAgLy8gb25seSBhZGQgc2hhZG93IHNlbGVjdG9ycyBpZiBzaGFkb3dkb20gaXMgc3VwcG9ydGVkXHJcbiAgdmFyIGhhc1NoYWRvd1Jvb3QgPSAhd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIGRvY3VtZW50LmhlYWQuY3JlYXRlU2hhZG93Um9vdDtcclxuXHJcbiAgZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVTdHlsZXMoKSB7XHJcbiAgICBpZiAoaGFzTmF0aXZlUEUpIHtcclxuICAgICAgYXR0cmliMmNzcy5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcclxuICAgICAgICBpZiAoU3RyaW5nKHIpID09PSByKSB7XHJcbiAgICAgICAgICBzdHlsZXMgKz0gc2VsZWN0b3IocikgKyBydWxlKHIpICsgJ1xcbic7XHJcbiAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgICBzdHlsZXMgKz0gc2hhZG93U2VsZWN0b3IocikgKyBydWxlKHIpICsgJ1xcbic7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0eWxlcyArPSByLnNlbGVjdG9ycy5tYXAoc2VsZWN0b3IpICsgcnVsZShyLnJ1bGUpICsgJ1xcbic7XHJcbiAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdCkge1xyXG4gICAgICAgICAgICBzdHlsZXMgKz0gci5zZWxlY3RvcnMubWFwKHNoYWRvd1NlbGVjdG9yKSArIHJ1bGUoci5ydWxlKSArICdcXG4nO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcblxyXG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgICBlbC50ZXh0Q29udGVudCA9IHN0eWxlcztcclxuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlbCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgcG9pbnRlcm1hcCA9IGRpc3BhdGNoZXIucG9pbnRlcm1hcDtcclxuXHJcbiAgLy8gcmFkaXVzIGFyb3VuZCB0b3VjaGVuZCB0aGF0IHN3YWxsb3dzIG1vdXNlIGV2ZW50c1xyXG4gIHZhciBERURVUF9ESVNUID0gMjU7XHJcblxyXG4gIC8vIGxlZnQsIG1pZGRsZSwgcmlnaHQsIGJhY2ssIGZvcndhcmRcclxuICB2YXIgQlVUVE9OX1RPX0JVVFRPTlMgPSBbMSwgNCwgMiwgOCwgMTZdO1xyXG5cclxuICB2YXIgSEFTX0JVVFRPTlMgPSBmYWxzZTtcclxuICB0cnkge1xyXG4gICAgSEFTX0JVVFRPTlMgPSBuZXcgTW91c2VFdmVudCgndGVzdCcsIHsgYnV0dG9uczogMSB9KS5idXR0b25zID09PSAxO1xyXG4gIH0gY2F0Y2ggKGUpIHt9XHJcblxyXG4gIC8vIGhhbmRsZXIgYmxvY2sgZm9yIG5hdGl2ZSBtb3VzZSBldmVudHNcclxuICB2YXIgbW91c2VFdmVudHMgPSB7XHJcbiAgICBQT0lOVEVSX0lEOiAxLFxyXG4gICAgUE9JTlRFUl9UWVBFOiAnbW91c2UnLFxyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICdtb3VzZWRvd24nLFxyXG4gICAgICAnbW91c2Vtb3ZlJyxcclxuICAgICAgJ21vdXNldXAnLFxyXG4gICAgICAnbW91c2VvdmVyJyxcclxuICAgICAgJ21vdXNlb3V0J1xyXG4gICAgXSxcclxuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XHJcbiAgICB9LFxyXG4gICAgdW5yZWdpc3RlcjogZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XHJcbiAgICB9LFxyXG4gICAgbGFzdFRvdWNoZXM6IFtdLFxyXG5cclxuICAgIC8vIGNvbGxpZGUgd2l0aCB0aGUgZ2xvYmFsIG1vdXNlIGxpc3RlbmVyXHJcbiAgICBpc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIHZhciBsdHMgPSB0aGlzLmxhc3RUb3VjaGVzO1xyXG4gICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WDtcclxuICAgICAgdmFyIHkgPSBpbkV2ZW50LmNsaWVudFk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbHRzLmxlbmd0aCwgdDsgaSA8IGwgJiYgKHQgPSBsdHNbaV0pOyBpKyspIHtcclxuXHJcbiAgICAgICAgLy8gc2ltdWxhdGVkIG1vdXNlIGV2ZW50cyB3aWxsIGJlIHN3YWxsb3dlZCBuZWFyIGEgcHJpbWFyeSB0b3VjaGVuZFxyXG4gICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHggLSB0LngpO1xyXG4gICAgICAgIHZhciBkeSA9IE1hdGguYWJzKHkgLSB0LnkpO1xyXG4gICAgICAgIGlmIChkeCA8PSBERURVUF9ESVNUICYmIGR5IDw9IERFRFVQX0RJU1QpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIHByZXBhcmVFdmVudDogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICB2YXIgZSA9IGRpc3BhdGNoZXIuY2xvbmVFdmVudChpbkV2ZW50KTtcclxuXHJcbiAgICAgIC8vIGZvcndhcmQgbW91c2UgcHJldmVudERlZmF1bHRcclxuICAgICAgdmFyIHBkID0gZS5wcmV2ZW50RGVmYXVsdDtcclxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGluRXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICBwZCgpO1xyXG4gICAgICB9O1xyXG4gICAgICBlLnBvaW50ZXJJZCA9IHRoaXMuUE9JTlRFUl9JRDtcclxuICAgICAgZS5pc1ByaW1hcnkgPSB0cnVlO1xyXG4gICAgICBlLnBvaW50ZXJUeXBlID0gdGhpcy5QT0lOVEVSX1RZUEU7XHJcbiAgICAgIHJldHVybiBlO1xyXG4gICAgfSxcclxuICAgIHByZXBhcmVCdXR0b25zRm9yTW92ZTogZnVuY3Rpb24oZSwgaW5FdmVudCkge1xyXG4gICAgICB2YXIgcCA9IHBvaW50ZXJtYXAuZ2V0KHRoaXMuUE9JTlRFUl9JRCk7XHJcblxyXG4gICAgICAvLyBVcGRhdGUgYnV0dG9ucyBzdGF0ZSBhZnRlciBwb3NzaWJsZSBvdXQtb2YtZG9jdW1lbnQgbW91c2V1cC5cclxuICAgICAgaWYgKGluRXZlbnQud2hpY2ggPT09IDAgfHwgIXApIHtcclxuICAgICAgICBlLmJ1dHRvbnMgPSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGUuYnV0dG9ucyA9IHAuYnV0dG9ucztcclxuICAgICAgfVxyXG4gICAgICBpbkV2ZW50LmJ1dHRvbnMgPSBlLmJ1dHRvbnM7XHJcbiAgICB9LFxyXG4gICAgbW91c2Vkb3duOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoKGluRXZlbnQpKSB7XHJcbiAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmdldCh0aGlzLlBPSU5URVJfSUQpO1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XHJcbiAgICAgICAgaWYgKCFIQVNfQlVUVE9OUykge1xyXG4gICAgICAgICAgZS5idXR0b25zID0gQlVUVE9OX1RPX0JVVFRPTlNbZS5idXR0b25dO1xyXG4gICAgICAgICAgaWYgKHApIHsgZS5idXR0b25zIHw9IHAuYnV0dG9uczsgfVxyXG4gICAgICAgICAgaW5FdmVudC5idXR0b25zID0gZS5idXR0b25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2ludGVybWFwLnNldCh0aGlzLlBPSU5URVJfSUQsIGluRXZlbnQpO1xyXG4gICAgICAgIGlmICghcCB8fCBwLmJ1dHRvbnMgPT09IDApIHtcclxuICAgICAgICAgIGRpc3BhdGNoZXIuZG93bihlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5tb3ZlKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XHJcbiAgICAgICAgaWYgKCFIQVNfQlVUVE9OUykgeyB0aGlzLnByZXBhcmVCdXR0b25zRm9yTW92ZShlLCBpbkV2ZW50KTsgfVxyXG4gICAgICAgIGUuYnV0dG9uID0gLTE7XHJcbiAgICAgICAgcG9pbnRlcm1hcC5zZXQodGhpcy5QT0lOVEVSX0lELCBpbkV2ZW50KTtcclxuICAgICAgICBkaXNwYXRjaGVyLm1vdmUoZSk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBtb3VzZXVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoKGluRXZlbnQpKSB7XHJcbiAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmdldCh0aGlzLlBPSU5URVJfSUQpO1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XHJcbiAgICAgICAgaWYgKCFIQVNfQlVUVE9OUykge1xyXG4gICAgICAgICAgdmFyIHVwID0gQlVUVE9OX1RPX0JVVFRPTlNbZS5idXR0b25dO1xyXG5cclxuICAgICAgICAgIC8vIFByb2R1Y2VzIHdyb25nIHN0YXRlIG9mIGJ1dHRvbnMgaW4gQnJvd3NlcnMgd2l0aG91dCBgYnV0dG9uc2Agc3VwcG9ydFxyXG4gICAgICAgICAgLy8gd2hlbiBhIG1vdXNlIGJ1dHRvbiB0aGF0IHdhcyBwcmVzc2VkIG91dHNpZGUgdGhlIGRvY3VtZW50IGlzIHJlbGVhc2VkXHJcbiAgICAgICAgICAvLyBpbnNpZGUgYW5kIG90aGVyIGJ1dHRvbnMgYXJlIHN0aWxsIHByZXNzZWQgZG93bi5cclxuICAgICAgICAgIGUuYnV0dG9ucyA9IHAgPyBwLmJ1dHRvbnMgJiB+dXAgOiAwO1xyXG4gICAgICAgICAgaW5FdmVudC5idXR0b25zID0gZS5idXR0b25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2ludGVybWFwLnNldCh0aGlzLlBPSU5URVJfSUQsIGluRXZlbnQpO1xyXG5cclxuICAgICAgICAvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDQgb25seVxyXG4gICAgICAgIC8vIEZGIFVidW50dSBpbmNsdWRlcyB0aGUgbGlmdGVkIGJ1dHRvbiBpbiB0aGUgYGJ1dHRvbnNgIHByb3BlcnR5IG9uXHJcbiAgICAgICAgLy8gbW91c2V1cC5cclxuICAgICAgICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjIzMzY2XHJcbiAgICAgICAgZS5idXR0b25zICY9IH5CVVRUT05fVE9fQlVUVE9OU1tlLmJ1dHRvbl07XHJcbiAgICAgICAgaWYgKGUuYnV0dG9ucyA9PT0gMCkge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci51cChlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5tb3ZlKGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdXNlb3ZlcjogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xyXG4gICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XHJcbiAgICAgICAgaWYgKCFIQVNfQlVUVE9OUykgeyB0aGlzLnByZXBhcmVCdXR0b25zRm9yTW92ZShlLCBpbkV2ZW50KTsgfVxyXG4gICAgICAgIGUuYnV0dG9uID0gLTE7XHJcbiAgICAgICAgcG9pbnRlcm1hcC5zZXQodGhpcy5QT0lOVEVSX0lELCBpbkV2ZW50KTtcclxuICAgICAgICBkaXNwYXRjaGVyLmVudGVyT3ZlcihlKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdXNlb3V0OiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIGlmICghdGhpcy5pc0V2ZW50U2ltdWxhdGVkRnJvbVRvdWNoKGluRXZlbnQpKSB7XHJcbiAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcclxuICAgICAgICBpZiAoIUhBU19CVVRUT05TKSB7IHRoaXMucHJlcGFyZUJ1dHRvbnNGb3JNb3ZlKGUsIGluRXZlbnQpOyB9XHJcbiAgICAgICAgZS5idXR0b24gPSAtMTtcclxuICAgICAgICBkaXNwYXRjaGVyLmxlYXZlT3V0KGUpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XHJcbiAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGUpO1xyXG4gICAgICB0aGlzLmRlYWN0aXZhdGVNb3VzZSgpO1xyXG4gICAgfSxcclxuICAgIGRlYWN0aXZhdGVNb3VzZTogZnVuY3Rpb24oKSB7XHJcbiAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKHRoaXMuUE9JTlRFUl9JRCk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGNhcHR1cmVJbmZvID0gZGlzcGF0Y2hlci5jYXB0dXJlSW5mbztcclxuICB2YXIgZmluZFRhcmdldCA9IHRhcmdldGluZy5maW5kVGFyZ2V0LmJpbmQodGFyZ2V0aW5nKTtcclxuICB2YXIgYWxsU2hhZG93cyA9IHRhcmdldGluZy5hbGxTaGFkb3dzLmJpbmQodGFyZ2V0aW5nKTtcclxuICB2YXIgcG9pbnRlcm1hcCQxID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xyXG5cclxuICAvLyBUaGlzIHNob3VsZCBiZSBsb25nIGVub3VnaCB0byBpZ25vcmUgY29tcGF0IG1vdXNlIGV2ZW50cyBtYWRlIGJ5IHRvdWNoXHJcbiAgdmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xyXG4gIHZhciBDTElDS19DT1VOVF9USU1FT1VUID0gMjAwO1xyXG4gIHZhciBBVFRSSUIgPSAndG91Y2gtYWN0aW9uJztcclxuICB2YXIgSU5TVEFMTEVSO1xyXG5cclxuICAvLyBoYW5kbGVyIGJsb2NrIGZvciBuYXRpdmUgdG91Y2ggZXZlbnRzXHJcbiAgdmFyIHRvdWNoRXZlbnRzID0ge1xyXG4gICAgZXZlbnRzOiBbXHJcbiAgICAgICd0b3VjaHN0YXJ0JyxcclxuICAgICAgJ3RvdWNobW92ZScsXHJcbiAgICAgICd0b3VjaGVuZCcsXHJcbiAgICAgICd0b3VjaGNhbmNlbCdcclxuICAgIF0sXHJcbiAgICByZWdpc3RlcjogZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgIElOU1RBTExFUi5lbmFibGVPblN1YnRyZWUodGFyZ2V0KTtcclxuICAgIH0sXHJcbiAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgIC8vIFRPRE8oZGZyZWVkbWFuKTogaXMgaXQgd29ydGggaXQgdG8gZGlzY29ubmVjdCB0aGUgTU8/XHJcbiAgICB9LFxyXG4gICAgZWxlbWVudEFkZGVkOiBmdW5jdGlvbihlbCkge1xyXG4gICAgICB2YXIgYSA9IGVsLmdldEF0dHJpYnV0ZShBVFRSSUIpO1xyXG4gICAgICB2YXIgc3QgPSB0aGlzLnRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlKGEpO1xyXG4gICAgICBpZiAoc3QpIHtcclxuICAgICAgICBlbC5fc2Nyb2xsVHlwZSA9IHN0O1xyXG4gICAgICAgIGRpc3BhdGNoZXIubGlzdGVuKGVsLCB0aGlzLmV2ZW50cyk7XHJcblxyXG4gICAgICAgIC8vIHNldCB0b3VjaC1hY3Rpb24gb24gc2hhZG93cyBhcyB3ZWxsXHJcbiAgICAgICAgYWxsU2hhZG93cyhlbCkuZm9yRWFjaChmdW5jdGlvbihzKSB7XHJcbiAgICAgICAgICBzLl9zY3JvbGxUeXBlID0gc3Q7XHJcbiAgICAgICAgICBkaXNwYXRjaGVyLmxpc3RlbihzLCB0aGlzLmV2ZW50cyk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBlbGVtZW50UmVtb3ZlZDogZnVuY3Rpb24oZWwpIHtcclxuICAgICAgZWwuX3Njcm9sbFR5cGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4oZWwsIHRoaXMuZXZlbnRzKTtcclxuXHJcbiAgICAgIC8vIHJlbW92ZSB0b3VjaC1hY3Rpb24gZnJvbSBzaGFkb3dcclxuICAgICAgYWxsU2hhZG93cyhlbCkuZm9yRWFjaChmdW5jdGlvbihzKSB7XHJcbiAgICAgICAgcy5fc2Nyb2xsVHlwZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICBkaXNwYXRjaGVyLnVubGlzdGVuKHMsIHRoaXMuZXZlbnRzKTtcclxuICAgICAgfSwgdGhpcyk7XHJcbiAgICB9LFxyXG4gICAgZWxlbWVudENoYW5nZWQ6IGZ1bmN0aW9uKGVsLCBvbGRWYWx1ZSkge1xyXG4gICAgICB2YXIgYSA9IGVsLmdldEF0dHJpYnV0ZShBVFRSSUIpO1xyXG4gICAgICB2YXIgc3QgPSB0aGlzLnRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlKGEpO1xyXG4gICAgICB2YXIgb2xkU3QgPSB0aGlzLnRvdWNoQWN0aW9uVG9TY3JvbGxUeXBlKG9sZFZhbHVlKTtcclxuXHJcbiAgICAgIC8vIHNpbXBseSB1cGRhdGUgc2Nyb2xsVHlwZSBpZiBsaXN0ZW5lcnMgYXJlIGFscmVhZHkgZXN0YWJsaXNoZWRcclxuICAgICAgaWYgKHN0ICYmIG9sZFN0KSB7XHJcbiAgICAgICAgZWwuX3Njcm9sbFR5cGUgPSBzdDtcclxuICAgICAgICBhbGxTaGFkb3dzKGVsKS5mb3JFYWNoKGZ1bmN0aW9uKHMpIHtcclxuICAgICAgICAgIHMuX3Njcm9sbFR5cGUgPSBzdDtcclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgfSBlbHNlIGlmIChvbGRTdCkge1xyXG4gICAgICAgIHRoaXMuZWxlbWVudFJlbW92ZWQoZWwpO1xyXG4gICAgICB9IGVsc2UgaWYgKHN0KSB7XHJcbiAgICAgICAgdGhpcy5lbGVtZW50QWRkZWQoZWwpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgc2Nyb2xsVHlwZXM6IHtcclxuICAgICAgRU1JVFRFUjogJ25vbmUnLFxyXG4gICAgICBYU0NST0xMRVI6ICdwYW4teCcsXHJcbiAgICAgIFlTQ1JPTExFUjogJ3Bhbi15JyxcclxuICAgICAgU0NST0xMRVI6IC9eKD86cGFuLXggcGFuLXkpfCg/OnBhbi15IHBhbi14KXxhdXRvJC9cclxuICAgIH0sXHJcbiAgICB0b3VjaEFjdGlvblRvU2Nyb2xsVHlwZTogZnVuY3Rpb24odG91Y2hBY3Rpb24pIHtcclxuICAgICAgdmFyIHQgPSB0b3VjaEFjdGlvbjtcclxuICAgICAgdmFyIHN0ID0gdGhpcy5zY3JvbGxUeXBlcztcclxuICAgICAgaWYgKHQgPT09ICdub25lJykge1xyXG4gICAgICAgIHJldHVybiAnbm9uZSc7XHJcbiAgICAgIH0gZWxzZSBpZiAodCA9PT0gc3QuWFNDUk9MTEVSKSB7XHJcbiAgICAgICAgcmV0dXJuICdYJztcclxuICAgICAgfSBlbHNlIGlmICh0ID09PSBzdC5ZU0NST0xMRVIpIHtcclxuICAgICAgICByZXR1cm4gJ1knO1xyXG4gICAgICB9IGVsc2UgaWYgKHN0LlNDUk9MTEVSLmV4ZWModCkpIHtcclxuICAgICAgICByZXR1cm4gJ1hZJztcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIFBPSU5URVJfVFlQRTogJ3RvdWNoJyxcclxuICAgIGZpcnN0VG91Y2g6IG51bGwsXHJcbiAgICBpc1ByaW1hcnlUb3VjaDogZnVuY3Rpb24oaW5Ub3VjaCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5maXJzdFRvdWNoID09PSBpblRvdWNoLmlkZW50aWZpZXI7XHJcbiAgICB9LFxyXG4gICAgc2V0UHJpbWFyeVRvdWNoOiBmdW5jdGlvbihpblRvdWNoKSB7XHJcblxyXG4gICAgICAvLyBzZXQgcHJpbWFyeSB0b3VjaCBpZiB0aGVyZSBubyBwb2ludGVycywgb3IgdGhlIG9ubHkgcG9pbnRlciBpcyB0aGUgbW91c2VcclxuICAgICAgaWYgKHBvaW50ZXJtYXAkMS5zaXplID09PSAwIHx8IChwb2ludGVybWFwJDEuc2l6ZSA9PT0gMSAmJiBwb2ludGVybWFwJDEuaGFzKDEpKSkge1xyXG4gICAgICAgIHRoaXMuZmlyc3RUb3VjaCA9IGluVG91Y2guaWRlbnRpZmllcjtcclxuICAgICAgICB0aGlzLmZpcnN0WFkgPSB7IFg6IGluVG91Y2guY2xpZW50WCwgWTogaW5Ub3VjaC5jbGllbnRZIH07XHJcbiAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNhbmNlbFJlc2V0Q2xpY2tDb3VudCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlUHJpbWFyeVBvaW50ZXI6IGZ1bmN0aW9uKGluUG9pbnRlcikge1xyXG4gICAgICBpZiAoaW5Qb2ludGVyLmlzUHJpbWFyeSkge1xyXG4gICAgICAgIHRoaXMuZmlyc3RUb3VjaCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5maXJzdFhZID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJlc2V0Q2xpY2tDb3VudCgpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgY2xpY2tDb3VudDogMCxcclxuICAgIHJlc2V0SWQ6IG51bGwsXHJcbiAgICByZXNldENsaWNrQ291bnQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNsaWNrQ291bnQgPSAwO1xyXG4gICAgICAgIHRoaXMucmVzZXRJZCA9IG51bGw7XHJcbiAgICAgIH0uYmluZCh0aGlzKTtcclxuICAgICAgdGhpcy5yZXNldElkID0gc2V0VGltZW91dChmbiwgQ0xJQ0tfQ09VTlRfVElNRU9VVCk7XHJcbiAgICB9LFxyXG4gICAgY2FuY2VsUmVzZXRDbGlja0NvdW50OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKHRoaXMucmVzZXRJZCkge1xyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlc2V0SWQpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdHlwZVRvQnV0dG9uczogZnVuY3Rpb24odHlwZSkge1xyXG4gICAgICB2YXIgcmV0ID0gMDtcclxuICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJykge1xyXG4gICAgICAgIHJldCA9IDE7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0sXHJcbiAgICB0b3VjaFRvUG9pbnRlcjogZnVuY3Rpb24oaW5Ub3VjaCkge1xyXG4gICAgICB2YXIgY3RlID0gdGhpcy5jdXJyZW50VG91Y2hFdmVudDtcclxuICAgICAgdmFyIGUgPSBkaXNwYXRjaGVyLmNsb25lRXZlbnQoaW5Ub3VjaCk7XHJcblxyXG4gICAgICAvLyBXZSByZXNlcnZlIHBvaW50ZXJJZCAxIGZvciBNb3VzZS5cclxuICAgICAgLy8gVG91Y2ggaWRlbnRpZmllcnMgY2FuIHN0YXJ0IGF0IDAuXHJcbiAgICAgIC8vIEFkZCAyIHRvIHRoZSB0b3VjaCBpZGVudGlmaWVyIGZvciBjb21wYXRpYmlsaXR5LlxyXG4gICAgICB2YXIgaWQgPSBlLnBvaW50ZXJJZCA9IGluVG91Y2guaWRlbnRpZmllciArIDI7XHJcbiAgICAgIGUudGFyZ2V0ID0gY2FwdHVyZUluZm9baWRdIHx8IGZpbmRUYXJnZXQoZSk7XHJcbiAgICAgIGUuYnViYmxlcyA9IHRydWU7XHJcbiAgICAgIGUuY2FuY2VsYWJsZSA9IHRydWU7XHJcbiAgICAgIGUuZGV0YWlsID0gdGhpcy5jbGlja0NvdW50O1xyXG4gICAgICBlLmJ1dHRvbiA9IDA7XHJcbiAgICAgIGUuYnV0dG9ucyA9IHRoaXMudHlwZVRvQnV0dG9ucyhjdGUudHlwZSk7XHJcbiAgICAgIGUud2lkdGggPSBpblRvdWNoLnJhZGl1c1ggfHwgaW5Ub3VjaC53ZWJraXRSYWRpdXNYIHx8IDA7XHJcbiAgICAgIGUuaGVpZ2h0ID0gaW5Ub3VjaC5yYWRpdXNZIHx8IGluVG91Y2gud2Via2l0UmFkaXVzWSB8fCAwO1xyXG4gICAgICBlLnByZXNzdXJlID0gaW5Ub3VjaC5mb3JjZSB8fCBpblRvdWNoLndlYmtpdEZvcmNlIHx8IDAuNTtcclxuICAgICAgZS5pc1ByaW1hcnkgPSB0aGlzLmlzUHJpbWFyeVRvdWNoKGluVG91Y2gpO1xyXG4gICAgICBlLnBvaW50ZXJUeXBlID0gdGhpcy5QT0lOVEVSX1RZUEU7XHJcblxyXG4gICAgICAvLyBmb3J3YXJkIG1vZGlmaWVyIGtleXNcclxuICAgICAgZS5hbHRLZXkgPSBjdGUuYWx0S2V5O1xyXG4gICAgICBlLmN0cmxLZXkgPSBjdGUuY3RybEtleTtcclxuICAgICAgZS5tZXRhS2V5ID0gY3RlLm1ldGFLZXk7XHJcbiAgICAgIGUuc2hpZnRLZXkgPSBjdGUuc2hpZnRLZXk7XHJcblxyXG4gICAgICAvLyBmb3J3YXJkIHRvdWNoIHByZXZlbnREZWZhdWx0c1xyXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XHJcbiAgICAgIGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzZWxmLnNjcm9sbGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHNlbGYuZmlyc3RYWSA9IG51bGw7XHJcbiAgICAgICAgY3RlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiBlO1xyXG4gICAgfSxcclxuICAgIHByb2Nlc3NUb3VjaGVzOiBmdW5jdGlvbihpbkV2ZW50LCBpbkZ1bmN0aW9uKSB7XHJcbiAgICAgIHZhciB0bCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXM7XHJcbiAgICAgIHRoaXMuY3VycmVudFRvdWNoRXZlbnQgPSBpbkV2ZW50O1xyXG4gICAgICBmb3IgKHZhciBpID0gMCwgdDsgaSA8IHRsLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgdCA9IHRsW2ldO1xyXG4gICAgICAgIGluRnVuY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnRvdWNoVG9Qb2ludGVyKHQpKTtcclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBGb3Igc2luZ2xlIGF4aXMgc2Nyb2xsZXJzLCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGVsZW1lbnQgc2hvdWxkIGVtaXRcclxuICAgIC8vIHBvaW50ZXIgZXZlbnRzIG9yIGJlaGF2ZSBhcyBhIHNjcm9sbGVyXHJcbiAgICBzaG91bGRTY3JvbGw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcclxuICAgICAgaWYgKHRoaXMuZmlyc3RYWSkge1xyXG4gICAgICAgIHZhciByZXQ7XHJcbiAgICAgICAgdmFyIHNjcm9sbEF4aXMgPSBpbkV2ZW50LmN1cnJlbnRUYXJnZXQuX3Njcm9sbFR5cGU7XHJcbiAgICAgICAgaWYgKHNjcm9sbEF4aXMgPT09ICdub25lJykge1xyXG5cclxuICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBpcyBhIHRvdWNoLWFjdGlvbjogbm9uZSwgc2hvdWxkIG5ldmVyIHNjcm9sbFxyXG4gICAgICAgICAgcmV0ID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxBeGlzID09PSAnWFknKSB7XHJcblxyXG4gICAgICAgICAgLy8gdGhpcyBlbGVtZW50IHNob3VsZCBhbHdheXMgc2Nyb2xsXHJcbiAgICAgICAgICByZXQgPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB2YXIgdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblxyXG4gICAgICAgICAgLy8gY2hlY2sgdGhlIGludGVuZGVkIHNjcm9sbCBheGlzLCBhbmQgb3RoZXIgYXhpc1xyXG4gICAgICAgICAgdmFyIGEgPSBzY3JvbGxBeGlzO1xyXG4gICAgICAgICAgdmFyIG9hID0gc2Nyb2xsQXhpcyA9PT0gJ1knID8gJ1gnIDogJ1knO1xyXG4gICAgICAgICAgdmFyIGRhID0gTWF0aC5hYnModFsnY2xpZW50JyArIGFdIC0gdGhpcy5maXJzdFhZW2FdKTtcclxuICAgICAgICAgIHZhciBkb2EgPSBNYXRoLmFicyh0WydjbGllbnQnICsgb2FdIC0gdGhpcy5maXJzdFhZW29hXSk7XHJcblxyXG4gICAgICAgICAgLy8gaWYgZGVsdGEgaW4gdGhlIHNjcm9sbCBheGlzID4gZGVsdGEgb3RoZXIgYXhpcywgc2Nyb2xsIGluc3RlYWQgb2ZcclxuICAgICAgICAgIC8vIG1ha2luZyBldmVudHNcclxuICAgICAgICAgIHJldCA9IGRhID49IGRvYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5maXJzdFhZID0gbnVsbDtcclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgZmluZFRvdWNoOiBmdW5jdGlvbihpblRMLCBpbklkKSB7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaW5UTC5sZW5ndGgsIHQ7IGkgPCBsICYmICh0ID0gaW5UTFtpXSk7IGkrKykge1xyXG4gICAgICAgIGlmICh0LmlkZW50aWZpZXIgPT09IGluSWQpIHtcclxuICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICAvLyBJbiBzb21lIGluc3RhbmNlcywgYSB0b3VjaHN0YXJ0IGNhbiBoYXBwZW4gd2l0aG91dCBhIHRvdWNoZW5kLiBUaGlzXHJcbiAgICAvLyBsZWF2ZXMgdGhlIHBvaW50ZXJtYXAgaW4gYSBicm9rZW4gc3RhdGUuXHJcbiAgICAvLyBUaGVyZWZvcmUsIG9uIGV2ZXJ5IHRvdWNoc3RhcnQsIHdlIHJlbW92ZSB0aGUgdG91Y2hlcyB0aGF0IGRpZCBub3QgZmlyZSBhXHJcbiAgICAvLyB0b3VjaGVuZCBldmVudC5cclxuICAgIC8vIFRvIGtlZXAgc3RhdGUgZ2xvYmFsbHkgY29uc2lzdGVudCwgd2UgZmlyZSBhXHJcbiAgICAvLyBwb2ludGVyY2FuY2VsIGZvciB0aGlzIFwiYWJhbmRvbmVkXCIgdG91Y2hcclxuICAgIHZhY3V1bVRvdWNoZXM6IGZ1bmN0aW9uKGluRXZlbnQpIHtcclxuICAgICAgdmFyIHRsID0gaW5FdmVudC50b3VjaGVzO1xyXG5cclxuICAgICAgLy8gcG9pbnRlcm1hcC5zaXplIHNob3VsZCBiZSA8IHRsLmxlbmd0aCBoZXJlLCBhcyB0aGUgdG91Y2hzdGFydCBoYXMgbm90XHJcbiAgICAgIC8vIGJlZW4gcHJvY2Vzc2VkIHlldC5cclxuICAgICAgaWYgKHBvaW50ZXJtYXAkMS5zaXplID49IHRsLmxlbmd0aCkge1xyXG4gICAgICAgIHZhciBkID0gW107XHJcbiAgICAgICAgcG9pbnRlcm1hcCQxLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xyXG5cclxuICAgICAgICAgIC8vIE5ldmVyIHJlbW92ZSBwb2ludGVySWQgPT0gMSwgd2hpY2ggaXMgbW91c2UuXHJcbiAgICAgICAgICAvLyBUb3VjaCBpZGVudGlmaWVycyBhcmUgMiBzbWFsbGVyIHRoYW4gdGhlaXIgcG9pbnRlcklkLCB3aGljaCBpcyB0aGVcclxuICAgICAgICAgIC8vIGluZGV4IGluIHBvaW50ZXJtYXAuXHJcbiAgICAgICAgICBpZiAoa2V5ICE9PSAxICYmICF0aGlzLmZpbmRUb3VjaCh0bCwga2V5IC0gMikpIHtcclxuICAgICAgICAgICAgdmFyIHAgPSB2YWx1ZS5vdXQ7XHJcbiAgICAgICAgICAgIGQucHVzaChwKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB0aGlzKTtcclxuICAgICAgICBkLmZvckVhY2godGhpcy5jYW5jZWxPdXQsIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgdG91Y2hzdGFydDogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICB0aGlzLnZhY3V1bVRvdWNoZXMoaW5FdmVudCk7XHJcbiAgICAgIHRoaXMuc2V0UHJpbWFyeVRvdWNoKGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pO1xyXG4gICAgICB0aGlzLmRlZHVwU3ludGhNb3VzZShpbkV2ZW50KTtcclxuICAgICAgaWYgKCF0aGlzLnNjcm9sbGluZykge1xyXG4gICAgICAgIHRoaXMuY2xpY2tDb3VudCsrO1xyXG4gICAgICAgIHRoaXMucHJvY2Vzc1RvdWNoZXMoaW5FdmVudCwgdGhpcy5vdmVyRG93bik7XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICBvdmVyRG93bjogZnVuY3Rpb24oaW5Qb2ludGVyKSB7XHJcbiAgICAgIHBvaW50ZXJtYXAkMS5zZXQoaW5Qb2ludGVyLnBvaW50ZXJJZCwge1xyXG4gICAgICAgIHRhcmdldDogaW5Qb2ludGVyLnRhcmdldCxcclxuICAgICAgICBvdXQ6IGluUG9pbnRlcixcclxuICAgICAgICBvdXRUYXJnZXQ6IGluUG9pbnRlci50YXJnZXRcclxuICAgICAgfSk7XHJcbiAgICAgIGRpc3BhdGNoZXIuZW50ZXJPdmVyKGluUG9pbnRlcik7XHJcbiAgICAgIGRpc3BhdGNoZXIuZG93bihpblBvaW50ZXIpO1xyXG4gICAgfSxcclxuICAgIHRvdWNobW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICBpZiAoIXRoaXMuc2Nyb2xsaW5nKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkU2Nyb2xsKGluRXZlbnQpKSB7XHJcbiAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IHRydWU7XHJcbiAgICAgICAgICB0aGlzLnRvdWNoY2FuY2VsKGluRXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbkV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMubW92ZU92ZXJPdXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIG1vdmVPdmVyT3V0OiBmdW5jdGlvbihpblBvaW50ZXIpIHtcclxuICAgICAgdmFyIGV2ZW50ID0gaW5Qb2ludGVyO1xyXG4gICAgICB2YXIgcG9pbnRlciA9IHBvaW50ZXJtYXAkMS5nZXQoZXZlbnQucG9pbnRlcklkKTtcclxuXHJcbiAgICAgIC8vIGEgZmluZ2VyIGRyaWZ0ZWQgb2ZmIHRoZSBzY3JlZW4sIGlnbm9yZSBpdFxyXG4gICAgICBpZiAoIXBvaW50ZXIpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdmFyIG91dEV2ZW50ID0gcG9pbnRlci5vdXQ7XHJcbiAgICAgIHZhciBvdXRUYXJnZXQgPSBwb2ludGVyLm91dFRhcmdldDtcclxuICAgICAgZGlzcGF0Y2hlci5tb3ZlKGV2ZW50KTtcclxuICAgICAgaWYgKG91dEV2ZW50ICYmIG91dFRhcmdldCAhPT0gZXZlbnQudGFyZ2V0KSB7XHJcbiAgICAgICAgb3V0RXZlbnQucmVsYXRlZFRhcmdldCA9IGV2ZW50LnRhcmdldDtcclxuICAgICAgICBldmVudC5yZWxhdGVkVGFyZ2V0ID0gb3V0VGFyZ2V0O1xyXG5cclxuICAgICAgICAvLyByZWNvdmVyIGZyb20gcmV0YXJnZXRpbmcgYnkgc2hhZG93XHJcbiAgICAgICAgb3V0RXZlbnQudGFyZ2V0ID0gb3V0VGFyZ2V0O1xyXG4gICAgICAgIGlmIChldmVudC50YXJnZXQpIHtcclxuICAgICAgICAgIGRpc3BhdGNoZXIubGVhdmVPdXQob3V0RXZlbnQpO1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5lbnRlck92ZXIoZXZlbnQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gY2xlYW4gdXAgY2FzZSB3aGVuIGZpbmdlciBsZWF2ZXMgdGhlIHNjcmVlblxyXG4gICAgICAgICAgZXZlbnQudGFyZ2V0ID0gb3V0VGFyZ2V0O1xyXG4gICAgICAgICAgZXZlbnQucmVsYXRlZFRhcmdldCA9IG51bGw7XHJcbiAgICAgICAgICB0aGlzLmNhbmNlbE91dChldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHBvaW50ZXIub3V0ID0gZXZlbnQ7XHJcbiAgICAgIHBvaW50ZXIub3V0VGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgfSxcclxuICAgIHRvdWNoZW5kOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIHRoaXMuZGVkdXBTeW50aE1vdXNlKGluRXZlbnQpO1xyXG4gICAgICB0aGlzLnByb2Nlc3NUb3VjaGVzKGluRXZlbnQsIHRoaXMudXBPdXQpO1xyXG4gICAgfSxcclxuICAgIHVwT3V0OiBmdW5jdGlvbihpblBvaW50ZXIpIHtcclxuICAgICAgaWYgKCF0aGlzLnNjcm9sbGluZykge1xyXG4gICAgICAgIGRpc3BhdGNoZXIudXAoaW5Qb2ludGVyKTtcclxuICAgICAgICBkaXNwYXRjaGVyLmxlYXZlT3V0KGluUG9pbnRlcik7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5jbGVhblVwUG9pbnRlcihpblBvaW50ZXIpO1xyXG4gICAgfSxcclxuICAgIHRvdWNoY2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIHRoaXMucHJvY2Vzc1RvdWNoZXMoaW5FdmVudCwgdGhpcy5jYW5jZWxPdXQpO1xyXG4gICAgfSxcclxuICAgIGNhbmNlbE91dDogZnVuY3Rpb24oaW5Qb2ludGVyKSB7XHJcbiAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGluUG9pbnRlcik7XHJcbiAgICAgIGRpc3BhdGNoZXIubGVhdmVPdXQoaW5Qb2ludGVyKTtcclxuICAgICAgdGhpcy5jbGVhblVwUG9pbnRlcihpblBvaW50ZXIpO1xyXG4gICAgfSxcclxuICAgIGNsZWFuVXBQb2ludGVyOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcclxuICAgICAgcG9pbnRlcm1hcCQxLmRlbGV0ZShpblBvaW50ZXIucG9pbnRlcklkKTtcclxuICAgICAgdGhpcy5yZW1vdmVQcmltYXJ5UG9pbnRlcihpblBvaW50ZXIpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvLyBwcmV2ZW50IHN5bnRoIG1vdXNlIGV2ZW50cyBmcm9tIGNyZWF0aW5nIHBvaW50ZXIgZXZlbnRzXHJcbiAgICBkZWR1cFN5bnRoTW91c2U6IGZ1bmN0aW9uKGluRXZlbnQpIHtcclxuICAgICAgdmFyIGx0cyA9IG1vdXNlRXZlbnRzLmxhc3RUb3VjaGVzO1xyXG4gICAgICB2YXIgdCA9IGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF07XHJcblxyXG4gICAgICAvLyBvbmx5IHRoZSBwcmltYXJ5IGZpbmdlciB3aWxsIHN5bnRoIG1vdXNlIGV2ZW50c1xyXG4gICAgICBpZiAodGhpcy5pc1ByaW1hcnlUb3VjaCh0KSkge1xyXG5cclxuICAgICAgICAvLyByZW1lbWJlciB4L3kgb2YgbGFzdCB0b3VjaFxyXG4gICAgICAgIHZhciBsdCA9IHsgeDogdC5jbGllbnRYLCB5OiB0LmNsaWVudFkgfTtcclxuICAgICAgICBsdHMucHVzaChsdCk7XHJcbiAgICAgICAgdmFyIGZuID0gKGZ1bmN0aW9uKGx0cywgbHQpIHtcclxuICAgICAgICAgIHZhciBpID0gbHRzLmluZGV4T2YobHQpO1xyXG4gICAgICAgICAgaWYgKGkgPiAtMSkge1xyXG4gICAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pLmJpbmQobnVsbCwgbHRzLCBsdCk7XHJcbiAgICAgICAgc2V0VGltZW91dChmbiwgREVEVVBfVElNRU9VVCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG5cclxuICBJTlNUQUxMRVIgPSBuZXcgSW5zdGFsbGVyKHRvdWNoRXZlbnRzLmVsZW1lbnRBZGRlZCwgdG91Y2hFdmVudHMuZWxlbWVudFJlbW92ZWQsXHJcbiAgICB0b3VjaEV2ZW50cy5lbGVtZW50Q2hhbmdlZCwgdG91Y2hFdmVudHMpO1xyXG5cclxuICB2YXIgcG9pbnRlcm1hcCQyID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xyXG4gIHZhciBIQVNfQklUTUFQX1RZUEUgPSB3aW5kb3cuTVNQb2ludGVyRXZlbnQgJiZcclxuICAgIHR5cGVvZiB3aW5kb3cuTVNQb2ludGVyRXZlbnQuTVNQT0lOVEVSX1RZUEVfTU9VU0UgPT09ICdudW1iZXInO1xyXG4gIHZhciBtc0V2ZW50cyA9IHtcclxuICAgIGV2ZW50czogW1xyXG4gICAgICAnTVNQb2ludGVyRG93bicsXHJcbiAgICAgICdNU1BvaW50ZXJNb3ZlJyxcclxuICAgICAgJ01TUG9pbnRlclVwJyxcclxuICAgICAgJ01TUG9pbnRlck91dCcsXHJcbiAgICAgICdNU1BvaW50ZXJPdmVyJyxcclxuICAgICAgJ01TUG9pbnRlckNhbmNlbCcsXHJcbiAgICAgICdNU0dvdFBvaW50ZXJDYXB0dXJlJyxcclxuICAgICAgJ01TTG9zdFBvaW50ZXJDYXB0dXJlJ1xyXG4gICAgXSxcclxuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcclxuICAgICAgZGlzcGF0Y2hlci5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XHJcbiAgICB9LFxyXG4gICAgdW5yZWdpc3RlcjogZnVuY3Rpb24odGFyZ2V0KSB7XHJcbiAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XHJcbiAgICB9LFxyXG4gICAgUE9JTlRFUl9UWVBFUzogW1xyXG4gICAgICAnJyxcclxuICAgICAgJ3VuYXZhaWxhYmxlJyxcclxuICAgICAgJ3RvdWNoJyxcclxuICAgICAgJ3BlbicsXHJcbiAgICAgICdtb3VzZSdcclxuICAgIF0sXHJcbiAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcclxuICAgICAgdmFyIGUgPSBpbkV2ZW50O1xyXG4gICAgICBpZiAoSEFTX0JJVE1BUF9UWVBFKSB7XHJcbiAgICAgICAgZSA9IGRpc3BhdGNoZXIuY2xvbmVFdmVudChpbkV2ZW50KTtcclxuICAgICAgICBlLnBvaW50ZXJUeXBlID0gdGhpcy5QT0lOVEVSX1RZUEVTW2luRXZlbnQucG9pbnRlclR5cGVdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBlO1xyXG4gICAgfSxcclxuICAgIGNsZWFudXA6IGZ1bmN0aW9uKGlkKSB7XHJcbiAgICAgIHBvaW50ZXJtYXAkMi5kZWxldGUoaWQpO1xyXG4gICAgfSxcclxuICAgIE1TUG9pbnRlckRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcclxuICAgICAgcG9pbnRlcm1hcCQyLnNldChpbkV2ZW50LnBvaW50ZXJJZCwgaW5FdmVudCk7XHJcbiAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XHJcbiAgICAgIGRpc3BhdGNoZXIuZG93bihlKTtcclxuICAgIH0sXHJcbiAgICBNU1BvaW50ZXJNb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XHJcbiAgICAgIGRpc3BhdGNoZXIubW92ZShlKTtcclxuICAgIH0sXHJcbiAgICBNU1BvaW50ZXJVcDogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xyXG4gICAgICBkaXNwYXRjaGVyLnVwKGUpO1xyXG4gICAgICB0aGlzLmNsZWFudXAoaW5FdmVudC5wb2ludGVySWQpO1xyXG4gICAgfSxcclxuICAgIE1TUG9pbnRlck91dDogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xyXG4gICAgICBkaXNwYXRjaGVyLmxlYXZlT3V0KGUpO1xyXG4gICAgfSxcclxuICAgIE1TUG9pbnRlck92ZXI6IGZ1bmN0aW9uKGluRXZlbnQpIHtcclxuICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcclxuICAgICAgZGlzcGF0Y2hlci5lbnRlck92ZXIoZSk7XHJcbiAgICB9LFxyXG4gICAgTVNQb2ludGVyQ2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XHJcbiAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGUpO1xyXG4gICAgICB0aGlzLmNsZWFudXAoaW5FdmVudC5wb2ludGVySWQpO1xyXG4gICAgfSxcclxuICAgIE1TTG9zdFBvaW50ZXJDYXB0dXJlOiBmdW5jdGlvbihpbkV2ZW50KSB7XHJcbiAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5tYWtlRXZlbnQoJ2xvc3Rwb2ludGVyY2FwdHVyZScsIGluRXZlbnQpO1xyXG4gICAgICBkaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoZSk7XHJcbiAgICB9LFxyXG4gICAgTVNHb3RQb2ludGVyQ2FwdHVyZTogZnVuY3Rpb24oaW5FdmVudCkge1xyXG4gICAgICB2YXIgZSA9IGRpc3BhdGNoZXIubWFrZUV2ZW50KCdnb3Rwb2ludGVyY2FwdHVyZScsIGluRXZlbnQpO1xyXG4gICAgICBkaXNwYXRjaGVyLmRpc3BhdGNoRXZlbnQoZSk7XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gYXBwbHlQb2x5ZmlsbCgpIHtcclxuXHJcbiAgICAvLyBvbmx5IGFjdGl2YXRlIGlmIHRoaXMgcGxhdGZvcm0gZG9lcyBub3QgaGF2ZSBwb2ludGVyIGV2ZW50c1xyXG4gICAgaWYgKCF3aW5kb3cuUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgIHdpbmRvdy5Qb2ludGVyRXZlbnQgPSBQb2ludGVyRXZlbnQ7XHJcblxyXG4gICAgICBpZiAod2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XHJcbiAgICAgICAgdmFyIHRwID0gd2luZG93Lm5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzO1xyXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cubmF2aWdhdG9yLCAnbWF4VG91Y2hQb2ludHMnLCB7XHJcbiAgICAgICAgICB2YWx1ZTogdHAsXHJcbiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5yZWdpc3RlclNvdXJjZSgnbXMnLCBtc0V2ZW50cyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZGlzcGF0Y2hlci5yZWdpc3RlclNvdXJjZSgnbW91c2UnLCBtb3VzZUV2ZW50cyk7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgZGlzcGF0Y2hlci5yZWdpc3RlclNvdXJjZSgndG91Y2gnLCB0b3VjaEV2ZW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyKGRvY3VtZW50KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBuID0gd2luZG93Lm5hdmlnYXRvcjtcclxuICB2YXIgcztcclxuICB2YXIgcjtcclxuICBmdW5jdGlvbiBhc3NlcnRBY3RpdmUoaWQpIHtcclxuICAgIGlmICghZGlzcGF0Y2hlci5wb2ludGVybWFwLmhhcyhpZCkpIHtcclxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkUG9pbnRlcklkJyk7XHJcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YWxpZFBvaW50ZXJJZCc7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBhc3NlcnRDb25uZWN0ZWQoZWxlbSkge1xyXG4gICAgaWYgKCFlbGVtLm93bmVyRG9jdW1lbnQuY29udGFpbnMoZWxlbSkpIHtcclxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcicpO1xyXG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFsaWRTdGF0ZUVycm9yJztcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGluQWN0aXZlQnV0dG9uU3RhdGUoaWQpIHtcclxuICAgIHZhciBwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwLmdldChpZCk7XHJcbiAgICByZXR1cm4gcC5idXR0b25zICE9PSAwO1xyXG4gIH1cclxuICBpZiAobi5tc1BvaW50ZXJFbmFibGVkKSB7XHJcbiAgICBzID0gZnVuY3Rpb24ocG9pbnRlcklkKSB7XHJcbiAgICAgIGFzc2VydEFjdGl2ZShwb2ludGVySWQpO1xyXG4gICAgICBhc3NlcnRDb25uZWN0ZWQodGhpcyk7XHJcbiAgICAgIGlmIChpbkFjdGl2ZUJ1dHRvblN0YXRlKHBvaW50ZXJJZCkpIHtcclxuICAgICAgICB0aGlzLm1zU2V0UG9pbnRlckNhcHR1cmUocG9pbnRlcklkKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHIgPSBmdW5jdGlvbihwb2ludGVySWQpIHtcclxuICAgICAgYXNzZXJ0QWN0aXZlKHBvaW50ZXJJZCk7XHJcbiAgICAgIHRoaXMubXNSZWxlYXNlUG9pbnRlckNhcHR1cmUocG9pbnRlcklkKTtcclxuICAgIH07XHJcbiAgfSBlbHNlIHtcclxuICAgIHMgPSBmdW5jdGlvbiBzZXRQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpIHtcclxuICAgICAgYXNzZXJ0QWN0aXZlKHBvaW50ZXJJZCk7XHJcbiAgICAgIGFzc2VydENvbm5lY3RlZCh0aGlzKTtcclxuICAgICAgaWYgKGluQWN0aXZlQnV0dG9uU3RhdGUocG9pbnRlcklkKSkge1xyXG4gICAgICAgIGRpc3BhdGNoZXIuc2V0Q2FwdHVyZShwb2ludGVySWQsIHRoaXMpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gICAgciA9IGZ1bmN0aW9uIHJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpIHtcclxuICAgICAgYXNzZXJ0QWN0aXZlKHBvaW50ZXJJZCk7XHJcbiAgICAgIGRpc3BhdGNoZXIucmVsZWFzZUNhcHR1cmUocG9pbnRlcklkLCB0aGlzKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBhcHBseVBvbHlmaWxsJDEoKSB7XHJcbiAgICBpZiAod2luZG93LkVsZW1lbnQgJiYgIUVsZW1lbnQucHJvdG90eXBlLnNldFBvaW50ZXJDYXB0dXJlKSB7XHJcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEVsZW1lbnQucHJvdG90eXBlLCB7XHJcbiAgICAgICAgJ3NldFBvaW50ZXJDYXB0dXJlJzoge1xyXG4gICAgICAgICAgdmFsdWU6IHNcclxuICAgICAgICB9LFxyXG4gICAgICAgICdyZWxlYXNlUG9pbnRlckNhcHR1cmUnOiB7XHJcbiAgICAgICAgICB2YWx1ZTogclxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhcHBseUF0dHJpYnV0ZVN0eWxlcygpO1xyXG4gIGFwcGx5UG9seWZpbGwoKTtcclxuICBhcHBseVBvbHlmaWxsJDEoKTtcclxuXHJcbiAgdmFyIHBvaW50ZXJldmVudHMgPSB7XHJcbiAgICBkaXNwYXRjaGVyOiBkaXNwYXRjaGVyLFxyXG4gICAgSW5zdGFsbGVyOiBJbnN0YWxsZXIsXHJcbiAgICBQb2ludGVyRXZlbnQ6IFBvaW50ZXJFdmVudCxcclxuICAgIFBvaW50ZXJNYXA6IFBvaW50ZXJNYXAsXHJcbiAgICB0YXJnZXRGaW5kaW5nOiB0YXJnZXRpbmdcclxuICB9O1xyXG5cclxuICByZXR1cm4gcG9pbnRlcmV2ZW50cztcclxuXHJcbn0pKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9wZXBqcy9kaXN0L3BlcC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcGVwanMvZGlzdC9wZXAuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwidmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xuXG4vLyBET00gQVBJcywgZm9yIGNvbXBsZXRlbmVzc1xuXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0VGltZW91dCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XG5yZXF1aXJlKFwic2V0aW1tZWRpYXRlXCIpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVpZGF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCIvKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMClcclxuICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgZXhwb3J0cykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKG9bbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH07IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanNcbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLy8gQ29weXJpZ2h0IDIwMTQgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gICAgIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gICAgIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuXG4hZnVuY3Rpb24oYSxiKXt2YXIgYz17fSxkPXt9LGU9e307IWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtpZihcIm51bWJlclwiPT10eXBlb2YgYSlyZXR1cm4gYTt2YXIgYj17fTtmb3IodmFyIGMgaW4gYSliW2NdPWFbY107cmV0dXJuIGJ9ZnVuY3Rpb24gZCgpe3RoaXMuX2RlbGF5PTAsdGhpcy5fZW5kRGVsYXk9MCx0aGlzLl9maWxsPVwibm9uZVwiLHRoaXMuX2l0ZXJhdGlvblN0YXJ0PTAsdGhpcy5faXRlcmF0aW9ucz0xLHRoaXMuX2R1cmF0aW9uPTAsdGhpcy5fcGxheWJhY2tSYXRlPTEsdGhpcy5fZGlyZWN0aW9uPVwibm9ybWFsXCIsdGhpcy5fZWFzaW5nPVwibGluZWFyXCIsdGhpcy5fZWFzaW5nRnVuY3Rpb249eH1mdW5jdGlvbiBlKCl7cmV0dXJuIGEuaXNEZXByZWNhdGVkKFwiSW52YWxpZCB0aW1pbmcgaW5wdXRzXCIsXCIyMDE2LTAzLTAyXCIsXCJUeXBlRXJyb3IgZXhjZXB0aW9ucyB3aWxsIGJlIHRocm93biBpbnN0ZWFkLlwiLCEwKX1mdW5jdGlvbiBmKGIsYyxlKXt2YXIgZj1uZXcgZDtyZXR1cm4gYyYmKGYuZmlsbD1cImJvdGhcIixmLmR1cmF0aW9uPVwiYXV0b1wiKSxcIm51bWJlclwiIT10eXBlb2YgYnx8aXNOYU4oYik/dm9pZCAwIT09YiYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYikuZm9yRWFjaChmdW5jdGlvbihjKXtpZihcImF1dG9cIiE9YltjXSl7aWYoKFwibnVtYmVyXCI9PXR5cGVvZiBmW2NdfHxcImR1cmF0aW9uXCI9PWMpJiYoXCJudW1iZXJcIiE9dHlwZW9mIGJbY118fGlzTmFOKGJbY10pKSlyZXR1cm47aWYoXCJmaWxsXCI9PWMmJi0xPT12LmluZGV4T2YoYltjXSkpcmV0dXJuO2lmKFwiZGlyZWN0aW9uXCI9PWMmJi0xPT13LmluZGV4T2YoYltjXSkpcmV0dXJuO2lmKFwicGxheWJhY2tSYXRlXCI9PWMmJjEhPT1iW2NdJiZhLmlzRGVwcmVjYXRlZChcIkFuaW1hdGlvbkVmZmVjdFRpbWluZy5wbGF5YmFja1JhdGVcIixcIjIwMTQtMTEtMjhcIixcIlVzZSBBbmltYXRpb24ucGxheWJhY2tSYXRlIGluc3RlYWQuXCIpKXJldHVybjtmW2NdPWJbY119fSk6Zi5kdXJhdGlvbj1iLGZ9ZnVuY3Rpb24gZyhhKXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgYSYmKGE9aXNOYU4oYSk/e2R1cmF0aW9uOjB9OntkdXJhdGlvbjphfSksYX1mdW5jdGlvbiBoKGIsYyl7cmV0dXJuIGI9YS5udW1lcmljVGltaW5nVG9PYmplY3QoYiksZihiLGMpfWZ1bmN0aW9uIGkoYSxiLGMsZCl7cmV0dXJuIGE8MHx8YT4xfHxjPDB8fGM+MT94OmZ1bmN0aW9uKGUpe2Z1bmN0aW9uIGYoYSxiLGMpe3JldHVybiAzKmEqKDEtYykqKDEtYykqYyszKmIqKDEtYykqYypjK2MqYypjfWlmKGU8PTApe3ZhciBnPTA7cmV0dXJuIGE+MD9nPWIvYTohYiYmYz4wJiYoZz1kL2MpLGcqZX1pZihlPj0xKXt2YXIgaD0wO3JldHVybiBjPDE/aD0oZC0xKS8oYy0xKToxPT1jJiZhPDEmJihoPShiLTEpLyhhLTEpKSwxK2gqKGUtMSl9Zm9yKHZhciBpPTAsaj0xO2k8ajspe3ZhciBrPShpK2opLzIsbD1mKGEsYyxrKTtpZihNYXRoLmFicyhlLWwpPDFlLTUpcmV0dXJuIGYoYixkLGspO2w8ZT9pPWs6aj1rfXJldHVybiBmKGIsZCxrKX19ZnVuY3Rpb24gaihhLGIpe3JldHVybiBmdW5jdGlvbihjKXtpZihjPj0xKXJldHVybiAxO3ZhciBkPTEvYTtyZXR1cm4oYys9YipkKS1jJWR9fWZ1bmN0aW9uIGsoYSl7Q3x8KEM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSksQy5hbmltYXRpb25UaW1pbmdGdW5jdGlvbj1cIlwiLEMuYW5pbWF0aW9uVGltaW5nRnVuY3Rpb249YTt2YXIgYj1DLmFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uO2lmKFwiXCI9PWImJmUoKSl0aHJvdyBuZXcgVHlwZUVycm9yKGErXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIGVhc2luZ1wiKTtyZXR1cm4gYn1mdW5jdGlvbiBsKGEpe2lmKFwibGluZWFyXCI9PWEpcmV0dXJuIHg7dmFyIGI9RS5leGVjKGEpO2lmKGIpcmV0dXJuIGkuYXBwbHkodGhpcyxiLnNsaWNlKDEpLm1hcChOdW1iZXIpKTt2YXIgYz1GLmV4ZWMoYSk7cmV0dXJuIGM/aihOdW1iZXIoY1sxXSkse3N0YXJ0OnksbWlkZGxlOnosZW5kOkF9W2NbMl1dKTpCW2FdfHx4fWZ1bmN0aW9uIG0oYSl7cmV0dXJuIE1hdGguYWJzKG4oYSkvYS5wbGF5YmFja1JhdGUpfWZ1bmN0aW9uIG4oYSl7cmV0dXJuIDA9PT1hLmR1cmF0aW9ufHwwPT09YS5pdGVyYXRpb25zPzA6YS5kdXJhdGlvbiphLml0ZXJhdGlvbnN9ZnVuY3Rpb24gbyhhLGIsYyl7aWYobnVsbD09YilyZXR1cm4gRzt2YXIgZD1jLmRlbGF5K2ErYy5lbmREZWxheTtyZXR1cm4gYjxNYXRoLm1pbihjLmRlbGF5LGQpP0g6Yj49TWF0aC5taW4oYy5kZWxheSthLGQpP0k6Sn1mdW5jdGlvbiBwKGEsYixjLGQsZSl7c3dpdGNoKGQpe2Nhc2UgSDpyZXR1cm5cImJhY2t3YXJkc1wiPT1ifHxcImJvdGhcIj09Yj8wOm51bGw7Y2FzZSBKOnJldHVybiBjLWU7Y2FzZSBJOnJldHVyblwiZm9yd2FyZHNcIj09Ynx8XCJib3RoXCI9PWI/YTpudWxsO2Nhc2UgRzpyZXR1cm4gbnVsbH19ZnVuY3Rpb24gcShhLGIsYyxkLGUpe3ZhciBmPWU7cmV0dXJuIDA9PT1hP2IhPT1IJiYoZis9Yyk6Zis9ZC9hLGZ9ZnVuY3Rpb24gcihhLGIsYyxkLGUsZil7dmFyIGc9YT09PTEvMD9iJTE6YSUxO3JldHVybiAwIT09Z3x8YyE9PUl8fDA9PT1kfHwwPT09ZSYmMCE9PWZ8fChnPTEpLGd9ZnVuY3Rpb24gcyhhLGIsYyxkKXtyZXR1cm4gYT09PUkmJmI9PT0xLzA/MS8wOjE9PT1jP01hdGguZmxvb3IoZCktMTpNYXRoLmZsb29yKGQpfWZ1bmN0aW9uIHQoYSxiLGMpe3ZhciBkPWE7aWYoXCJub3JtYWxcIiE9PWEmJlwicmV2ZXJzZVwiIT09YSl7dmFyIGU9YjtcImFsdGVybmF0ZS1yZXZlcnNlXCI9PT1hJiYoZSs9MSksZD1cIm5vcm1hbFwiLGUhPT0xLzAmJmUlMiE9MCYmKGQ9XCJyZXZlcnNlXCIpfXJldHVyblwibm9ybWFsXCI9PT1kP2M6MS1jfWZ1bmN0aW9uIHUoYSxiLGMpe3ZhciBkPW8oYSxiLGMpLGU9cChhLGMuZmlsbCxiLGQsYy5kZWxheSk7aWYobnVsbD09PWUpcmV0dXJuIG51bGw7dmFyIGY9cShjLmR1cmF0aW9uLGQsYy5pdGVyYXRpb25zLGUsYy5pdGVyYXRpb25TdGFydCksZz1yKGYsYy5pdGVyYXRpb25TdGFydCxkLGMuaXRlcmF0aW9ucyxlLGMuZHVyYXRpb24pLGg9cyhkLGMuaXRlcmF0aW9ucyxnLGYpLGk9dChjLmRpcmVjdGlvbixoLGcpO3JldHVybiBjLl9lYXNpbmdGdW5jdGlvbihpKX12YXIgdj1cImJhY2t3YXJkc3xmb3J3YXJkc3xib3RofG5vbmVcIi5zcGxpdChcInxcIiksdz1cInJldmVyc2V8YWx0ZXJuYXRlfGFsdGVybmF0ZS1yZXZlcnNlXCIuc3BsaXQoXCJ8XCIpLHg9ZnVuY3Rpb24oYSl7cmV0dXJuIGF9O2QucHJvdG90eXBlPXtfc2V0TWVtYmVyOmZ1bmN0aW9uKGIsYyl7dGhpc1tcIl9cIitiXT1jLHRoaXMuX2VmZmVjdCYmKHRoaXMuX2VmZmVjdC5fdGltaW5nSW5wdXRbYl09Yyx0aGlzLl9lZmZlY3QuX3RpbWluZz1hLm5vcm1hbGl6ZVRpbWluZ0lucHV0KHRoaXMuX2VmZmVjdC5fdGltaW5nSW5wdXQpLHRoaXMuX2VmZmVjdC5hY3RpdmVEdXJhdGlvbj1hLmNhbGN1bGF0ZUFjdGl2ZUR1cmF0aW9uKHRoaXMuX2VmZmVjdC5fdGltaW5nKSx0aGlzLl9lZmZlY3QuX2FuaW1hdGlvbiYmdGhpcy5fZWZmZWN0Ll9hbmltYXRpb24uX3JlYnVpbGRVbmRlcmx5aW5nQW5pbWF0aW9uKCkpfSxnZXQgcGxheWJhY2tSYXRlKCl7cmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZX0sc2V0IGRlbGF5KGEpe3RoaXMuX3NldE1lbWJlcihcImRlbGF5XCIsYSl9LGdldCBkZWxheSgpe3JldHVybiB0aGlzLl9kZWxheX0sc2V0IGVuZERlbGF5KGEpe3RoaXMuX3NldE1lbWJlcihcImVuZERlbGF5XCIsYSl9LGdldCBlbmREZWxheSgpe3JldHVybiB0aGlzLl9lbmREZWxheX0sc2V0IGZpbGwoYSl7dGhpcy5fc2V0TWVtYmVyKFwiZmlsbFwiLGEpfSxnZXQgZmlsbCgpe3JldHVybiB0aGlzLl9maWxsfSxzZXQgaXRlcmF0aW9uU3RhcnQoYSl7aWYoKGlzTmFOKGEpfHxhPDApJiZlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIml0ZXJhdGlvblN0YXJ0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLCByZWNlaXZlZDogXCIrdGltaW5nLml0ZXJhdGlvblN0YXJ0KTt0aGlzLl9zZXRNZW1iZXIoXCJpdGVyYXRpb25TdGFydFwiLGEpfSxnZXQgaXRlcmF0aW9uU3RhcnQoKXtyZXR1cm4gdGhpcy5faXRlcmF0aW9uU3RhcnR9LHNldCBkdXJhdGlvbihhKXtpZihcImF1dG9cIiE9YSYmKGlzTmFOKGEpfHxhPDApJiZlKCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcImR1cmF0aW9uIG11c3QgYmUgbm9uLW5lZ2F0aXZlIG9yIGF1dG8sIHJlY2VpdmVkOiBcIithKTt0aGlzLl9zZXRNZW1iZXIoXCJkdXJhdGlvblwiLGEpfSxnZXQgZHVyYXRpb24oKXtyZXR1cm4gdGhpcy5fZHVyYXRpb259LHNldCBkaXJlY3Rpb24oYSl7dGhpcy5fc2V0TWVtYmVyKFwiZGlyZWN0aW9uXCIsYSl9LGdldCBkaXJlY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGlyZWN0aW9ufSxzZXQgZWFzaW5nKGEpe3RoaXMuX2Vhc2luZ0Z1bmN0aW9uPWwoayhhKSksdGhpcy5fc2V0TWVtYmVyKFwiZWFzaW5nXCIsYSl9LGdldCBlYXNpbmcoKXtyZXR1cm4gdGhpcy5fZWFzaW5nfSxzZXQgaXRlcmF0aW9ucyhhKXtpZigoaXNOYU4oYSl8fGE8MCkmJmUoKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiaXRlcmF0aW9ucyBtdXN0IGJlIG5vbi1uZWdhdGl2ZSwgcmVjZWl2ZWQ6IFwiK2EpO3RoaXMuX3NldE1lbWJlcihcIml0ZXJhdGlvbnNcIixhKX0sZ2V0IGl0ZXJhdGlvbnMoKXtyZXR1cm4gdGhpcy5faXRlcmF0aW9uc319O3ZhciB5PTEsej0uNSxBPTAsQj17ZWFzZTppKC4yNSwuMSwuMjUsMSksXCJlYXNlLWluXCI6aSguNDIsMCwxLDEpLFwiZWFzZS1vdXRcIjppKDAsMCwuNTgsMSksXCJlYXNlLWluLW91dFwiOmkoLjQyLDAsLjU4LDEpLFwic3RlcC1zdGFydFwiOmooMSx5KSxcInN0ZXAtbWlkZGxlXCI6aigxLHopLFwic3RlcC1lbmRcIjpqKDEsQSl9LEM9bnVsbCxEPVwiXFxcXHMqKC0/XFxcXGQrXFxcXC4/XFxcXGQqfC0/XFxcXC5cXFxcZCspXFxcXHMqXCIsRT1uZXcgUmVnRXhwKFwiY3ViaWMtYmV6aWVyXFxcXChcIitEK1wiLFwiK0QrXCIsXCIrRCtcIixcIitEK1wiXFxcXClcIiksRj0vc3RlcHNcXChcXHMqKFxcZCspXFxzKixcXHMqKHN0YXJ0fG1pZGRsZXxlbmQpXFxzKlxcKS8sRz0wLEg9MSxJPTIsSj0zO2EuY2xvbmVUaW1pbmdJbnB1dD1jLGEubWFrZVRpbWluZz1mLGEubnVtZXJpY1RpbWluZ1RvT2JqZWN0PWcsYS5ub3JtYWxpemVUaW1pbmdJbnB1dD1oLGEuY2FsY3VsYXRlQWN0aXZlRHVyYXRpb249bSxhLmNhbGN1bGF0ZUl0ZXJhdGlvblByb2dyZXNzPXUsYS5jYWxjdWxhdGVQaGFzZT1vLGEubm9ybWFsaXplRWFzaW5nPWssYS5wYXJzZUVhc2luZ0Z1bmN0aW9uPWx9KGMpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIpe3JldHVybiBhIGluIGs/a1thXVtiXXx8YjpifWZ1bmN0aW9uIGQoYSl7cmV0dXJuXCJkaXNwbGF5XCI9PT1hfHwwPT09YS5sYXN0SW5kZXhPZihcImFuaW1hdGlvblwiLDApfHwwPT09YS5sYXN0SW5kZXhPZihcInRyYW5zaXRpb25cIiwwKX1mdW5jdGlvbiBlKGEsYixlKXtpZighZChhKSl7dmFyIGY9aFthXTtpZihmKXtpLnN0eWxlW2FdPWI7Zm9yKHZhciBnIGluIGYpe3ZhciBqPWZbZ10saz1pLnN0eWxlW2pdO2Vbal09YyhqLGspfX1lbHNlIGVbYV09YyhhLGIpfX1mdW5jdGlvbiBmKGEpe3ZhciBiPVtdO2Zvcih2YXIgYyBpbiBhKWlmKCEoYyBpbltcImVhc2luZ1wiLFwib2Zmc2V0XCIsXCJjb21wb3NpdGVcIl0pKXt2YXIgZD1hW2NdO0FycmF5LmlzQXJyYXkoZCl8fChkPVtkXSk7Zm9yKHZhciBlLGY9ZC5sZW5ndGgsZz0wO2c8ZjtnKyspZT17fSxlLm9mZnNldD1cIm9mZnNldFwiaW4gYT9hLm9mZnNldDoxPT1mPzE6Zy8oZi0xKSxcImVhc2luZ1wiaW4gYSYmKGUuZWFzaW5nPWEuZWFzaW5nKSxcImNvbXBvc2l0ZVwiaW4gYSYmKGUuY29tcG9zaXRlPWEuY29tcG9zaXRlKSxlW2NdPWRbZ10sYi5wdXNoKGUpfXJldHVybiBiLnNvcnQoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYS5vZmZzZXQtYi5vZmZzZXR9KSxifWZ1bmN0aW9uIGcoYil7ZnVuY3Rpb24gYygpe3ZhciBhPWQubGVuZ3RoO251bGw9PWRbYS0xXS5vZmZzZXQmJihkW2EtMV0ub2Zmc2V0PTEpLGE+MSYmbnVsbD09ZFswXS5vZmZzZXQmJihkWzBdLm9mZnNldD0wKTtmb3IodmFyIGI9MCxjPWRbMF0ub2Zmc2V0LGU9MTtlPGE7ZSsrKXt2YXIgZj1kW2VdLm9mZnNldDtpZihudWxsIT1mKXtmb3IodmFyIGc9MTtnPGUtYjtnKyspZFtiK2ddLm9mZnNldD1jKyhmLWMpKmcvKGUtYik7Yj1lLGM9Zn19fWlmKG51bGw9PWIpcmV0dXJuW107d2luZG93LlN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yJiZBcnJheS5wcm90b3R5cGUuZnJvbSYmYltTeW1ib2wuaXRlcmF0b3JdJiYoYj1BcnJheS5mcm9tKGIpKSxBcnJheS5pc0FycmF5KGIpfHwoYj1mKGIpKTtmb3IodmFyIGQ9Yi5tYXAoZnVuY3Rpb24oYil7dmFyIGM9e307Zm9yKHZhciBkIGluIGIpe3ZhciBmPWJbZF07aWYoXCJvZmZzZXRcIj09ZCl7aWYobnVsbCE9Zil7aWYoZj1OdW1iZXIoZiksIWlzRmluaXRlKGYpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJLZXlmcmFtZSBvZmZzZXRzIG11c3QgYmUgbnVtYmVycy5cIik7aWYoZjwwfHxmPjEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIktleWZyYW1lIG9mZnNldHMgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEuXCIpfX1lbHNlIGlmKFwiY29tcG9zaXRlXCI9PWQpe2lmKFwiYWRkXCI9PWZ8fFwiYWNjdW11bGF0ZVwiPT1mKXRocm93e3R5cGU6RE9NRXhjZXB0aW9uLk5PVF9TVVBQT1JURURfRVJSLG5hbWU6XCJOb3RTdXBwb3J0ZWRFcnJvclwiLG1lc3NhZ2U6XCJhZGQgY29tcG9zaXRpbmcgaXMgbm90IHN1cHBvcnRlZFwifTtpZihcInJlcGxhY2VcIiE9Zil0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBjb21wb3NpdGUgbW9kZSBcIitmK1wiLlwiKX1lbHNlIGY9XCJlYXNpbmdcIj09ZD9hLm5vcm1hbGl6ZUVhc2luZyhmKTpcIlwiK2Y7ZShkLGYsYyl9cmV0dXJuIHZvaWQgMD09Yy5vZmZzZXQmJihjLm9mZnNldD1udWxsKSx2b2lkIDA9PWMuZWFzaW5nJiYoYy5lYXNpbmc9XCJsaW5lYXJcIiksY30pLGc9ITAsaD0tMS8wLGk9MDtpPGQubGVuZ3RoO2krKyl7dmFyIGo9ZFtpXS5vZmZzZXQ7aWYobnVsbCE9ail7aWYoajxoKXRocm93IG5ldyBUeXBlRXJyb3IoXCJLZXlmcmFtZXMgYXJlIG5vdCBsb29zZWx5IHNvcnRlZCBieSBvZmZzZXQuIFNvcnQgb3Igc3BlY2lmeSBvZmZzZXRzLlwiKTtoPWp9ZWxzZSBnPSExfXJldHVybiBkPWQuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBhLm9mZnNldD49MCYmYS5vZmZzZXQ8PTF9KSxnfHxjKCksZH12YXIgaD17YmFja2dyb3VuZDpbXCJiYWNrZ3JvdW5kSW1hZ2VcIixcImJhY2tncm91bmRQb3NpdGlvblwiLFwiYmFja2dyb3VuZFNpemVcIixcImJhY2tncm91bmRSZXBlYXRcIixcImJhY2tncm91bmRBdHRhY2htZW50XCIsXCJiYWNrZ3JvdW5kT3JpZ2luXCIsXCJiYWNrZ3JvdW5kQ2xpcFwiLFwiYmFja2dyb3VuZENvbG9yXCJdLGJvcmRlcjpbXCJib3JkZXJUb3BDb2xvclwiLFwiYm9yZGVyVG9wU3R5bGVcIixcImJvcmRlclRvcFdpZHRoXCIsXCJib3JkZXJSaWdodENvbG9yXCIsXCJib3JkZXJSaWdodFN0eWxlXCIsXCJib3JkZXJSaWdodFdpZHRoXCIsXCJib3JkZXJCb3R0b21Db2xvclwiLFwiYm9yZGVyQm90dG9tU3R5bGVcIixcImJvcmRlckJvdHRvbVdpZHRoXCIsXCJib3JkZXJMZWZ0Q29sb3JcIixcImJvcmRlckxlZnRTdHlsZVwiLFwiYm9yZGVyTGVmdFdpZHRoXCJdLGJvcmRlckJvdHRvbTpbXCJib3JkZXJCb3R0b21XaWR0aFwiLFwiYm9yZGVyQm90dG9tU3R5bGVcIixcImJvcmRlckJvdHRvbUNvbG9yXCJdLGJvcmRlckNvbG9yOltcImJvcmRlclRvcENvbG9yXCIsXCJib3JkZXJSaWdodENvbG9yXCIsXCJib3JkZXJCb3R0b21Db2xvclwiLFwiYm9yZGVyTGVmdENvbG9yXCJdLGJvcmRlckxlZnQ6W1wiYm9yZGVyTGVmdFdpZHRoXCIsXCJib3JkZXJMZWZ0U3R5bGVcIixcImJvcmRlckxlZnRDb2xvclwiXSxib3JkZXJSYWRpdXM6W1wiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFwiYm9yZGVyVG9wUmlnaHRSYWRpdXNcIixcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCJdLGJvcmRlclJpZ2h0OltcImJvcmRlclJpZ2h0V2lkdGhcIixcImJvcmRlclJpZ2h0U3R5bGVcIixcImJvcmRlclJpZ2h0Q29sb3JcIl0sYm9yZGVyVG9wOltcImJvcmRlclRvcFdpZHRoXCIsXCJib3JkZXJUb3BTdHlsZVwiLFwiYm9yZGVyVG9wQ29sb3JcIl0sYm9yZGVyV2lkdGg6W1wiYm9yZGVyVG9wV2lkdGhcIixcImJvcmRlclJpZ2h0V2lkdGhcIixcImJvcmRlckJvdHRvbVdpZHRoXCIsXCJib3JkZXJMZWZ0V2lkdGhcIl0sZmxleDpbXCJmbGV4R3Jvd1wiLFwiZmxleFNocmlua1wiLFwiZmxleEJhc2lzXCJdLGZvbnQ6W1wiZm9udEZhbWlseVwiLFwiZm9udFNpemVcIixcImZvbnRTdHlsZVwiLFwiZm9udFZhcmlhbnRcIixcImZvbnRXZWlnaHRcIixcImxpbmVIZWlnaHRcIl0sbWFyZ2luOltcIm1hcmdpblRvcFwiLFwibWFyZ2luUmlnaHRcIixcIm1hcmdpbkJvdHRvbVwiLFwibWFyZ2luTGVmdFwiXSxvdXRsaW5lOltcIm91dGxpbmVDb2xvclwiLFwib3V0bGluZVN0eWxlXCIsXCJvdXRsaW5lV2lkdGhcIl0scGFkZGluZzpbXCJwYWRkaW5nVG9wXCIsXCJwYWRkaW5nUmlnaHRcIixcInBhZGRpbmdCb3R0b21cIixcInBhZGRpbmdMZWZ0XCJdfSxpPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcImRpdlwiKSxqPXt0aGluOlwiMXB4XCIsbWVkaXVtOlwiM3B4XCIsdGhpY2s6XCI1cHhcIn0saz17Ym9yZGVyQm90dG9tV2lkdGg6aixib3JkZXJMZWZ0V2lkdGg6aixib3JkZXJSaWdodFdpZHRoOmosYm9yZGVyVG9wV2lkdGg6aixmb250U2l6ZTp7XCJ4eC1zbWFsbFwiOlwiNjAlXCIsXCJ4LXNtYWxsXCI6XCI3NSVcIixzbWFsbDpcIjg5JVwiLG1lZGl1bTpcIjEwMCVcIixsYXJnZTpcIjEyMCVcIixcIngtbGFyZ2VcIjpcIjE1MCVcIixcInh4LWxhcmdlXCI6XCIyMDAlXCJ9LGZvbnRXZWlnaHQ6e25vcm1hbDpcIjQwMFwiLGJvbGQ6XCI3MDBcIn0sb3V0bGluZVdpZHRoOmosdGV4dFNoYWRvdzp7bm9uZTpcIjBweCAwcHggMHB4IHRyYW5zcGFyZW50XCJ9LGJveFNoYWRvdzp7bm9uZTpcIjBweCAwcHggMHB4IDBweCB0cmFuc3BhcmVudFwifX07YS5jb252ZXJ0VG9BcnJheUZvcm09ZixhLm5vcm1hbGl6ZUtleWZyYW1lcz1nfShjKSxmdW5jdGlvbihhKXt2YXIgYj17fTthLmlzRGVwcmVjYXRlZD1mdW5jdGlvbihhLGMsZCxlKXt2YXIgZj1lP1wiYXJlXCI6XCJpc1wiLGc9bmV3IERhdGUsaD1uZXcgRGF0ZShjKTtyZXR1cm4gaC5zZXRNb250aChoLmdldE1vbnRoKCkrMyksIShnPGgmJihhIGluIGJ8fGNvbnNvbGUud2FybihcIldlYiBBbmltYXRpb25zOiBcIithK1wiIFwiK2YrXCIgZGVwcmVjYXRlZCBhbmQgd2lsbCBzdG9wIHdvcmtpbmcgb24gXCIraC50b0RhdGVTdHJpbmcoKStcIi4gXCIrZCksYlthXT0hMCwxKSl9LGEuZGVwcmVjYXRlZD1mdW5jdGlvbihiLGMsZCxlKXt2YXIgZj1lP1wiYXJlXCI6XCJpc1wiO2lmKGEuaXNEZXByZWNhdGVkKGIsYyxkLGUpKXRocm93IG5ldyBFcnJvcihiK1wiIFwiK2YrXCIgbm8gbG9uZ2VyIHN1cHBvcnRlZC4gXCIrZCl9fShjKSxmdW5jdGlvbigpe2lmKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hbmltYXRlKXt2YXIgYT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYW5pbWF0ZShbXSwwKSxiPSEwO2lmKGEmJihiPSExLFwicGxheXxjdXJyZW50VGltZXxwYXVzZXxyZXZlcnNlfHBsYXliYWNrUmF0ZXxjYW5jZWx8ZmluaXNofHN0YXJ0VGltZXxwbGF5U3RhdGVcIi5zcGxpdChcInxcIikuZm9yRWFjaChmdW5jdGlvbihjKXt2b2lkIDA9PT1hW2NdJiYoYj0hMCl9KSksIWIpcmV0dXJufSFmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtmb3IodmFyIGI9e30sYz0wO2M8YS5sZW5ndGg7YysrKWZvcih2YXIgZCBpbiBhW2NdKWlmKFwib2Zmc2V0XCIhPWQmJlwiZWFzaW5nXCIhPWQmJlwiY29tcG9zaXRlXCIhPWQpe3ZhciBlPXtvZmZzZXQ6YVtjXS5vZmZzZXQsZWFzaW5nOmFbY10uZWFzaW5nLHZhbHVlOmFbY11bZF19O2JbZF09YltkXXx8W10sYltkXS5wdXNoKGUpfWZvcih2YXIgZiBpbiBiKXt2YXIgZz1iW2ZdO2lmKDAhPWdbMF0ub2Zmc2V0fHwxIT1nW2cubGVuZ3RoLTFdLm9mZnNldCl0aHJvd3t0eXBlOkRPTUV4Y2VwdGlvbi5OT1RfU1VQUE9SVEVEX0VSUixuYW1lOlwiTm90U3VwcG9ydGVkRXJyb3JcIixtZXNzYWdlOlwiUGFydGlhbCBrZXlmcmFtZXMgYXJlIG5vdCBzdXBwb3J0ZWRcIn19cmV0dXJuIGJ9ZnVuY3Rpb24gZShjKXt2YXIgZD1bXTtmb3IodmFyIGUgaW4gYylmb3IodmFyIGY9Y1tlXSxnPTA7ZzxmLmxlbmd0aC0xO2crKyl7dmFyIGg9ZyxpPWcrMSxqPWZbaF0ub2Zmc2V0LGs9ZltpXS5vZmZzZXQsbD1qLG09azswPT1nJiYobD0tMS8wLDA9PWsmJihpPWgpKSxnPT1mLmxlbmd0aC0yJiYobT0xLzAsMT09aiYmKGg9aSkpLGQucHVzaCh7YXBwbHlGcm9tOmwsYXBwbHlUbzptLHN0YXJ0T2Zmc2V0OmZbaF0ub2Zmc2V0LGVuZE9mZnNldDpmW2ldLm9mZnNldCxlYXNpbmdGdW5jdGlvbjphLnBhcnNlRWFzaW5nRnVuY3Rpb24oZltoXS5lYXNpbmcpLHByb3BlcnR5OmUsaW50ZXJwb2xhdGlvbjpiLnByb3BlcnR5SW50ZXJwb2xhdGlvbihlLGZbaF0udmFsdWUsZltpXS52YWx1ZSl9KX1yZXR1cm4gZC5zb3J0KGZ1bmN0aW9uKGEsYil7cmV0dXJuIGEuc3RhcnRPZmZzZXQtYi5zdGFydE9mZnNldH0pLGR9Yi5jb252ZXJ0RWZmZWN0SW5wdXQ9ZnVuY3Rpb24oYyl7dmFyIGY9YS5ub3JtYWxpemVLZXlmcmFtZXMoYyksZz1kKGYpLGg9ZShnKTtyZXR1cm4gZnVuY3Rpb24oYSxjKXtpZihudWxsIT1jKWguZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBjPj1hLmFwcGx5RnJvbSYmYzxhLmFwcGx5VG99KS5mb3JFYWNoKGZ1bmN0aW9uKGQpe3ZhciBlPWMtZC5zdGFydE9mZnNldCxmPWQuZW5kT2Zmc2V0LWQuc3RhcnRPZmZzZXQsZz0wPT1mPzA6ZC5lYXNpbmdGdW5jdGlvbihlL2YpO2IuYXBwbHkoYSxkLnByb3BlcnR5LGQuaW50ZXJwb2xhdGlvbihnKSl9KTtlbHNlIGZvcih2YXIgZCBpbiBnKVwib2Zmc2V0XCIhPWQmJlwiZWFzaW5nXCIhPWQmJlwiY29tcG9zaXRlXCIhPWQmJmIuY2xlYXIoYSxkKX19fShjLGQpLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe3JldHVybiBhLnJlcGxhY2UoLy0oLikvZyxmdW5jdGlvbihhLGIpe3JldHVybiBiLnRvVXBwZXJDYXNlKCl9KX1mdW5jdGlvbiBlKGEsYixjKXtoW2NdPWhbY118fFtdLGhbY10ucHVzaChbYSxiXSl9ZnVuY3Rpb24gZihhLGIsYyl7Zm9yKHZhciBmPTA7ZjxjLmxlbmd0aDtmKyspe2UoYSxiLGQoY1tmXSkpfX1mdW5jdGlvbiBnKGMsZSxmKXt2YXIgZz1jOy8tLy50ZXN0KGMpJiYhYS5pc0RlcHJlY2F0ZWQoXCJIeXBoZW5hdGVkIHByb3BlcnR5IG5hbWVzXCIsXCIyMDE2LTAzLTIyXCIsXCJVc2UgY2FtZWxDYXNlIGluc3RlYWQuXCIsITApJiYoZz1kKGMpKSxcImluaXRpYWxcIiE9ZSYmXCJpbml0aWFsXCIhPWZ8fChcImluaXRpYWxcIj09ZSYmKGU9aVtnXSksXCJpbml0aWFsXCI9PWYmJihmPWlbZ10pKTtmb3IodmFyIGo9ZT09Zj9bXTpoW2ddLGs9MDtqJiZrPGoubGVuZ3RoO2srKyl7dmFyIGw9altrXVswXShlKSxtPWpba11bMF0oZik7aWYodm9pZCAwIT09bCYmdm9pZCAwIT09bSl7dmFyIG49altrXVsxXShsLG0pO2lmKG4pe3ZhciBvPWIuSW50ZXJwb2xhdGlvbi5hcHBseShudWxsLG4pO3JldHVybiBmdW5jdGlvbihhKXtyZXR1cm4gMD09YT9lOjE9PWE/ZjpvKGEpfX19fXJldHVybiBiLkludGVycG9sYXRpb24oITEsITAsZnVuY3Rpb24oYSl7cmV0dXJuIGE/ZjplfSl9dmFyIGg9e307Yi5hZGRQcm9wZXJ0aWVzSGFuZGxlcj1mO3ZhciBpPXtiYWNrZ3JvdW5kQ29sb3I6XCJ0cmFuc3BhcmVudFwiLGJhY2tncm91bmRQb3NpdGlvbjpcIjAlIDAlXCIsYm9yZGVyQm90dG9tQ29sb3I6XCJjdXJyZW50Q29sb3JcIixib3JkZXJCb3R0b21MZWZ0UmFkaXVzOlwiMHB4XCIsYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6XCIwcHhcIixib3JkZXJCb3R0b21XaWR0aDpcIjNweFwiLGJvcmRlckxlZnRDb2xvcjpcImN1cnJlbnRDb2xvclwiLGJvcmRlckxlZnRXaWR0aDpcIjNweFwiLGJvcmRlclJpZ2h0Q29sb3I6XCJjdXJyZW50Q29sb3JcIixib3JkZXJSaWdodFdpZHRoOlwiM3B4XCIsYm9yZGVyU3BhY2luZzpcIjJweFwiLGJvcmRlclRvcENvbG9yOlwiY3VycmVudENvbG9yXCIsYm9yZGVyVG9wTGVmdFJhZGl1czpcIjBweFwiLGJvcmRlclRvcFJpZ2h0UmFkaXVzOlwiMHB4XCIsYm9yZGVyVG9wV2lkdGg6XCIzcHhcIixib3R0b206XCJhdXRvXCIsY2xpcDpcInJlY3QoMHB4LCAwcHgsIDBweCwgMHB4KVwiLGNvbG9yOlwiYmxhY2tcIixmb250U2l6ZTpcIjEwMCVcIixmb250V2VpZ2h0OlwiNDAwXCIsaGVpZ2h0OlwiYXV0b1wiLGxlZnQ6XCJhdXRvXCIsbGV0dGVyU3BhY2luZzpcIm5vcm1hbFwiLGxpbmVIZWlnaHQ6XCIxMjAlXCIsbWFyZ2luQm90dG9tOlwiMHB4XCIsbWFyZ2luTGVmdDpcIjBweFwiLG1hcmdpblJpZ2h0OlwiMHB4XCIsbWFyZ2luVG9wOlwiMHB4XCIsbWF4SGVpZ2h0Olwibm9uZVwiLG1heFdpZHRoOlwibm9uZVwiLG1pbkhlaWdodDpcIjBweFwiLG1pbldpZHRoOlwiMHB4XCIsb3BhY2l0eTpcIjEuMFwiLG91dGxpbmVDb2xvcjpcImludmVydFwiLG91dGxpbmVPZmZzZXQ6XCIwcHhcIixvdXRsaW5lV2lkdGg6XCIzcHhcIixwYWRkaW5nQm90dG9tOlwiMHB4XCIscGFkZGluZ0xlZnQ6XCIwcHhcIixwYWRkaW5nUmlnaHQ6XCIwcHhcIixwYWRkaW5nVG9wOlwiMHB4XCIscmlnaHQ6XCJhdXRvXCIsc3Ryb2tlRGFzaGFycmF5Olwibm9uZVwiLHN0cm9rZURhc2hvZmZzZXQ6XCIwcHhcIix0ZXh0SW5kZW50OlwiMHB4XCIsdGV4dFNoYWRvdzpcIjBweCAwcHggMHB4IHRyYW5zcGFyZW50XCIsdG9wOlwiYXV0b1wiLHRyYW5zZm9ybTpcIlwiLHZlcnRpY2FsQWxpZ246XCIwcHhcIix2aXNpYmlsaXR5OlwidmlzaWJsZVwiLHdpZHRoOlwiYXV0b1wiLHdvcmRTcGFjaW5nOlwibm9ybWFsXCIsekluZGV4OlwiYXV0b1wifTtiLnByb3BlcnR5SW50ZXJwb2xhdGlvbj1nfShjLGQpLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGIpe3ZhciBjPWEuY2FsY3VsYXRlQWN0aXZlRHVyYXRpb24oYiksZD1mdW5jdGlvbihkKXtyZXR1cm4gYS5jYWxjdWxhdGVJdGVyYXRpb25Qcm9ncmVzcyhjLGQsYil9O3JldHVybiBkLl90b3RhbER1cmF0aW9uPWIuZGVsYXkrYytiLmVuZERlbGF5LGR9Yi5LZXlmcmFtZUVmZmVjdD1mdW5jdGlvbihjLGUsZixnKXt2YXIgaCxpPWQoYS5ub3JtYWxpemVUaW1pbmdJbnB1dChmKSksaj1iLmNvbnZlcnRFZmZlY3RJbnB1dChlKSxrPWZ1bmN0aW9uKCl7aihjLGgpfTtyZXR1cm4gay5fdXBkYXRlPWZ1bmN0aW9uKGEpe3JldHVybiBudWxsIT09KGg9aShhKSl9LGsuX2NsZWFyPWZ1bmN0aW9uKCl7aihjLG51bGwpfSxrLl9oYXNTYW1lVGFyZ2V0PWZ1bmN0aW9uKGEpe3JldHVybiBjPT09YX0say5fdGFyZ2V0PWMsay5fdG90YWxEdXJhdGlvbj1pLl90b3RhbER1cmF0aW9uLGsuX2lkPWcsa319KGMsZCksZnVuY3Rpb24oYSxiKXthLmFwcGx5PWZ1bmN0aW9uKGIsYyxkKXtiLnN0eWxlW2EucHJvcGVydHlOYW1lKGMpXT1kfSxhLmNsZWFyPWZ1bmN0aW9uKGIsYyl7Yi5zdHlsZVthLnByb3BlcnR5TmFtZShjKV09XCJcIn19KGQpLGZ1bmN0aW9uKGEpe3dpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hbmltYXRlPWZ1bmN0aW9uKGIsYyl7dmFyIGQ9XCJcIjtyZXR1cm4gYyYmYy5pZCYmKGQ9Yy5pZCksYS50aW1lbGluZS5fcGxheShhLktleWZyYW1lRWZmZWN0KHRoaXMsYixjLGQpKX19KGQpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhLGIsZCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGEmJlwibnVtYmVyXCI9PXR5cGVvZiBiKXJldHVybiBhKigxLWQpK2IqZDtpZihcImJvb2xlYW5cIj09dHlwZW9mIGEmJlwiYm9vbGVhblwiPT10eXBlb2YgYilyZXR1cm4gZDwuNT9hOmI7aWYoYS5sZW5ndGg9PWIubGVuZ3RoKXtmb3IodmFyIGU9W10sZj0wO2Y8YS5sZW5ndGg7ZisrKWUucHVzaChjKGFbZl0sYltmXSxkKSk7cmV0dXJuIGV9dGhyb3dcIk1pc21hdGNoZWQgaW50ZXJwb2xhdGlvbiBhcmd1bWVudHMgXCIrYStcIjpcIitifWEuSW50ZXJwb2xhdGlvbj1mdW5jdGlvbihhLGIsZCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3JldHVybiBkKGMoYSxiLGUpKX19fShkKSxmdW5jdGlvbihhLGIsYyl7YS5zZXF1ZW5jZU51bWJlcj0wO3ZhciBkPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnRhcmdldD1hLHRoaXMuY3VycmVudFRpbWU9Yix0aGlzLnRpbWVsaW5lVGltZT1jLHRoaXMudHlwZT1cImZpbmlzaFwiLHRoaXMuYnViYmxlcz0hMSx0aGlzLmNhbmNlbGFibGU9ITEsdGhpcy5jdXJyZW50VGFyZ2V0PWEsdGhpcy5kZWZhdWx0UHJldmVudGVkPSExLHRoaXMuZXZlbnRQaGFzZT1FdmVudC5BVF9UQVJHRVQsdGhpcy50aW1lU3RhbXA9RGF0ZS5ub3coKX07Yi5BbmltYXRpb249ZnVuY3Rpb24oYil7dGhpcy5pZD1cIlwiLGImJmIuX2lkJiYodGhpcy5pZD1iLl9pZCksdGhpcy5fc2VxdWVuY2VOdW1iZXI9YS5zZXF1ZW5jZU51bWJlcisrLHRoaXMuX2N1cnJlbnRUaW1lPTAsdGhpcy5fc3RhcnRUaW1lPW51bGwsdGhpcy5fcGF1c2VkPSExLHRoaXMuX3BsYXliYWNrUmF0ZT0xLHRoaXMuX2luVGltZWxpbmU9ITAsdGhpcy5fZmluaXNoZWRGbGFnPSEwLHRoaXMub25maW5pc2g9bnVsbCx0aGlzLl9maW5pc2hIYW5kbGVycz1bXSx0aGlzLl9lZmZlY3Q9Yix0aGlzLl9pbkVmZmVjdD10aGlzLl9lZmZlY3QuX3VwZGF0ZSgwKSx0aGlzLl9pZGxlPSEwLHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMX0sYi5BbmltYXRpb24ucHJvdG90eXBlPXtfZW5zdXJlQWxpdmU6ZnVuY3Rpb24oKXt0aGlzLnBsYXliYWNrUmF0ZTwwJiYwPT09dGhpcy5jdXJyZW50VGltZT90aGlzLl9pbkVmZmVjdD10aGlzLl9lZmZlY3QuX3VwZGF0ZSgtMSk6dGhpcy5faW5FZmZlY3Q9dGhpcy5fZWZmZWN0Ll91cGRhdGUodGhpcy5jdXJyZW50VGltZSksdGhpcy5faW5UaW1lbGluZXx8IXRoaXMuX2luRWZmZWN0JiZ0aGlzLl9maW5pc2hlZEZsYWd8fCh0aGlzLl9pblRpbWVsaW5lPSEwLGIudGltZWxpbmUuX2FuaW1hdGlvbnMucHVzaCh0aGlzKSl9LF90aWNrQ3VycmVudFRpbWU6ZnVuY3Rpb24oYSxiKXthIT10aGlzLl9jdXJyZW50VGltZSYmKHRoaXMuX2N1cnJlbnRUaW1lPWEsdGhpcy5faXNGaW5pc2hlZCYmIWImJih0aGlzLl9jdXJyZW50VGltZT10aGlzLl9wbGF5YmFja1JhdGU+MD90aGlzLl90b3RhbER1cmF0aW9uOjApLHRoaXMuX2Vuc3VyZUFsaXZlKCkpfSxnZXQgY3VycmVudFRpbWUoKXtyZXR1cm4gdGhpcy5faWRsZXx8dGhpcy5fY3VycmVudFRpbWVQZW5kaW5nP251bGw6dGhpcy5fY3VycmVudFRpbWV9LHNldCBjdXJyZW50VGltZShhKXthPSthLGlzTmFOKGEpfHwoYi5yZXN0YXJ0KCksdGhpcy5fcGF1c2VkfHxudWxsPT10aGlzLl9zdGFydFRpbWV8fCh0aGlzLl9zdGFydFRpbWU9dGhpcy5fdGltZWxpbmUuY3VycmVudFRpbWUtYS90aGlzLl9wbGF5YmFja1JhdGUpLHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMSx0aGlzLl9jdXJyZW50VGltZSE9YSYmKHRoaXMuX2lkbGUmJih0aGlzLl9pZGxlPSExLHRoaXMuX3BhdXNlZD0hMCksdGhpcy5fdGlja0N1cnJlbnRUaW1lKGEsITApLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKSl9LGdldCBzdGFydFRpbWUoKXtyZXR1cm4gdGhpcy5fc3RhcnRUaW1lfSxzZXQgc3RhcnRUaW1lKGEpe2E9K2EsaXNOYU4oYSl8fHRoaXMuX3BhdXNlZHx8dGhpcy5faWRsZXx8KHRoaXMuX3N0YXJ0VGltZT1hLHRoaXMuX3RpY2tDdXJyZW50VGltZSgodGhpcy5fdGltZWxpbmUuY3VycmVudFRpbWUtdGhpcy5fc3RhcnRUaW1lKSp0aGlzLnBsYXliYWNrUmF0ZSksYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcykpfSxnZXQgcGxheWJhY2tSYXRlKCl7cmV0dXJuIHRoaXMuX3BsYXliYWNrUmF0ZX0sc2V0IHBsYXliYWNrUmF0ZShhKXtpZihhIT10aGlzLl9wbGF5YmFja1JhdGUpe3ZhciBjPXRoaXMuY3VycmVudFRpbWU7dGhpcy5fcGxheWJhY2tSYXRlPWEsdGhpcy5fc3RhcnRUaW1lPW51bGwsXCJwYXVzZWRcIiE9dGhpcy5wbGF5U3RhdGUmJlwiaWRsZVwiIT10aGlzLnBsYXlTdGF0ZSYmKHRoaXMuX2ZpbmlzaGVkRmxhZz0hMSx0aGlzLl9pZGxlPSExLHRoaXMuX2Vuc3VyZUFsaXZlKCksYi5hcHBseURpcnRpZWRBbmltYXRpb24odGhpcykpLG51bGwhPWMmJih0aGlzLmN1cnJlbnRUaW1lPWMpfX0sZ2V0IF9pc0ZpbmlzaGVkKCl7cmV0dXJuIXRoaXMuX2lkbGUmJih0aGlzLl9wbGF5YmFja1JhdGU+MCYmdGhpcy5fY3VycmVudFRpbWU+PXRoaXMuX3RvdGFsRHVyYXRpb258fHRoaXMuX3BsYXliYWNrUmF0ZTwwJiZ0aGlzLl9jdXJyZW50VGltZTw9MCl9LGdldCBfdG90YWxEdXJhdGlvbigpe3JldHVybiB0aGlzLl9lZmZlY3QuX3RvdGFsRHVyYXRpb259LGdldCBwbGF5U3RhdGUoKXtyZXR1cm4gdGhpcy5faWRsZT9cImlkbGVcIjpudWxsPT10aGlzLl9zdGFydFRpbWUmJiF0aGlzLl9wYXVzZWQmJjAhPXRoaXMucGxheWJhY2tSYXRlfHx0aGlzLl9jdXJyZW50VGltZVBlbmRpbmc/XCJwZW5kaW5nXCI6dGhpcy5fcGF1c2VkP1wicGF1c2VkXCI6dGhpcy5faXNGaW5pc2hlZD9cImZpbmlzaGVkXCI6XCJydW5uaW5nXCJ9LF9yZXdpbmQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9wbGF5YmFja1JhdGU+PTApdGhpcy5fY3VycmVudFRpbWU9MDtlbHNle2lmKCEodGhpcy5fdG90YWxEdXJhdGlvbjwxLzApKXRocm93IG5ldyBET01FeGNlcHRpb24oXCJVbmFibGUgdG8gcmV3aW5kIG5lZ2F0aXZlIHBsYXliYWNrIHJhdGUgYW5pbWF0aW9uIHdpdGggaW5maW5pdGUgZHVyYXRpb25cIixcIkludmFsaWRTdGF0ZUVycm9yXCIpO3RoaXMuX2N1cnJlbnRUaW1lPXRoaXMuX3RvdGFsRHVyYXRpb259fSxwbGF5OmZ1bmN0aW9uKCl7dGhpcy5fcGF1c2VkPSExLCh0aGlzLl9pc0ZpbmlzaGVkfHx0aGlzLl9pZGxlKSYmKHRoaXMuX3Jld2luZCgpLHRoaXMuX3N0YXJ0VGltZT1udWxsKSx0aGlzLl9maW5pc2hlZEZsYWc9ITEsdGhpcy5faWRsZT0hMSx0aGlzLl9lbnN1cmVBbGl2ZSgpLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpfSxwYXVzZTpmdW5jdGlvbigpe3RoaXMuX2lzRmluaXNoZWR8fHRoaXMuX3BhdXNlZHx8dGhpcy5faWRsZT90aGlzLl9pZGxlJiYodGhpcy5fcmV3aW5kKCksdGhpcy5faWRsZT0hMSk6dGhpcy5fY3VycmVudFRpbWVQZW5kaW5nPSEwLHRoaXMuX3N0YXJ0VGltZT1udWxsLHRoaXMuX3BhdXNlZD0hMH0sZmluaXNoOmZ1bmN0aW9uKCl7dGhpcy5faWRsZXx8KHRoaXMuY3VycmVudFRpbWU9dGhpcy5fcGxheWJhY2tSYXRlPjA/dGhpcy5fdG90YWxEdXJhdGlvbjowLHRoaXMuX3N0YXJ0VGltZT10aGlzLl90b3RhbER1cmF0aW9uLXRoaXMuY3VycmVudFRpbWUsdGhpcy5fY3VycmVudFRpbWVQZW5kaW5nPSExLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKX0sY2FuY2VsOmZ1bmN0aW9uKCl7dGhpcy5faW5FZmZlY3QmJih0aGlzLl9pbkVmZmVjdD0hMSx0aGlzLl9pZGxlPSEwLHRoaXMuX3BhdXNlZD0hMSx0aGlzLl9pc0ZpbmlzaGVkPSEwLHRoaXMuX2ZpbmlzaGVkRmxhZz0hMCx0aGlzLl9jdXJyZW50VGltZT0wLHRoaXMuX3N0YXJ0VGltZT1udWxsLHRoaXMuX2VmZmVjdC5fdXBkYXRlKG51bGwpLGIuYXBwbHlEaXJ0aWVkQW5pbWF0aW9uKHRoaXMpKX0scmV2ZXJzZTpmdW5jdGlvbigpe3RoaXMucGxheWJhY2tSYXRlKj0tMSx0aGlzLnBsYXkoKX0sYWRkRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGImJlwiZmluaXNoXCI9PWEmJnRoaXMuX2ZpbmlzaEhhbmRsZXJzLnB1c2goYil9LHJlbW92ZUV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24oYSxiKXtpZihcImZpbmlzaFwiPT1hKXt2YXIgYz10aGlzLl9maW5pc2hIYW5kbGVycy5pbmRleE9mKGIpO2M+PTAmJnRoaXMuX2ZpbmlzaEhhbmRsZXJzLnNwbGljZShjLDEpfX0sX2ZpcmVFdmVudHM6ZnVuY3Rpb24oYSl7aWYodGhpcy5faXNGaW5pc2hlZCl7aWYoIXRoaXMuX2ZpbmlzaGVkRmxhZyl7dmFyIGI9bmV3IGQodGhpcyx0aGlzLl9jdXJyZW50VGltZSxhKSxjPXRoaXMuX2ZpbmlzaEhhbmRsZXJzLmNvbmNhdCh0aGlzLm9uZmluaXNoP1t0aGlzLm9uZmluaXNoXTpbXSk7c2V0VGltZW91dChmdW5jdGlvbigpe2MuZm9yRWFjaChmdW5jdGlvbihhKXthLmNhbGwoYi50YXJnZXQsYil9KX0sMCksdGhpcy5fZmluaXNoZWRGbGFnPSEwfX1lbHNlIHRoaXMuX2ZpbmlzaGVkRmxhZz0hMX0sX3RpY2s6ZnVuY3Rpb24oYSxiKXt0aGlzLl9pZGxlfHx0aGlzLl9wYXVzZWR8fChudWxsPT10aGlzLl9zdGFydFRpbWU/YiYmKHRoaXMuc3RhcnRUaW1lPWEtdGhpcy5fY3VycmVudFRpbWUvdGhpcy5wbGF5YmFja1JhdGUpOnRoaXMuX2lzRmluaXNoZWR8fHRoaXMuX3RpY2tDdXJyZW50VGltZSgoYS10aGlzLl9zdGFydFRpbWUpKnRoaXMucGxheWJhY2tSYXRlKSksYiYmKHRoaXMuX2N1cnJlbnRUaW1lUGVuZGluZz0hMSx0aGlzLl9maXJlRXZlbnRzKGEpKX0sZ2V0IF9uZWVkc1RpY2soKXtyZXR1cm4gdGhpcy5wbGF5U3RhdGUgaW57cGVuZGluZzoxLHJ1bm5pbmc6MX18fCF0aGlzLl9maW5pc2hlZEZsYWd9LF90YXJnZXRBbmltYXRpb25zOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fZWZmZWN0Ll90YXJnZXQ7cmV0dXJuIGEuX2FjdGl2ZUFuaW1hdGlvbnN8fChhLl9hY3RpdmVBbmltYXRpb25zPVtdKSxhLl9hY3RpdmVBbmltYXRpb25zfSxfbWFya1RhcmdldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX3RhcmdldEFuaW1hdGlvbnMoKTstMT09PWEuaW5kZXhPZih0aGlzKSYmYS5wdXNoKHRoaXMpfSxfdW5tYXJrVGFyZ2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fdGFyZ2V0QW5pbWF0aW9ucygpLGI9YS5pbmRleE9mKHRoaXMpOy0xIT09YiYmYS5zcGxpY2UoYiwxKX19fShjLGQpLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGEpe3ZhciBiPWo7aj1bXSxhPHEuY3VycmVudFRpbWUmJihhPXEuY3VycmVudFRpbWUpLHEuX2FuaW1hdGlvbnMuc29ydChlKSxxLl9hbmltYXRpb25zPWgoYSwhMCxxLl9hbmltYXRpb25zKVswXSxiLmZvckVhY2goZnVuY3Rpb24oYil7YlsxXShhKX0pLGcoKSxsPXZvaWQgMH1mdW5jdGlvbiBlKGEsYil7cmV0dXJuIGEuX3NlcXVlbmNlTnVtYmVyLWIuX3NlcXVlbmNlTnVtYmVyfWZ1bmN0aW9uIGYoKXt0aGlzLl9hbmltYXRpb25zPVtdLHRoaXMuY3VycmVudFRpbWU9d2luZG93LnBlcmZvcm1hbmNlJiZwZXJmb3JtYW5jZS5ub3c/cGVyZm9ybWFuY2Uubm93KCk6MH1mdW5jdGlvbiBnKCl7by5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EoKX0pLG8ubGVuZ3RoPTB9ZnVuY3Rpb24gaChhLGMsZCl7cD0hMCxuPSExLGIudGltZWxpbmUuY3VycmVudFRpbWU9YSxtPSExO3ZhciBlPVtdLGY9W10sZz1bXSxoPVtdO3JldHVybiBkLmZvckVhY2goZnVuY3Rpb24oYil7Yi5fdGljayhhLGMpLGIuX2luRWZmZWN0PyhmLnB1c2goYi5fZWZmZWN0KSxiLl9tYXJrVGFyZ2V0KCkpOihlLnB1c2goYi5fZWZmZWN0KSxiLl91bm1hcmtUYXJnZXQoKSksYi5fbmVlZHNUaWNrJiYobT0hMCk7dmFyIGQ9Yi5faW5FZmZlY3R8fGIuX25lZWRzVGljaztiLl9pblRpbWVsaW5lPWQsZD9nLnB1c2goYik6aC5wdXNoKGIpfSksby5wdXNoLmFwcGx5KG8sZSksby5wdXNoLmFwcGx5KG8sZiksbSYmcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7fSkscD0hMSxbZyxoXX12YXIgaT13aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLGo9W10saz0wO3dpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU9ZnVuY3Rpb24oYSl7dmFyIGI9aysrO3JldHVybiAwPT1qLmxlbmd0aCYmaShkKSxqLnB1c2goW2IsYV0pLGJ9LHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZT1mdW5jdGlvbihhKXtqLmZvckVhY2goZnVuY3Rpb24oYil7YlswXT09YSYmKGJbMV09ZnVuY3Rpb24oKXt9KX0pfSxmLnByb3RvdHlwZT17X3BsYXk6ZnVuY3Rpb24oYyl7Yy5fdGltaW5nPWEubm9ybWFsaXplVGltaW5nSW5wdXQoYy50aW1pbmcpO3ZhciBkPW5ldyBiLkFuaW1hdGlvbihjKTtyZXR1cm4gZC5faWRsZT0hMSxkLl90aW1lbGluZT10aGlzLHRoaXMuX2FuaW1hdGlvbnMucHVzaChkKSxiLnJlc3RhcnQoKSxiLmFwcGx5RGlydGllZEFuaW1hdGlvbihkKSxkfX07dmFyIGw9dm9pZCAwLG09ITEsbj0hMTtiLnJlc3RhcnQ9ZnVuY3Rpb24oKXtyZXR1cm4gbXx8KG09ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7fSksbj0hMCksbn0sYi5hcHBseURpcnRpZWRBbmltYXRpb249ZnVuY3Rpb24oYSl7aWYoIXApe2EuX21hcmtUYXJnZXQoKTt2YXIgYz1hLl90YXJnZXRBbmltYXRpb25zKCk7Yy5zb3J0KGUpLGgoYi50aW1lbGluZS5jdXJyZW50VGltZSwhMSxjLnNsaWNlKCkpWzFdLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9cS5fYW5pbWF0aW9ucy5pbmRleE9mKGEpOy0xIT09YiYmcS5fYW5pbWF0aW9ucy5zcGxpY2UoYiwxKX0pLGcoKX19O3ZhciBvPVtdLHA9ITEscT1uZXcgZjtiLnRpbWVsaW5lPXF9KGMsZCksZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIpe3ZhciBjPWEuZXhlYyhiKTtpZihjKXJldHVybiBjPWEuaWdub3JlQ2FzZT9jWzBdLnRvTG93ZXJDYXNlKCk6Y1swXSxbYyxiLnN1YnN0cihjLmxlbmd0aCldfWZ1bmN0aW9uIGMoYSxiKXtiPWIucmVwbGFjZSgvXlxccyovLFwiXCIpO3ZhciBjPWEoYik7aWYoYylyZXR1cm5bY1swXSxjWzFdLnJlcGxhY2UoL15cXHMqLyxcIlwiKV19ZnVuY3Rpb24gZChhLGQsZSl7YT1jLmJpbmQobnVsbCxhKTtmb3IodmFyIGY9W107Oyl7dmFyIGc9YShlKTtpZighZylyZXR1cm5bZixlXTtpZihmLnB1c2goZ1swXSksZT1nWzFdLCEoZz1iKGQsZSkpfHxcIlwiPT1nWzFdKXJldHVybltmLGVdO2U9Z1sxXX19ZnVuY3Rpb24gZShhLGIpe2Zvcih2YXIgYz0wLGQ9MDtkPGIubGVuZ3RoJiYoIS9cXHN8LC8udGVzdChiW2RdKXx8MCE9Yyk7ZCsrKWlmKFwiKFwiPT1iW2RdKWMrKztlbHNlIGlmKFwiKVwiPT1iW2RdJiYoYy0tLDA9PWMmJmQrKyxjPD0wKSlicmVhazt2YXIgZT1hKGIuc3Vic3RyKDAsZCkpO3JldHVybiB2b2lkIDA9PWU/dm9pZCAwOltlLGIuc3Vic3RyKGQpXX1mdW5jdGlvbiBmKGEsYil7Zm9yKHZhciBjPWEsZD1iO2MmJmQ7KWM+ZD9jJT1kOmQlPWM7cmV0dXJuIGM9YSpiLyhjK2QpfWZ1bmN0aW9uIGcoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3ZhciBjPWEoYik7cmV0dXJuIGMmJihjWzBdPXZvaWQgMCksY319ZnVuY3Rpb24gaChhLGIpe3JldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gYShjKXx8W2IsY119fWZ1bmN0aW9uIGkoYixjKXtmb3IodmFyIGQ9W10sZT0wO2U8Yi5sZW5ndGg7ZSsrKXt2YXIgZj1hLmNvbnN1bWVUcmltbWVkKGJbZV0sYyk7aWYoIWZ8fFwiXCI9PWZbMF0pcmV0dXJuO3ZvaWQgMCE9PWZbMF0mJmQucHVzaChmWzBdKSxjPWZbMV19aWYoXCJcIj09YylyZXR1cm4gZH1mdW5jdGlvbiBqKGEsYixjLGQsZSl7Zm9yKHZhciBnPVtdLGg9W10saT1bXSxqPWYoZC5sZW5ndGgsZS5sZW5ndGgpLGs9MDtrPGo7aysrKXt2YXIgbD1iKGRbayVkLmxlbmd0aF0sZVtrJWUubGVuZ3RoXSk7aWYoIWwpcmV0dXJuO2cucHVzaChsWzBdKSxoLnB1c2gobFsxXSksaS5wdXNoKGxbMl0pfXJldHVybltnLGgsZnVuY3Rpb24oYil7dmFyIGQ9Yi5tYXAoZnVuY3Rpb24oYSxiKXtyZXR1cm4gaVtiXShhKX0pLmpvaW4oYyk7cmV0dXJuIGE/YShkKTpkfV19ZnVuY3Rpb24gayhhLGIsYyl7Zm9yKHZhciBkPVtdLGU9W10sZj1bXSxnPTAsaD0wO2g8Yy5sZW5ndGg7aCsrKWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mIGNbaF0pe3ZhciBpPWNbaF0oYVtnXSxiW2crK10pO2QucHVzaChpWzBdKSxlLnB1c2goaVsxXSksZi5wdXNoKGlbMl0pfWVsc2UhZnVuY3Rpb24oYSl7ZC5wdXNoKCExKSxlLnB1c2goITEpLGYucHVzaChmdW5jdGlvbigpe3JldHVybiBjW2FdfSl9KGgpO3JldHVybltkLGUsZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVwiXCIsYz0wO2M8YS5sZW5ndGg7YysrKWIrPWZbY10oYVtjXSk7cmV0dXJuIGJ9XX1hLmNvbnN1bWVUb2tlbj1iLGEuY29uc3VtZVRyaW1tZWQ9YyxhLmNvbnN1bWVSZXBlYXRlZD1kLGEuY29uc3VtZVBhcmVudGhlc2lzZWQ9ZSxhLmlnbm9yZT1nLGEub3B0aW9uYWw9aCxhLmNvbnN1bWVMaXN0PWksYS5tZXJnZU5lc3RlZFJlcGVhdGVkPWouYmluZChudWxsLG51bGwpLGEubWVyZ2VXcmFwcGVkTmVzdGVkUmVwZWF0ZWQ9aixhLm1lcmdlTGlzdD1rfShkKSxmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGIpe2Z1bmN0aW9uIGMoYil7dmFyIGM9YS5jb25zdW1lVG9rZW4oL15pbnNldC9pLGIpO2lmKGMpcmV0dXJuIGQuaW5zZXQ9ITAsYzt2YXIgYz1hLmNvbnN1bWVMZW5ndGhPclBlcmNlbnQoYik7aWYoYylyZXR1cm4gZC5sZW5ndGhzLnB1c2goY1swXSksYzt2YXIgYz1hLmNvbnN1bWVDb2xvcihiKTtyZXR1cm4gYz8oZC5jb2xvcj1jWzBdLGMpOnZvaWQgMH12YXIgZD17aW5zZXQ6ITEsbGVuZ3RoczpbXSxjb2xvcjpudWxsfSxlPWEuY29uc3VtZVJlcGVhdGVkKGMsL14vLGIpO2lmKGUmJmVbMF0ubGVuZ3RoKXJldHVybltkLGVbMV1dfWZ1bmN0aW9uIGMoYyl7dmFyIGQ9YS5jb25zdW1lUmVwZWF0ZWQoYiwvXiwvLGMpO2lmKGQmJlwiXCI9PWRbMV0pcmV0dXJuIGRbMF19ZnVuY3Rpb24gZChiLGMpe2Zvcig7Yi5sZW5ndGhzLmxlbmd0aDxNYXRoLm1heChiLmxlbmd0aHMubGVuZ3RoLGMubGVuZ3Rocy5sZW5ndGgpOyliLmxlbmd0aHMucHVzaCh7cHg6MH0pO2Zvcig7Yy5sZW5ndGhzLmxlbmd0aDxNYXRoLm1heChiLmxlbmd0aHMubGVuZ3RoLGMubGVuZ3Rocy5sZW5ndGgpOyljLmxlbmd0aHMucHVzaCh7cHg6MH0pO2lmKGIuaW5zZXQ9PWMuaW5zZXQmJiEhYi5jb2xvcj09ISFjLmNvbG9yKXtmb3IodmFyIGQsZT1bXSxmPVtbXSwwXSxnPVtbXSwwXSxoPTA7aDxiLmxlbmd0aHMubGVuZ3RoO2grKyl7dmFyIGk9YS5tZXJnZURpbWVuc2lvbnMoYi5sZW5ndGhzW2hdLGMubGVuZ3Roc1toXSwyPT1oKTtmWzBdLnB1c2goaVswXSksZ1swXS5wdXNoKGlbMV0pLGUucHVzaChpWzJdKX1pZihiLmNvbG9yJiZjLmNvbG9yKXt2YXIgaj1hLm1lcmdlQ29sb3JzKGIuY29sb3IsYy5jb2xvcik7ZlsxXT1qWzBdLGdbMV09alsxXSxkPWpbMl19cmV0dXJuW2YsZyxmdW5jdGlvbihhKXtmb3IodmFyIGM9Yi5pbnNldD9cImluc2V0IFwiOlwiIFwiLGY9MDtmPGUubGVuZ3RoO2YrKyljKz1lW2ZdKGFbMF1bZl0pK1wiIFwiO3JldHVybiBkJiYoYys9ZChhWzFdKSksY31dfX1mdW5jdGlvbiBlKGIsYyxkLGUpe2Z1bmN0aW9uIGYoYSl7cmV0dXJue2luc2V0OmEsY29sb3I6WzAsMCwwLDBdLGxlbmd0aHM6W3tweDowfSx7cHg6MH0se3B4OjB9LHtweDowfV19fWZvcih2YXIgZz1bXSxoPVtdLGk9MDtpPGQubGVuZ3RofHxpPGUubGVuZ3RoO2krKyl7dmFyIGo9ZFtpXXx8ZihlW2ldLmluc2V0KSxrPWVbaV18fGYoZFtpXS5pbnNldCk7Zy5wdXNoKGopLGgucHVzaChrKX1yZXR1cm4gYS5tZXJnZU5lc3RlZFJlcGVhdGVkKGIsYyxnLGgpfXZhciBmPWUuYmluZChudWxsLGQsXCIsIFwiKTthLmFkZFByb3BlcnRpZXNIYW5kbGVyKGMsZixbXCJib3gtc2hhZG93XCIsXCJ0ZXh0LXNoYWRvd1wiXSl9KGQpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gYS50b0ZpeGVkKDMpLnJlcGxhY2UoLzArJC8sXCJcIikucmVwbGFjZSgvXFwuJC8sXCJcIil9ZnVuY3Rpb24gZChhLGIsYyl7cmV0dXJuIE1hdGgubWluKGIsTWF0aC5tYXgoYSxjKSl9ZnVuY3Rpb24gZShhKXtpZigvXlxccypbLStdPyhcXGQqXFwuKT9cXGQrXFxzKiQvLnRlc3QoYSkpcmV0dXJuIE51bWJlcihhKX1mdW5jdGlvbiBmKGEsYil7cmV0dXJuW2EsYixjXX1mdW5jdGlvbiBnKGEsYil7aWYoMCE9YSlyZXR1cm4gaSgwLDEvMCkoYSxiKX1mdW5jdGlvbiBoKGEsYil7cmV0dXJuW2EsYixmdW5jdGlvbihhKXtyZXR1cm4gTWF0aC5yb3VuZChkKDEsMS8wLGEpKX1dfWZ1bmN0aW9uIGkoYSxiKXtyZXR1cm4gZnVuY3Rpb24oZSxmKXtyZXR1cm5bZSxmLGZ1bmN0aW9uKGUpe3JldHVybiBjKGQoYSxiLGUpKX1dfX1mdW5jdGlvbiBqKGEpe3ZhciBiPWEudHJpbSgpLnNwbGl0KC9cXHMqW1xccyxdXFxzKi8pO2lmKDAhPT1iLmxlbmd0aCl7Zm9yKHZhciBjPVtdLGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGY9ZShiW2RdKTtpZih2b2lkIDA9PT1mKXJldHVybjtjLnB1c2goZil9cmV0dXJuIGN9fWZ1bmN0aW9uIGsoYSxiKXtpZihhLmxlbmd0aD09Yi5sZW5ndGgpcmV0dXJuW2EsYixmdW5jdGlvbihhKXtyZXR1cm4gYS5tYXAoYykuam9pbihcIiBcIil9XX1mdW5jdGlvbiBsKGEsYil7cmV0dXJuW2EsYixNYXRoLnJvdW5kXX1hLmNsYW1wPWQsYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihqLGssW1wic3Ryb2tlLWRhc2hhcnJheVwiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihlLGkoMCwxLzApLFtcImJvcmRlci1pbWFnZS13aWR0aFwiLFwibGluZS1oZWlnaHRcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxpKDAsMSksW1wib3BhY2l0eVwiLFwic2hhcGUtaW1hZ2UtdGhyZXNob2xkXCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsZyxbXCJmbGV4LWdyb3dcIixcImZsZXgtc2hyaW5rXCJdKSxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGUsaCxbXCJvcnBoYW5zXCIsXCJ3aWRvd3NcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxsLFtcInotaW5kZXhcIl0pLGEucGFyc2VOdW1iZXI9ZSxhLnBhcnNlTnVtYmVyTGlzdD1qLGEubWVyZ2VOdW1iZXJzPWYsYS5udW1iZXJUb1N0cmluZz1jfShkKSxmdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoYSxiKXtpZihcInZpc2libGVcIj09YXx8XCJ2aXNpYmxlXCI9PWIpcmV0dXJuWzAsMSxmdW5jdGlvbihjKXtyZXR1cm4gYzw9MD9hOmM+PTE/YjpcInZpc2libGVcIn1dfWEuYWRkUHJvcGVydGllc0hhbmRsZXIoU3RyaW5nLGMsW1widmlzaWJpbGl0eVwiXSl9KGQpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhhKXthPWEudHJpbSgpLGYuZmlsbFN0eWxlPVwiIzAwMFwiLGYuZmlsbFN0eWxlPWE7dmFyIGI9Zi5maWxsU3R5bGU7aWYoZi5maWxsU3R5bGU9XCIjZmZmXCIsZi5maWxsU3R5bGU9YSxiPT1mLmZpbGxTdHlsZSl7Zi5maWxsUmVjdCgwLDAsMSwxKTt2YXIgYz1mLmdldEltYWdlRGF0YSgwLDAsMSwxKS5kYXRhO2YuY2xlYXJSZWN0KDAsMCwxLDEpO3ZhciBkPWNbM10vMjU1O3JldHVybltjWzBdKmQsY1sxXSpkLGNbMl0qZCxkXX19ZnVuY3Rpb24gZChiLGMpe3JldHVybltiLGMsZnVuY3Rpb24oYil7ZnVuY3Rpb24gYyhhKXtyZXR1cm4gTWF0aC5tYXgoMCxNYXRoLm1pbigyNTUsYSkpfWlmKGJbM10pZm9yKHZhciBkPTA7ZDwzO2QrKyliW2RdPU1hdGgucm91bmQoYyhiW2RdL2JbM10pKTtyZXR1cm4gYlszXT1hLm51bWJlclRvU3RyaW5nKGEuY2xhbXAoMCwxLGJbM10pKSxcInJnYmEoXCIrYi5qb2luKFwiLFwiKStcIilcIn1dfXZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcImNhbnZhc1wiKTtlLndpZHRoPWUuaGVpZ2h0PTE7dmFyIGY9ZS5nZXRDb250ZXh0KFwiMmRcIik7YS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihjLGQsW1wiYmFja2dyb3VuZC1jb2xvclwiLFwiYm9yZGVyLWJvdHRvbS1jb2xvclwiLFwiYm9yZGVyLWxlZnQtY29sb3JcIixcImJvcmRlci1yaWdodC1jb2xvclwiLFwiYm9yZGVyLXRvcC1jb2xvclwiLFwiY29sb3JcIixcImZpbGxcIixcImZsb29kLWNvbG9yXCIsXCJsaWdodGluZy1jb2xvclwiLFwib3V0bGluZS1jb2xvclwiLFwic3RvcC1jb2xvclwiLFwic3Ryb2tlXCIsXCJ0ZXh0LWRlY29yYXRpb24tY29sb3JcIl0pLGEuY29uc3VtZUNvbG9yPWEuY29uc3VtZVBhcmVudGhlc2lzZWQuYmluZChudWxsLGMpLGEubWVyZ2VDb2xvcnM9ZH0oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe2Z1bmN0aW9uIGIoKXt2YXIgYj1oLmV4ZWMoYSk7Zz1iP2JbMF06dm9pZCAwfWZ1bmN0aW9uIGMoKXt2YXIgYT1OdW1iZXIoZyk7cmV0dXJuIGIoKSxhfWZ1bmN0aW9uIGQoKXtpZihcIihcIiE9PWcpcmV0dXJuIGMoKTtiKCk7dmFyIGE9ZigpO3JldHVyblwiKVwiIT09Zz9OYU46KGIoKSxhKX1mdW5jdGlvbiBlKCl7Zm9yKHZhciBhPWQoKTtcIipcIj09PWd8fFwiL1wiPT09Zzspe3ZhciBjPWc7YigpO3ZhciBlPWQoKTtcIipcIj09PWM/YSo9ZTphLz1lfXJldHVybiBhfWZ1bmN0aW9uIGYoKXtmb3IodmFyIGE9ZSgpO1wiK1wiPT09Z3x8XCItXCI9PT1nOyl7dmFyIGM9ZztiKCk7dmFyIGQ9ZSgpO1wiK1wiPT09Yz9hKz1kOmEtPWR9cmV0dXJuIGF9dmFyIGcsaD0vKFtcXCtcXC1cXHdcXC5dK3xbXFwoXFwpXFwqXFwvXSkvZztyZXR1cm4gYigpLGYoKX1mdW5jdGlvbiBkKGEsYil7aWYoXCIwXCI9PShiPWIudHJpbSgpLnRvTG93ZXJDYXNlKCkpJiZcInB4XCIuc2VhcmNoKGEpPj0wKXJldHVybntweDowfTtpZigvXlteKF0qJHxeY2FsYy8udGVzdChiKSl7Yj1iLnJlcGxhY2UoL2NhbGNcXCgvZyxcIihcIik7dmFyIGQ9e307Yj1iLnJlcGxhY2UoYSxmdW5jdGlvbihhKXtyZXR1cm4gZFthXT1udWxsLFwiVVwiK2F9KTtmb3IodmFyIGU9XCJVKFwiK2Euc291cmNlK1wiKVwiLGY9Yi5yZXBsYWNlKC9bLStdPyhcXGQqXFwuKT9cXGQrKFtFZV1bLStdP1xcZCspPy9nLFwiTlwiKS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJOXCIrZSxcImdcIiksXCJEXCIpLnJlcGxhY2UoL1xcc1srLV1cXHMvZyxcIk9cIikucmVwbGFjZSgvXFxzL2csXCJcIiksZz1bL05cXCooRCkvZywvKE58RClbKlxcL11OL2csLyhOfEQpT1xcMS9nLC9cXCgoTnxEKVxcKS9nXSxoPTA7aDxnLmxlbmd0aDspZ1toXS50ZXN0KGYpPyhmPWYucmVwbGFjZShnW2hdLFwiJDFcIiksaD0wKTpoKys7aWYoXCJEXCI9PWYpe2Zvcih2YXIgaSBpbiBkKXt2YXIgaj1jKGIucmVwbGFjZShuZXcgUmVnRXhwKFwiVVwiK2ksXCJnXCIpLFwiXCIpLnJlcGxhY2UobmV3IFJlZ0V4cChlLFwiZ1wiKSxcIiowXCIpKTtpZighaXNGaW5pdGUoaikpcmV0dXJuO2RbaV09an1yZXR1cm4gZH19fWZ1bmN0aW9uIGUoYSxiKXtyZXR1cm4gZihhLGIsITApfWZ1bmN0aW9uIGYoYixjLGQpe3ZhciBlLGY9W107Zm9yKGUgaW4gYilmLnB1c2goZSk7Zm9yKGUgaW4gYylmLmluZGV4T2YoZSk8MCYmZi5wdXNoKGUpO3JldHVybiBiPWYubWFwKGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfHwwfSksYz1mLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gY1thXXx8MH0pLFtiLGMsZnVuY3Rpb24oYil7dmFyIGM9Yi5tYXAoZnVuY3Rpb24oYyxlKXtyZXR1cm4gMT09Yi5sZW5ndGgmJmQmJihjPU1hdGgubWF4KGMsMCkpLGEubnVtYmVyVG9TdHJpbmcoYykrZltlXX0pLmpvaW4oXCIgKyBcIik7cmV0dXJuIGIubGVuZ3RoPjE/XCJjYWxjKFwiK2MrXCIpXCI6Y31dfXZhciBnPVwicHh8ZW18ZXh8Y2h8cmVtfHZ3fHZofHZtaW58dm1heHxjbXxtbXxpbnxwdHxwY1wiLGg9ZC5iaW5kKG51bGwsbmV3IFJlZ0V4cChnLFwiZ1wiKSksaT1kLmJpbmQobnVsbCxuZXcgUmVnRXhwKGcrXCJ8JVwiLFwiZ1wiKSksaj1kLmJpbmQobnVsbCwvZGVnfHJhZHxncmFkfHR1cm4vZyk7YS5wYXJzZUxlbmd0aD1oLGEucGFyc2VMZW5ndGhPclBlcmNlbnQ9aSxhLmNvbnN1bWVMZW5ndGhPclBlcmNlbnQ9YS5jb25zdW1lUGFyZW50aGVzaXNlZC5iaW5kKG51bGwsaSksYS5wYXJzZUFuZ2xlPWosYS5tZXJnZURpbWVuc2lvbnM9Zjt2YXIgaz1hLmNvbnN1bWVQYXJlbnRoZXNpc2VkLmJpbmQobnVsbCxoKSxsPWEuY29uc3VtZVJlcGVhdGVkLmJpbmQodm9pZCAwLGssL14vKSxtPWEuY29uc3VtZVJlcGVhdGVkLmJpbmQodm9pZCAwLGwsL14sLyk7YS5jb25zdW1lU2l6ZVBhaXJMaXN0PW07dmFyIG49ZnVuY3Rpb24oYSl7dmFyIGI9bShhKTtpZihiJiZcIlwiPT1iWzFdKXJldHVybiBiWzBdfSxvPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKHZvaWQgMCxlLFwiIFwiKSxwPWEubWVyZ2VOZXN0ZWRSZXBlYXRlZC5iaW5kKHZvaWQgMCxvLFwiLFwiKTthLm1lcmdlTm9uTmVnYXRpdmVTaXplUGFpcj1vLGEuYWRkUHJvcGVydGllc0hhbmRsZXIobixwLFtcImJhY2tncm91bmQtc2l6ZVwiXSksYS5hZGRQcm9wZXJ0aWVzSGFuZGxlcihpLGUsW1wiYm9yZGVyLWJvdHRvbS13aWR0aFwiLFwiYm9yZGVyLWltYWdlLXdpZHRoXCIsXCJib3JkZXItbGVmdC13aWR0aFwiLFwiYm9yZGVyLXJpZ2h0LXdpZHRoXCIsXCJib3JkZXItdG9wLXdpZHRoXCIsXCJmbGV4LWJhc2lzXCIsXCJmb250LXNpemVcIixcImhlaWdodFwiLFwibGluZS1oZWlnaHRcIixcIm1heC1oZWlnaHRcIixcIm1heC13aWR0aFwiLFwib3V0bGluZS13aWR0aFwiLFwid2lkdGhcIl0pLGEuYWRkUHJvcGVydGllc0hhbmRsZXIoaSxmLFtcImJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXNcIixcImJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzXCIsXCJib3JkZXItdG9wLWxlZnQtcmFkaXVzXCIsXCJib3JkZXItdG9wLXJpZ2h0LXJhZGl1c1wiLFwiYm90dG9tXCIsXCJsZWZ0XCIsXCJsZXR0ZXItc3BhY2luZ1wiLFwibWFyZ2luLWJvdHRvbVwiLFwibWFyZ2luLWxlZnRcIixcIm1hcmdpbi1yaWdodFwiLFwibWFyZ2luLXRvcFwiLFwibWluLWhlaWdodFwiLFwibWluLXdpZHRoXCIsXCJvdXRsaW5lLW9mZnNldFwiLFwicGFkZGluZy1ib3R0b21cIixcInBhZGRpbmctbGVmdFwiLFwicGFkZGluZy1yaWdodFwiLFwicGFkZGluZy10b3BcIixcInBlcnNwZWN0aXZlXCIsXCJyaWdodFwiLFwic2hhcGUtbWFyZ2luXCIsXCJzdHJva2UtZGFzaG9mZnNldFwiLFwidGV4dC1pbmRlbnRcIixcInRvcFwiLFwidmVydGljYWwtYWxpZ25cIixcIndvcmQtc3BhY2luZ1wiXSl9KGQpLGZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYyhiKXtyZXR1cm4gYS5jb25zdW1lTGVuZ3RoT3JQZXJjZW50KGIpfHxhLmNvbnN1bWVUb2tlbigvXmF1dG8vLGIpfWZ1bmN0aW9uIGQoYil7dmFyIGQ9YS5jb25zdW1lTGlzdChbYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZChudWxsLC9ecmVjdC8pKSxhLmlnbm9yZShhLmNvbnN1bWVUb2tlbi5iaW5kKG51bGwsL15cXCgvKSksYS5jb25zdW1lUmVwZWF0ZWQuYmluZChudWxsLGMsL14sLyksYS5pZ25vcmUoYS5jb25zdW1lVG9rZW4uYmluZChudWxsLC9eXFwpLykpXSxiKTtpZihkJiY0PT1kWzBdLmxlbmd0aClyZXR1cm4gZFswXX1mdW5jdGlvbiBlKGIsYyl7cmV0dXJuXCJhdXRvXCI9PWJ8fFwiYXV0b1wiPT1jP1shMCwhMSxmdW5jdGlvbihkKXt2YXIgZT1kP2I6YztpZihcImF1dG9cIj09ZSlyZXR1cm5cImF1dG9cIjt2YXIgZj1hLm1lcmdlRGltZW5zaW9ucyhlLGUpO3JldHVybiBmWzJdKGZbMF0pfV06YS5tZXJnZURpbWVuc2lvbnMoYixjKX1mdW5jdGlvbiBmKGEpe3JldHVyblwicmVjdChcIithK1wiKVwifXZhciBnPWEubWVyZ2VXcmFwcGVkTmVzdGVkUmVwZWF0ZWQuYmluZChudWxsLGYsZSxcIiwgXCIpO2EucGFyc2VCb3g9ZCxhLm1lcmdlQm94ZXM9ZyxhLmFkZFByb3BlcnRpZXNIYW5kbGVyKGQsZyxbXCJjbGlwXCJdKX0oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEpe3JldHVybiBmdW5jdGlvbihiKXt2YXIgYz0wO3JldHVybiBhLm1hcChmdW5jdGlvbihhKXtyZXR1cm4gYT09PWs/YltjKytdOmF9KX19ZnVuY3Rpb24gZChhKXtyZXR1cm4gYX1mdW5jdGlvbiBlKGIpe2lmKFwibm9uZVwiPT0oYj1iLnRvTG93ZXJDYXNlKCkudHJpbSgpKSlyZXR1cm5bXTtmb3IodmFyIGMsZD0vXFxzKihcXHcrKVxcKChbXildKilcXCkvZyxlPVtdLGY9MDtjPWQuZXhlYyhiKTspe2lmKGMuaW5kZXghPWYpcmV0dXJuO2Y9Yy5pbmRleCtjWzBdLmxlbmd0aDt2YXIgZz1jWzFdLGg9bltnXTtpZighaClyZXR1cm47dmFyIGk9Y1syXS5zcGxpdChcIixcIiksaj1oWzBdO2lmKGoubGVuZ3RoPGkubGVuZ3RoKXJldHVybjtmb3IodmFyIGs9W10sbz0wO288ai5sZW5ndGg7bysrKXt2YXIgcCxxPWlbb10scj1qW29dO2lmKHZvaWQgMD09PShwPXE/e0E6ZnVuY3Rpb24oYil7cmV0dXJuXCIwXCI9PWIudHJpbSgpP206YS5wYXJzZUFuZ2xlKGIpfSxOOmEucGFyc2VOdW1iZXIsVDphLnBhcnNlTGVuZ3RoT3JQZXJjZW50LEw6YS5wYXJzZUxlbmd0aH1bci50b1VwcGVyQ2FzZSgpXShxKTp7YTptLG46a1swXSx0Omx9W3JdKSlyZXR1cm47ay5wdXNoKHApfWlmKGUucHVzaCh7dDpnLGQ6a30pLGQubGFzdEluZGV4PT1iLmxlbmd0aClyZXR1cm4gZX19ZnVuY3Rpb24gZihhKXtyZXR1cm4gYS50b0ZpeGVkKDYpLnJlcGxhY2UoXCIuMDAwMDAwXCIsXCJcIil9ZnVuY3Rpb24gZyhiLGMpe2lmKGIuZGVjb21wb3NpdGlvblBhaXIhPT1jKXtiLmRlY29tcG9zaXRpb25QYWlyPWM7dmFyIGQ9YS5tYWtlTWF0cml4RGVjb21wb3NpdGlvbihiKX1pZihjLmRlY29tcG9zaXRpb25QYWlyIT09Yil7Yy5kZWNvbXBvc2l0aW9uUGFpcj1iO3ZhciBlPWEubWFrZU1hdHJpeERlY29tcG9zaXRpb24oYyl9cmV0dXJuIG51bGw9PWRbMF18fG51bGw9PWVbMF0/W1shMV0sWyEwXSxmdW5jdGlvbihhKXtyZXR1cm4gYT9jWzBdLmQ6YlswXS5kfV06KGRbMF0ucHVzaCgwKSxlWzBdLnB1c2goMSksW2QsZSxmdW5jdGlvbihiKXt2YXIgYz1hLnF1YXQoZFswXVszXSxlWzBdWzNdLGJbNV0pO3JldHVybiBhLmNvbXBvc2VNYXRyaXgoYlswXSxiWzFdLGJbMl0sYyxiWzRdKS5tYXAoZikuam9pbihcIixcIil9XSl9ZnVuY3Rpb24gaChhKXtyZXR1cm4gYS5yZXBsYWNlKC9beHldLyxcIlwiKX1mdW5jdGlvbiBpKGEpe3JldHVybiBhLnJlcGxhY2UoLyh4fHl8enwzZCk/JC8sXCIzZFwiKX1mdW5jdGlvbiBqKGIsYyl7dmFyIGQ9YS5tYWtlTWF0cml4RGVjb21wb3NpdGlvbiYmITAsZT0hMTtpZighYi5sZW5ndGh8fCFjLmxlbmd0aCl7Yi5sZW5ndGh8fChlPSEwLGI9YyxjPVtdKTtmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrKyl7dmFyIGo9YltmXS50LGs9YltmXS5kLGw9XCJzY2FsZVwiPT1qLnN1YnN0cigwLDUpPzE6MDtjLnB1c2goe3Q6aixkOmsubWFwKGZ1bmN0aW9uKGEpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhKXJldHVybiBsO3ZhciBiPXt9O2Zvcih2YXIgYyBpbiBhKWJbY109bDtyZXR1cm4gYn0pfSl9fXZhciBtPWZ1bmN0aW9uKGEsYil7cmV0dXJuXCJwZXJzcGVjdGl2ZVwiPT1hJiZcInBlcnNwZWN0aXZlXCI9PWJ8fChcIm1hdHJpeFwiPT1hfHxcIm1hdHJpeDNkXCI9PWEpJiYoXCJtYXRyaXhcIj09Ynx8XCJtYXRyaXgzZFwiPT1iKX0sbz1bXSxwPVtdLHE9W107aWYoYi5sZW5ndGghPWMubGVuZ3RoKXtpZighZClyZXR1cm47dmFyIHI9ZyhiLGMpO289W3JbMF1dLHA9W3JbMV1dLHE9W1tcIm1hdHJpeFwiLFtyWzJdXV1dfWVsc2UgZm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKyspe3ZhciBqLHM9YltmXS50LHQ9Y1tmXS50LHU9YltmXS5kLHY9Y1tmXS5kLHc9bltzXSx4PW5bdF07aWYobShzLHQpKXtpZighZClyZXR1cm47dmFyIHI9ZyhbYltmXV0sW2NbZl1dKTtvLnB1c2goclswXSkscC5wdXNoKHJbMV0pLHEucHVzaChbXCJtYXRyaXhcIixbclsyXV1dKX1lbHNle2lmKHM9PXQpaj1zO2Vsc2UgaWYod1syXSYmeFsyXSYmaChzKT09aCh0KSlqPWgocyksdT13WzJdKHUpLHY9eFsyXSh2KTtlbHNle2lmKCF3WzFdfHwheFsxXXx8aShzKSE9aSh0KSl7aWYoIWQpcmV0dXJuO3ZhciByPWcoYixjKTtvPVtyWzBdXSxwPVtyWzFdXSxxPVtbXCJtYXRyaXhcIixbclsyXV1dXTticmVha31qPWkocyksdT13WzFdKHUpLHY9eFsxXSh2KX1mb3IodmFyIHk9W10sej1bXSxBPVtdLEI9MDtCPHUubGVuZ3RoO0IrKyl7dmFyIEM9XCJudW1iZXJcIj09dHlwZW9mIHVbQl0/YS5tZXJnZU51bWJlcnM6YS5tZXJnZURpbWVuc2lvbnMscj1DKHVbQl0sdltCXSk7eVtCXT1yWzBdLHpbQl09clsxXSxBLnB1c2goclsyXSl9by5wdXNoKHkpLHAucHVzaCh6KSxxLnB1c2goW2osQV0pfX1pZihlKXt2YXIgRD1vO289cCxwPUR9cmV0dXJuW28scCxmdW5jdGlvbihhKXtyZXR1cm4gYS5tYXAoZnVuY3Rpb24oYSxiKXt2YXIgYz1hLm1hcChmdW5jdGlvbihhLGMpe3JldHVybiBxW2JdWzFdW2NdKGEpfSkuam9pbihcIixcIik7cmV0dXJuXCJtYXRyaXhcIj09cVtiXVswXSYmMTY9PWMuc3BsaXQoXCIsXCIpLmxlbmd0aCYmKHFbYl1bMF09XCJtYXRyaXgzZFwiKSxxW2JdWzBdK1wiKFwiK2MrXCIpXCJ9KS5qb2luKFwiIFwiKX1dfXZhciBrPW51bGwsbD17cHg6MH0sbT17ZGVnOjB9LG49e21hdHJpeDpbXCJOTk5OTk5cIixbayxrLDAsMCxrLGssMCwwLDAsMCwxLDAsayxrLDAsMV0sZF0sbWF0cml4M2Q6W1wiTk5OTk5OTk5OTk5OTk5OTlwiLGRdLHJvdGF0ZTpbXCJBXCJdLHJvdGF0ZXg6W1wiQVwiXSxyb3RhdGV5OltcIkFcIl0scm90YXRlejpbXCJBXCJdLHJvdGF0ZTNkOltcIk5OTkFcIl0scGVyc3BlY3RpdmU6W1wiTFwiXSxzY2FsZTpbXCJOblwiLGMoW2ssaywxXSksZF0sc2NhbGV4OltcIk5cIixjKFtrLDEsMV0pLGMoW2ssMV0pXSxzY2FsZXk6W1wiTlwiLGMoWzEsaywxXSksYyhbMSxrXSldLHNjYWxlejpbXCJOXCIsYyhbMSwxLGtdKV0sc2NhbGUzZDpbXCJOTk5cIixkXSxza2V3OltcIkFhXCIsbnVsbCxkXSxza2V3eDpbXCJBXCIsbnVsbCxjKFtrLG1dKV0sc2tld3k6W1wiQVwiLG51bGwsYyhbbSxrXSldLHRyYW5zbGF0ZTpbXCJUdFwiLGMoW2ssayxsXSksZF0sdHJhbnNsYXRleDpbXCJUXCIsYyhbayxsLGxdKSxjKFtrLGxdKV0sdHJhbnNsYXRleTpbXCJUXCIsYyhbbCxrLGxdKSxjKFtsLGtdKV0sdHJhbnNsYXRlejpbXCJMXCIsYyhbbCxsLGtdKV0sdHJhbnNsYXRlM2Q6W1wiVFRMXCIsZF19O2EuYWRkUHJvcGVydGllc0hhbmRsZXIoZSxqLFtcInRyYW5zZm9ybVwiXSksYS50cmFuc2Zvcm1Ub1N2Z01hdHJpeD1mdW5jdGlvbihiKXt2YXIgYz1hLnRyYW5zZm9ybUxpc3RUb01hdHJpeChlKGIpKTtyZXR1cm5cIm1hdHJpeChcIitmKGNbMF0pK1wiIFwiK2YoY1sxXSkrXCIgXCIrZihjWzRdKStcIiBcIitmKGNbNV0pK1wiIFwiK2YoY1sxMl0pK1wiIFwiK2YoY1sxM10pK1wiKVwifX0oZCksZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKGEsYil7Yi5jb25jYXQoW2FdKS5mb3JFYWNoKGZ1bmN0aW9uKGIpe2IgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlJiYoZFthXT1iKSxlW2JdPWF9KX12YXIgZD17fSxlPXt9O2MoXCJ0cmFuc2Zvcm1cIixbXCJ3ZWJraXRUcmFuc2Zvcm1cIixcIm1zVHJhbnNmb3JtXCJdKSxjKFwidHJhbnNmb3JtT3JpZ2luXCIsW1wid2Via2l0VHJhbnNmb3JtT3JpZ2luXCJdKSxjKFwicGVyc3BlY3RpdmVcIixbXCJ3ZWJraXRQZXJzcGVjdGl2ZVwiXSksYyhcInBlcnNwZWN0aXZlT3JpZ2luXCIsW1wid2Via2l0UGVyc3BlY3RpdmVPcmlnaW5cIl0pLGEucHJvcGVydHlOYW1lPWZ1bmN0aW9uKGEpe3JldHVybiBkW2FdfHxhfSxhLnVucHJlZml4ZWRQcm9wZXJ0eU5hbWU9ZnVuY3Rpb24oYSl7cmV0dXJuIGVbYV18fGF9fShkKX0oKSxmdW5jdGlvbigpe2lmKHZvaWQgMD09PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuYW5pbWF0ZShbXSkub25jYW5jZWwpe3ZhciBhO2lmKHdpbmRvdy5wZXJmb3JtYW5jZSYmcGVyZm9ybWFuY2Uubm93KXZhciBhPWZ1bmN0aW9uKCl7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfTtlbHNlIHZhciBhPWZ1bmN0aW9uKCl7cmV0dXJuIERhdGUubm93KCl9O3ZhciBiPWZ1bmN0aW9uKGEsYixjKXt0aGlzLnRhcmdldD1hLHRoaXMuY3VycmVudFRpbWU9Yix0aGlzLnRpbWVsaW5lVGltZT1jLHRoaXMudHlwZT1cImNhbmNlbFwiLHRoaXMuYnViYmxlcz0hMSx0aGlzLmNhbmNlbGFibGU9ITEsdGhpcy5jdXJyZW50VGFyZ2V0PWEsdGhpcy5kZWZhdWx0UHJldmVudGVkPSExLHRoaXMuZXZlbnRQaGFzZT1FdmVudC5BVF9UQVJHRVQsdGhpcy50aW1lU3RhbXA9RGF0ZS5ub3coKX0sYz13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZTt3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihkLGUpe3ZhciBmPWMuY2FsbCh0aGlzLGQsZSk7Zi5fY2FuY2VsSGFuZGxlcnM9W10sZi5vbmNhbmNlbD1udWxsO3ZhciBnPWYuY2FuY2VsO2YuY2FuY2VsPWZ1bmN0aW9uKCl7Zy5jYWxsKHRoaXMpO3ZhciBjPW5ldyBiKHRoaXMsbnVsbCxhKCkpLGQ9dGhpcy5fY2FuY2VsSGFuZGxlcnMuY29uY2F0KHRoaXMub25jYW5jZWw/W3RoaXMub25jYW5jZWxdOltdKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7ZC5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EuY2FsbChjLnRhcmdldCxjKX0pfSwwKX07dmFyIGg9Zi5hZGRFdmVudExpc3RlbmVyO2YuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIpe1wiZnVuY3Rpb25cIj09dHlwZW9mIGImJlwiY2FuY2VsXCI9PWE/dGhpcy5fY2FuY2VsSGFuZGxlcnMucHVzaChiKTpoLmNhbGwodGhpcyxhLGIpfTt2YXIgaT1mLnJlbW92ZUV2ZW50TGlzdGVuZXI7cmV0dXJuIGYucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIpe2lmKFwiY2FuY2VsXCI9PWEpe3ZhciBjPXRoaXMuX2NhbmNlbEhhbmRsZXJzLmluZGV4T2YoYik7Yz49MCYmdGhpcy5fY2FuY2VsSGFuZGxlcnMuc3BsaWNlKGMsMSl9ZWxzZSBpLmNhbGwodGhpcyxhLGIpfSxmfX19KCksZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGM9bnVsbCxkPSExO3RyeXt2YXIgZT1nZXRDb21wdXRlZFN0eWxlKGIpLmdldFByb3BlcnR5VmFsdWUoXCJvcGFjaXR5XCIpLGY9XCIwXCI9PWU/XCIxXCI6XCIwXCI7Yz1iLmFuaW1hdGUoe29wYWNpdHk6W2YsZl19LHtkdXJhdGlvbjoxfSksYy5jdXJyZW50VGltZT0wLGQ9Z2V0Q29tcHV0ZWRTdHlsZShiKS5nZXRQcm9wZXJ0eVZhbHVlKFwib3BhY2l0eVwiKT09Zn1jYXRjaChhKXt9ZmluYWxseXtjJiZjLmNhbmNlbCgpfWlmKCFkKXt2YXIgZz13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZTt3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZT1mdW5jdGlvbihiLGMpe3JldHVybiB3aW5kb3cuU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3ImJkFycmF5LnByb3RvdHlwZS5mcm9tJiZiW1N5bWJvbC5pdGVyYXRvcl0mJihiPUFycmF5LmZyb20oYikpLEFycmF5LmlzQXJyYXkoYil8fG51bGw9PT1ifHwoYj1hLmNvbnZlcnRUb0FycmF5Rm9ybShiKSksZy5jYWxsKHRoaXMsYixjKX19fShjKSxmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXt2YXIgYz1iLnRpbWVsaW5lO2MuY3VycmVudFRpbWU9YSxjLl9kaXNjYXJkQW5pbWF0aW9ucygpLDA9PWMuX2FuaW1hdGlvbnMubGVuZ3RoP2Y9ITE6cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGQpfXZhciBlPXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZT1mdW5jdGlvbihhKXtyZXR1cm4gZShmdW5jdGlvbihjKXtiLnRpbWVsaW5lLl91cGRhdGVBbmltYXRpb25zUHJvbWlzZXMoKSxhKGMpLGIudGltZWxpbmUuX3VwZGF0ZUFuaW1hdGlvbnNQcm9taXNlcygpfSl9LGIuQW5pbWF0aW9uVGltZWxpbmU9ZnVuY3Rpb24oKXt0aGlzLl9hbmltYXRpb25zPVtdLHRoaXMuY3VycmVudFRpbWU9dm9pZCAwfSxiLkFuaW1hdGlvblRpbWVsaW5lLnByb3RvdHlwZT17Z2V0QW5pbWF0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kaXNjYXJkQW5pbWF0aW9ucygpLHRoaXMuX2FuaW1hdGlvbnMuc2xpY2UoKX0sX3VwZGF0ZUFuaW1hdGlvbnNQcm9taXNlczpmdW5jdGlvbigpe2IuYW5pbWF0aW9uc1dpdGhQcm9taXNlcz1iLmFuaW1hdGlvbnNXaXRoUHJvbWlzZXMuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBhLl91cGRhdGVQcm9taXNlcygpfSl9LF9kaXNjYXJkQW5pbWF0aW9uczpmdW5jdGlvbigpe3RoaXMuX3VwZGF0ZUFuaW1hdGlvbnNQcm9taXNlcygpLHRoaXMuX2FuaW1hdGlvbnM9dGhpcy5fYW5pbWF0aW9ucy5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuXCJmaW5pc2hlZFwiIT1hLnBsYXlTdGF0ZSYmXCJpZGxlXCIhPWEucGxheVN0YXRlfSl9LF9wbGF5OmZ1bmN0aW9uKGEpe3ZhciBjPW5ldyBiLkFuaW1hdGlvbihhLHRoaXMpO3JldHVybiB0aGlzLl9hbmltYXRpb25zLnB1c2goYyksYi5yZXN0YXJ0V2ViQW5pbWF0aW9uc05leHRUaWNrKCksYy5fdXBkYXRlUHJvbWlzZXMoKSxjLl9hbmltYXRpb24ucGxheSgpLGMuX3VwZGF0ZVByb21pc2VzKCksY30scGxheTpmdW5jdGlvbihhKXtyZXR1cm4gYSYmYS5yZW1vdmUoKSx0aGlzLl9wbGF5KGEpfX07dmFyIGY9ITE7Yi5yZXN0YXJ0V2ViQW5pbWF0aW9uc05leHRUaWNrPWZ1bmN0aW9uKCl7Znx8KGY9ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKGQpKX07dmFyIGc9bmV3IGIuQW5pbWF0aW9uVGltZWxpbmU7Yi50aW1lbGluZT1nO3RyeXtPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LmRvY3VtZW50LFwidGltZWxpbmVcIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBnfX0pfWNhdGNoKGEpe310cnl7d2luZG93LmRvY3VtZW50LnRpbWVsaW5lPWd9Y2F0Y2goYSl7fX0oMCxlKSxmdW5jdGlvbihhLGIsYyl7Yi5hbmltYXRpb25zV2l0aFByb21pc2VzPVtdLGIuQW5pbWF0aW9uPWZ1bmN0aW9uKGIsYyl7aWYodGhpcy5pZD1cIlwiLGImJmIuX2lkJiYodGhpcy5pZD1iLl9pZCksdGhpcy5lZmZlY3Q9YixiJiYoYi5fYW5pbWF0aW9uPXRoaXMpLCFjKXRocm93IG5ldyBFcnJvcihcIkFuaW1hdGlvbiB3aXRoIG51bGwgdGltZWxpbmUgaXMgbm90IHN1cHBvcnRlZFwiKTt0aGlzLl90aW1lbGluZT1jLHRoaXMuX3NlcXVlbmNlTnVtYmVyPWEuc2VxdWVuY2VOdW1iZXIrKyx0aGlzLl9ob2xkVGltZT0wLHRoaXMuX3BhdXNlZD0hMSx0aGlzLl9pc0dyb3VwPSExLHRoaXMuX2FuaW1hdGlvbj1udWxsLHRoaXMuX2NoaWxkQW5pbWF0aW9ucz1bXSx0aGlzLl9jYWxsYmFjaz1udWxsLHRoaXMuX29sZFBsYXlTdGF0ZT1cImlkbGVcIix0aGlzLl9yZWJ1aWxkVW5kZXJseWluZ0FuaW1hdGlvbigpLHRoaXMuX2FuaW1hdGlvbi5jYW5jZWwoKSx0aGlzLl91cGRhdGVQcm9taXNlcygpfSxiLkFuaW1hdGlvbi5wcm90b3R5cGU9e191cGRhdGVQcm9taXNlczpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX29sZFBsYXlTdGF0ZSxiPXRoaXMucGxheVN0YXRlO3JldHVybiB0aGlzLl9yZWFkeVByb21pc2UmJmIhPT1hJiYoXCJpZGxlXCI9PWI/KHRoaXMuX3JlamVjdFJlYWR5UHJvbWlzZSgpLHRoaXMuX3JlYWR5UHJvbWlzZT12b2lkIDApOlwicGVuZGluZ1wiPT1hP3RoaXMuX3Jlc29sdmVSZWFkeVByb21pc2UoKTpcInBlbmRpbmdcIj09YiYmKHRoaXMuX3JlYWR5UHJvbWlzZT12b2lkIDApKSx0aGlzLl9maW5pc2hlZFByb21pc2UmJmIhPT1hJiYoXCJpZGxlXCI9PWI/KHRoaXMuX3JlamVjdEZpbmlzaGVkUHJvbWlzZSgpLHRoaXMuX2ZpbmlzaGVkUHJvbWlzZT12b2lkIDApOlwiZmluaXNoZWRcIj09Yj90aGlzLl9yZXNvbHZlRmluaXNoZWRQcm9taXNlKCk6XCJmaW5pc2hlZFwiPT1hJiYodGhpcy5fZmluaXNoZWRQcm9taXNlPXZvaWQgMCkpLHRoaXMuX29sZFBsYXlTdGF0ZT10aGlzLnBsYXlTdGF0ZSx0aGlzLl9yZWFkeVByb21pc2V8fHRoaXMuX2ZpbmlzaGVkUHJvbWlzZX0sX3JlYnVpbGRVbmRlcmx5aW5nQW5pbWF0aW9uOmZ1bmN0aW9uKCl7dGhpcy5fdXBkYXRlUHJvbWlzZXMoKTt2YXIgYSxjLGQsZSxmPSEhdGhpcy5fYW5pbWF0aW9uO2YmJihhPXRoaXMucGxheWJhY2tSYXRlLGM9dGhpcy5fcGF1c2VkLGQ9dGhpcy5zdGFydFRpbWUsZT10aGlzLmN1cnJlbnRUaW1lLHRoaXMuX2FuaW1hdGlvbi5jYW5jZWwoKSx0aGlzLl9hbmltYXRpb24uX3dyYXBwZXI9bnVsbCx0aGlzLl9hbmltYXRpb249bnVsbCksKCF0aGlzLmVmZmVjdHx8dGhpcy5lZmZlY3QgaW5zdGFuY2VvZiB3aW5kb3cuS2V5ZnJhbWVFZmZlY3QpJiYodGhpcy5fYW5pbWF0aW9uPWIubmV3VW5kZXJseWluZ0FuaW1hdGlvbkZvcktleWZyYW1lRWZmZWN0KHRoaXMuZWZmZWN0KSxiLmJpbmRBbmltYXRpb25Gb3JLZXlmcmFtZUVmZmVjdCh0aGlzKSksKHRoaXMuZWZmZWN0IGluc3RhbmNlb2Ygd2luZG93LlNlcXVlbmNlRWZmZWN0fHx0aGlzLmVmZmVjdCBpbnN0YW5jZW9mIHdpbmRvdy5Hcm91cEVmZmVjdCkmJih0aGlzLl9hbmltYXRpb249Yi5uZXdVbmRlcmx5aW5nQW5pbWF0aW9uRm9yR3JvdXAodGhpcy5lZmZlY3QpLGIuYmluZEFuaW1hdGlvbkZvckdyb3VwKHRoaXMpKSx0aGlzLmVmZmVjdCYmdGhpcy5lZmZlY3QuX29uc2FtcGxlJiZiLmJpbmRBbmltYXRpb25Gb3JDdXN0b21FZmZlY3QodGhpcyksZiYmKDEhPWEmJih0aGlzLnBsYXliYWNrUmF0ZT1hKSxudWxsIT09ZD90aGlzLnN0YXJ0VGltZT1kOm51bGwhPT1lP3RoaXMuY3VycmVudFRpbWU9ZTpudWxsIT09dGhpcy5faG9sZFRpbWUmJih0aGlzLmN1cnJlbnRUaW1lPXRoaXMuX2hvbGRUaW1lKSxjJiZ0aGlzLnBhdXNlKCkpLHRoaXMuX3VwZGF0ZVByb21pc2VzKCl9LF91cGRhdGVDaGlsZHJlbjpmdW5jdGlvbigpe2lmKHRoaXMuZWZmZWN0JiZcImlkbGVcIiE9dGhpcy5wbGF5U3RhdGUpe3ZhciBhPXRoaXMuZWZmZWN0Ll90aW1pbmcuZGVsYXk7dGhpcy5fY2hpbGRBbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24oYyl7dGhpcy5fYXJyYW5nZUNoaWxkcmVuKGMsYSksdGhpcy5lZmZlY3QgaW5zdGFuY2VvZiB3aW5kb3cuU2VxdWVuY2VFZmZlY3QmJihhKz1iLmdyb3VwQ2hpbGREdXJhdGlvbihjLmVmZmVjdCkpfS5iaW5kKHRoaXMpKX19LF9zZXRFeHRlcm5hbEFuaW1hdGlvbjpmdW5jdGlvbihhKXtpZih0aGlzLmVmZmVjdCYmdGhpcy5faXNHcm91cClmb3IodmFyIGI9MDtiPHRoaXMuZWZmZWN0LmNoaWxkcmVuLmxlbmd0aDtiKyspdGhpcy5lZmZlY3QuY2hpbGRyZW5bYl0uX2FuaW1hdGlvbj1hLHRoaXMuX2NoaWxkQW5pbWF0aW9uc1tiXS5fc2V0RXh0ZXJuYWxBbmltYXRpb24oYSl9LF9jb25zdHJ1Y3RDaGlsZEFuaW1hdGlvbnM6ZnVuY3Rpb24oKXtpZih0aGlzLmVmZmVjdCYmdGhpcy5faXNHcm91cCl7dmFyIGE9dGhpcy5lZmZlY3QuX3RpbWluZy5kZWxheTt0aGlzLl9yZW1vdmVDaGlsZEFuaW1hdGlvbnMoKSx0aGlzLmVmZmVjdC5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGMpe3ZhciBkPWIudGltZWxpbmUuX3BsYXkoYyk7dGhpcy5fY2hpbGRBbmltYXRpb25zLnB1c2goZCksZC5wbGF5YmFja1JhdGU9dGhpcy5wbGF5YmFja1JhdGUsdGhpcy5fcGF1c2VkJiZkLnBhdXNlKCksYy5fYW5pbWF0aW9uPXRoaXMuZWZmZWN0Ll9hbmltYXRpb24sdGhpcy5fYXJyYW5nZUNoaWxkcmVuKGQsYSksdGhpcy5lZmZlY3QgaW5zdGFuY2VvZiB3aW5kb3cuU2VxdWVuY2VFZmZlY3QmJihhKz1iLmdyb3VwQ2hpbGREdXJhdGlvbihjKSl9LmJpbmQodGhpcykpfX0sX2FycmFuZ2VDaGlsZHJlbjpmdW5jdGlvbihhLGIpe251bGw9PT10aGlzLnN0YXJ0VGltZT9hLmN1cnJlbnRUaW1lPXRoaXMuY3VycmVudFRpbWUtYi90aGlzLnBsYXliYWNrUmF0ZTphLnN0YXJ0VGltZSE9PXRoaXMuc3RhcnRUaW1lK2IvdGhpcy5wbGF5YmFja1JhdGUmJihhLnN0YXJ0VGltZT10aGlzLnN0YXJ0VGltZStiL3RoaXMucGxheWJhY2tSYXRlKX0sZ2V0IHRpbWVsaW5lKCl7cmV0dXJuIHRoaXMuX3RpbWVsaW5lfSxnZXQgcGxheVN0YXRlKCl7cmV0dXJuIHRoaXMuX2FuaW1hdGlvbj90aGlzLl9hbmltYXRpb24ucGxheVN0YXRlOlwiaWRsZVwifSxnZXQgZmluaXNoZWQoKXtyZXR1cm4gd2luZG93LlByb21pc2U/KHRoaXMuX2ZpbmlzaGVkUHJvbWlzZXx8KC0xPT1iLmFuaW1hdGlvbnNXaXRoUHJvbWlzZXMuaW5kZXhPZih0aGlzKSYmYi5hbmltYXRpb25zV2l0aFByb21pc2VzLnB1c2godGhpcyksdGhpcy5fZmluaXNoZWRQcm9taXNlPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGEsYil7dGhpcy5fcmVzb2x2ZUZpbmlzaGVkUHJvbWlzZT1mdW5jdGlvbigpe2EodGhpcyl9LHRoaXMuX3JlamVjdEZpbmlzaGVkUHJvbWlzZT1mdW5jdGlvbigpe2Ioe3R5cGU6RE9NRXhjZXB0aW9uLkFCT1JUX0VSUixuYW1lOlwiQWJvcnRFcnJvclwifSl9fS5iaW5kKHRoaXMpKSxcImZpbmlzaGVkXCI9PXRoaXMucGxheVN0YXRlJiZ0aGlzLl9yZXNvbHZlRmluaXNoZWRQcm9taXNlKCkpLHRoaXMuX2ZpbmlzaGVkUHJvbWlzZSk6KGNvbnNvbGUud2FybihcIkFuaW1hdGlvbiBQcm9taXNlcyByZXF1aXJlIEphdmFTY3JpcHQgUHJvbWlzZSBjb25zdHJ1Y3RvclwiKSxudWxsKX0sZ2V0IHJlYWR5KCl7cmV0dXJuIHdpbmRvdy5Qcm9taXNlPyh0aGlzLl9yZWFkeVByb21pc2V8fCgtMT09Yi5hbmltYXRpb25zV2l0aFByb21pc2VzLmluZGV4T2YodGhpcykmJmIuYW5pbWF0aW9uc1dpdGhQcm9taXNlcy5wdXNoKHRoaXMpLHRoaXMuX3JlYWR5UHJvbWlzZT1uZXcgUHJvbWlzZShmdW5jdGlvbihhLGIpe3RoaXMuX3Jlc29sdmVSZWFkeVByb21pc2U9ZnVuY3Rpb24oKXthKHRoaXMpfSx0aGlzLl9yZWplY3RSZWFkeVByb21pc2U9ZnVuY3Rpb24oKXtiKHt0eXBlOkRPTUV4Y2VwdGlvbi5BQk9SVF9FUlIsbmFtZTpcIkFib3J0RXJyb3JcIn0pfX0uYmluZCh0aGlzKSksXCJwZW5kaW5nXCIhPT10aGlzLnBsYXlTdGF0ZSYmdGhpcy5fcmVzb2x2ZVJlYWR5UHJvbWlzZSgpKSx0aGlzLl9yZWFkeVByb21pc2UpOihjb25zb2xlLndhcm4oXCJBbmltYXRpb24gUHJvbWlzZXMgcmVxdWlyZSBKYXZhU2NyaXB0IFByb21pc2UgY29uc3RydWN0b3JcIiksbnVsbCl9LGdldCBvbmZpbmlzaCgpe3JldHVybiB0aGlzLl9hbmltYXRpb24ub25maW5pc2h9LHNldCBvbmZpbmlzaChhKXt0aGlzLl9hbmltYXRpb24ub25maW5pc2g9XCJmdW5jdGlvblwiPT10eXBlb2YgYT9mdW5jdGlvbihiKXtiLnRhcmdldD10aGlzLGEuY2FsbCh0aGlzLGIpfS5iaW5kKHRoaXMpOmF9LGdldCBvbmNhbmNlbCgpe3JldHVybiB0aGlzLl9hbmltYXRpb24ub25jYW5jZWx9LHNldCBvbmNhbmNlbChhKXt0aGlzLl9hbmltYXRpb24ub25jYW5jZWw9XCJmdW5jdGlvblwiPT10eXBlb2YgYT9mdW5jdGlvbihiKXtiLnRhcmdldD10aGlzLGEuY2FsbCh0aGlzLGIpfS5iaW5kKHRoaXMpOmF9LGdldCBjdXJyZW50VGltZSgpe3RoaXMuX3VwZGF0ZVByb21pc2VzKCk7dmFyIGE9dGhpcy5fYW5pbWF0aW9uLmN1cnJlbnRUaW1lO3JldHVybiB0aGlzLl91cGRhdGVQcm9taXNlcygpLGF9LHNldCBjdXJyZW50VGltZShhKXt0aGlzLl91cGRhdGVQcm9taXNlcygpLHRoaXMuX2FuaW1hdGlvbi5jdXJyZW50VGltZT1pc0Zpbml0ZShhKT9hOk1hdGguc2lnbihhKSpOdW1iZXIuTUFYX1ZBTFVFLHRoaXMuX3JlZ2lzdGVyKCksdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uKGIsYyl7Yi5jdXJyZW50VGltZT1hLWN9KSx0aGlzLl91cGRhdGVQcm9taXNlcygpfSxnZXQgc3RhcnRUaW1lKCl7cmV0dXJuIHRoaXMuX2FuaW1hdGlvbi5zdGFydFRpbWV9LHNldCBzdGFydFRpbWUoYSl7dGhpcy5fdXBkYXRlUHJvbWlzZXMoKSx0aGlzLl9hbmltYXRpb24uc3RhcnRUaW1lPWlzRmluaXRlKGEpP2E6TWF0aC5zaWduKGEpKk51bWJlci5NQVhfVkFMVUUsdGhpcy5fcmVnaXN0ZXIoKSx0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24oYixjKXtiLnN0YXJ0VGltZT1hK2N9KSx0aGlzLl91cGRhdGVQcm9taXNlcygpfSxnZXQgcGxheWJhY2tSYXRlKCl7cmV0dXJuIHRoaXMuX2FuaW1hdGlvbi5wbGF5YmFja1JhdGV9LHNldCBwbGF5YmFja1JhdGUoYSl7dGhpcy5fdXBkYXRlUHJvbWlzZXMoKTt2YXIgYj10aGlzLmN1cnJlbnRUaW1lO3RoaXMuX2FuaW1hdGlvbi5wbGF5YmFja1JhdGU9YSx0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24oYil7Yi5wbGF5YmFja1JhdGU9YX0pLG51bGwhPT1iJiYodGhpcy5jdXJyZW50VGltZT1iKSx0aGlzLl91cGRhdGVQcm9taXNlcygpfSxwbGF5OmZ1bmN0aW9uKCl7dGhpcy5fdXBkYXRlUHJvbWlzZXMoKSx0aGlzLl9wYXVzZWQ9ITEsdGhpcy5fYW5pbWF0aW9uLnBsYXkoKSwtMT09dGhpcy5fdGltZWxpbmUuX2FuaW1hdGlvbnMuaW5kZXhPZih0aGlzKSYmdGhpcy5fdGltZWxpbmUuX2FuaW1hdGlvbnMucHVzaCh0aGlzKSx0aGlzLl9yZWdpc3RlcigpLGIuYXdhaXRTdGFydFRpbWUodGhpcyksdGhpcy5fZm9yRWFjaENoaWxkKGZ1bmN0aW9uKGEpe3ZhciBiPWEuY3VycmVudFRpbWU7YS5wbGF5KCksYS5jdXJyZW50VGltZT1ifSksdGhpcy5fdXBkYXRlUHJvbWlzZXMoKX0scGF1c2U6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVQcm9taXNlcygpLHRoaXMuY3VycmVudFRpbWUmJih0aGlzLl9ob2xkVGltZT10aGlzLmN1cnJlbnRUaW1lKSx0aGlzLl9hbmltYXRpb24ucGF1c2UoKSx0aGlzLl9yZWdpc3RlcigpLHRoaXMuX2ZvckVhY2hDaGlsZChmdW5jdGlvbihhKXthLnBhdXNlKCl9KSx0aGlzLl9wYXVzZWQ9ITAsdGhpcy5fdXBkYXRlUHJvbWlzZXMoKX0sZmluaXNoOmZ1bmN0aW9uKCl7dGhpcy5fdXBkYXRlUHJvbWlzZXMoKSx0aGlzLl9hbmltYXRpb24uZmluaXNoKCksdGhpcy5fcmVnaXN0ZXIoKSx0aGlzLl91cGRhdGVQcm9taXNlcygpfSxjYW5jZWw6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVQcm9taXNlcygpLHRoaXMuX2FuaW1hdGlvbi5jYW5jZWwoKSx0aGlzLl9yZWdpc3RlcigpLHRoaXMuX3JlbW92ZUNoaWxkQW5pbWF0aW9ucygpLHRoaXMuX3VwZGF0ZVByb21pc2VzKCl9LHJldmVyc2U6ZnVuY3Rpb24oKXt0aGlzLl91cGRhdGVQcm9taXNlcygpO3ZhciBhPXRoaXMuY3VycmVudFRpbWU7dGhpcy5fYW5pbWF0aW9uLnJldmVyc2UoKSx0aGlzLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24oYSl7YS5yZXZlcnNlKCl9KSxudWxsIT09YSYmKHRoaXMuY3VycmVudFRpbWU9YSksdGhpcy5fdXBkYXRlUHJvbWlzZXMoKX0sYWRkRXZlbnRMaXN0ZW5lcjpmdW5jdGlvbihhLGIpe3ZhciBjPWI7XCJmdW5jdGlvblwiPT10eXBlb2YgYiYmKGM9ZnVuY3Rpb24oYSl7YS50YXJnZXQ9dGhpcyxiLmNhbGwodGhpcyxhKX0uYmluZCh0aGlzKSxiLl93cmFwcGVyPWMpLHRoaXMuX2FuaW1hdGlvbi5hZGRFdmVudExpc3RlbmVyKGEsYyl9LHJlbW92ZUV2ZW50TGlzdGVuZXI6ZnVuY3Rpb24oYSxiKXt0aGlzLl9hbmltYXRpb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLGImJmIuX3dyYXBwZXJ8fGIpfSxfcmVtb3ZlQ2hpbGRBbmltYXRpb25zOmZ1bmN0aW9uKCl7Zm9yKDt0aGlzLl9jaGlsZEFuaW1hdGlvbnMubGVuZ3RoOyl0aGlzLl9jaGlsZEFuaW1hdGlvbnMucG9wKCkuY2FuY2VsKCl9LF9mb3JFYWNoQ2hpbGQ6ZnVuY3Rpb24oYil7dmFyIGM9MDtpZih0aGlzLmVmZmVjdC5jaGlsZHJlbiYmdGhpcy5fY2hpbGRBbmltYXRpb25zLmxlbmd0aDx0aGlzLmVmZmVjdC5jaGlsZHJlbi5sZW5ndGgmJnRoaXMuX2NvbnN0cnVjdENoaWxkQW5pbWF0aW9ucygpLHRoaXMuX2NoaWxkQW5pbWF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKGEpe2IuY2FsbCh0aGlzLGEsYyksdGhpcy5lZmZlY3QgaW5zdGFuY2VvZiB3aW5kb3cuU2VxdWVuY2VFZmZlY3QmJihjKz1hLmVmZmVjdC5hY3RpdmVEdXJhdGlvbil9LmJpbmQodGhpcykpLFwicGVuZGluZ1wiIT10aGlzLnBsYXlTdGF0ZSl7dmFyIGQ9dGhpcy5lZmZlY3QuX3RpbWluZyxlPXRoaXMuY3VycmVudFRpbWU7bnVsbCE9PWUmJihlPWEuY2FsY3VsYXRlSXRlcmF0aW9uUHJvZ3Jlc3MoYS5jYWxjdWxhdGVBY3RpdmVEdXJhdGlvbihkKSxlLGQpKSwobnVsbD09ZXx8aXNOYU4oZSkpJiZ0aGlzLl9yZW1vdmVDaGlsZEFuaW1hdGlvbnMoKX19fSx3aW5kb3cuQW5pbWF0aW9uPWIuQW5pbWF0aW9ufShjLGUpLGZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGIpe3RoaXMuX2ZyYW1lcz1hLm5vcm1hbGl6ZUtleWZyYW1lcyhiKX1mdW5jdGlvbiBlKCl7Zm9yKHZhciBhPSExO2kubGVuZ3RoOylpLnNoaWZ0KCkuX3VwZGF0ZUNoaWxkcmVuKCksYT0hMDtyZXR1cm4gYX12YXIgZj1mdW5jdGlvbihhKXtpZihhLl9hbmltYXRpb249dm9pZCAwLGEgaW5zdGFuY2VvZiB3aW5kb3cuU2VxdWVuY2VFZmZlY3R8fGEgaW5zdGFuY2VvZiB3aW5kb3cuR3JvdXBFZmZlY3QpZm9yKHZhciBiPTA7YjxhLmNoaWxkcmVuLmxlbmd0aDtiKyspZihhLmNoaWxkcmVuW2JdKX07Yi5yZW1vdmVNdWx0aT1mdW5jdGlvbihhKXtmb3IodmFyIGI9W10sYz0wO2M8YS5sZW5ndGg7YysrKXt2YXIgZD1hW2NdO2QuX3BhcmVudD8oLTE9PWIuaW5kZXhPZihkLl9wYXJlbnQpJiZiLnB1c2goZC5fcGFyZW50KSxkLl9wYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGQuX3BhcmVudC5jaGlsZHJlbi5pbmRleE9mKGQpLDEpLGQuX3BhcmVudD1udWxsLGYoZCkpOmQuX2FuaW1hdGlvbiYmZC5fYW5pbWF0aW9uLmVmZmVjdD09ZCYmKGQuX2FuaW1hdGlvbi5jYW5jZWwoKSxkLl9hbmltYXRpb24uZWZmZWN0PW5ldyBLZXlmcmFtZUVmZmVjdChudWxsLFtdKSxkLl9hbmltYXRpb24uX2NhbGxiYWNrJiYoZC5fYW5pbWF0aW9uLl9jYWxsYmFjay5fYW5pbWF0aW9uPW51bGwpLGQuX2FuaW1hdGlvbi5fcmVidWlsZFVuZGVybHlpbmdBbmltYXRpb24oKSxmKGQpKX1mb3IoYz0wO2M8Yi5sZW5ndGg7YysrKWJbY10uX3JlYnVpbGQoKX0sYi5LZXlmcmFtZUVmZmVjdD1mdW5jdGlvbihiLGMsZSxmKXtyZXR1cm4gdGhpcy50YXJnZXQ9Yix0aGlzLl9wYXJlbnQ9bnVsbCxlPWEubnVtZXJpY1RpbWluZ1RvT2JqZWN0KGUpLHRoaXMuX3RpbWluZ0lucHV0PWEuY2xvbmVUaW1pbmdJbnB1dChlKSx0aGlzLl90aW1pbmc9YS5ub3JtYWxpemVUaW1pbmdJbnB1dChlKSx0aGlzLnRpbWluZz1hLm1ha2VUaW1pbmcoZSwhMSx0aGlzKSx0aGlzLnRpbWluZy5fZWZmZWN0PXRoaXMsXCJmdW5jdGlvblwiPT10eXBlb2YgYz8oYS5kZXByZWNhdGVkKFwiQ3VzdG9tIEtleWZyYW1lRWZmZWN0XCIsXCIyMDE1LTA2LTIyXCIsXCJVc2UgS2V5ZnJhbWVFZmZlY3Qub25zYW1wbGUgaW5zdGVhZC5cIiksdGhpcy5fbm9ybWFsaXplZEtleWZyYW1lcz1jKTp0aGlzLl9ub3JtYWxpemVkS2V5ZnJhbWVzPW5ldyBkKGMpLHRoaXMuX2tleWZyYW1lcz1jLHRoaXMuYWN0aXZlRHVyYXRpb249YS5jYWxjdWxhdGVBY3RpdmVEdXJhdGlvbih0aGlzLl90aW1pbmcpLHRoaXMuX2lkPWYsdGhpc30sYi5LZXlmcmFtZUVmZmVjdC5wcm90b3R5cGU9e2dldEZyYW1lczpmdW5jdGlvbigpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHRoaXMuX25vcm1hbGl6ZWRLZXlmcmFtZXM/dGhpcy5fbm9ybWFsaXplZEtleWZyYW1lczp0aGlzLl9ub3JtYWxpemVkS2V5ZnJhbWVzLl9mcmFtZXN9LHNldCBvbnNhbXBsZShhKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmdldEZyYW1lcygpKXRocm93IG5ldyBFcnJvcihcIlNldHRpbmcgb25zYW1wbGUgb24gY3VzdG9tIGVmZmVjdCBLZXlmcmFtZUVmZmVjdCBpcyBub3Qgc3VwcG9ydGVkLlwiKTt0aGlzLl9vbnNhbXBsZT1hLHRoaXMuX2FuaW1hdGlvbiYmdGhpcy5fYW5pbWF0aW9uLl9yZWJ1aWxkVW5kZXJseWluZ0FuaW1hdGlvbigpfSxnZXQgcGFyZW50KCl7cmV0dXJuIHRoaXMuX3BhcmVudH0sY2xvbmU6ZnVuY3Rpb24oKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLmdldEZyYW1lcygpKXRocm93IG5ldyBFcnJvcihcIkNsb25pbmcgY3VzdG9tIGVmZmVjdHMgaXMgbm90IHN1cHBvcnRlZC5cIik7dmFyIGI9bmV3IEtleWZyYW1lRWZmZWN0KHRoaXMudGFyZ2V0LFtdLGEuY2xvbmVUaW1pbmdJbnB1dCh0aGlzLl90aW1pbmdJbnB1dCksdGhpcy5faWQpO3JldHVybiBiLl9ub3JtYWxpemVkS2V5ZnJhbWVzPXRoaXMuX25vcm1hbGl6ZWRLZXlmcmFtZXMsYi5fa2V5ZnJhbWVzPXRoaXMuX2tleWZyYW1lcyxifSxyZW1vdmU6ZnVuY3Rpb24oKXtiLnJlbW92ZU11bHRpKFt0aGlzXSl9fTt2YXIgZz1FbGVtZW50LnByb3RvdHlwZS5hbmltYXRlO0VsZW1lbnQucHJvdG90eXBlLmFuaW1hdGU9ZnVuY3Rpb24oYSxjKXt2YXIgZD1cIlwiO3JldHVybiBjJiZjLmlkJiYoZD1jLmlkKSxiLnRpbWVsaW5lLl9wbGF5KG5ldyBiLktleWZyYW1lRWZmZWN0KHRoaXMsYSxjLGQpKX07dmFyIGg9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiLFwiZGl2XCIpO2IubmV3VW5kZXJseWluZ0FuaW1hdGlvbkZvcktleWZyYW1lRWZmZWN0PWZ1bmN0aW9uKGEpe2lmKGEpe3ZhciBiPWEudGFyZ2V0fHxoLGM9YS5fa2V5ZnJhbWVzO1wiZnVuY3Rpb25cIj09dHlwZW9mIGMmJihjPVtdKTt2YXIgZD1hLl90aW1pbmdJbnB1dDtkLmlkPWEuX2lkfWVsc2UgdmFyIGI9aCxjPVtdLGQ9MDtyZXR1cm4gZy5hcHBseShiLFtjLGRdKX0sYi5iaW5kQW5pbWF0aW9uRm9yS2V5ZnJhbWVFZmZlY3Q9ZnVuY3Rpb24oYSl7YS5lZmZlY3QmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGEuZWZmZWN0Ll9ub3JtYWxpemVkS2V5ZnJhbWVzJiZiLmJpbmRBbmltYXRpb25Gb3JDdXN0b21FZmZlY3QoYSl9O3ZhciBpPVtdO2IuYXdhaXRTdGFydFRpbWU9ZnVuY3Rpb24oYSl7bnVsbD09PWEuc3RhcnRUaW1lJiZhLl9pc0dyb3VwJiYoMD09aS5sZW5ndGgmJnJlcXVlc3RBbmltYXRpb25GcmFtZShlKSxpLnB1c2goYSkpfTt2YXIgaj13aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZTtPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LFwiZ2V0Q29tcHV0ZWRTdHlsZVwiLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpmdW5jdGlvbigpe2IudGltZWxpbmUuX3VwZGF0ZUFuaW1hdGlvbnNQcm9taXNlcygpO3ZhciBhPWouYXBwbHkodGhpcyxhcmd1bWVudHMpO3JldHVybiBlKCkmJihhPWouYXBwbHkodGhpcyxhcmd1bWVudHMpKSxiLnRpbWVsaW5lLl91cGRhdGVBbmltYXRpb25zUHJvbWlzZXMoKSxhfX0pLHdpbmRvdy5LZXlmcmFtZUVmZmVjdD1iLktleWZyYW1lRWZmZWN0LHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5nZXRBbmltYXRpb25zPWZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LnRpbWVsaW5lLmdldEFuaW1hdGlvbnMoKS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIG51bGwhPT1hLmVmZmVjdCYmYS5lZmZlY3QudGFyZ2V0PT10aGlzfS5iaW5kKHRoaXMpKX19KGMsZSksZnVuY3Rpb24oYSxiLGMpe2Z1bmN0aW9uIGQoYSl7YS5fcmVnaXN0ZXJlZHx8KGEuX3JlZ2lzdGVyZWQ9ITAsZy5wdXNoKGEpLGh8fChoPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZShlKSkpfWZ1bmN0aW9uIGUoYSl7dmFyIGI9ZztnPVtdLGIuc29ydChmdW5jdGlvbihhLGIpe3JldHVybiBhLl9zZXF1ZW5jZU51bWJlci1iLl9zZXF1ZW5jZU51bWJlcn0pLGI9Yi5maWx0ZXIoZnVuY3Rpb24oYSl7YSgpO3ZhciBiPWEuX2FuaW1hdGlvbj9hLl9hbmltYXRpb24ucGxheVN0YXRlOlwiaWRsZVwiO3JldHVyblwicnVubmluZ1wiIT1iJiZcInBlbmRpbmdcIiE9YiYmKGEuX3JlZ2lzdGVyZWQ9ITEpLGEuX3JlZ2lzdGVyZWR9KSxnLnB1c2guYXBwbHkoZyxiKSxnLmxlbmd0aD8oaD0hMCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZSkpOmg9ITF9dmFyIGY9KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixcImRpdlwiKSwwKTtiLmJpbmRBbmltYXRpb25Gb3JDdXN0b21FZmZlY3Q9ZnVuY3Rpb24oYil7dmFyIGMsZT1iLmVmZmVjdC50YXJnZXQsZz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBiLmVmZmVjdC5nZXRGcmFtZXMoKTtjPWc/Yi5lZmZlY3QuZ2V0RnJhbWVzKCk6Yi5lZmZlY3QuX29uc2FtcGxlO3ZhciBoPWIuZWZmZWN0LnRpbWluZyxpPW51bGw7aD1hLm5vcm1hbGl6ZVRpbWluZ0lucHV0KGgpO3ZhciBqPWZ1bmN0aW9uKCl7dmFyIGQ9ai5fYW5pbWF0aW9uP2ouX2FuaW1hdGlvbi5jdXJyZW50VGltZTpudWxsO251bGwhPT1kJiYoZD1hLmNhbGN1bGF0ZUl0ZXJhdGlvblByb2dyZXNzKGEuY2FsY3VsYXRlQWN0aXZlRHVyYXRpb24oaCksZCxoKSxpc05hTihkKSYmKGQ9bnVsbCkpLGQhPT1pJiYoZz9jKGQsZSxiLmVmZmVjdCk6YyhkLGIuZWZmZWN0LGIuZWZmZWN0Ll9hbmltYXRpb24pKSxpPWR9O2ouX2FuaW1hdGlvbj1iLGouX3JlZ2lzdGVyZWQ9ITEsai5fc2VxdWVuY2VOdW1iZXI9ZisrLGIuX2NhbGxiYWNrPWosZChqKX07dmFyIGc9W10saD0hMTtiLkFuaW1hdGlvbi5wcm90b3R5cGUuX3JlZ2lzdGVyPWZ1bmN0aW9uKCl7dGhpcy5fY2FsbGJhY2smJmQodGhpcy5fY2FsbGJhY2spfX0oYyxlKSxmdW5jdGlvbihhLGIsYyl7ZnVuY3Rpb24gZChhKXtyZXR1cm4gYS5fdGltaW5nLmRlbGF5K2EuYWN0aXZlRHVyYXRpb24rYS5fdGltaW5nLmVuZERlbGF5fWZ1bmN0aW9uIGUoYixjLGQpe3RoaXMuX2lkPWQsdGhpcy5fcGFyZW50PW51bGwsdGhpcy5jaGlsZHJlbj1ifHxbXSx0aGlzLl9yZXBhcmVudCh0aGlzLmNoaWxkcmVuKSxjPWEubnVtZXJpY1RpbWluZ1RvT2JqZWN0KGMpLHRoaXMuX3RpbWluZ0lucHV0PWEuY2xvbmVUaW1pbmdJbnB1dChjKSx0aGlzLl90aW1pbmc9YS5ub3JtYWxpemVUaW1pbmdJbnB1dChjLCEwKSx0aGlzLnRpbWluZz1hLm1ha2VUaW1pbmcoYywhMCx0aGlzKSx0aGlzLnRpbWluZy5fZWZmZWN0PXRoaXMsXCJhdXRvXCI9PT10aGlzLl90aW1pbmcuZHVyYXRpb24mJih0aGlzLl90aW1pbmcuZHVyYXRpb249dGhpcy5hY3RpdmVEdXJhdGlvbil9d2luZG93LlNlcXVlbmNlRWZmZWN0PWZ1bmN0aW9uKCl7ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHdpbmRvdy5Hcm91cEVmZmVjdD1mdW5jdGlvbigpe2UuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxlLnByb3RvdHlwZT17X2lzQW5jZXN0b3I6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPXRoaXM7bnVsbCE9PWI7KXtpZihiPT1hKXJldHVybiEwO2I9Yi5fcGFyZW50fXJldHVybiExfSxfcmVidWlsZDpmdW5jdGlvbigpe2Zvcih2YXIgYT10aGlzO2E7KVwiYXV0b1wiPT09YS50aW1pbmcuZHVyYXRpb24mJihhLl90aW1pbmcuZHVyYXRpb249YS5hY3RpdmVEdXJhdGlvbiksYT1hLl9wYXJlbnQ7dGhpcy5fYW5pbWF0aW9uJiZ0aGlzLl9hbmltYXRpb24uX3JlYnVpbGRVbmRlcmx5aW5nQW5pbWF0aW9uKCl9LF9yZXBhcmVudDpmdW5jdGlvbihhKXtiLnJlbW92ZU11bHRpKGEpO2Zvcih2YXIgYz0wO2M8YS5sZW5ndGg7YysrKWFbY10uX3BhcmVudD10aGlzfSxfcHV0Q2hpbGQ6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9Yj9cIkNhbm5vdCBhcHBlbmQgYW4gYW5jZXN0b3Igb3Igc2VsZlwiOlwiQ2Fubm90IHByZXBlbmQgYW4gYW5jZXN0b3Igb3Igc2VsZlwiLGQ9MDtkPGEubGVuZ3RoO2QrKylpZih0aGlzLl9pc0FuY2VzdG9yKGFbZF0pKXRocm93e3R5cGU6RE9NRXhjZXB0aW9uLkhJRVJBUkNIWV9SRVFVRVNUX0VSUixuYW1lOlwiSGllcmFyY2h5UmVxdWVzdEVycm9yXCIsbWVzc2FnZTpjfTtmb3IodmFyIGQ9MDtkPGEubGVuZ3RoO2QrKyliP3RoaXMuY2hpbGRyZW4ucHVzaChhW2RdKTp0aGlzLmNoaWxkcmVuLnVuc2hpZnQoYVtkXSk7dGhpcy5fcmVwYXJlbnQoYSksdGhpcy5fcmVidWlsZCgpfSxhcHBlbmQ6ZnVuY3Rpb24oKXt0aGlzLl9wdXRDaGlsZChhcmd1bWVudHMsITApfSxwcmVwZW5kOmZ1bmN0aW9uKCl7dGhpcy5fcHV0Q2hpbGQoYXJndW1lbnRzLCExKX0sZ2V0IHBhcmVudCgpe3JldHVybiB0aGlzLl9wYXJlbnR9LGdldCBmaXJzdENoaWxkKCl7cmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RoP3RoaXMuY2hpbGRyZW5bMF06bnVsbH0sZ2V0IGxhc3RDaGlsZCgpe3JldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aD90aGlzLmNoaWxkcmVuW3RoaXMuY2hpbGRyZW4ubGVuZ3RoLTFdOm51bGx9LGNsb25lOmZ1bmN0aW9uKCl7Zm9yKHZhciBiPWEuY2xvbmVUaW1pbmdJbnB1dCh0aGlzLl90aW1pbmdJbnB1dCksYz1bXSxkPTA7ZDx0aGlzLmNoaWxkcmVuLmxlbmd0aDtkKyspYy5wdXNoKHRoaXMuY2hpbGRyZW5bZF0uY2xvbmUoKSk7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBHcm91cEVmZmVjdD9uZXcgR3JvdXBFZmZlY3QoYyxiKTpuZXcgU2VxdWVuY2VFZmZlY3QoYyxiKX0scmVtb3ZlOmZ1bmN0aW9uKCl7Yi5yZW1vdmVNdWx0aShbdGhpc10pfX0sd2luZG93LlNlcXVlbmNlRWZmZWN0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlKSxPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlNlcXVlbmNlRWZmZWN0LnByb3RvdHlwZSxcImFjdGl2ZUR1cmF0aW9uXCIse2dldDpmdW5jdGlvbigpe3ZhciBhPTA7cmV0dXJuIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihiKXthKz1kKGIpfSksTWF0aC5tYXgoYSwwKX19KSx3aW5kb3cuR3JvdXBFZmZlY3QucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuR3JvdXBFZmZlY3QucHJvdG90eXBlLFwiYWN0aXZlRHVyYXRpb25cIix7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9MDtyZXR1cm4gdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGIpe2E9TWF0aC5tYXgoYSxkKGIpKX0pLGF9fSksYi5uZXdVbmRlcmx5aW5nQW5pbWF0aW9uRm9yR3JvdXA9ZnVuY3Rpb24oYyl7dmFyIGQsZT1udWxsLGY9ZnVuY3Rpb24oYil7dmFyIGM9ZC5fd3JhcHBlcjtpZihjJiZcInBlbmRpbmdcIiE9Yy5wbGF5U3RhdGUmJmMuZWZmZWN0KXJldHVybiBudWxsPT1iP3ZvaWQgYy5fcmVtb3ZlQ2hpbGRBbmltYXRpb25zKCk6MD09YiYmYy5wbGF5YmFja1JhdGU8MCYmKGV8fChlPWEubm9ybWFsaXplVGltaW5nSW5wdXQoYy5lZmZlY3QudGltaW5nKSksYj1hLmNhbGN1bGF0ZUl0ZXJhdGlvblByb2dyZXNzKGEuY2FsY3VsYXRlQWN0aXZlRHVyYXRpb24oZSksLTEsZSksaXNOYU4oYil8fG51bGw9PWIpPyhjLl9mb3JFYWNoQ2hpbGQoZnVuY3Rpb24oYSl7YS5jdXJyZW50VGltZT0tMX0pLHZvaWQgYy5fcmVtb3ZlQ2hpbGRBbmltYXRpb25zKCkpOnZvaWQgMH0sZz1uZXcgS2V5ZnJhbWVFZmZlY3QobnVsbCxbXSxjLl90aW1pbmcsYy5faWQpO3JldHVybiBnLm9uc2FtcGxlPWYsZD1iLnRpbWVsaW5lLl9wbGF5KGcpfSxiLmJpbmRBbmltYXRpb25Gb3JHcm91cD1mdW5jdGlvbihhKXthLl9hbmltYXRpb24uX3dyYXBwZXI9YSxhLl9pc0dyb3VwPSEwLGIuYXdhaXRTdGFydFRpbWUoYSksYS5fY29uc3RydWN0Q2hpbGRBbmltYXRpb25zKCksYS5fc2V0RXh0ZXJuYWxBbmltYXRpb24oYSl9LGIuZ3JvdXBDaGlsZER1cmF0aW9uPWR9KGMsZSksYi50cnVlPWF9KHt9LGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViLWFuaW1hdGlvbnMtbmV4dC1saXRlLm1pbi5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy93ZWItYW5pbWF0aW9ucy1qcy93ZWItYW5pbWF0aW9ucy1uZXh0LWxpdGUubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy93ZWItYW5pbWF0aW9ucy1qcy93ZWItYW5pbWF0aW9ucy1uZXh0LWxpdGUubWluLmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gbWFpbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcbn0gY2F0Y2goZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxuXHRcdGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IG1haW4iLCJpbXBvcnQgKiBhcyBjc3MgZnJvbSAnLi9hcHAubS5jc3MnO1xuXG5jb25zdCBBcHAgPSBhc3luYyBmdW5jdGlvbigpIHtcblx0Y29uc3QgRm9vID0gYXdhaXQgaW1wb3J0KCcuL0ZvbycpO1xuXHRyZXR1cm4gRm9vLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBCYXIgPSBhc3luYyBmdW5jdGlvbigpIHtcblx0Y29uc3QgQmFyID0gYXdhaXQgaW1wb3J0KCcuL0JhcicpO1xuXHRyZXR1cm4gQmFyLmRlZmF1bHQ7XG59O1xuXG5jb25zdCBCYXogPSBhc3luYyBmdW5jdGlvbigpIHtcblx0Y29uc3QgQmF6ID0gYXdhaXQgaW1wb3J0KCcuL0JheicpO1xuXHRyZXR1cm4gQmF6LmRlZmF1bHQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbigpIHtcblx0Y29uc29sZS5sb2coY3NzKTtcblx0Y29uc3QgYmFyID0gYXdhaXQgQmFyKCk7XG5cdGNvbnN0IGJheiA9IGF3YWl0IEJheigpO1xuXHRiYXIoKTtcblx0YmF6KCk7XG5cdHJldHVybiBBcHAoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AZG9qby93ZWJwYWNrLWNvbnRyaWIvY3NzLW1vZHVsZS1kdHMtbG9hZGVyP3R5cGU9dHMmaW5zdGFuY2VOYW1lPTBfZG9qbyEuL3NyYy9BcHAudHMiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxubW9kdWxlLmV4cG9ydHMgPSB7XCIgX2tleVwiOlwidGVzdC1hcHAvYXBwXCIsXCJyb290XCI6XCJhcHAtbV9fcm9vdF9fWXh0dFAgdGhlbWUtbV9fcm9vdF9fMmQ4NnBcIn07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvYXBwLm0uY3NzXG4vLyBtb2R1bGUgaWQgPSAuL3NyYy9hcHAubS5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiLy8gcmVtb3ZlZCBieSBleHRyYWN0LXRleHQtd2VicGFjay1wbHVnaW5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9tYWluLmNzc1xuLy8gbW9kdWxlIGlkID0gLi9zcmMvbWFpbi5jc3Ncbi8vIG1vZHVsZSBjaHVua3MgPSBtYWluIiwiaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XG5pbXBvcnQgKiBhcyBjc3MgZnJvbSAnLi9hcHAubS5jc3MnO1xuaW1wb3J0IGhhcyBmcm9tICdAZG9qby9oYXMvaGFzJztcbichaGFzKFwiYmFyXCIpJztcbmltcG9ydCAnLi9CYXInO1xuXG5pZiAoaGFzKCdmb28nKSkge1xuXHRjb25zb2xlLmxvZygnZm9vJyk7XG59XG5cbkFwcCgpLnRoZW4ocmVzdWx0ID0+IHtcblx0Y29uc29sZS5sb2cocmVzdWx0KCkpO1xuXHRjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0ZGl2LmlubmVySFRNTCA9ICdoZWxsbywgd29ybGQnO1xuXHRkaXYuY2xhc3NMaXN0LmFkZCguLi5jc3Mucm9vdC5zcGxpdCgnICcpKTtcblx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQGRvam8vd2VicGFjay1jb250cmliL2Nzcy1tb2R1bGUtZHRzLWxvYWRlcj90eXBlPXRzJmluc3RhbmNlTmFtZT0wX2Rvam8hLi9zcmMvbWFpbi50cyJdLCJzb3VyY2VSb290IjoiIn0=